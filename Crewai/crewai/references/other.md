# Crewai - Other

**Pages:** 1411

---

## to search across any discovered websites

**URL:** llms-txt#to-search-across-any-discovered-websites

tool = WebsiteSearchTool()

---

## Inicialize a ferramenta com um caminho PDF específico para buscas exclusivas naquele documento

**URL:** llms-txt#inicialize-a-ferramenta-com-um-caminho-pdf-específico-para-buscas-exclusivas-naquele-documento

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = PDFSearchTool(pdf='path/to/your/document.pdf')
python Code theme={null}
from crewai_tools import PDFSearchTool
from chromadb.config import Settings  # Persistência no Chroma

tool = PDFSearchTool(
    config={
        # Obrigatório: provedor de embeddings + configuração
        "embedding_model": {
            # Provedores suportados: "openai", "azure", "google-generativeai", "google-vertex",
            # "voyageai", "cohere", "huggingface", "jina", "sentence-transformer",
            # "text2vec", "ollama", "openclip", "instructor", "onnx", "roboflow", "watsonx", "custom"
            "provider": "openai",
            "config": {
                # "model" é mapeado internamente para "model_name".
                "model": "text-embedding-3-small",
                # Opcional: chave da API (se ausente, usa variáveis de ambiente do provedor)
                # "api_key": "sk-...",

# Exemplos específicos por provedor
                # --- Google ---
                # (defina provider="google-generativeai")
                # "model": "models/embedding-001",
                # "task_type": "retrieval_document",

# --- Cohere ---
                # (defina provider="cohere")
                # "model": "embed-english-v3.0",

# --- Ollama (local) ---
                # (defina provider="ollama")
                # "model": "nomic-embed-text",
            },
        },

# Obrigatório: configuração do banco vetorial
        "vectordb": {
            "provider": "chromadb",  # ou "qdrant"
            "config": {
                # Exemplo Chroma:
                # "settings": Settings(
                #     persist_directory="/content/chroma",
                #     allow_reset=True,
                #     is_persistent=True,
                # ),

# Exemplo Qdrant:
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),

# Observação: o nome da coleção é controlado pela ferramenta (padrão: "rag_tool_collection").
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `pdf`: **Opcional** O caminho do PDF para busca. Pode ser fornecido na inicialização ou nos argumentos do método `run`. Caso seja fornecido na inicialização, a ferramenta confinará suas buscas ao documento especificado.

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza OpenAI para embeddings e sumarização. Para personalizar, use um dicionário de configuração conforme abaixo. Observação: um banco vetorial (vectordb) é necessário, pois os embeddings gerados precisam ser armazenados e consultados.
```

---

## __init__.py

**URL:** llms-txt#__init__.py

from .my_custom_listener import my_custom_listener
from .another_listener import another_listener

---

## Tarefa para automatizar gestão de issues

**URL:** llms-txt#tarefa-para-automatizar-gestão-de-issues

**Contents:**
  - Operações Avançadas Baseadas em Schema

automation_task = Task(
    description="""
    1. Buscar todas as issues não atribuídas usando JQL
    2. Obter responsáveis disponíveis de cada projeto
    3. Atribuir issues automaticamente com base na carga de trabalho e especialidade
    4. Atualizar prioridades das issues baseando-se na idade e tipo
    5. Criar issues semanais de planejamento de sprint
    """,
    agent=automation_manager,
    expected_output="Issues atribuídas automaticamente e issues de planejamento de sprint criadas"
)

crew = Crew(
    agents=[automation_manager],
    tasks=[automation_task]
)

crew.kickoff()
python  theme={null}
from crewai import Agent, Task, Crew

schema_specialist = Agent(
    role="Schema Specialist",
    goal="Executar operações complexas no Jira usando schemas dinâmicos",
    backstory="Um assistente de IA que manipula schemas dinâmicos e tipos de issues customizadas do Jira.",
    apps=['jira']
)

**Examples:**

Example 1 (unknown):
```unknown
### Operações Avançadas Baseadas em Schema
```

---

## Obtenha somente a ferramenta para criar contatos

**URL:** llms-txt#obtenha-somente-a-ferramenta-para-criar-contatos

actions_list=["hubspot/create_contact"]
)

contact_creator = Agent(
    role="Contact Creator",
    goal="Create new contacts in HubSpot",
    backstory="An AI assistant that focuses on creating new contact entries in the CRM.",
    apps=['hubspot']
)

---

## 특정 GitHub 저장소 내에서 시맨틱 검색을 위한 도구 초기화

**URL:** llms-txt#특정-github-저장소-내에서-시맨틱-검색을-위한-도구-초기화

tool = GithubSearchTool(
	github_repo='https://github.com/example/repo',
	gh_token='your_github_personal_access_token',
	content_types=['code', 'issue'] # 옵션: code, repo, pr, issue
)

---

## 마켓플레이스

**URL:** llms-txt#마켓플레이스

**Contents:**
- 개요
- 탐색
- 설치 & 활성화
- 관련 문서

Source: https://docs.crewai.com/ko/enterprise/features/marketplace

엔터프라이즈 크루를 위한 재사용 가능한 자산을 탐색, 설치 및 관리하세요.

마켓플레이스는 통합, 내부 도구 및 재사용 가능한 자산을 탐색할 수 있는 큐레이션된 공간을 제공하여 크루 개발을 가속화합니다.

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=77786aca40c58c31775cb4de35b26d54" alt="마켓플레이스 개요" data-og-width="3040" width="3040" data-og-height="2266" height="2266" data-path="images/enterprise/marketplace-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=ae939d5b2f6f4d087498ec8a3a342ea7 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=6113d807f99c7de5a4ac3012518dbfcc 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=9e21e42a266f06cb864455b8935f54fc 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=41b47b8f0c3694766edfffe121f81402 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b8d75afbe1aeb98abc3cfd55d90ebce0 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=a798183edcdfddb19e6ae6b7ab0ab76b 2500w" />
</Frame>

* 카테고리 및 기능별로 탐색
* 이름 또는 키워드로 검색

* 승인된 자산은 원클릭 설치 지원
* 크루별로 활성화/비활성화 가능
* 필요한 환경 변수 및 스코프 구성

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=cc15b069d1d4da8555e9630e1e874346" alt="설치 & 구성" data-og-width="2672" width="2672" data-og-height="2266" height="2266" data-path="images/enterprise/marketplace-install.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=cfdaa8690cb6651c51c5ba579364fb7a 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=2ddf18661fb7c7ad08e3f1029311813f 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b0c3ee1f87a674b1ae31956a201e4b10 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=cedd73cab5194bd1381d594d0b102e2a 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=acfc5d304485f464f7bb5780c97ab237 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=1ea74be846d2c2eaf37cd372273f6347 2500w" />
</Frame>

마켓플레이스에서 `Download` 버튼을 클릭해 템플릿을 직접 내려받아 로컬에서 사용하거나 필요에 맞게 수정할 수도 있습니다.

<CardGroup cols={3}>
  <Card title="도구 & 통합" href="/ko/enterprise/features/tools-and-integrations" icon="wrench">
    에이전트가 사용할 외부 앱 연결 및 내부 도구 관리.
  </Card>

<Card title="도구 저장소" href="/ko/enterprise/features/tool-repository" icon="toolbox">
    크루 기능을 확장할 수 있도록 도구를 게시하고 설치.
  </Card>

<Card title="에이전트 저장소" href="/ko/enterprise/features/agent-repositories" icon="people-group">
    팀과 프로젝트 전반에서 에이전트 정의 저장, 공유 및 재사용.
  </Card>
</CardGroup>

---

## Editor Agent

**URL:** llms-txt#editor-agent

**Contents:**
  - Criando Usuários Especializados de Ferramentas
  - Personalizando Agentes para Capacidades do LLM

role: "Content Quality Editor"
goal: "Ensure content is accurate, well-structured, and polished while maintaining consistency"
backstory: "With years of experience in publishing, you have a keen eye for detail..."
yaml  theme={null}
role: "Data Analysis Specialist"
goal: "Derive meaningful insights from complex datasets through statistical analysis"
backstory: "With a background in data science, you excel at working with structured and unstructured data..."
tools: [PythonREPLTool, DataVisualizationTool, CSVAnalysisTool]
yaml  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Criando Usuários Especializados de Ferramentas

Alguns agentes podem ser projetados para explorar certas ferramentas de maneira eficiente:
```

Example 2 (unknown):
```unknown
### Personalizando Agentes para Capacidades do LLM

Diferentes LLMs têm pontos fortes distintos. Projete seus agentes levando essas capacidades em conta:
```

---

## Inicializar a ferramenta para capacidades de busca na internet

**URL:** llms-txt#inicializar-a-ferramenta-para-capacidades-de-busca-na-internet

**Contents:**
- Etapas para Começar
- Parâmetros
- Exemplo com Parâmetros

tool = SerperDevTool()
python Code theme={null}
from crewai_tools import SerperDevTool

tool = SerperDevTool(
    search_url="https://google.serper.dev/scholar",
    n_results=2,
)

print(tool.run(search_query="ChatGPT"))

**Examples:**

Example 1 (unknown):
```unknown
## Etapas para Começar

Para utilizar o `SerperDevTool` de forma eficaz, siga estes passos:

1. **Instalação do Pacote**: Confirme se o pacote `crewai[tools]` está instalado em seu ambiente Python.
2. **Obtenção da Chave de API**: Adquira uma chave de API do `serper.dev` registrando-se para uma conta gratuita em `serper.dev`.
3. **Configuração do Ambiente**: Armazene sua chave de API obtida em uma variável de ambiente chamada `SERPER_API_KEY` para facilitar o uso pela ferramenta.

## Parâmetros

O `SerperDevTool` possui vários parâmetros que serão passados para a API:

* **search\_url**: O endpoint da URL para a API de busca. (Padrão é `https://google.serper.dev/search`)

* **country**: Opcional. Especifica o país para os resultados de busca.

* **location**: Opcional. Especifica a localização para os resultados de busca.

* **locale**: Opcional. Especifica o local para os resultados de busca.

* **n\_results**: Número de resultados de busca a serem retornados. O padrão é `10`.

Os valores para `country`, `location`, `locale` e `search_url` podem ser encontrados no [Serper Playground](https://serper.dev/playground).

## Exemplo com Parâmetros

Aqui está um exemplo demonstrando como usar a ferramenta com parâmetros adicionais:
```

---

## Carregar modelo e tokenizer

**URL:** llms-txt#carregar-modelo-e-tokenizer

tokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
model = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')

def custom_embeddings(text: str) -> list[float]:
    # Tokenizar e obter saídas do modelo
    inputs = tokenizer(text, return_tensors="pt", padding=True, truncation=True)
    outputs = model(**inputs)

# Usar mean pooling para obter o embedding do texto
    embeddings = outputs.last_hidden_state.mean(dim=1)

# Converter para lista de floats e retornar
    return embeddings[0].tolist()

---

## Integração com Box

**URL:** llms-txt#integração-com-box

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o Box
  - 1. Conecte sua conta Box
  - 2. Instale o pacote necessário
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de Agente Box

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/box

Armazenamento de arquivos e gerenciamento de documentos com a integração do Box para CrewAI.

Permita que seus agentes gerenciem arquivos, pastas e documentos através do Box. Faça upload de arquivos, organize estruturas de pastas, pesquise conteúdos e otimize o gerenciamento de documentos da sua equipe com automação alimentada por IA.

Antes de utilizar a integração com o Box, assegure-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Box com as permissões apropriadas
* Sua conta Box conectada através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com o Box

### 1. Conecte sua conta Box

1. Acesse [Integrações do CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Box** na seção de Integrações de Autenticação
3. Clique em **Conectar** e conclua o fluxo de OAuth
4. Conceda as permissões necessárias para gerenciamento de arquivos e pastas
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o pacote necessário

<AccordionGroup>
  <Accordion title="box/save_file">
    **Descrição:** Salva um arquivo a partir de uma URL no Box.

* `fileAttributes` (object, obrigatório): Atributos - Metadados do arquivo incluindo nome, pasta pai e datas.
      
    * `file` (string, obrigatório): URL do arquivo - Os arquivos devem ter menos de 50MB. (exemplo: "[https://picsum.photos/200/300](https://picsum.photos/200/300)").
  </Accordion>

<Accordion title="box/save_file_from_object">
    **Descrição:** Salva um arquivo no Box.

* `file` (string, obrigatório): Arquivo - Aceita um Objeto de Arquivo contendo os dados. O arquivo deve ter menos de 50MB.
    * `fileName` (string, obrigatório): Nome do Arquivo (exemplo: "qwerty.png").
    * `folder` (string, opcional): Pasta - Use as configurações de workflow do Connect Portal para permitir que usuários escolham o destino da pasta. Caso em branco, o padrão é a pasta raiz do usuário.
  </Accordion>

<Accordion title="box/get_file_by_id">
    **Descrição:** Obtém um arquivo pelo ID no Box.

* `fileId` (string, obrigatório): ID do arquivo - Identificador único que representa um arquivo. (exemplo: "12345").
  </Accordion>

<Accordion title="box/list_files">
    **Descrição:** Lista arquivos no Box.

* `folderId` (string, obrigatório): ID da pasta - Identificador único que representa uma pasta. (exemplo: "0").
    * `filterFormula` (object, opcional): Um filtro em forma normal disjuntiva - OU de grupos E de condições únicas.
      
  </Accordion>

<Accordion title="box/create_folder">
    **Descrição:** Cria uma pasta no Box.

* `folderName` (string, obrigatório): Nome - Nome para a nova pasta. (exemplo: "Nova Pasta").
    * `folderParent` (object, obrigatório): Pasta Pai - A pasta onde a nova pasta será criada.
      
  </Accordion>

<Accordion title="box/move_folder">
    **Descrição:** Move uma pasta no Box.

* `folderId` (string, obrigatório): ID da pasta - Identificador único que representa uma pasta. (exemplo: "0").
    * `folderName` (string, obrigatório): Nome - Nome da pasta. (exemplo: "Nova Pasta").
    * `folderParent` (object, obrigatório): Nova pasta pai de destino.
      
  </Accordion>

<Accordion title="box/get_folder_by_id">
    **Descrição:** Obtém uma pasta pelo ID no Box.

* `folderId` (string, obrigatório): ID da pasta - Identificador único que representa uma pasta. (exemplo: "0").
  </Accordion>

<Accordion title="box/search_folders">
    **Descrição:** Pesquisa pastas no Box.

* `folderId` (string, obrigatório): ID da pasta - A pasta na qual pesquisar.
    * `filterFormula` (object, opcional): Um filtro em forma normal disjuntiva - OU de grupos E de condições únicas.
      
  </Accordion>

<Accordion title="box/delete_folder">
    **Descrição:** Exclui uma pasta no Box.

* `folderId` (string, obrigatório): ID da pasta - Identificador único que representa uma pasta. (exemplo: "0").
    * `recursive` (boolean, opcional): Recursivo - Exclui uma pasta que não está vazia, deletando de forma recursiva a pasta e todo o seu conteúdo.
  </Accordion>
</AccordionGroup>

### Configuração Básica de Agente Box

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="box/save_file">
    **Descrição:** Salva um arquivo a partir de uma URL no Box.

    **Parâmetros:**

    * `fileAttributes` (object, obrigatório): Atributos - Metadados do arquivo incluindo nome, pasta pai e datas.
```

Example 2 (unknown):
```unknown
* `file` (string, obrigatório): URL do arquivo - Os arquivos devem ter menos de 50MB. (exemplo: "[https://picsum.photos/200/300](https://picsum.photos/200/300)").
  </Accordion>

  <Accordion title="box/save_file_from_object">
    **Descrição:** Salva um arquivo no Box.

    **Parâmetros:**

    * `file` (string, obrigatório): Arquivo - Aceita um Objeto de Arquivo contendo os dados. O arquivo deve ter menos de 50MB.
    * `fileName` (string, obrigatório): Nome do Arquivo (exemplo: "qwerty.png").
    * `folder` (string, opcional): Pasta - Use as configurações de workflow do Connect Portal para permitir que usuários escolham o destino da pasta. Caso em branco, o padrão é a pasta raiz do usuário.
  </Accordion>

  <Accordion title="box/get_file_by_id">
    **Descrição:** Obtém um arquivo pelo ID no Box.

    **Parâmetros:**

    * `fileId` (string, obrigatório): ID do arquivo - Identificador único que representa um arquivo. (exemplo: "12345").
  </Accordion>

  <Accordion title="box/list_files">
    **Descrição:** Lista arquivos no Box.

    **Parâmetros:**

    * `folderId` (string, obrigatório): ID da pasta - Identificador único que representa uma pasta. (exemplo: "0").
    * `filterFormula` (object, opcional): Um filtro em forma normal disjuntiva - OU de grupos E de condições únicas.
```

Example 3 (unknown):
```unknown
</Accordion>

  <Accordion title="box/create_folder">
    **Descrição:** Cria uma pasta no Box.

    **Parâmetros:**

    * `folderName` (string, obrigatório): Nome - Nome para a nova pasta. (exemplo: "Nova Pasta").
    * `folderParent` (object, obrigatório): Pasta Pai - A pasta onde a nova pasta será criada.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="box/move_folder">
    **Descrição:** Move uma pasta no Box.

    **Parâmetros:**

    * `folderId` (string, obrigatório): ID da pasta - Identificador único que representa uma pasta. (exemplo: "0").
    * `folderName` (string, obrigatório): Nome - Nome da pasta. (exemplo: "Nova Pasta").
    * `folderParent` (object, obrigatório): Nova pasta pai de destino.
```

---

## Basic HTTPS server

**URL:** llms-txt#basic-https-server

"https://api.example.com/mcp"

---

## Crie LLM com configuração de fallback

**URL:** llms-txt#crie-llm-com-configuração-de-fallback

portkey_llm = LLM(
    model="gpt-4o",
    max_tokens=1000,
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        config={
            "strategy": {
                "mode": "fallback"
            },
            "targets": [
                {
                    "provider": "openai",
                    "api_key": "YOUR_OPENAI_API_KEY",
                    "override_params": {"model": "gpt-4o"}
                },
                {
                    "provider": "anthropic",
                    "api_key": "YOUR_ANTHROPIC_API_KEY",
                    "override_params": {"model": "claude-3-opus-20240229"}
                }
            ]
        }
    )
)

---

## Retorna um objeto TaskOutput com a descrição e resultado da tarefa

**URL:** llms-txt#retorna-um-objeto-taskoutput-com-a-descrição-e-resultado-da-tarefa

**Contents:**
- Mecanismo de Sobrescrição de Ferramentas
- Mecanismos de Validação e Tratamento de Erros
- Guardrails em Tarefas
  - Uso Básico
  - Como Guardrails Funcionam
  - Casos Comuns de Uso
  - Recursos Avançados

print(f"""
    Tarefa concluída!
    Tarefa: {task1.output.description}
    Saída: {task1.output.raw}
""")
python Code theme={null}
from typing import Tuple, Union
from crewai import Task

def validate_json_output(result: str) -> Tuple[bool, Union[dict, str]]:
    """Valida se a saída é um JSON válido."""
    try:
        json_data = json.loads(result)
        return (True, json_data)
    except json.JSONDecodeError:
        return (False, "A saída deve ser um JSON válido")

task = Task(
    description="Gerar dados em JSON",
    expected_output="Objeto JSON válido",
    guardrail=validate_json_output
)
python Code theme={null}
@CrewBase
class InternalCrew:
    agents_config = "config/agents.yaml"
    tasks_config = "config/tasks.yaml"

...
    @task
    def research_task(self):
        return Task(config=self.tasks_config["research_task"])  # type: ignore[index]
    ...
python Code theme={null}
from crewai import Task
from crewai.llm import LLM

task = Task(
    description="Gerar dados em JSON",
    expected_output="Objeto JSON válido",
    guardrail=LLMGuardrail(
        description="Garanta que a resposta é um objeto JSON válido",
        llm=LLM(model="gpt-4o-mini"),
    )
)
python Code theme={null}
def validate_email_format(result: str) -> Tuple[bool, Union[str, str]]:
    """Garante que a saída contenha um e-mail válido."""
    import re
    email_pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    if re.match(email_pattern, result.strip()):
        return (True, result.strip())
    return (False, "A saída deve ser um e-mail válido")
python Code theme={null}
def filter_sensitive_info(result: str) -> Tuple[bool, Union[str, str]]:
    """Remove ou valida informações sensíveis."""
    sensitive_patterns = ['SSN:', 'password:', 'secret:']
    for pattern in sensitive_patterns:
        if pattern.lower() in result.lower():
            return (False, f"A saída contém informação sensível ({pattern})")
    return (True, result)
python Code theme={null}
def normalize_phone_number(result: str) -> Tuple[bool, Union[str, str]]:
    """Garante que números de telefone estejam em formato consistente."""
    import re
    digits = re.sub(r'\D', '', result)
    if len(digits) == 10:
        formatted = f"({digits[:3]}) {digits[3:6]}-{digits[6:]}"
        return (True, formatted)
    return (False, "A saída deve ser um telefone com 10 dígitos")
python Code theme={null}
def chain_validations(*validators):
    """Encadeia múltiplos validadores."""
    def combined_validator(result):
        for validator in validators:
            success, data = validator(result)
            if not success:
                return (False, data)
            result = data
        return (True, result)
    return combined_validator

**Examples:**

Example 1 (unknown):
```unknown
## Mecanismo de Sobrescrição de Ferramentas

Especificar ferramentas em uma tarefa permite a adaptação dinâmica das capacidades do agente, destacando a flexibilidade do CrewAI.

## Mecanismos de Validação e Tratamento de Erros

Ao criar e executar tarefas, determinados mecanismos de validação garantem a robustez e confiabilidade dos atributos das tarefas. Isso inclui, mas não se limita a:

* Garantir que apenas um tipo de saída seja definido por tarefa para manter expectativas de saída claras.
* Impedir a atribuição manual do atributo `id`, preservando a integridade do sistema de identificadores únicos.

Estas validações colaboram para a consistência e confiabilidade das execuções de tarefas no framework CrewAI.

## Guardrails em Tarefas

Guardrails de tarefas oferecem uma maneira poderosa de validar, transformar ou filtrar as saídas das tarefas antes de serem encaminhadas à próxima. São funções opcionais que executam antes do início da próxima tarefa, garantindo que as saídas estejam em conformidade com requisitos ou formatos esperados.

### Uso Básico

#### Defina sua própria lógica de validação
```

Example 2 (unknown):
```unknown

```

Example 3 (unknown):
```unknown
#### Use modelos customizados para geração de código
```

Example 4 (unknown):
```unknown
### Como Guardrails Funcionam

1. **Atributo Opcional**: Guardrails são opcionais por tarefa, permitindo adicionar validação só onde for necessário.
2. **Momento de Execução**: A função guardrail é executada antes do início da próxima tarefa, garantindo fluxo de dados válido entre tarefas.
3. **Formato de Retorno**: Guardrails devem retornar uma tupla `(sucesso, dados)`:
   * Se `sucesso` é `True`, `dados` é o resultado validado/transformado
   * Se `sucesso` é `False`, `dados` é a mensagem de erro
4. **Roteamento do Resultado**:
   * Sucesso (`True`): o resultado é automaticamente passado para a próxima tarefa
   * Falha (`False`): o erro é enviado de volta ao agente para gerar uma nova resposta

### Casos Comuns de Uso

#### Validação de Formato de Dados
```

---

## Snippet: … ChatGPT in public health. In this overview, we will examine the potential uses of ChatGPT in

**URL:** llms-txt#snippet:-…-chatgpt-in-public-health.-in-this-overview,-we-will-examine-the-potential-uses-of-chatgpt-in

---

## Use sem expor as chaves no código

**URL:** llms-txt#use-sem-expor-as-chaves-no-código

**Contents:**
  - Testando Diferentes Provedores de Embedding

crew = Crew(
    memory=True,
    embedder={
        "provider": "openai",
        "config": {
            "model": "text-embedding-3-small"
            # A chave de API será carregada automaticamente da variável de ambiente
        }
    }
)
python  theme={null}
from crewai import Crew
from crewai.utilities.paths import db_storage_path

**Examples:**

Example 1 (unknown):
```unknown
### Testando Diferentes Provedores de Embedding

Compare provedores de embedding para o seu caso de uso específico:
```

---

## Criar tarefa de pesquisa abrangente

**URL:** llms-txt#criar-tarefa-de-pesquisa-abrangente

tarefa_pesquisa = Task(
    description="""Pesquisar o impacto dos agentes de IA na produtividade empresarial.
    Incluir impactos climáticos atuais no trabalho remoto, tendências do mercado financeiro,
    e publicações acadêmicas recentes sobre frameworks de agentes de IA.""",
    expected_output="""Relatório abrangente cobrindo:
    1. Análise do impacto dos agentes de IA nos negócios
    2. Considerações climáticas para trabalho remoto
    3. Tendências do mercado financeiro relacionadas à IA
    4. Citações e insights de pesquisa acadêmica
    5. Análise do cenário competitivo""",
    agent=agente_multi_fonte
)

---

## MDX RAG Search

**URL:** llms-txt#mdx-rag-search

Source: https://docs.crewai.com/en/tools/file-document/mdxsearchtool

The `MDXSearchTool` is designed to search MDX files and return the most relevant results.

---

## Google Drive 통합

**URL:** llms-txt#google-drive-통합

**Contents:**
- 개요
- 전제 조건
- Google Drive 통합 설정
  - 1. Google 계정 연결
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 문제 해결
  - 도움 받기

Source: https://docs.crewai.com/ko/enterprise/integrations/google_drive

CrewAI를 위한 Google Drive 통합으로 파일 및 폴더 관리.

에이전트가 Google Drive의 파일과 폴더에 액세스하고 관리할 수 있도록 합니다. AI 기반 자동화로 파일을 업로드, 다운로드, 콘텐츠 구성, 공유 링크 생성 및 클라우드 스토리지 워크플로를 간소화합니다.

Google Drive 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Google Drive 액세스 권한이 있는 Google 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Google 계정 연결

## Google Drive 통합 설정

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동합니다.
2. 인증 통합 섹션에서 **Google Drive**를 찾습니다.
3. **연결**을 클릭하고 OAuth 과정을 완료합니다.
4. 파일 및 폴더 관리에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

자세한 매개변수 및 사용법은 [영어 문서](../../../en/enterprise/integrations/google_drive)를 참조하세요.

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  Google Drive 통합 설정 또는 문제 해결에 대한 지원이 필요하시면 지원팀에 문의하세요.
</Card>

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

---

## Carregue um agente do repositório

**URL:** llms-txt#carregue-um-agente-do-repositório

analyst = Agent(
    from_repository="market-analyst-agent",
    verbose=True
)

---

## Databricks SQL 쿼리 도구

**URL:** llms-txt#databricks-sql-쿼리-도구

Source: https://docs.crewai.com/ko/tools/search-research/databricks-query-tool

DatabricksQueryTool은 Databricks 워크스페이스 테이블에 대해 SQL 쿼리를 실행합니다.

---

## Carregar documentos

**URL:** llms-txt#carregar-documentos

docs_to_load = os.listdir("knowledge")
with test_docs.batch.dynamic() as batch:
    for d in docs_to_load:
        with open(os.path.join("knowledge", d), "r") as f:
            content = f.read()
        batch.add_object(
            {
                "content": content,
                "year": d.split("_")[0],
            }
        )

---

## Agente Gerente Personalizado

**URL:** llms-txt#agente-gerente-personalizado

Source: https://docs.crewai.com/pt-BR/learn/custom-manager-agent

Saiba como definir um agente personalizado como gerente no CrewAI, proporcionando mais controle sobre o gerenciamento e a coordenação das tarefas.

---

## Inicializar a ferramenta

**URL:** llms-txt#inicializar-a-ferramenta

weaviate_tool = WeaviateVectorSearchTool(
    collection_name='example_collections',
    limit=3,
    weaviate_cluster_url="https://your-weaviate-cluster-url.com",
    weaviate_api_key="your-weaviate-api-key",
)

---

## Dog(name='Kona', age=3, breed='black german shepherd')

**URL:** llms-txt#dog(name='kona',-age=3,-breed='black-german-shepherd')

**Contents:**
- Recursos Avançados e Otimização
- Problemas Comuns e Soluções

python  theme={null}
    from crewai import LLM

# O CrewAI automaticamente gerencia:
    # 1. Contagem e acompanhamento de tokens
    # 2. Resumo de conteúdo quando necessário
    # 3. Divisão de tarefas para grandes contextos

llm = LLM(
        model="gpt-4",
        max_tokens=4000,  # Limitar tamanho da resposta
    )
    python  theme={null}
        # Configure o modelo com as opções certas
        llm = LLM(
            model="openai/gpt-4-turbo-preview",
            temperature=0.7,    # Ajuste conforme a tarefa
            max_tokens=4096,    # Defina conforme a necessidade da saída
            timeout=300        # Timeout maior para tarefas complexas
        )
        python  theme={null}
    from crewai import LLM
    import os

os.environ["OPENAI_API_KEY"] = "<api-key>"

o3_llm = LLM(
        model="o3",
        drop_params=True,
        additional_drop_params=["stop"]
    )
    bash  theme={null}
    # OpenAI
    OPENAI_API_KEY=sk-...

# Anthropic
    ANTHROPIC_API_KEY=sk-ant-...
    python  theme={null}
    # Correto
    llm = LLM(model="openai/gpt-4")

# Incorreto
    llm = LLM(model="gpt-4")
    python  theme={null}
    # Modelo com contexto expandido
    llm = LLM(model="openai/gpt-4o")  # 128K tokens
    ```
  </Tab>
</Tabs>

**Examples:**

Example 1 (unknown):
```unknown
## Recursos Avançados e Otimização

Saiba como obter o máximo da configuração do seu LLM:

<AccordionGroup>
  <Accordion title="Gestão da Janela de Contexto">
    O CrewAI inclui recursos inteligentes para gerenciamento de contexto:
```

Example 2 (unknown):
```unknown
<Info>
      Boas práticas para o gerenciamento de contexto:

      1. Prefira modelos com janelas apropriadas
      2. Pré-processe entradas muito longas
      3. Utilize divisão para documentos grandes
      4. Monitore tokens para otimizar custos
    </Info>
  </Accordion>

  <Accordion title="Otimização de Performance">
    <Steps>
      <Step title="Otimização do Uso de Tokens">
        Escolha a janela de contexto certa para sua tarefa:

        * Tarefas pequenas (até 4K tokens): Modelos padrão
        * Tarefas médias (entre 4K-32K): Modelos aprimorados
        * Tarefas grandes (acima de 32K): Modelos com contexto expandido
```

Example 3 (unknown):
```unknown
<Tip>
          * Temperaturas baixas (0.1 a 0.3) para respostas factuais
          * Temperaturas altas (0.7 a 0.9) para tarefas criativas
        </Tip>
      </Step>

      <Step title="Boas Práticas">
        1. Monitore o uso de tokens
        2. Implemente limites de taxa (rate limiting)
        3. Use cache quando possível
        4. Defina limites apropriados para max\_tokens
      </Step>
    </Steps>

    <Info>
      Lembre-se de monitorar regularmente o uso de tokens e ajustar suas configurações para otimizar custos e desempenho.
    </Info>
  </Accordion>

  <Accordion title="Descartar Parâmetros Adicionais">
    O CrewAI usa Litellm internamente para chamadas LLM, permitindo descartar parâmetros adicionais desnecessários para seu caso de uso. Isso pode simplificar seu código e reduzir a complexidade da configuração do LLM.
    Por exemplo, se não precisar enviar o parâmetro <code>stop</code>, basta omiti-lo na chamada do LLM:
```

Example 4 (unknown):
```unknown
</Accordion>
</AccordionGroup>

## Problemas Comuns e Soluções

<Tabs>
  <Tab title="Autenticação">
    <Warning>
      A maioria dos problemas de autenticação pode ser resolvida verificando o formato da chave da API e os nomes das variáveis de ambiente.
    </Warning>
```

---

## reasoning이 활성화된 에이전트를 생성합니다

**URL:** llms-txt#reasoning이-활성화된-에이전트를-생성합니다

agent = Agent(
    role="Data Analyst",
    goal="Analyze data and provide insights",
    reasoning=True,
    max_reasoning_attempts=3
)

---

## ✅ Utilize estes padrões de nomeação

**URL:** llms-txt#✅-utilize-estes-padrões-de-nomeação

**Contents:**
  - Melhores Práticas
  - Interaja com Seu Crew Implantado
  - Dispare uma Execução
  - Monitoramento e Análises
  - Funcionalidades Avançadas

OPENAI_API_KEY=sk-...
DATABASE_CREDENTIALS=mysenha
API_CONFIG=segredo123
```

### Melhores Práticas

1. **Use convenções padrão de nomenclatura**: `PROVIDER_API_KEY` em vez de `PROVIDER_TOKEN`
2. **Teste localmente primeiro**: Certifique-se de que seu crew funciona com as variáveis renomeadas
3. **Atualize seu código**: Altere todas as referências aos nomes antigos das variáveis
4. **Documente as mudanças**: Mantenha registro das variáveis renomeadas para seu time

<Tip>
  Se você se deparar com falhas de implantação com erros enigmáticos de variáveis de ambiente, confira primeiro os nomes das variáveis em relação a esses padrões.
</Tip>

### Interaja com Seu Crew Implantado

Após a implantação, você pode acessar seu crew por meio de:

1. **REST API**: A plataforma gera um endpoint HTTPS exclusivo com estas rotas principais:
   * `/inputs`: Lista os parâmetros de entrada requeridos
   * `/kickoff`: Inicia uma execução com os inputs fornecidos
   * `/status/{kickoff_id}`: Consulta o status da execução

2. **Interface Web**: Acesse [app.crewai.com](https://app.crewai.com) para visualizar:
   * **Aba Status**: Informações da implantação, detalhes do endpoint da API e token de autenticação
   * **Aba Run**: Visualização da estrutura do seu crew
   * **Aba Executions**: Histórico de todas as execuções
   * **Aba Metrics**: Análises de desempenho
   * **Aba Traces**: Insights detalhados das execuções

### Dispare uma Execução

No dashboard Enterprise, você pode:

1. Clicar no nome do seu crew para abrir seus detalhes
2. Selecionar "Trigger Crew" na interface de gerenciamento
3. Inserir os inputs necessários no modal exibido
4. Monitorar o progresso à medida que a execução avança pelo pipeline

### Monitoramento e Análises

A plataforma Enterprise oferece recursos abrangentes de observabilidade:

* **Gestão das Execuções**: Acompanhe execuções ativas e concluídas
* **Traces**: Quebra detalhada de cada execução
* **Métricas**: Uso de tokens, tempos de execução e custos
* **Visualização em Linha do Tempo**: Representação visual das sequências de tarefas

### Funcionalidades Avançadas

A plataforma Enterprise também oferece:

* **Gerenciamento de Variáveis de Ambiente**: Armazene e gerencie com segurança as chaves de API
* **Conexões com LLM**: Configure integrações com diversos provedores de LLM
* **Repositório Custom Tools**: Crie, compartilhe e instale ferramentas
* **Crew Studio**: Monte crews via interface de chat sem escrever código

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nossa equipe de suporte para ajuda com questões de implantação ou dúvidas sobre a plataforma Enterprise.
</Card>

---

## Use this initialization method when you want to limit the search scope to a specific JSON file.

**URL:** llms-txt#use-this-initialization-method-when-you-want-to-limit-the-search-scope-to-a-specific-json-file.

**Contents:**
- Arguments
- Configuration Options

tool = JSONSearchTool(json_path='./path/to/your/file.json')
python Code theme={null}
tool = JSONSearchTool(
    config={
        "llm": {
            "provider": "ollama",  # Other options include google, openai, anthropic, llama2, etc.
            "config": {
                "model": "llama2",
                # Additional optional configurations can be specified here.
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            },
        },
        "embedding_model": {
            "provider": "google", # or openai, ollama, ...
            "config": {
                "model": "models/embedding-001",
                "task_type": "retrieval_document",
                # Further customization options can be added here.
            },
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Arguments

* `json_path` (str, optional): Specifies the path to the JSON file to be searched. This argument is not required if the tool is initialized for a general search. When provided, it confines the search to the specified JSON file.

## Configuration Options

The JSONSearchTool supports extensive customization through a configuration dictionary. This allows users to select different models for embeddings and summarization based on their requirements.
```

---

## `CodeInterpreterTool`

**URL:** llms-txt#`codeinterpretertool`

**Contents:**
- Descrição
  - Container Docker (Recomendado)
  - Ambiente Sandbox
  - Execução Não Segura
- Registro de Logs
- Instalação
- Exemplo

O `CodeInterpreterTool` permite que agentes CrewAI executem códigos Python 3 gerados autonomamente. Essa funcionalidade é particularmente valiosa, pois permite que os agentes criem códigos, os executem, obtenham os resultados e usem essas informações para orientar decisões e ações subsequentes.

Há diversas formas de usar esta ferramenta:

### Container Docker (Recomendado)

Esta é a opção principal. O código é executado em um container Docker seguro e isolado, garantindo a segurança independentemente de seu conteúdo.
Certifique-se de que o Docker esteja instalado e em funcionamento em seu sistema. Se ainda não tiver, você pode instalá-lo a partir [deste link](https://docs.docker.com/get-docker/).

Se o Docker não estiver disponível — seja por não estar instalado ou inacessível por qualquer motivo — o código será executado em um ambiente Python restrito, chamado de sandbox.
Esse ambiente é bastante limitado, com restrições severas a vários módulos e funções embutidas.

### Execução Não Segura

**NÃO RECOMENDADO PARA PRODUÇÃO**
Este modo permite a execução de qualquer código Python, inclusive chamadas perigosas para os módulos `sys, os..` e semelhantes. [Veja aqui](/pt-BR/tools/ai-ml/codeinterpretertool#enabling-unsafe-mode) como habilitar este modo.

O `CodeInterpreterTool` registra a estratégia de execução selecionada no STDOUT.

Para utilizar esta ferramenta, você precisa instalar o pacote de ferramentas CrewAI:

O exemplo a seguir demonstra como usar o `CodeInterpreterTool` com um agente CrewAI:

```python Code theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import CodeInterpreterTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O exemplo a seguir demonstra como usar o `CodeInterpreterTool` com um agente CrewAI:
```

---

## 2. Log warnings for failing servers

**URL:** llms-txt#2.-log-warnings-for-failing-servers

---

## Forçar a Saída da Ferramenta como Resultado

**URL:** llms-txt#forçar-a-saída-da-ferramenta-como-resultado

**Contents:**
- Introdução
- Forçando a Saída da Ferramenta como Resultado

Source: https://docs.crewai.com/pt-BR/learn/force-tool-output-as-result

Aprenda como forçar a saída de uma ferramenta como resultado em uma tarefa de Agent no CrewAI.

No CrewAI, você pode forçar a saída de uma ferramenta como o resultado de uma tarefa de um agent.\
Esse recurso é útil quando você deseja garantir que a saída da ferramenta seja capturada e retornada como resultado da tarefa, evitando quaisquer modificações pelo agent durante a execução da tarefa.

## Forçando a Saída da Ferramenta como Resultado

Para forçar a saída da ferramenta como resultado da tarefa de um agent, você precisa definir o parâmetro `result_as_answer` como `True` ao adicionar uma ferramenta ao agent.\
Esse parâmetro garante que a saída da ferramenta seja capturada e retornada como resultado da tarefa, sem qualquer modificação pelo agent.

Veja um exemplo de como forçar a saída da ferramenta como resultado da tarefa de um agent:

```python Code theme={null}
from crewai.agent import Agent
from my_tool import MyCustomTool

---

## 새 텍스트 문서 생성 작업

**URL:** llms-txt#새-텍스트-문서-생성-작업

create_doc_task = Task(
    description="'회의노트.txt'라는 새 텍스트 문서를 만들고 내용은 '2024년 1월 회의 노트: 주요 토론 사항 및 실행 항목.'으로 하세요",
    agent=word_agent,
    expected_output="새 텍스트 문서 '회의노트.txt'가 성공적으로 생성됨."
)

---

## 배포 로그 보기

**URL:** llms-txt#배포-로그-보기

---

## Criar ferramentas

**URL:** llms-txt#criar-ferramentas

search_tool = SerperDevTool()
wiki_tool = WikipediaTools()

---

## 예시 사용법 (server_params 설정 후 주석 해제 및 적용):

**URL:** llms-txt#예시-사용법-(server_params-설정-후-주석-해제-및-적용):

**Contents:**
- 필터링 도구
  - 딕셔너리 스타일 인덱싱을 사용하여 특정 도구에 접근하기
  - `MCPServerAdapter` 생성자에 도구 이름의 리스트를 전달하세요.
- CrewBase와 함께 사용하기
  - 연결 타임아웃 구성
  - 도구 필터링
- MCP 통합 탐색
- MCP와 함께 안전하게 사용하기
  - 제한 사항

with MCPServerAdapter(server_params, connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

my_agent = Agent(
        role="MCP Tool User",
        goal="MCP 서버의 도구를 활용합니다.",
        backstory="나는 MCP 서버에 연결하여 해당 도구를 사용할 수 있습니다.",
        tools=mcp_tools, # 불러온 도구를 Agent에 전달
        reasoning=True,
        verbose=True
    )
    # ... 나머지 crew 설정 ...
python  theme={null}
with MCPServerAdapter(server_params, connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

my_agent = Agent(
        role="MCP Tool User",
        goal="Utilize tools from an MCP server.",
        backstory="I can connect to MCP servers and use their tools.",
        tools=[mcp_tools["tool_name"]], # Pass the loaded tools to your agent
        reasoning=True,
        verbose=True
    )
    # ... rest of your crew setup ...
python  theme={null}
with MCPServerAdapter(server_params, "tool_name", connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

my_agent = Agent(
        role="MCP Tool User",
        goal="Utilize tools from an MCP server.",
        backstory="I can connect to MCP servers and use their tools.",
        tools=mcp_tools, # Pass the loaded tools to your agent
        reasoning=True,
        verbose=True
    )
    # ... rest of your crew setup ...
python  theme={null}
@CrewBase
class CrewWithMCP:
  # ... 에이전트 및 작업 구성 파일 정의 ...

mcp_server_params = [
    # 스트리머블 HTTP 서버
    {
        "url": "http://localhost:8001/mcp",
        "transport": "streamable-http"
    },
    # SSE 서버
    {
        "url": "http://localhost:8000/sse",
        "transport": "sse"
    },
    # StdIO 서버
    StdioServerParameters(
        command="python3",
        args=["servers/your_stdio_server.py"],
        env={"UV_PYTHON": "3.12", **os.environ},
    )
  ]

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools()) # 모든 사용 가능한 도구 가져오기

# ... 나머지 crew 설정 ...
python  theme={null}
@CrewBase
class CrewWithMCP:
  mcp_server_params = [...]
  mcp_connect_timeout = 60  # 모든 MCP 연결에 60초 타임아웃

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools())
python  theme={null}
@CrewBase
class CrewWithDefaultTimeout:
  mcp_server_params = [...]
  # mcp_connect_timeout 지정하지 않음 - 기본 30초 사용

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools())
python  theme={null}
@agent
def another_agent(self):
    return Agent(
      config=self.agents_config["your_agent"],
      tools=self.get_mcp_tools("tool_1", "tool_2") # 특정 도구만 가져오기
    )
python  theme={null}
@CrewBase
class CrewWithCustomTimeout:
  mcp_server_params = [...]
  mcp_connect_timeout = 90  # 모든 MCP 연결에 90초 타임아웃

@agent
  def filtered_agent(self):
      return Agent(
        config=self.agents_config["your_agent"],
        tools=self.get_mcp_tools("tool_1", "tool_2") # 사용자 지정 타임아웃으로 특정 도구
      )
```

<CardGroup cols={2}>
  <Card title="Stdio 전송" icon="server" href="/ko/mcp/stdio" color="#3B82F6">
    표준 입력/출력을 통해 로컬 MCP 서버에 연결합니다. 스크립트와 로컬 실행 파일에 이상적입니다.
  </Card>

<Card title="SSE 전송" icon="wifi" href="/ko/mcp/sse" color="#10B981">
    실시간 데이터 스트리밍을 위해 Server-Sent Events를 사용하여 원격 MCP 서버와 통합합니다.
  </Card>

<Card title="스트림 가능한 HTTP 전송" icon="globe" href="/ko/mcp/streamable-http" color="#F59E0B">
    유연한 스트림 가능한 HTTP를 활용하여 원격 MCP 서버와 안정적으로 통신할 수 있습니다.
  </Card>

<Card title="다중 서버 연결" icon="layer-group" href="/ko/mcp/multiple-servers" color="#8B5CF6">
    하나의 어댑터를 사용하여 여러 MCP 서버의 도구를 동시에 통합할 수 있습니다.
  </Card>

<Card title="보안 고려사항" icon="lock" href="/ko/mcp/security" color="#EF4444">
    에이전트를 안전하게 보호하기 위한 MCP 통합의 중요한 보안 모범 사례를 검토하세요.
  </Card>
</CardGroup>

CrewAI와의 MCP 통합에 대한 전체 데모와 예제를 보려면 이 저장소를 확인하세요! 👇

<Card title="GitHub 저장소" icon="github" href="https://github.com/tonykipkemboi/crewai-mcp-demo" target="_blank">
  CrewAI MCP 데모
</Card>

<Warning>
  항상 MCP 서버를 사용하기 전에 해당 서버를 신뢰할 수 있는지 확인하세요.
</Warning>

#### 보안 경고: DNS 리바인딩 공격

SSE 전송은 적절하게 보안되지 않은 경우 DNS 리바인딩 공격에 취약할 수 있습니다.
이를 방지하려면 다음을 수행하세요:

1. **항상 Origin 헤더를 검증**하여 들어오는 SSE 연결이 예상한 소스에서 오는지 확인합니다.
2. **서버를 모든 네트워크 인터페이스**(0.0.0.0)에 바인딩하는 것을 피하고, 로컬에서 실행할 때는 localhost(127.0.0.1)에만 바인딩합니다.
3. **모든 SSE 연결에 대해 적절한 인증을 구현**합니다.

이러한 보호 조치가 없으면 공격자가 원격 웹사이트에서 로컬 MCP 서버와 상호작용하기 위해 DNS 리바인딩을 사용할 수 있습니다.

자세한 내용은 [Anthropic의 MCP 전송 보안 문서](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations)를 참고하세요.

* **지원되는 프리미티브**: 현재 `MCPServerAdapter`는 주로 MCP `tools`를 어댑팅하는 기능을 지원합니다. 다른 MCP 프리미티브(예: `prompts` 또는 `resources`)는 현재 이 어댑터를 통해 CrewAI 컴포넌트로 직접 통합되어 있지 않습니다.
* **출력 처리**: 어댑터는 일반적으로 MCP tool의 주요 텍스트 출력(예: `.content[0].text`)을 처리합니다. 복잡하거나 멀티모달 출력의 경우 이 패턴에 맞지 않으면 별도의 커스텀 처리가 필요할 수 있습니다.

**Examples:**

Example 1 (unknown):
```unknown
이 일반적인 패턴은 도구를 통합하는 방법을 보여줍니다. 각 transport에 맞춘 구체적인 예시는 아래의 상세 가이드를 참고하세요.

## 필터링 도구

도구를 필터링하는 방법에는 두 가지가 있습니다:

1. 딕셔너리 스타일의 인덱싱을 사용하여 특정 도구에 접근하기.
2. 도구 이름 목록을 `MCPServerAdapter` 생성자에 전달하기.

### 딕셔너리 스타일 인덱싱을 사용하여 특정 도구에 접근하기
```

Example 2 (unknown):
```unknown
### `MCPServerAdapter` 생성자에 도구 이름의 리스트를 전달하세요.
```

Example 3 (unknown):
```unknown
## CrewBase와 함께 사용하기

CrewBase 클래스 내에서 MCPServer 도구를 사용하려면 `get_mcp_tools` 메서드를 사용하세요. 서버 구성은 `mcp_server_params` 속성을 통해 제공되어야 합니다. 단일 구성 또는 여러 서버 구성을 리스트 형태로 전달할 수 있습니다.
```

Example 4 (unknown):
```unknown
<Tip>
  `@CrewBase`로 데코레이션된 클래스에서는 어댑터 수명 주기가 자동으로 관리됩니다.

  * `get_mcp_tools()`가 처음 호출될 때 공유 `MCPServerAdapter`가 지연 생성되며 crew 내 모든 에이전트가 이를 재사용합니다.
  * `.kickoff()`가 끝나면 `@CrewBase`가 주입한 after-kickoff 훅이 어댑터를 종료하므로 별도의 정리 코드가 필요 없습니다.
  * `mcp_server_params`를 지정하지 않으면 `get_mcp_tools()`는 빈 리스트를 반환하여 MCP 설정 여부와 상관없이 동일한 코드 경로를 사용할 수 있습니다.

  따라서 여러 에이전트에서 `get_mcp_tools()`를 호출하거나 환경에 따라 MCP 사용을 토글하더라도 안전하게 동작합니다.
</Tip>

### 연결 타임아웃 구성

`mcp_connect_timeout` 클래스 속성을 설정하여 MCP 서버의 연결 타임아웃을 구성할 수 있습니다. 타임아웃을 지정하지 않으면 기본값으로 30초가 사용됩니다.
```

---

## Define um agente que utiliza a ferramenta

**URL:** llms-txt#define-um-agente-que-utiliza-a-ferramenta

web_scraper_agent = Agent(
    role="Web Scraper",
    goal="Extract and analyze information from dynamic websites",
    backstory="""You are an expert web scraper who specializes in extracting 
    content from dynamic websites that require browser automation. You have 
    extensive knowledge of CSS selectors and can identify the right selectors 
    to target specific content on any website.""",
    tools=[selenium_tool],
    verbose=True,
)

---

## Load text content from a local folder and add to MongoDB

**URL:** llms-txt#load-text-content-from-a-local-folder-and-add-to-mongodb

texts = []
for fname in os.listdir("knowledge"):
    path = os.path.join("knowledge", fname)
    if os.path.isfile(path):
        with open(path, "r", encoding="utf-8") as f:
            texts.append(f.read())

tool.add_texts(texts)

---

## Link: https://olympics.com/fr/paris-2024

**URL:** llms-txt#link:-https://olympics.com/fr/paris-2024

---

## ... import events ...

**URL:** llms-txt#...-import-events-...

class MyCustomListener(BaseEventListener):
    # ... implementation ...

---

## Example task to extract product information from an e-commerce site

**URL:** llms-txt#example-task-to-extract-product-information-from-an-e-commerce-site

scrape_task = Task(
    description="Extract product names, prices, and descriptions from the featured products section of example.com.",
    expected_output="A structured list of product information including names, prices, and descriptions.",
    agent=web_scraper_agent,
)

---

## 기본 동작 - 디렉토리가 자동으로 생성됩니다

**URL:** llms-txt#기본-동작---디렉토리가-자동으로-생성됩니다

**Contents:**
  - 디렉터리 생성 비활성화

report_task = Task(
    description='Generate a comprehensive market analysis report',
    expected_output='A detailed market analysis with charts and insights',
    agent=analyst_agent,
    output_file='reports/2025/market_analysis.md',  # 'reports/2025/'가 없으면 생성됩니다
    markdown=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 디렉터리 생성 비활성화

자동 디렉터리 생성을 방지하고 디렉터리가 이미 존재함을 보장하려면 `create_directory=False`로 설정하세요:
```

---

## Integração com Google Sheets

**URL:** llms-txt#integração-com-google-sheets

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com Google Sheets
  - 1. Conecte sua Conta Google
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de um Agente Google Sheets

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/google_sheets

Sincronização de dados de planilhas com a integração do Google Sheets para CrewAI.

Permita que seus agentes gerenciem dados de planilhas por meio do Google Sheets. Leia linhas, crie novos registros, atualize dados existentes e otimize os fluxos de trabalho de gerenciamento de dados com automação alimentada por IA. Perfeito para acompanhamento de dados, relatórios e gestão colaborativa de informações.

Antes de utilizar a integração com o Google Sheets, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Google com acesso ao Google Sheets
* Sua conta Google conectada pela [página de integrações](https://app.crewai.com/crewai_plus/connectors)
* Planilhas com cabeçalhos de coluna adequados para operações com dados

## Configurando a Integração com Google Sheets

### 1. Conecte sua Conta Google

1. Acesse [Integrações do CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Localize **Google Sheets** na seção Integrações de Autenticação
3. Clique em **Conectar** e conclua o fluxo OAuth
4. Conceda as permissões necessárias para acesso à planilha
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="google_sheets/get_values">
    **Descrição:** Obtém linhas de uma planilha Google Sheets.

* `spreadsheetId` (string, obrigatório): Planilha - Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar uma planilha. Por padrão, usa a primeira worksheet da planilha selecionada.
    * `limit` (string, opcional): Limite de linhas - Limita o número máximo de linhas retornadas.
  </Accordion>

<Accordion title="google_sheets/append_values">
    **Descrição:** Cria uma nova linha em uma planilha Google Sheets.

* `spreadsheetId` (string, obrigatório): Planilha - Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar uma planilha. Por padrão, usa a primeira worksheet da planilha selecionada.
    * `worksheet` (string, obrigatório): Worksheet - Sua worksheet deve conter cabeçalhos de coluna.
    * `additionalFields` (object, obrigatório): Campos - Inclua os campos para criar essa linha como um objeto, usando os nomes das colunas como chaves. Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar um Mapeamento de Colunas.
      
  </Accordion>

<Accordion title="google_sheets/update_values">
    **Descrição:** Atualiza linhas existentes em uma planilha Google Sheets.

* `spreadsheetId` (string, obrigatório): Planilha - Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar uma planilha. Por padrão, usa a primeira worksheet da planilha selecionada.
    * `worksheet` (string, obrigatório): Worksheet - Sua worksheet deve conter cabeçalhos de coluna.
    * `filterFormula` (object, opcional): Filtro em forma normal disjuntiva - OU de grupos E (AND) de condições individuais para identificar quais linhas atualizar.
      
      Operadores disponíveis: `$stringContains`, `$stringDoesNotContain`, `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringStartsWith`, `$stringDoesNotStartWith`, `$stringEndsWith`, `$stringDoesNotEndWith`, `$numberGreaterThan`, `$numberLessThan`, `$numberEquals`, `$numberDoesNotEqual`, `$dateTimeAfter`, `$dateTimeBefore`, `$dateTimeEquals`, `$booleanTrue`, `$booleanFalse`, `$exists`, `$doesNotExist`
    * `additionalFields` (object, obrigatório): Campos - Inclua os campos a serem atualizados como objeto, usando os nomes das colunas como chaves. Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar um Mapeamento de Colunas.
      
  </Accordion>
</AccordionGroup>

### Configuração Básica de um Agente Google Sheets

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="google_sheets/get_values">
    **Descrição:** Obtém linhas de uma planilha Google Sheets.

    **Parâmetros:**

    * `spreadsheetId` (string, obrigatório): Planilha - Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar uma planilha. Por padrão, usa a primeira worksheet da planilha selecionada.
    * `limit` (string, opcional): Limite de linhas - Limita o número máximo de linhas retornadas.
  </Accordion>

  <Accordion title="google_sheets/append_values">
    **Descrição:** Cria uma nova linha em uma planilha Google Sheets.

    **Parâmetros:**

    * `spreadsheetId` (string, obrigatório): Planilha - Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar uma planilha. Por padrão, usa a primeira worksheet da planilha selecionada.
    * `worksheet` (string, obrigatório): Worksheet - Sua worksheet deve conter cabeçalhos de coluna.
    * `additionalFields` (object, obrigatório): Campos - Inclua os campos para criar essa linha como um objeto, usando os nomes das colunas como chaves. Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar um Mapeamento de Colunas.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="google_sheets/update_values">
    **Descrição:** Atualiza linhas existentes em uma planilha Google Sheets.

    **Parâmetros:**

    * `spreadsheetId` (string, obrigatório): Planilha - Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar uma planilha. Por padrão, usa a primeira worksheet da planilha selecionada.
    * `worksheet` (string, obrigatório): Worksheet - Sua worksheet deve conter cabeçalhos de coluna.
    * `filterFormula` (object, opcional): Filtro em forma normal disjuntiva - OU de grupos E (AND) de condições individuais para identificar quais linhas atualizar.
```

---

## Automação com Webhook

**URL:** llms-txt#automação-com-webhook

**Contents:**
- Configurando Webhooks
- Exemplos de Output do Webhook

Source: https://docs.crewai.com/pt-BR/enterprise/guides/webhook-automation

Automatize fluxos de trabalho do CrewAI AMP usando webhooks com plataformas como ActivePieces, Zapier e Make.com

O CrewAI AMP permite que você automatize seu fluxo de trabalho usando webhooks. Este artigo irá guiá-lo no processo de configuração e uso de webhooks para iniciar a execução do crew, com foco na integração com o ActivePieces, uma plataforma de automação de fluxos de trabalho semelhante ao Zapier e Make.com.

## Configurando Webhooks

<Steps>
  <Step title="Acessando a Interface de Kickoff">
    * Navegue até o painel do CrewAI AMP
    * Procure pela seção `/kickoff`, que é usada para iniciar a execução do crew
      <Frame>
        <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=4e6a4b1f098388c7f76e91c25ed4b077" alt="Interface Kickoff" data-og-width="670" width="670" data-og-height="358" height="358" data-path="images/enterprise/kickoff-interface.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=31eccbe3c20da734c90a1b2dd681261d 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b8f8311eeece00d69760069cf8f218cf 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=cd690e83cafc2b4675f5343d779fd413 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=640bf42c471ed898f434ff1b837aaf3f 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2ea591f56996cddcd1ab99a6ca951050 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c76d12bbd6580f8211a0c75c58105f41 2500w" />
      </Frame>
  </Step>

<Step title="Configurando o Conteúdo JSON">
    Na seção de Conteúdo JSON, você deverá fornecer as seguintes informações:

* **inputs**: Um objeto JSON contendo:
      * `company`: O nome da empresa (ex.: "tesla")
      * `product_name`: O nome do produto (ex.: "crewai")
      * `form_response`: O tipo de resposta (ex.: "financial")
      * `icp_description`: Uma breve descrição do Perfil de Cliente Ideal
      * `product_description`: Uma breve descrição do produto
      * `taskWebhookUrl`, `stepWebhookUrl`, `crewWebhookUrl`: URLs para diversos endpoints de webhook (ActivePieces, Zapier, Make.com ou outra plataforma compatível)
  </Step>

<Step title="Integração com ActivePieces">
    Neste exemplo usaremos o ActivePieces. Você pode utilizar outras plataformas, como Zapier e Make.com.

Para integrar com o ActivePieces:

1. Crie um novo flow no ActivePieces

2. Adicione um gatilho (ex.: agendamento `Every Day`)
       <Frame>
         <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1a52fc1bb47bef6228955360d00f190f" alt="Gatilho ActivePieces" data-og-width="595" width="595" data-og-height="773" height="773" data-path="images/enterprise/activepieces-trigger.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a08bb69bed1a61d5e8febbfe10ca5e7f 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=b1b5e3f75dc328b09023661ce318b68b 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a64f6e3cfd68c9c66e4248cf92e2f7f1 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=aedf530314a9542c8f217ba77feec4e8 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=95f0dc03528daddca61ad04822e7ba7c 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=48e52a1d3960d50b027f8c92f4a62e11 2500w" />
       </Frame>

3. Adicione uma etapa de ação HTTP
       * Configure a ação como `Send HTTP request`

* Use o método `POST`

* Defina a URL para o endpoint de kickoff do CrewAI AMP

* Adicione os headers necessários (ex.: `Bearer Token`)
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=602a5ed1aa2b462b0a81a122a5e2d35f" alt="Headers ActivePieces" data-og-width="449" width="449" data-og-height="572" height="572" data-path="images/enterprise/activepieces-headers.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=fb1852f1834f3ca324d88201890454c2 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3ac86c364aa02800cb7563d6f7a0cc4b 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1433e902dc31e3c5bba03cea45fca103 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=9ca4bc723b91d7681c7798019f933e00 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=d6efc61f86f20c2d850bbc6e43057084 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=508d671fe743548d52b5fa6f70d8c6f1 2500w" />
         </Frame>

* No corpo, inclua o conteúdo JSON conforme configurado na etapa 2
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f238e1630f7be667cce2d208315ddc75" alt="Body ActivePieces" data-og-width="670" width="670" data-og-height="401" height="401" data-path="images/enterprise/activepieces-body.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=184acb105d21412a7a2cb184d57b067e 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=2820fd618992f3299a713701cf6d3a3e 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=988d687157f7dea236e152edb382ac4f 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=9c7603e394ffb44676be999c9bfd8843 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=84b3aa1d756e36d3578c11a81a1bba03 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f8ca588c964165c10b66d26478b1201a 2500w" />
         </Frame>

* O crew será iniciado no horário pré-definido.
  </Step>

<Step title="Configurando o Webhook">
    1. Crie um novo flow no ActivePieces e nomeie-o
       <Frame>
         <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c23af88ea2df7919f680706318eb1506" alt="Flow ActivePieces" data-og-width="544" width="544" data-og-height="683" height="683" data-path="images/enterprise/activepieces-flow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3efbff7b8131db3e87a41b0885447729 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1993b2b3ba57a859e42efcf21737c351 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3f46a4b1b2a17fcb0c0f3a9373699b5a 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3eff0450a0f63e2ed5b00797ee1295ea 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f3ca2cd9eb16b9f4642a27df234b191c 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=ffa10bab192e9b54be9ad3df31ce9036 2500w" />
       </Frame>

2. Adicione uma etapa de webhook como gatilho:
       * Selecione `Catch Webhook` como tipo de gatilho

* Isso irá gerar uma URL única que receberá requisições HTTP e disparará seu flow
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=8236fd9a97149eff4fd86f1c9a9b0f1a" alt="Webhook ActivePieces" data-og-width="451" width="451" data-og-height="488" height="488" data-path="images/enterprise/activepieces-webhook.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=67e441a99da496ffc5c7267f7a9edf38 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=bd59361f9c3c3cc590116b69ae938e62 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6baa9171275b63542d4518d517def191 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=d2ca4c48d4c27d35f86634a8cff980aa 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=791a725473ebaa655f55060dc60ba4a2 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c84dd08fd3ec706b43868a9a7b5629a8 2500w" />
         </Frame>

* Configure o e-mail para usar o corpo de texto do webhook do crew
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=484c8d88ed96322d21894e9663f5fc4a" alt="Email ActivePieces" data-og-width="461" width="461" data-og-height="518" height="518" data-path="images/enterprise/activepieces-email.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=619ef405e48854a83bfdfcc2d6ef44ec 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=43448b60f1c1686da67239865b31586c 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=79a570bad87d3beeebe8f87437823cac 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=180ce65773e5fd6007f08fa159f21dfb 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=80df8a27d8ba193f531db980a9697f6a 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a8e77053f8fed779ccff7474435f3cc8 2500w" />
         </Frame>
  </Step>
</Steps>

## Exemplos de Output do Webhook

**Nota:** Qualquer objeto `meta` fornecido na sua requisição de kickoff será incluído em todos os payloads de webhook, permitindo rastrear requisições e manter contexto durante todo o ciclo de vida da execução do crew.

<Tabs>
  <Tab title="Step Webhook">
    `stepWebhookUrl` - Callback executado a cada pensamento interno do agente

<Tab title="Task Webhook">
    `taskWebhookUrl` - Callback executado ao final de cada task

<Tab title="Crew Webhook">
    `crewWebhookUrl` - Callback executado ao final da execução do crew

**Examples:**

Example 1 (unknown):
```unknown
</Tab>

  <Tab title="Task Webhook">
    `taskWebhookUrl` - Callback executado ao final de cada task
```

Example 2 (unknown):
```unknown
</Tab>

  <Tab title="Crew Webhook">
    `crewWebhookUrl` - Callback executado ao final da execução do crew
```

---

## Add a YouTube video

**URL:** llms-txt#add-a-youtube-video

rag_tool.add(data_type="youtube_video", url="https://www.youtube.com/watch?v=VIDEO_ID")

---

## Snowflake 검색 도구

**URL:** llms-txt#snowflake-검색-도구

Source: https://docs.crewai.com/ko/tools/database-data/snowflakesearchtool

SnowflakeSearchTool은 CrewAI 에이전트가 Snowflake 데이터 웨어하우스에서 SQL 쿼리를 실행하고 시맨틱 검색을 수행할 수 있도록 합니다.

---

## Extract text from PDF

**URL:** llms-txt#extract-text-from-pdf

def extract_text_from_pdf(pdf_path):
    text = []
    with pdfplumber.open(pdf_path) as pdf:
        for page in pdf.pages:
            page_text = page.extract_text()
            if page_text:
                text.append(page_text.strip())
    return text

---

## 추적된 LLM으로 에이전트 생성

**URL:** llms-txt#추적된-llm으로-에이전트-생성

**Contents:**
  - 6. 효율적인 Crews를 위한 캐싱
  - 7. 모델 상호 운용성

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=portkey_llm
)
python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

# Configure LLM with simple caching
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
            config={
                "cache": {
                    "mode": "simple"
                }
            }
        )
    )

# Create agent with cached LLM
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

# Configure LLM with semantic caching
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
            config={
                "cache": {
                    "mode": "semantic"
                }
            }
        )
    )

# Create agent with semantically cached LLM
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
from crewai import Agent, LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
**사용자별로 분석 필터링**

메타데이터가 설정되어 있으면, 사용자별로 분석을 필터링하고 사용자 단위의 성능 지표를 분석할 수 있습니다:

<Frame caption="사용자별로 분석 필터링">
  <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" />
</Frame>

이를 통해 다음이 가능합니다:

* 사용자별 비용 추적 및 예산 관리
* 개인화된 사용자 분석
* 팀 또는 조직 단위의 지표
* 환경별 모니터링(스테이징 vs. 프로덕션)

<Card title="메타데이터에 대해 더 알아보기" icon="tags" href="https://portkey.ai/docs/product/observability/metadata">
  맞춤형 메타데이터를 활용하여 분석 기능을 향상시키는 방법을 살펴보세요
</Card>

### 6. 효율적인 Crews를 위한 캐싱

캐싱을 구현하여 CrewAI agent를 보다 효율적이고 비용 효율적으로 만드세요:

<Tabs>
  <Tab title="Simple Caching">
```

Example 2 (unknown):
```unknown
Simple 캐싱은 입력 프롬프트에 대한 정확한 일치 항목을 수행하며, 동일한 요청을 캐시에 저장하여 중복된 모델 실행을 방지합니다.
  </Tab>

  <Tab title="Semantic Caching">
```

Example 3 (unknown):
```unknown
Semantic 캐싱은 입력 요청 간의 맥락적 유사성을 고려하여, 의미적으로 유사한 입력에 대한 응답을 캐시에 저장합니다.
  </Tab>
</Tabs>

### 7. 모델 상호 운용성

CrewAI는 여러 LLM 제공업체를 지원하며, Portkey는 통합 인터페이스를 통해 200개 이상의 LLM에 대한 액세스를 제공함으로써 이 기능을 확장합니다. 코어 에이전트 로직을 변경하지 않고도 다양한 모델 간에 쉽게 전환할 수 있습니다:
```

---

## `OxylabsAmazonSearchScraperTool`

**URL:** llms-txt#`oxylabsamazonsearchscrapertool`

**Contents:**
  - Exemplo

```python  theme={null}
from crewai_tools import OxylabsAmazonSearchScraperTool

---

## Second agent creation (within 5 minutes) - uses cached tool schemas

**URL:** llms-txt#second-agent-creation-(within-5-minutes)---uses-cached-tool-schemas

**Contents:**
  - On-Demand Connections

agent2 = Agent(role="Second", goal="Test", backstory="Test",
               mcps=["https://api.example.com/mcp"])  # Much faster!
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### On-Demand Connections

Tool connections are established only when tools are actually used:
```

---

## Configuração avançada OpenAI

**URL:** llms-txt#configuração-avançada-openai

**Contents:**
  - Azure OpenAI Embeddings
  - Google AI Embeddings
  - Vertex AI Embeddings
  - Ollama Embeddings (Local)

crew = Crew(
    memory=True,
    embedder={
        "provider": "openai",
        "config": {
            "api_key": "your-openai-api-key",  # Opcional: sobrescreve variável de ambiente
            "model": "text-embedding-3-large",
            "dimensions": 1536,  # Opcional: reduz as dimensões para armazenamento menor
            "organization_id": "your-org-id"  # Opcional: para contas organizacionais
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "openai",  # Use openai como provider para Azure
        "config": {
            "api_key": "your-azure-api-key",
            "api_base": "https://your-resource.openai.azure.com/",
            "api_type": "azure",
            "api_version": "2023-05-15",
            "model": "text-embedding-3-small",
            "deployment_id": "your-deployment-name"  # Nome do deploy Azure
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "google",
        "config": {
            "api_key": "your-google-api-key",
            "model": "text-embedding-004"  # ou "text-embedding-preview-0409"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "vertexai",
        "config": {
            "project_id": "your-gcp-project-id",
            "region": "us-central1",  # ou sua região preferencial
            "api_key": "your-service-account-key",
            "model_name": "textembedding-gecko"
        }
    }
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Azure OpenAI Embeddings

Para empresas que utilizam deploys Azure OpenAI.
```

Example 2 (unknown):
```unknown
### Google AI Embeddings

Use modelos de embeddings de texto do Google para integração com serviços do Google Cloud.
```

Example 3 (unknown):
```unknown
### Vertex AI Embeddings

Para usuários do Google Cloud com acesso ao Vertex AI.
```

Example 4 (unknown):
```unknown
### Ollama Embeddings (Local)

Execute embeddings localmente para privacidade e economia.
```

---

## 두 번째 에이전트 생성 (5분 이내) - 캐시된 도구 스키마 사용

**URL:** llms-txt#두-번째-에이전트-생성-(5분-이내)---캐시된-도구-스키마-사용

**Contents:**
  - 온디맨드 연결

agent2 = Agent(role="두 번째", goal="테스트", backstory="테스트",
               mcps=["https://api.example.com/mcp"])  # 훨씬 빠릅니다!
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 온디맨드 연결

도구 연결은 실제로 사용될 때만 설정됩니다:
```

---

## Efficient model for data processing

**URL:** llms-txt#efficient-model-for-data-processing

**Contents:**
  - b. 구성요소별 선택
- 작업 정의 프레임워크
  - a. 복잡성보다 명확성에 집중하기
  - b. 작업 순서 지정 전략
- LLM 성능을 위한 에이전트 구성 최적화
  - a. 역할 기반 LLM 선택

processing_llm = LLM(model="gpt-4o-mini", temperature=0)

research_manager = Agent(
    role="Research Strategy Manager",
    goal="Develop comprehensive research strategies and coordinate team efforts",
    backstory="Expert research strategist with deep analytical capabilities",
    llm=manager_llm,  # High-capability model for complex reasoning
    verbose=True
)

content_writer = Agent(
    role="Research Content Writer",
    goal="Transform research findings into compelling, well-structured reports",
    backstory="Skilled writer who excels at making complex topics accessible",
    llm=content_llm,  # Creative model for engaging content
    verbose=True
)

data_processor = Agent(
    role="Data Analysis Specialist",
    goal="Extract and organize key data points from research sources",
    backstory="Detail-oriented analyst focused on accuracy and efficiency",
    llm=processing_llm,  # Fast, cost-effective model for routine tasks
    verbose=True
)

crew = Crew(
    agents=[research_manager, content_writer, data_processor],
    tasks=[...],  # Your specific tasks
    manager_llm=manager_llm,  # Manager uses the reasoning model
    verbose=True
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
성공적인 멀티-모델 구현의 핵심은 서로 다른 agent들이 어떻게 상호작용하는지를 이해하고, 모델의 역량이 agent의 책임에 부합하는지 확인하는 것입니다. 이를 위해 신중한 기획이 필요하지만, 그 결과로 산출물의 품질과 운영 효율성 모두에서 큰 개선을 이끌어낼 수 있습니다.

### b. 구성요소별 선택

<Tabs>
  <Tab title="Manager LLM">
    Manager LLM은 계층적 CrewAI 프로세스에서 중요한 역할을 하며, 여러 에이전트와 작업을 조정하는 중심점으로 작동합니다. 이 모델은 위임, 작업 우선순위 지정, 여러 동시 작업 간의 컨텍스트 유지에 뛰어나야 합니다.

    효과적인 Manager LLM은 올바른 위임 결정을 내리기 위한 강력한 추론 능력, 예측 가능한 조정을 보장하는 일관된 성능, 여러 에이전트의 상태를 동시에 추적하기 위한 탁월한 컨텍스트 관리가 필요합니다. 이 모델은 다양한 에이전트의 역량과 한계를 이해하고, 효율성과 품질을 최적화하기 위해 작업 할당을 최적화해야 합니다.

    Manager LLM은 모든 작업에 관여하기 때문에 비용 고려가 특히 중요합니다. 모델은 효과적인 조정을 위한 충분한 역량을 제공하면서도, 잦은 사용에도 비용 효율적이어야 합니다. 이는 종종 가장 정교한 모델의 높은 가격 없이도 충분한 추론 능력을 제공하는 모델을 찾는 것을 의미합니다.
  </Tab>

  <Tab title="Function Calling LLM">
    Function calling LLM은 모든 에이전트 간 도구 사용을 처리하므로, 외부 도구와 API에 크게 의존하는 crew에서 매우 중요합니다. 이 모델은 도구의 역량을 이해하고, 파라미터를 정확하게 추출하며, 도구 응답을 효과적으로 처리하는 데 특화되어야 합니다.

    Function calling LLM에서 가장 중요한 특성은 창의성이나 정교한 추론력보다는 정확성과 신뢰성입니다. 모델은 자연어 요청에서 올바른 파라미터를 일관되게 추출하고, 도구 응답을 적절히 처리해야 합니다. 도구 사용은 여러 번의 왕복 작업이 수반될 수 있으므로 속도도 중요합니다.

    많은 팀들은, 창의적이거나 추론에 특화된 모델보다는, 특화된 function calling 모델이나 도구 지원이 강력한 범용 모델이 이 역할에 더 적합하다는 것을 발견합니다. 핵심은 모델이 자연어 지침과 구조화된 도구 호출 간의 간극을 신뢰성 있게 연결할 수 있도록 하는 것입니다.
  </Tab>

  <Tab title="Agent-Specific Overrides">
    개별 에이전트는 특정 요구가 일반적인 crew 요구와 크게 다를 때, crew 단위 LLM 설정을 재정의할 수 있습니다. 이 기능을 통해 대부분의 에이전트에는 운영 단순성을 유지하면서, 미세한 최적화가 가능합니다.

    에이전트별 재정의를 고려해야 하는 경우는 에이전트의 역할이 다른 crew 구성원과 본질적으로 다른 역량을 요구할 때입니다. 예를 들어, 창의적 글쓰기에 특화된 에이전트는 콘텐츠 생성에 최적화된 모델이 도움이 될 수 있고, 데이터 분석 에이전트는 추론에 중점을 둔 모델로 더 나은 성과를 거둘 수 있습니다.

    에이전트별 재정의를 적용할 때의 과제는 최적화와 운영 복잡도 간의 균형을 유지하는 것입니다. 모델이 하나 추가될 때마다 배포, 모니터링, 비용 관리의 복잡성이 늘어납니다. 따라서 팀은 성능 향상 효과가 추가 복잡성을 정당화할 수 있는 에이전트에만 재정의를 집중해야 합니다.
  </Tab>
</Tabs>

## 작업 정의 프레임워크

### a. 복잡성보다 명확성에 집중하기

CrewAI 출력의 품질을 결정하는 데 있어 모델 선택보다 효과적인 작업 정의가 더 중요한 경우가 많습니다. 잘 정의된 작업은 명확한 방향과 맥락을 제공하여 심지어 보통 수준의 모델도 좋은 성능을 낼 수 있게 해주지만, 잘못 정의된 작업은 고도화된 모델조차 만족스럽지 않은 결과를 만들 수 있습니다.

<AccordionGroup>
  <Accordion title="효과적인 작업 설명" icon="list-check">
    최고의 작업 설명은 적절한 세부 정보 제공과 명확성 유지를 균형 있게 조화시킵니다. 작업의 구체적인 목표를 성공이 어떤 모습인지에 대한 모호함 없이 명확하게 정의해야 하며, 접근 방식이나 방법론을 충분히 설명하여 에이전트가 어떻게 진행해야 하는지 이해할 수 있도록 해야 합니다.

    효과적인 작업 설명은 에이전트가 더 넓은 목적과 그들이 반드시 지켜야 할 제한사항을 이해할 수 있도록 관련 맥락 및 제약 조건을 포함합니다. 복잡한 작업을 체계적으로 실행할 수 있는 집중된 단계로 분할하여, 여러 측면이 뒤섞이고 접근하기 어려운 압도적인 목표로 제시하지 않습니다.

    일반적인 실수로는 목표가 너무 모호하다거나, 필요한 맥락을 제공하지 않는다거나, 성공 기준이 불분명하다거나, 관련 없는 여러 작업을 하나의 설명으로 결합하는 경우가 있습니다. 목표는 단일의 명확한 목적에 집중하며, 에이전트가 성공할 수 있을 정도로 충분한 정보를 제공하는 것입니다.
  </Accordion>

  <Accordion title="예상 산출물 가이드라인" icon="bullseye">
    예상 산출물 가이드라인은 작업 정의와 에이전트 간의 계약 역할을 하며, 산출물이 어떤 모습이어야 하며 어떻게 평가될 것인지 명확하게 지정합니다. 이러한 가이드라인은 필요한 형식과 구조뿐만 아니라 산출물이 완전하다고 간주되기 위해 반드시 포함되어야 하는 핵심 요소도 설명해야 합니다.

    최고의 산출물 가이드라인은 품질 지표에 대한 구체적인 예시를 제공하고, 완료 기준을 에이전트와 인간 평가자 모두가 작업의 성공적 완료 여부를 평가할 수 있을 만큼 명확하게 정의합니다. 이는 모호함을 줄이고 여러 작업 실행 간 일관된 결과를 보장하는 데 도움이 됩니다.

    어떤 작업에나 적용할 수 있을 정도로 일반적인 산출물 설명, 에이전트가 구조를 추측해야 하는 형식 명세 누락, 평가가 어려운 불분명한 품질 기준, 에이전트가 기대치를 이해하도록 도와주는 예시 또는 템플릿 미제공 등은 피해야 합니다.
  </Accordion>
</AccordionGroup>

### b. 작업 순서 지정 전략

<Tabs>
  <Tab title="순차적 의존성">
    작업이 이전 산출물에 기반을 두거나, 정보가 한 작업에서 다른 작업으로 흐르거나, 품질이 선행 작업의 완료에 의존할 때 순차적 작업 의존성이 필수적입니다. 이 접근 방식은 각 작업이 성공적으로 수행되는 데 필요한 정보와 맥락에 접근할 수 있도록 보장합니다.

    순차적 의존성을 효과적으로 구현하기 위해서는 context 파라미터를 사용하여 관련 작업을 연쇄시키고, 작업의 진행을 통해 점진적으로 복잡성을 구축하며, 각 작업이 다음 작업에 의미 있는 입력값이 될 수 있는 산출물을 생성하도록 해야 합니다. 목표는 의존된 작업 간의 논리적 흐름을 유지하면서 불필요한 병목을 피하는 것입니다.

    순차적 의존성은 한 작업에서 다른 작업으로 명확한 논리적 진행이 있고, 한 작업의 산출물이 다음 작업의 품질이나 실행 가능성을 실제로 향상시킬 때 가장 효과적입니다. 그러나 적절히 관리되지 않을 경우 병목 현상이 발생할 수 있으니, 반드시 진정으로 필요한 의존성과 단순히 편의상 설정된 의존성을 구분해야 합니다.
  </Tab>

  <Tab title="병렬 실행">
    병렬 실행은 작업 간에 상호 독립적이거나, 시간 효율성이 중요하거나, 서로 다른 전문 분야가 협업 없이 각자의 역량을 발휘할 수 있을 때 가치가 있습니다. 이 방식은 전체 실행 시간을 크게 줄일 수 있으며, 각 전문 에이전트가 자신의 강점을 동시에 발휘할 수 있습니다.

    성공적인 병렬 실행을 위해서는 실제로 독립적으로 수행이 가능한 작업을 식별하고, 관련되지만 분리된 작업 스트림을 효과적으로 그룹화하며, 병렬로 진행된 작업을 최종 결과물로 통합해야 할 때 결과 통합을 계획해야 합니다. 핵심은 병렬 작업이 전체 품질을 저하하는 충돌이나 중복을 만들지 않도록 하는 것입니다.

    여러 개의 독립적인 연구 스트림이나 서로 의존하지 않는 다양한 분석, 동시에 개발이 가능한 콘텐츠 생성 작업이 있을 때 병렬 실행을 고려하십시오. 다만, 자원 할당에 주의하고, 병렬 실행이 모델의 가용 용량이나 예산을 초과하지 않도록 해야 합니다.
  </Tab>
</Tabs>

## LLM 성능을 위한 에이전트 구성 최적화

### a. 역할 기반 LLM 선택

<Warning>
  일반적인 에이전트 역할은 올바른 LLM을 선택할 수 없게 만듭니다. 구체적인 역할은 목표에 맞춘 모델 최적화를 가능하게 합니다.
</Warning>

에이전트 역할의 구체성은 최적의 성능을 위해 어떤 LLM의 능력이 가장 중요한지를 직접적으로 결정합니다. 이는 에이전트의 책임에 정확히 맞는 모델 강점을 연결할 수 있는 전략적 기회를 만듭니다.

**일반 역할 vs. 구체적 역할이 LLM 선택에 미치는 영향:**

역할을 정의할 때 에이전트가 다룰 작업에 가장 가치 있는 특정 도메인 지식, 작업 방식, 의사결정 프레임워크를 고려하세요. 역할 정의가 더 구체적이고 상황에 맞을수록 모델이 그 역할을 효과적으로 구현할 수 있습니다.
```

---

## `DatabricksQueryTool`

**URL:** llms-txt#`databricksquerytool`

**Contents:**
- Description
- Installation
- Environment Variables
- Example
- Parameters
- Defaults on initialization
  - Error handling & tips

Run SQL against Databricks workspace tables with either CLI profile or direct host/token authentication.

## Environment Variables

* `DATABRICKS_CONFIG_PROFILE` or (`DATABRICKS_HOST` + `DATABRICKS_TOKEN`)

Create a personal access token and find host details in the Databricks workspace under User Settings → Developer.
Docs: [https://docs.databricks.com/en/dev-tools/auth/pat.html](https://docs.databricks.com/en/dev-tools/auth/pat.html)

* `query` (required): SQL query to execute
* `catalog` (optional): Override default catalog
* `db_schema` (optional): Override default schema
* `warehouse_id` (optional): Override default SQL warehouse
* `row_limit` (optional): Maximum rows to return (default: 1000)

## Defaults on initialization

* `default_catalog`
* `default_schema`
* `default_warehouse_id`

### Error handling & tips

* Authentication errors: verify `DATABRICKS_HOST` begins with `https://` and token is valid.
* Permissions: ensure your SQL warehouse and schema are accessible by your token.
* Limits: long‑running queries should be avoided in agent loops; add filters/limits.

**Examples:**

Example 1 (unknown):
```unknown
## Environment Variables

* `DATABRICKS_CONFIG_PROFILE` or (`DATABRICKS_HOST` + `DATABRICKS_TOKEN`)

Create a personal access token and find host details in the Databricks workspace under User Settings → Developer.
Docs: [https://docs.databricks.com/en/dev-tools/auth/pat.html](https://docs.databricks.com/en/dev-tools/auth/pat.html)

## Example
```

---

## Store in project directory

**URL:** llms-txt#store-in-project-directory

project_root = Path(__file__).parent
storage_dir = project_root / "crewai_storage"

os.environ["CREWAI_STORAGE_DIR"] = str(storage_dir)

---

## Ver organização atual

**URL:** llms-txt#ver-organização-atual

---

## OCR Tool

**URL:** llms-txt#ocr-tool

Source: https://docs.crewai.com/pt-BR/tools/file-document/ocrtool

The `OCRTool` extracts text from local images or image URLs using an LLM with vision.

---

## YouTube 비디오 추가

**URL:** llms-txt#youtube-비디오-추가

rag_tool.add(data_type="youtube_video", url="https://www.youtube.com/watch?v=VIDEO_ID")

---

## 검색에서 filter_by="year", filter_value=2024를 사용하는 경우

**URL:** llms-txt#검색에서-filter_by="year",-filter_value=2024를-사용하는-경우

---

## Or use knowledge sources instead of large prompts

**URL:** llms-txt#or-use-knowledge-sources-instead-of-large-prompts

python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**If automatic summarization loses important information:**
```

---

## Modelo eficiente para processamento de dados

**URL:** llms-txt#modelo-eficiente-para-processamento-de-dados

**Contents:**
  - b. Seleção Específica por Componente
- Framework de Definição de Tarefas
  - a. Foque em Clareza, Não em Complexidade
  - b. Estratégia de Sequenciamento de Tarefas
- Otimizando a Configuração dos Agentes para Desempenho de LLMs
  - a. Seleção de LLM Guiada pelo Papel

processing_llm = LLM(model="gpt-4o-mini", temperature=0)

research_manager = Agent(
    role="Research Strategy Manager",
    goal="Develop comprehensive research strategies and coordinate team efforts",
    backstory="Expert research strategist with deep analytical capabilities",
    llm=manager_llm,  # Modelo de alto nível para raciocínio complexo
    verbose=True
)

content_writer = Agent(
    role="Research Content Writer",
    goal="Transform research findings into compelling, well-structured reports",
    backstory="Skilled writer who excels at making complex topics accessible",
    llm=content_llm,  # Modelo criativo para conteúdo envolvente
    verbose=True
)

data_processor = Agent(
    role="Data Analysis Specialist",
    goal="Extract and organize key data points from research sources",
    backstory="Detail-oriented analyst focused on accuracy and efficiency",
    llm=processing_llm,  # Modelo rápido para tarefas rotineiras
    verbose=True
)

crew = Crew(
    agents=[research_manager, content_writer, data_processor],
    tasks=[...],  # Suas tarefas específicas
    manager_llm=manager_llm,  # Manager usa o modelo de raciocínio
    verbose=True
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
O segredo do sucesso na implementação multi-modelo está em entender como os agentes interagem e garantir que as capacidades dos modelos estejam alinhadas às responsabilidades. Isso exige planejamento estratégico, mas traz ganhos significativos em qualidade dos resultados e eficiência operacional.

### b. Seleção Específica por Componente

<Tabs>
  <Tab title="Manager LLM">
    O manager LLM desempenha papel central em fluxos hierárquicos CrewAI, coordenando agentes e tarefas. Este modelo precisa se destacar em delegação, priorização de tarefas e manutenção de contexto em várias operações simultâneas.

    LLMs de manager eficazes exigem forte raciocínio para delegar bem, desempenho consistente para coordenar previsivelmente e excelente gestão de contexto para acompanhar o estado dos agentes. O modelo deve entender capacidades e limitações dos agentes enquanto otimiza a alocação de tarefas.

    O custo é especialmente relevante, já que este LLM participa de todas as operações. O modelo precisa entregar capacidades suficientes, sem o preço premium de opções sofisticadas demais, buscando sempre o equilíbrio entre performance e valor.
  </Tab>

  <Tab title="Function Calling LLM">
    LLMs de function calling gerenciam o uso de ferramentas por todos os agentes, sendo críticos em crews que dependem fortemente de APIs externas e ferramentas. Devem ser precisos na extração de parâmetros e no processamento das respostas.

    As características mais importantes são precisão e confiabilidade, não criatividade ou raciocínio avançado. O modelo deve extrair parâmetros corretos de comandos em linguagem natural consistentemente e processar respostas de ferramentas adequadamente. Velocidade também importa, pois o uso de ferramentas pode envolver múltiplas idas e vindas de informação.

    Muitas equipes descobrem que modelos especializados em function calling ou de uso geral com forte suporte a ferramentas funcionam melhor do que modelos criativos ou de raciocínio nesse papel. O fundamental é assegurar que o modelo consiga converter instruções em chamadas estruturadas sem falhas.
  </Tab>

  <Tab title="Sobrescritas Específicas de Agente">
    Agentes individuais podem sobrescrever o LLM do nível da crew quando suas necessidades diferem significativamente das do restante. Isso permite otimização pontual, mantendo a simplicidade operacional para os demais agentes.

    Considere sobrescritas quando a função do agente exige capacidades distintas. Por exemplo, um agente de redação criativa pode se beneficiar de um LLM otimizado para geração de conteúdo, enquanto um analista de dados pode preferir um modelo voltado ao raciocínio.

    O desafio é balancear otimização com complexidade operacional. Cada modelo adicional aumenta a complexidade de deployment, monitoramento e custos. Foque em sobrescritas apenas quando a melhoria justificar essa complexidade.
  </Tab>
</Tabs>

## Framework de Definição de Tarefas

### a. Foque em Clareza, Não em Complexidade

Definir bem as tarefas é frequentemente mais importante do que a seleção do modelo no resultado gerado pelos agentes CrewAI. Tarefas bem formuladas orientam claramente mesmo modelos simples a terem bom desempenho. Já tarefas mal definidas prejudicam até os modelos mais avançados.

<AccordionGroup>
  <Accordion title="Descrições de Tarefas Eficazes" icon="list-check">
    As melhores descrições de tarefas equilibram detalhamento e clareza. Devem definir o objetivo de forma clara e sem ambiguidade, além de explicar o método a ser usado com detalhes que permitam ao agente agir corretamente.

    Descrições eficazes incluem contexto relevante e restrições, ajudando o agente a entender o propósito maior e quaisquer limitações. Divida trabalhos complexos em etapas gerenciáveis em vez de objetivos genéricos e sobrecarregados.

    Erros comuns incluem objetivos vagos, falta de contexto, critérios de sucesso mal definidos ou mistura de tarefas totalmente distintas em um mesmo texto. O objetivo é passar informação suficiente para o sucesso, mas mantendo foco no resultado claro.
  </Accordion>

  <Accordion title="Diretrizes para a Saída Esperada" icon="bullseye">
    As diretrizes da saída esperada funcionam como contrato entre definição de tarefa e agente, especificando claramente o que deve ser entregue e como será avaliado. Elas abrangem formato, estrutura e elementos essenciais.

    As melhores diretrizes incluem exemplos concretos de indicadores de qualidade e critérios claros de conclusão, de modo que agente e revisores humanos possam avaliar o resultado facilmente. Isso reduz ambiguidades e garante resultados consistentes.

    Evite descrições genéricas que serviriam para qualquer tarefa, ausência de especificações de formato, padrões vagos ou falta de exemplos/modelos que ajudem o agente a entender as expectativas.
  </Accordion>
</AccordionGroup>

### b. Estratégia de Sequenciamento de Tarefas

<Tabs>
  <Tab title="Dependências Sequenciais">
    Dependências são essenciais quando as tarefas se baseiam em resultados prévios, informações fluem de uma tarefa para outra, ou a qualidade depende da conclusão de fases anteriores. Assim, cada tarefa recebe o contexto correto para o sucesso.

    Para implementar bem, use o parâmetro de contexto para encadear tarefas, desenvolvendo gradualmente a complexidade. Cada tarefa deve gerar saídas que alimentam as próximas. O objetivo é manter um fluxo lógico entre as tarefas dependentes, evitando gargalos desnecessários.

    Funciona melhor quando há progressão lógica evidente e quando a saída de uma tarefa realmente agrega valor nas etapas seguintes. Cuidado com os gargalos; foque nas dependências essenciais.
  </Tab>

  <Tab title="Execução Paralela">
    A execução paralela é valiosa quando as tarefas são independentes, o tempo é crítico ou há expertise distintas que não exigem coordenação. Pode reduzir drasticamente o tempo total, permitindo que agentes especializados atuem simultaneamente.

    Para isso, identifique tarefas realmente independentes, agrupe fluxos de trabalho distintos e planeje a integração dos resultados posteriormente. O ponto-chave é garantir que tarefas paralelas não gerem conflitos ou redundâncias.

    Considere o paralelo em múltiplos fluxos independentes, diferentes tipos de análise autônoma, ou criação de conteúdo que pode ser feita ao mesmo tempo. Mas atente-se à alocação de recursos, evitando sobrecarga de modelos ou estouro no orçamento.
  </Tab>
</Tabs>

## Otimizando a Configuração dos Agentes para Desempenho de LLMs

### a. Seleção de LLM Guiada pelo Papel

<Warning>
  Funções genéricas de agentes tornam impossível escolher o LLM certo. Funções específicas permitem otimização do modelo conforme a função.
</Warning>

A especificidade das funções dos agentes determina quais capacidades de LLM mais importam para alto desempenho, criando oportunidade estratégica de alinhar forças do modelo ao papel do agente.

**Impacto de Funções Genéricas vs. Específicas:**

Ao definir funções, pense no conhecimento do domínio, estilo de trabalho e frameworks decisórios mais valiosos para o tipo de tarefa do agente. Quanto mais específica e contextualizada a função, melhor o modelo incorporará esse papel.
```

---

## Inicialize o agente com opções avançadas

**URL:** llms-txt#inicialize-o-agente-com-opções-avançadas

**Contents:**
- Delegação e Autonomia
  - Exemplo: Desabilitando Delegação para um Agente

agent = Agent(
  role='Analista de Pesquisa',
  goal='Fornecer análises de mercado atualizadas',
  backstory='Um analista especialista com olhar atento para tendências de mercado.',
  tools=[search_tool],
  memory=True, # Ativa memória
  verbose=True,
  max_rpm=None, # Sem limite de requisições por minuto
  max_iter=25, # Valor padrão de máximo de iterações
)
python Code theme={null}
agent = Agent(
  role='Redator de Conteúdo',
  goal='Escrever conteúdo envolvente sobre tendências de mercado',
  backstory='Um redator experiente com expertise em análise de mercado.',
  allow_delegation=True # Habilitando delegação
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Delegação e Autonomia

Controlar a capacidade de um agente delegar tarefas ou fazer perguntas é fundamental para ajustar sua autonomia e a dinâmica de colaboração dentro do framework CrewAI. Por padrão,
o atributo `allow_delegation` agora é definido como `False`, desabilitando para que agentes busquem assistência ou deleguem tarefas conforme necessário. Esse comportamento padrão pode ser alterado para promover resolução colaborativa de problemas e
eficiência dentro do ecossistema CrewAI. Se necessário, a delegação pode ser ativada para atender requisitos operacionais específicos.

### Exemplo: Desabilitando Delegação para um Agente
```

---

## Initialize Qdrant search tool

**URL:** llms-txt#initialize-qdrant-search-tool

from crewai_tools import QdrantConfig

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url=os.getenv("QDRANT_URL"),
        qdrant_api_key=os.getenv("QDRANT_API_KEY"),
        collection_name=collection_name,
        limit=3,
        score_threshold=0.35
    )
)

---

## Custom Manager Agent

**URL:** llms-txt#custom-manager-agent

Source: https://docs.crewai.com/en/learn/custom-manager-agent

Learn how to set a custom agent as the manager in CrewAI, providing more control over task management and coordination.

---

## 설치

**URL:** llms-txt#설치

**Contents:**
- 비디오 튜토리얼
- 텍스트 튜토리얼

Source: https://docs.crewai.com/ko/installation

CrewAI 시작하기 - 설치, 구성, 그리고 첫 번째 AI crew 구축하기

설치 과정을 단계별로 시연하는 비디오 튜토리얼을 시청하세요:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/-kSOTtYzgEw" title="CrewAI Installation Guide" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

<Note>
  **Python 버전 요구 사항**

CrewAI는 `Python >=3.10 및 <3.14`가 필요합니다. 버전을 확인하는 방법은 다음과 같습니다:

Python을 업데이트해야 하는 경우, [python.org/downloads](https://python.org/downloads)를 방문하세요.
</Note>

CrewAI는 의존성 관리와 패키지 처리를 위해 `uv`를 사용합니다. 프로젝트 설정과 실행을 간소화하여 원활한 경험을 제공합니다.

아직 `uv`를 설치하지 않았다면 **1단계**를 따라 빠르게 시스템에 설치할 수 있습니다. 이미 설치되어 있다면 **2단계**로 건너뛸 수 있습니다.

<Steps>
  <Step title="uv 설치하기">
    * **macOS/Linux에서:**

`curl`을 이용해 스크립트를 다운로드하고 `sh`로 실행하세요:

시스템에 `curl`이 없다면, `wget`을 사용할 수 있습니다:

`irm`으로 스크립트를 다운로드하고 `iex`로 실행하세요:

문제가 발생하면 [UV 설치 가이드](https://docs.astral.sh/uv/getting-started/installation/)를 참고하세요.
  </Step>

<Step title="CrewAI 설치 🚀">
    * 다음 명령어를 실행하여 `crewai` CLI를 설치하세요:

<Warning>
        `PATH` 경고가 발생하면 쉘을 업데이트하기 위해 아래 명령어를 실행하세요:

<Warning>
        Windows에서 `chroma-hnswlib==0.7.6` 빌드 오류(`fatal error C1083: Cannot open include file: 'float.h'`)가 발생하면, [Visual Studio Build Tools](https://visualstudio.microsoft.com/downloads/)에서 *C++를 사용한 데스크톱 개발*을 설치하세요.
      </Warning>

* `crewai`가 정상적으로 설치되었는지 확인하려면 다음을 실행하세요:

* `crewai`를 업데이트해야 하는 경우, 다음을 실행하세요:

<Check>설치가 완료되었습니다! 이제 첫 번째 crew를 만들 준비가 되었습니다! 🎉</Check>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
Python을 업데이트해야 하는 경우, [python.org/downloads](https://python.org/downloads)를 방문하세요.
</Note>

CrewAI는 의존성 관리와 패키지 처리를 위해 `uv`를 사용합니다. 프로젝트 설정과 실행을 간소화하여 원활한 경험을 제공합니다.

아직 `uv`를 설치하지 않았다면 **1단계**를 따라 빠르게 시스템에 설치할 수 있습니다. 이미 설치되어 있다면 **2단계**로 건너뛸 수 있습니다.

<Steps>
  <Step title="uv 설치하기">
    * **macOS/Linux에서:**

      `curl`을 이용해 스크립트를 다운로드하고 `sh`로 실행하세요:
```

Example 2 (unknown):
```unknown
시스템에 `curl`이 없다면, `wget`을 사용할 수 있습니다:
```

Example 3 (unknown):
```unknown
* **Windows에서:**

      `irm`으로 스크립트를 다운로드하고 `iex`로 실행하세요:
```

Example 4 (unknown):
```unknown
문제가 발생하면 [UV 설치 가이드](https://docs.astral.sh/uv/getting-started/installation/)를 참고하세요.
  </Step>

  <Step title="CrewAI 설치 🚀">
    * 다음 명령어를 실행하여 `crewai` CLI를 설치하세요:
```

---

## Outside the context, the temporary handler is removed

**URL:** llms-txt#outside-the-context,-the-temporary-handler-is-removed

**Contents:**
- Use Cases
- Best Practices

Event listeners can be used for a variety of purposes:

1. **Logging and Monitoring**: Track the execution of your Crew and log important events
2. **Analytics**: Collect data about your Crew's performance and behavior
3. **Debugging**: Set up temporary listeners to debug specific issues
4. **Integration**: Connect CrewAI with external systems like monitoring platforms, databases, or notification services
5. **Custom Behavior**: Trigger custom actions based on specific events

1. **Keep Handlers Light**: Event handlers should be lightweight and avoid blocking operations
2. **Error Handling**: Include proper error handling in your event handlers to prevent exceptions from affecting the main execution
3. **Cleanup**: If your listener allocates resources, ensure they're properly cleaned up
4. **Selective Listening**: Only listen for events you actually need to handle
5. **Testing**: Test your event listeners in isolation to ensure they behave as expected

By leveraging CrewAI's event system, you can extend its functionality and integrate it seamlessly with your existing infrastructure.

---

## OpenLIT 통합

**URL:** llms-txt#openlit-통합

Source: https://docs.crewai.com/ko/observability/openlit

OpenTelemetry와 함께 단 한 줄의 코드로 에이전트를 신속하게 모니터링을 시작하세요.

---

## A ferramenta usará automaticamente embeddings da OpenAI

**URL:** llms-txt#a-ferramenta-usará-automaticamente-embeddings-da-openai

---

## Create agent with specific Google Drive actions only

**URL:** llms-txt#create-agent-with-specific-google-drive-actions-only

file_manager_agent = Agent(
    role="Document Manager",
    goal="Upload and manage documents efficiently",
    backstory="An AI assistant that focuses on document upload and organization.",
    apps=[
        'google_drive/upload_file',
        'google_drive/create_folder',
        'google_drive/share_file'
    ]  # Specific Google Drive actions
)

---

## Serper 웹사이트 스크랩

**URL:** llms-txt#serper-웹사이트-스크랩

Source: https://docs.crewai.com/ko/tools/web-scraping/serperscrapewebsitetool

SerperScrapeWebsiteTool은 Serper의 스크래핑 API를 사용하여 웹사이트를 스크랩하고 깔끔하고 읽기 쉬운 콘텐츠를 추출하도록 설계되었습니다.

---

## GitHub 통합

**URL:** llms-txt#github-통합

**Contents:**
- 개요
- 사전 요구 사항
- GitHub 연동 설정
  - 1. GitHub 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 GitHub 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/github

CrewAI를 위한 GitHub 통합을 통한 리포지토리 및 이슈 관리.

에이전트가 GitHub를 통해 리포지토리, 이슈, 릴리스를 관리할 수 있도록 지원합니다. 이슈를 생성 및 업데이트하고, 릴리스를 관리하고, 프로젝트 개발을 추적하며, AI 기반 자동화를 통해 소프트웨어 개발 워크플로우를 효율화하세요.

GitHub 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 해당 리포지토리에 대한 적절한 권한이 있는 GitHub 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 GitHub 계정 연결 완료

### 1. GitHub 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **GitHub**을 찾습니다.
3. **Connect**를 클릭하고 OAuth 흐름을 완료합니다.
4. 리포지토리 및 이슈 관리를 위한 필수 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="github/create_issue">
    **설명:** GitHub에 이슈를 생성합니다.

* `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `title` (string, 필수): 이슈 제목 - 생성할 이슈의 제목을 지정합니다.
    * `body` (string, 선택): 이슈 본문 - 생성할 이슈의 본문 내용을 지정합니다.
    * `assignees` (string, 선택): 담당자 - 이 이슈의 담당자 GitHub 로그인을 문자열 배열로 지정합니다. (예시: `["octocat"]`).
  </Accordion>

<Accordion title="github/update_issue">
    **설명:** GitHub에서 이슈를 업데이트합니다.

* `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `issue_number` (string, 필수): 이슈 번호 - 업데이트할 이슈의 번호를 지정합니다.
    * `title` (string, 필수): 이슈 제목 - 업데이트할 이슈의 제목을 지정합니다.
    * `body` (string, 선택): 이슈 본문 - 업데이트할 이슈의 본문 내용을 지정합니다.
    * `assignees` (string, 선택): 담당자 - 이 이슈의 담당자 GitHub 로그인을 문자열 배열로 지정합니다. (예시: `["octocat"]`).
    * `state` (string, 선택): 상태 - 이슈의 변경된 상태를 지정합니다.
      * 옵션: `open`, `closed`
  </Accordion>

<Accordion title="github/get_issue_by_number">
    **설명:** GitHub에서 번호로 이슈를 조회합니다.

* `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `issue_number` (string, 필수): 이슈 번호 - 가져올 이슈의 번호를 지정합니다.
  </Accordion>

<Accordion title="github/lock_issue">
    **설명:** GitHub에서 이슈를 잠급니다.

* `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `issue_number` (string, 필수): 이슈 번호 - 잠글 이슈의 번호를 지정합니다.
    * `lock_reason` (string, 필수): 잠금 사유 - 이슈 또는 풀 리퀘스트 대화에 대한 잠금 이유를 지정합니다.
      * 옵션: `off-topic`, `too heated`, `resolved`, `spam`
  </Accordion>

<Accordion title="github/search_issue">
    **설명:** GitHub에서 이슈를 검색합니다.

* `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `filter` (object, 필수): 불리언 표준형의 필터 - 단일 조건의 AND 그룹의 OR 조합.
      
      사용 가능한 필드: `assignee`, `creator`, `mentioned`, `labels`
  </Accordion>

<Accordion title="github/create_release">
    **설명:** GitHub에 릴리스를 생성합니다.

* `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `tag_name` (string, 필수): 이름 - 생성할 릴리스 태그의 이름을 지정합니다. (예시: "v1.0.0").
    * `target_commitish` (string, 선택): 대상 - 릴리스의 대상을 지정합니다. 브랜치 이름이나 커밋 SHA가 될 수 있으며, 기본값은 메인 브랜치입니다. (예시: "master").
    * `body` (string, 선택): 본문 - 이 릴리스에 대한 설명을 지정합니다.
    * `draft` (string, 선택): 초안 - 생성할 릴리스를 초안(비공개) 릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `prerelease` (string, 선택): 프리릴리스 - 생성할 릴리스를 프리릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `discussion_category_name` (string, 선택): 토론 카테고리 이름 - 지정 시, 해당 카테고리의 토론이 생성되어 릴리스와 연결됩니다. 값은 저장소에 이미 존재하는 카테고리여야 합니다.
    * `generate_release_notes` (string, 선택): 릴리스 노트 - 지정한 이름과 본문을 사용하여 릴리스 노트를 자동으로 생성할지 여부를 지정합니다.
      * 옵션: `true`, `false`
  </Accordion>

<Accordion title="github/update_release">
    **설명:** GitHub에서 릴리스를 업데이트합니다.

* `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `id` (string, 필수): 릴리스 ID - 업데이트할 릴리스의 ID를 지정합니다.
    * `tag_name` (string, 선택): 이름 - 업데이트할 릴리스 태그의 이름을 지정합니다. (예시: "v1.0.0").
    * `target_commitish` (string, 선택): 대상 - 릴리스의 대상을 지정합니다. 브랜치 이름이나 커밋 SHA가 될 수 있으며, 기본값은 메인 브랜치입니다. (예시: "master").
    * `body` (string, 선택): 본문 - 이 릴리스에 대한 설명을 지정합니다.
    * `draft` (string, 선택): 초안 - 생성할 릴리스를 초안(비공개) 릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `prerelease` (string, 선택): 프리릴리스 - 생성할 릴리스를 프리릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `discussion_category_name` (string, 선택): 토론 카테고리 이름 - 지정 시, 해당 카테고리의 토론이 생성되어 릴리스와 연결됩니다. 값은 저장소에 이미 존재하는 카테고리여야 합니다.
    * `generate_release_notes` (string, 선택): 릴리스 노트 - 지정한 이름과 본문을 사용하여 릴리스 노트를 자동으로 생성할지 여부를 지정합니다.
      * 옵션: `true`, `false`
  </Accordion>

<Accordion title="github/get_release_by_id">
    **설명:** GitHub에서 ID로 릴리스를 조회합니다.

* `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `id` (string, 필수): 릴리스 ID - 조회할 릴리스의 ID를 지정합니다.
  </Accordion>

<Accordion title="github/get_release_by_tag_name">
    **설명:** GitHub에서 태그 이름으로 릴리스를 조회합니다.

* `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `tag_name` (string, 필수): 이름 - 가져올 릴리스의 태그를 지정합니다. (예시: "v1.0.0").
  </Accordion>

<Accordion title="github/delete_release">
    **설명:** GitHub에서 릴리스를 삭제합니다.

* `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `id` (string, 필수): 릴리스 ID - 삭제할 릴리스의 ID를 지정합니다.
  </Accordion>
</AccordionGroup>

### 기본 GitHub 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="github/create_issue">
    **설명:** GitHub에 이슈를 생성합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `title` (string, 필수): 이슈 제목 - 생성할 이슈의 제목을 지정합니다.
    * `body` (string, 선택): 이슈 본문 - 생성할 이슈의 본문 내용을 지정합니다.
    * `assignees` (string, 선택): 담당자 - 이 이슈의 담당자 GitHub 로그인을 문자열 배열로 지정합니다. (예시: `["octocat"]`).
  </Accordion>

  <Accordion title="github/update_issue">
    **설명:** GitHub에서 이슈를 업데이트합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `issue_number` (string, 필수): 이슈 번호 - 업데이트할 이슈의 번호를 지정합니다.
    * `title` (string, 필수): 이슈 제목 - 업데이트할 이슈의 제목을 지정합니다.
    * `body` (string, 선택): 이슈 본문 - 업데이트할 이슈의 본문 내용을 지정합니다.
    * `assignees` (string, 선택): 담당자 - 이 이슈의 담당자 GitHub 로그인을 문자열 배열로 지정합니다. (예시: `["octocat"]`).
    * `state` (string, 선택): 상태 - 이슈의 변경된 상태를 지정합니다.
      * 옵션: `open`, `closed`
  </Accordion>

  <Accordion title="github/get_issue_by_number">
    **설명:** GitHub에서 번호로 이슈를 조회합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `issue_number` (string, 필수): 이슈 번호 - 가져올 이슈의 번호를 지정합니다.
  </Accordion>

  <Accordion title="github/lock_issue">
    **설명:** GitHub에서 이슈를 잠급니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `issue_number` (string, 필수): 이슈 번호 - 잠글 이슈의 번호를 지정합니다.
    * `lock_reason` (string, 필수): 잠금 사유 - 이슈 또는 풀 리퀘스트 대화에 대한 잠금 이유를 지정합니다.
      * 옵션: `off-topic`, `too heated`, `resolved`, `spam`
  </Accordion>

  <Accordion title="github/search_issue">
    **설명:** GitHub에서 이슈를 검색합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 이슈와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 이슈와 연관된 저장소 이름을 지정합니다.
    * `filter` (object, 필수): 불리언 표준형의 필터 - 단일 조건의 AND 그룹의 OR 조합.
```

Example 4 (unknown):
```unknown
사용 가능한 필드: `assignee`, `creator`, `mentioned`, `labels`
  </Accordion>

  <Accordion title="github/create_release">
    **설명:** GitHub에 릴리스를 생성합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `tag_name` (string, 필수): 이름 - 생성할 릴리스 태그의 이름을 지정합니다. (예시: "v1.0.0").
    * `target_commitish` (string, 선택): 대상 - 릴리스의 대상을 지정합니다. 브랜치 이름이나 커밋 SHA가 될 수 있으며, 기본값은 메인 브랜치입니다. (예시: "master").
    * `body` (string, 선택): 본문 - 이 릴리스에 대한 설명을 지정합니다.
    * `draft` (string, 선택): 초안 - 생성할 릴리스를 초안(비공개) 릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `prerelease` (string, 선택): 프리릴리스 - 생성할 릴리스를 프리릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `discussion_category_name` (string, 선택): 토론 카테고리 이름 - 지정 시, 해당 카테고리의 토론이 생성되어 릴리스와 연결됩니다. 값은 저장소에 이미 존재하는 카테고리여야 합니다.
    * `generate_release_notes` (string, 선택): 릴리스 노트 - 지정한 이름과 본문을 사용하여 릴리스 노트를 자동으로 생성할지 여부를 지정합니다.
      * 옵션: `true`, `false`
  </Accordion>

  <Accordion title="github/update_release">
    **설명:** GitHub에서 릴리스를 업데이트합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `id` (string, 필수): 릴리스 ID - 업데이트할 릴리스의 ID를 지정합니다.
    * `tag_name` (string, 선택): 이름 - 업데이트할 릴리스 태그의 이름을 지정합니다. (예시: "v1.0.0").
    * `target_commitish` (string, 선택): 대상 - 릴리스의 대상을 지정합니다. 브랜치 이름이나 커밋 SHA가 될 수 있으며, 기본값은 메인 브랜치입니다. (예시: "master").
    * `body` (string, 선택): 본문 - 이 릴리스에 대한 설명을 지정합니다.
    * `draft` (string, 선택): 초안 - 생성할 릴리스를 초안(비공개) 릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `prerelease` (string, 선택): 프리릴리스 - 생성할 릴리스를 프리릴리스로 지정할지 여부를 지정합니다.
      * 옵션: `true`, `false`
    * `discussion_category_name` (string, 선택): 토론 카테고리 이름 - 지정 시, 해당 카테고리의 토론이 생성되어 릴리스와 연결됩니다. 값은 저장소에 이미 존재하는 카테고리여야 합니다.
    * `generate_release_notes` (string, 선택): 릴리스 노트 - 지정한 이름과 본문을 사용하여 릴리스 노트를 자동으로 생성할지 여부를 지정합니다.
      * 옵션: `true`, `false`
  </Accordion>

  <Accordion title="github/get_release_by_id">
    **설명:** GitHub에서 ID로 릴리스를 조회합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `id` (string, 필수): 릴리스 ID - 조회할 릴리스의 ID를 지정합니다.
  </Accordion>

  <Accordion title="github/get_release_by_tag_name">
    **설명:** GitHub에서 태그 이름으로 릴리스를 조회합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `tag_name` (string, 필수): 이름 - 가져올 릴리스의 태그를 지정합니다. (예시: "v1.0.0").
  </Accordion>

  <Accordion title="github/delete_release">
    **설명:** GitHub에서 릴리스를 삭제합니다.

    **파라미터:**

    * `owner` (string, 필수): 소유자 - 이 릴리스와 연관된 저장소의 계정 소유자 이름을 지정합니다. (예시: "abc").
    * `repo` (string, 필수): 저장소 - 이 릴리스와 연관된 저장소 이름을 지정합니다.
    * `id` (string, 필수): 릴리스 ID - 삭제할 릴리스의 ID를 지정합니다.
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 GitHub 에이전트 설정
```

---

## Verify the server is running and accessible

**URL:** llms-txt#verify-the-server-is-running-and-accessible

mcps=["https://mcp.example.com/mcp?api_key=valid_key"]
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Connection timeouts:**
```

---

## Tarefa para criar um novo documento de texto

**URL:** llms-txt#tarefa-para-criar-um-novo-documento-de-texto

create_doc_task = Task(
    description="Criar um novo documento de texto chamado 'notas_reuniao.txt' com conteúdo 'Notas da Reunião de Janeiro de 2024: Pontos-chave de discussão e itens de ação.'",
    agent=word_agent,
    expected_output="Novo documento de texto 'notas_reuniao.txt' criado com sucesso."
)

---

## Example task to extract content from a website

**URL:** llms-txt#example-task-to-extract-content-from-a-website

scrape_task = Task(
    description="Extract the main content from the product page at https://web-scraping.dev/products and summarize the available products.",
    expected_output="A summary of the products available on the website.",
    agent=web_scraper_agent,
)

---

## ❌ Estas irão causar falhas na implantação

**URL:** llms-txt#❌-estas-irão-causar-falhas-na-implantação

OPENAI_TOKEN=sk-...
DATABASE_PASSWORD=mysenha
API_SECRET=segredo123

---

## Crie um agente com todos os parâmetros disponíveis

**URL:** llms-txt#crie-um-agente-com-todos-os-parâmetros-disponíveis

**Contents:**
  - Detalhes dos Parâmetros
- Ferramentas do Agente

agent = Agent(
    role="Cientista de Dados Sênior",
    goal="Analisar e interpretar conjuntos de dados complexos para fornecer insights acionáveis",
    backstory="Com mais de 10 anos de experiência em ciência de dados e aprendizado de máquina, você é especialista em encontrar padrões em grandes volumes de dados.",
    llm="gpt-4",  # Padrão: OPENAI_MODEL_NAME ou "gpt-4"
    function_calling_llm=None,  # Opcional: LLM separado para chamadas de ferramentas
    verbose=False,  # Padrão: False
    allow_delegation=False,  # Padrão: False
    max_iter=20,  # Padrão: 20 iterações
    max_rpm=None,  # Opcional: Limite de requisições por minuto
    max_execution_time=None,  # Opcional: Tempo máximo de execução em segundos
    max_retry_limit=2,  # Padrão: 2 tentativas em caso de erro
    allow_code_execution=False,  # Padrão: False
    code_execution_mode="safe",  # Padrão: "safe" (opções: "safe", "unsafe")
    respect_context_window=True,  # Padrão: True
    use_system_prompt=True,  # Padrão: True
    multimodal=False,  # Padrão: False
    inject_date=False,  # Padrão: False
    date_format="%Y-%m-%d",  # Padrão: formato ISO
    reasoning=False,  # Padrão: False
    max_reasoning_attempts=None,  # Padrão: None
    tools=[SerperDevTool()],  # Opcional: Lista de ferramentas
    knowledge_sources=None,  # Opcional: Lista de fontes de conhecimento
    embedder=None,  # Opcional: Configuração de embedder customizado
    system_template=None,  # Opcional: Template de prompt de sistema
    prompt_template=None,  # Opcional: Template de prompt customizado
    response_template=None,  # Opcional: Template de resposta customizado
    step_callback=None,  # Opcional: Função de callback para monitoramento
)
python Code theme={null}
research_agent = Agent(
    role="Analista de Pesquisa",
    goal="Encontrar e resumir informações sobre tópicos específicos",
    backstory="Você é um pesquisador experiente com atenção aos detalhes",
    tools=[SerperDevTool()],
    verbose=True  # Ativa logs para depuração
)
python Code theme={null}
dev_agent = Agent(
    role="Desenvolvedor Python Sênior",
    goal="Escrever e depurar códigos Python",
    backstory="Desenvolvedor Python especialista com 10 anos de experiência",
    allow_code_execution=True,
    code_execution_mode="safe",  # Usa Docker para segurança
    max_execution_time=300,  # Limite de 5 minutos
    max_retry_limit=3  # Mais tentativas para tarefas complexas
)
python Code theme={null}
analysis_agent = Agent(
    role="Analista de Dados",
    goal="Realizar análise aprofundada de grandes conjuntos de dados",
    backstory="Especialista em análise de big data e reconhecimento de padrões",
    memory=True,
    respect_context_window=True,
    max_rpm=10,  # Limite de requisições por minuto
    function_calling_llm="gpt-4o-mini"  # Modelo mais econômico para chamadas de ferramentas
)
python Code theme={null}
custom_agent = Agent(
    role="Atendente de Suporte ao Cliente",
    goal="Auxiliar clientes com suas dúvidas e solicitações",
    backstory="Experiente em atendimento ao cliente com foco em satisfação",
    system_template="""<|start_header_id|>system<|end_header_id|>\n                        {{ .System }}<|eot_id|>""",
    prompt_template="""<|start_header_id|>user<|end_header_id|>\n                        {{ .Prompt }}<|eot_id|>""",
    response_template="""<|start_header_id|>assistant<|end_header_id|>\n                        {{ .Response }}<|eot_id|>""",
)
python Code theme={null}
strategic_agent = Agent(
    role="Analista de Mercado",
    goal="Acompanhar movimentos do mercado com referências de datas precisas e planejamento estratégico",
    backstory="Especialista em análise financeira sensível ao tempo e relatórios estratégicos",
    inject_date=True,  # Injeta automaticamente a data atual nas tarefas
    date_format="%d de %B de %Y",  # Exemplo: "21 de maio de 2025"
    reasoning=True,  # Ativa planejamento estratégico
    max_reasoning_attempts=2,  # Limite de iterações de planejamento
    verbose=True
)
python Code theme={null}
reasoning_agent = Agent(
    role="Planejador Estratégico",
    goal="Analisar problemas complexos e criar planos de execução detalhados",
    backstory="Especialista em planejamento estratégico que desmembra desafios complexos metodicamente",
    reasoning=True,  # Ativa raciocínio e planejamento
    max_reasoning_attempts=3,  # Limite de tentativas de raciocínio
    max_iter=30,  # Permite mais iterações para planejamento complexo
    verbose=True
)
python Code theme={null}
multimodal_agent = Agent(
    role="Analista de Conteúdo Visual",
    goal="Analisar e processar tanto conteúdo textual quanto visual",
    backstory="Especialista em análise multimodal combinando compreensão de texto e imagem",
    multimodal=True,  # Ativa capacidades multimodais
    verbose=True
)
python Code theme={null}
from crewai import Agent
from crewai_tools import SerperDevTool, WikipediaTools

**Examples:**

Example 1 (unknown):
```unknown
Vamos detalhar algumas combinações de parâmetros-chave para casos de uso comuns:

#### Agente de Pesquisa Básico
```

Example 2 (unknown):
```unknown
#### Agente de Desenvolvimento de Código
```

Example 3 (unknown):
```unknown
#### Agente de Análise de Longa Duração
```

Example 4 (unknown):
```unknown
#### Agente com Template Personalizado
```

---

## Exemplo de server_params (escolha um baseado no seu tipo de servidor):

**URL:** llms-txt#exemplo-de-server_params-(escolha-um-baseado-no-seu-tipo-de-servidor):

---

## Get only the forecast tool from weather server

**URL:** llms-txt#get-only-the-forecast-tool-from-weather-server

"https://weather.api.com/mcp#get_forecast"

---

## 인터랙티브 요소 찾기

**URL:** llms-txt#인터랙티브-요소-찾기

result = stagehand_tool.run(
    instruction="Find all interactive elements in the navigation menu", 
    url="https://example.com",
    command_type="observe"
)

---

## Create a task for the agent to extract specific elements

**URL:** llms-txt#create-a-task-for-the-agent-to-extract-specific-elements

extract_task = Task(
    description="""
    Extract all product titles from the featured products section on example.com.
    Use the CSS selector '.product-title' to target the title elements.
    """,
    expected_output="A list of product titles from the website",
    agent=web_scraper_agent,
)

---

## OCR 도구

**URL:** llms-txt#ocr-도구

Source: https://docs.crewai.com/ko/tools/file-document/ocrtool

OCRTool은 비전 기능을 가진 LLM을 사용하여 로컬 이미지나 이미지 URL에서 텍스트를 추출합니다.

---

## Inicialize a ferramenta para capacidades de busca na internet

**URL:** llms-txt#inicialize-a-ferramenta-para-capacidades-de-busca-na-internet

tool = BraveSearchTool()

---

## Lide com o resultado de acordo com seu tipo

**URL:** llms-txt#lide-com-o-resultado-de-acordo-com-seu-tipo

if hasattr(result, "json_dict") and result.json_dict:
    json_result = result.json_dict
    print("\nStructured JSON result:")
    print(f"{json.dumps(json_result, indent=2)}")

# Acesse os campos de forma segura
    if isinstance(json_result, dict):
        if "code" in json_result:
            print("\nCode:")
            print(
                json_result["code"][:200] + "..."
                if len(json_result["code"]) > 200
                else json_result["code"]
            )

if "links" in json_result:
            print("\nLinks:")
            for link in json_result["links"][:5]:  # Print first 5 links
                print(f"- {link}")
            if len(json_result["links"]) > 5:
                print(f"...and {len(json_result['links']) - 5} more links")
elif hasattr(result, "pydantic") and result.pydantic:
    print("\nPydantic model result:")
    print(result.pydantic.model_dump_json(indent=2))
else:
    # Fallback para saída bruta
    print("\nNo structured result available, using raw output:")
    print(result.raw[:500] + "..." if len(result.raw) > 500 else result.raw)

---

## S3 리더 도구

**URL:** llms-txt#s3-리더-도구

Source: https://docs.crewai.com/ko/tools/cloud-storage/s3readertool

S3ReaderTool은 CrewAI 에이전트가 Amazon S3 버킷에서 파일을 읽을 수 있도록 합니다.

---

## `ScrapeElementFromWebsiteTool`

**URL:** llms-txt#`scrapeelementfromwebsitetool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

A `ScrapeElementFromWebsiteTool` foi projetada para extrair elementos específicos de websites utilizando seletores CSS. Esta ferramenta permite que agentes CrewAI capturem conteúdos direcionados de páginas web, tornando-se útil para tarefas de extração de dados em que apenas partes específicas de uma página são necessárias.

Para utilizar esta ferramenta, você precisa instalar as dependências necessárias:

## Passos para Começar

Para usar a `ScrapeElementFromWebsiteTool` de maneira eficaz, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários com o comando acima.
2. **Identifique os Seletores CSS**: Determine os seletores CSS dos elementos que deseja extrair do site.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta com os parâmetros necessários.

O exemplo abaixo demonstra como usar a `ScrapeElementFromWebsiteTool` para extrair elementos específicos de um website:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import ScrapeElementFromWebsiteTool

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para usar a `ScrapeElementFromWebsiteTool` de maneira eficaz, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários com o comando acima.
2. **Identifique os Seletores CSS**: Determine os seletores CSS dos elementos que deseja extrair do site.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta com os parâmetros necessários.

## Exemplo

O exemplo abaixo demonstra como usar a `ScrapeElementFromWebsiteTool` para extrair elementos específicos de um website:
```

---

## 검색 실행

**URL:** llms-txt#검색-실행

**Contents:**
- 매개변수
- 매개변수와 함께 사용하는 예시

results = tool.run(search_query="CrewAI agent framework")
print(results)
python Code theme={null}
from crewai_tools import BraveSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## 매개변수

`BraveSearchTool`은 다음과 같은 매개변수를 받습니다:

* **search\_query**: 필수. 인터넷 검색에 사용할 검색 쿼리입니다.
* **country**: 선택. 검색 결과의 국가를 지정합니다. 기본값은 빈 문자열입니다.
* **n\_results**: 선택. 반환할 검색 결과의 개수입니다. 기본값은 `10`입니다.
* **save\_file**: 선택. 검색 결과를 파일로 저장할지 여부입니다. 기본값은 `False`입니다.

## 매개변수와 함께 사용하는 예시

다음은 추가 매개변수를 사용하여 도구를 활용하는 방법을 보여주는 예시입니다:
```

---

## "proxy_pool": "public_residential_pool",  # Select a proxy pool

**URL:** llms-txt#"proxy_pool":-"public_residential_pool",--#-select-a-proxy-pool

---

## Input Humano na Execução

**URL:** llms-txt#input-humano-na-execução

**Contents:**
- Input humano na execução dos agentes
- Usando input humano com CrewAI
  - Exemplo:

Source: https://docs.crewai.com/pt-BR/learn/human-input-on-execution

Integrando o CrewAI com input humano durante a execução em processos complexos de tomada de decisão e aproveitando ao máximo todos os atributos e ferramentas do agente.

## Input humano na execução dos agentes

O input humano é fundamental em vários cenários de execução de agentes, permitindo que os agentes solicitem informações adicionais ou esclarecimentos quando necessário.
Esse recurso é especialmente útil em processos complexos de tomada de decisão ou quando os agentes precisam de mais detalhes para concluir uma tarefa de forma eficaz.

## Usando input humano com CrewAI

Para integrar input humano durante a execução do agente, defina o parâmetro `human_input` na definição da tarefa. Quando ativado, o agente solicitará informações ao usuário antes de fornecer sua resposta final.
Esse input pode oferecer contexto extra, esclarecer ambiguidades ou validar a saída produzida pelo agente.

```python Code theme={null}
import os
from crewai import Agent, Task, Crew
from crewai_tools import SerperDevTool

os.environ["SERPER_API_KEY"] = "Your Key"  # serper.dev API key
os.environ["OPENAI_API_KEY"] = "Your Key"

**Examples:**

Example 1 (unknown):
```unknown

```

---

## Visão Geral

**URL:** llms-txt#visão-geral

**Contents:**
- Visão Geral
- Pré-requisitos
- Uso
  - Implementação Básica

A `StagehandTool` integra o framework [Stagehand](https://docs.stagehand.dev/get_started/introduction) com o CrewAI, permitindo que agentes interajam com sites e automatizem tarefas no navegador utilizando instruções em linguagem natural.

O Stagehand é um poderoso framework de automação de navegador criado pela Browserbase que permite aos agentes de IA:

* Navegar por sites
* Clicar em botões, links e outros elementos
* Preencher formulários
* Extrair dados de páginas web
* Observar e identificar elementos
* Realizar fluxos de trabalho complexos

A StagehandTool encapsula o SDK Python do Stagehand para fornecer aos agentes do CrewAI capacidades de controle do navegador através de três primitivas principais:

1. **Act**: Executar ações como clicar, digitar ou navegar
2. **Extract**: Extrair dados estruturados de páginas web
3. **Observe**: Identificar e analisar elementos na página

Antes de utilizar esta ferramenta, certifique-se de que você possui:

1. Uma conta [Browserbase](https://www.browserbase.com/) com chave API e ID de projeto
2. Uma chave API para um LLM (OpenAI ou Anthropic Claude)
3. O SDK Python do Stagehand instalado

Instale a dependência necessária:

### Implementação Básica

A StagehandTool pode ser implementada de duas maneiras:

#### 1. Usando Context Manager (Recomendado)

<Tip>
  A abordagem de context manager é recomendada, pois garante o encerramento adequado dos recursos mesmo em caso de exceções.
</Tip>

```python  theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import StagehandTool
from stagehand.schemas import AvailableModel

**Examples:**

Example 1 (unknown):
```unknown
## Uso

### Implementação Básica

A StagehandTool pode ser implementada de duas maneiras:

#### 1. Usando Context Manager (Recomendado)

<Tip>
  A abordagem de context manager é recomendada, pois garante o encerramento adequado dos recursos mesmo em caso de exceções.
</Tip>
```

---

## Esse contexto faz o Claude agir como especialista do setor

**URL:** llms-txt#esse-contexto-faz-o-claude-agir-como-especialista-do-setor

---

## Inicialize a ferramenta para ler quaisquer arquivos que os agentes conhecem ou informe o caminho para

**URL:** llms-txt#inicialize-a-ferramenta-para-ler-quaisquer-arquivos-que-os-agentes-conhecem-ou-informe-o-caminho-para

file_read_tool = FileReadTool()

---

## Permite que agentes busquem no conteúdo de qualquer arquivo XML

**URL:** llms-txt#permite-que-agentes-busquem-no-conteúdo-de-qualquer-arquivo-xml

---

## 에이전트가 실행 중에 알게 되는 모든 디렉터리의 내용을 읽을 수 있도록 도구를 초기화합니다.

**URL:** llms-txt#에이전트가-실행-중에-알게-되는-모든-디렉터리의-내용을-읽을-수-있도록-도구를-초기화합니다.

tool = DirectoryReadTool()

---

## 소개

**URL:** llms-txt#소개

**Contents:**
- 왜 Neatlogs를 사용해야 하나요?
- 핵심 기능
- CrewAI로 빠른 설정하기
- 내부 구조
- 작동하는 모습을 살펴보기
  - 🔍 전체 데모 (4 분)
  - ⚙️ CrewAI 통합 (30초)
- 링크 & 지원
- TL;DR

Neatlogs는 **에이전트가 무엇을 했는지**, **이유는 무엇인지**, 그리고 **공유하는 방법**을 확인할 수 있도록 도와줍니다.

모든 단계를 캡처합니다: 생각, 도구 호출, 응답, 평가 등. 원시 로그는 없습니다. 명확하고 구조화된 추적만 제공합니다. 디버깅과 협업에 탁월합니다.

## 왜 Neatlogs를 사용해야 하나요?

CrewAI 에이전트는 여러 도구와 추론 단계를 사용합니다. 문제가 발생했을 때, 단순한 오류만으로는 충분하지 않습니다 — 맥락이 필요합니다.

Neatlogs를 사용하면 다음과 같은 이점이 있습니다:

* 전체 의사 결정 경로를 따라갈 수 있습니다
* 단계마다 직접 피드백을 남길 수 있습니다
* AI 어시스턴트와 함께 트레이스에 대해 채팅할 수 있습니다
* 실행 결과를 공개적으로 공유해 피드백을 받을 수 있습니다
* 인사이트를 업무로 전환할 수 있습니다

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d01a5ce64066c6c7387b238068e71369" alt="Traces" data-og-width="1999" width="1999" data-og-height="763" height="763" data-path="images/neatlogs-1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ee62fda86fa566c25c133bcab4749395 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5cb6eaca0429f7e70bb5c8d98a489a97 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=cb664845151f8e54c0e0b9fba753f383 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=fb471833d13ba8718ebd37cc6f557697 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=e470693ab78a2cce5b34570b328c6939 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=2211c7cdbf87f4e96de3aa5a51927b1d 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5b737699468781be25098c33040d2125" alt="Trace Response" data-og-width="1999" width="1999" data-og-height="1128" height="1128" data-path="images/neatlogs-2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=020336c536f38ce54dfc04854acac7d4 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=8a40138ff848d453607b8e4cf6d0af31 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=411d496952511260f03dcf703cf40402 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ce7a99a7d6752ae77706cde411104694 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=e943a0308341c59d6b4d17e29e17126c 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=61b95cdb68c4c5cbdd349e802db3f2cb 2500w" />

CrewAI 트레이스를 보기 위한 최고의 UX. 원하는 곳 어디든 댓글을 남기세요. AI를 활용해 디버깅할 수 있습니다.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=43cda9bcd83376dda4523ff0596b2043" alt="Trace Details" data-og-width="1999" width="1999" data-og-height="1125" height="1125" data-path="images/neatlogs-3.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b412fc1111d110fba24398449f86c8a6 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=bc9a8210c617335893a0b9e94b9dcede 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=bca4c7758110744a457e3e635ba86e1c 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c259898ac4cbe4835a0df33f161c7840 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=74f03053e7cc5b98b3e568417de3a319 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-3.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b90e2b8fcadb097c82a60e6522533386 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c9e7ad0653cae7bfaad2dd448d90eda0" alt="Ai Chat Bot With A Trace" data-og-width="1999" width="1999" data-og-height="751" height="751" data-path="images/neatlogs-4.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=eb0debf5272db5db3729d8b4b4634d94 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9ebccf5654ad590f1d231118b4a29037 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a7987df251bd7085c86535c31c3bc8fe 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=113e589438936a55df794a60faec5ff7 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=469f0ab2f09cdd65c18e925ebd88be11 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-4.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=55115f959b3f2e49231e9ed273e6d11c 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a977655abb8cd26d9ed4cef5fdd7d859" alt="Comments Drawer" data-og-width="1999" width="1999" data-og-height="1388" height="1388" data-path="images/neatlogs-5.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=51ad567b077e31082ed8f2a1c53be446 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b4c663fe1527dc74a13e8c7a7ae955d2 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=fdddfe615d4098db90f694707d70ec87 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=15cefd5838432e622844dced45f2f6b6 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=18b726e6b4bf38ee419f2a50be1e748a 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/neatlogs-5.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=52fcf26f16e0d4177dbcb9c0da5d1bb9 2500w" />

* **Trace Viewer**: 사고, 도구, 결정을 순서대로 추적
* **인라인 댓글**: 모든 trace 단계에서 팀원을 태그
* **피드백 및 평가**: 출력물을 올바름 또는 틀림으로 표시
* **오류 하이라이팅**: API/도구 실패 자동 감지
* **작업 전환**: 댓글을 할당된 작업으로 변환
* **Ask the Trace (AI)**: Neatlogs AI 봇과 trace에서 채팅
* **공개 공유**: trace 링크를 커뮤니티에 게시

<Steps>
  <Step title="회원가입 및 API 키 발급">
    [neatlogs.com](https://neatlogs.com/?utm_source=crewAI-docs)에 방문하여 프로젝트를 생성하고, API 키를 복사하세요.
  </Step>

<Step title="SDK 설치">

(최신 버전 0.8.0, Python 3.8+; MIT 라이선스)
  </Step>

<Step title="Neatlogs 초기화">
    Crew 에이전트를 시작하기 전에 다음을 추가하세요:

에이전트는 평소와 같이 실행됩니다. Neatlogs가 모든 것을 자동으로 캡처합니다.
  </Step>
</Steps>

GitHub에 따르면, Neatlogs는:

* 생각, 도구 호출, 응답, 오류, 그리고 토큰 통계를 캡처합니다
* AI 기반 작업 생성과 견고한 평가 워크플로우를 지원합니다

이 모든 것이 단 두 줄의 코드로 가능합니다.

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/8KDme9T2I7Q?si=b8oHteaBwFNs_Duk" title="NeatLogs 개요" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

### ⚙️ CrewAI 통합 (30초)

<iframe className="w-full aspect-video rounded-xl" src="https://www.loom.com/embed/9c78b552af43452bb3e4783cb8d91230?sid=e9d7d370-a91a-49b0-809e-2f375d9e801d" title="Loom video player" frameBorder="0" allowFullScreen />

* 📘 [Neatlogs 문서](https://docs.neatlogs.com/)
* 🔐 [대시보드 & API 키](https://app.neatlogs.com/)
* 🐦 [트위터 팔로우](https://twitter.com/neatlogs)
* 📧 문의: [hello@neatlogs.com](mailto:hello@neatlogs.com)
* 🛠 [GitHub SDK](https://github.com/NeatLogs/neatlogs)

이제 몇 초 만에 CrewAI agent 실행을 캡처, 이해, 공유하고 바로 조치할 수 있습니다.
별도의 설정이 필요하지 않습니다. 완전한 트레이스 투명성. 전체 팀 협업 지원.

**Examples:**

Example 1 (unknown):
```unknown
(최신 버전 0.8.0, Python 3.8+; MIT 라이선스)
  </Step>

  <Step title="Neatlogs 초기화">
    Crew 에이전트를 시작하기 전에 다음을 추가하세요:
```

Example 2 (unknown):
```unknown
에이전트는 평소와 같이 실행됩니다. Neatlogs가 모든 것을 자동으로 캡처합니다.
  </Step>
</Steps>

## 내부 구조

GitHub에 따르면, Neatlogs는:

* 생각, 도구 호출, 응답, 오류, 그리고 토큰 통계를 캡처합니다
* AI 기반 작업 생성과 견고한 평가 워크플로우를 지원합니다

이 모든 것이 단 두 줄의 코드로 가능합니다.

## 작동하는 모습을 살펴보기

### 🔍 전체 데모 (4 분)

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/8KDme9T2I7Q?si=b8oHteaBwFNs_Duk" title="NeatLogs 개요" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

### ⚙️ CrewAI 통합 (30초)

<iframe className="w-full aspect-video rounded-xl" src="https://www.loom.com/embed/9c78b552af43452bb3e4783cb8d91230?sid=e9d7d370-a91a-49b0-809e-2f375d9e801d" title="Loom video player" frameBorder="0" allowFullScreen />

## 링크 & 지원

* 📘 [Neatlogs 문서](https://docs.neatlogs.com/)
* 🔐 [대시보드 & API 키](https://app.neatlogs.com/)
* 🐦 [트위터 팔로우](https://twitter.com/neatlogs)
* 📧 문의: [hello@neatlogs.com](mailto:hello@neatlogs.com)
* 🛠 [GitHub SDK](https://github.com/NeatLogs/neatlogs)

## TL;DR

아래와 같이:
```

---

## Bright Data 도구

**URL:** llms-txt#bright-data-도구

**Contents:**
- 설치
- 환경 변수
- 포함된 도구
- 예시
  - SERP 검색
  - 웹 언로커
  - 데이터셋 API
- 문제 해결
- 예시

이 도구 세트는 웹 추출을 위한 Bright Data 서비스를 통합합니다.

* `BRIGHT_DATA_API_KEY` (필수)
* `BRIGHT_DATA_ZONE` (SERP/Web Unlocker용)

[https://brightdata.com/](https://brightdata.com/) 에서 자격 증명을 생성하세요 (회원가입 후 API 토큰과 zone을 만드세요).\
문서는 여기를 참고하세요: [https://developers.brightdata.com/](https://developers.brightdata.com/)

* `BrightDataSearchTool`: 지역/언어/디바이스 옵션과 함께 SERP 검색(Google/Bing/Yandex).
* `BrightDataWebUnlockerTool`: 안티봇 우회 및 렌더링을 통한 페이지 스크랩.
* `BrightDataDatasetTool`: Dataset API 작업 실행 및 결과 가져오기.

* 401/403: `BRIGHT_DATA_API_KEY`와 `BRIGHT_DATA_ZONE`을 확인하세요.
* 빈 내용/차단된 콘텐츠: 렌더링을 활성화하거나 다른 존을 시도해 보세요.

**Examples:**

Example 1 (unknown):
```unknown
## 환경 변수

* `BRIGHT_DATA_API_KEY` (필수)
* `BRIGHT_DATA_ZONE` (SERP/Web Unlocker용)

[https://brightdata.com/](https://brightdata.com/) 에서 자격 증명을 생성하세요 (회원가입 후 API 토큰과 zone을 만드세요).\
문서는 여기를 참고하세요: [https://developers.brightdata.com/](https://developers.brightdata.com/)

## 포함된 도구

* `BrightDataSearchTool`: 지역/언어/디바이스 옵션과 함께 SERP 검색(Google/Bing/Yandex).
* `BrightDataWebUnlockerTool`: 안티봇 우회 및 렌더링을 통한 페이지 스크랩.
* `BrightDataDatasetTool`: Dataset API 작업 실행 및 결과 가져오기.

## 예시

### SERP 검색
```

Example 2 (unknown):
```unknown
### 웹 언로커
```

Example 3 (unknown):
```unknown
### 데이터셋 API
```

Example 4 (unknown):
```unknown
## 문제 해결

* 401/403: `BRIGHT_DATA_API_KEY`와 `BRIGHT_DATA_ZONE`을 확인하세요.
* 빈 내용/차단된 콘텐츠: 렌더링을 활성화하거나 다른 존을 시도해 보세요.

## 예시
```

---

## Complex flow benefits from structured state

**URL:** llms-txt#complex-flow-benefits-from-structured-state

**Contents:**
  - 3. 문서 상태 전이
  - 4. 상태 오류를 정상적으로 처리하기
  - 5. 상태를 사용하여 진행 상황 추적
  - 6. 가능한 경우 불변(Immutable) 연산 사용하기

class UserRegistrationState(BaseModel):
    username: str
    email: str
    verification_status: bool = False
    registration_date: datetime = Field(default_factory=datetime.now)
    last_login: Optional[datetime] = None

class RegistrationFlow(Flow[UserRegistrationState]):
    # Methods with strongly-typed state access
python  theme={null}
@start()
def initialize_order(self):
    """
    Initialize order state with empty values.

State before: {}
    State after: {order_id: str, items: [], status: 'new'}
    """
    self.state.order_id = str(uuid.uuid4())
    self.state.items = []
    self.state.status = "new"
    return "Order initialized"
python  theme={null}
@listen(previous_step)
def process_data(self, _):
    try:
        # Try to access a value that might not exist
        user_preference = self.state.preferences.get("theme", "default")
    except (AttributeError, KeyError):
        # Handle the error gracefully
        self.state.errors = self.state.get("errors", [])
        self.state.errors.append("Failed to access preferences")
        user_preference = "default"

return f"Used preference: {user_preference}"
python  theme={null}
class ProgressTrackingFlow(Flow):
    @start()
    def initialize(self):
        self.state["total_steps"] = 3
        self.state["current_step"] = 0
        self.state["progress"] = 0.0
        self.update_progress()
        return "Initialized"

def update_progress(self):
        """Helper method to calculate and update progress"""
        if self.state.get("total_steps", 0) > 0:
            self.state["progress"] = (self.state.get("current_step", 0) /
                                    self.state["total_steps"]) * 100
            print(f"Progress: {self.state['progress']:.1f}%")

@listen(initialize)
    def step_one(self, _):
        # Do work...
        self.state["current_step"] = 1
        self.update_progress()
        return "Step 1 complete"

# Additional steps...
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 3. 문서 상태 전이

복잡한 흐름의 경우, 실행 중에 상태가 어떻게 변하는지 문서화하세요:
```

Example 2 (unknown):
```unknown
### 4. 상태 오류를 정상적으로 처리하기

상태 접근에 대한 오류 처리를 구현하세요:
```

Example 3 (unknown):
```unknown
### 5. 상태를 사용하여 진행 상황 추적

긴 실행 흐름에서 진행 상황을 추적하기 위해 상태를 활용하세요:
```

Example 4 (unknown):
```unknown
### 6. 가능한 경우 불변(Immutable) 연산 사용하기

특히 구조화된 상태에서는 명확성을 위해 불변 연산을 선호하세요:
```

---

## Inicialize a ferramenta com QdrantConfig

**URL:** llms-txt#inicialize-a-ferramenta-com-qdrantconfig

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_qdrant_url",
        qdrant_api_key="your_qdrant_api_key",
        collection_name="your_collection"
    )
)

---

## Create a sample task

**URL:** llms-txt#create-a-sample-task

task = Task(
    description="Analyze the sales data and identify trends",
    expected_output="A detailed analysis with key insights and trends",
    agent=agent
)

---

## Tarefa de automação de workflow complexa

**URL:** llms-txt#tarefa-de-automação-de-workflow-complexa

**Contents:**
- Solução de Problemas
  - Problemas Comuns
  - Obtendo Ajuda

automation_task = Task(
    description="""
    1. Pesquise por issues que estejam em progresso há mais de 7 dias
    2. Atualize suas prioridades com base nas datas de vencimento e importância do projeto
    3. Crie issues semanais de planejamento de sprint para cada equipe
    4. Arquive issues concluídas do ciclo anterior
    5. Gere relatórios de status do projeto como novas issues
    """,
    agent=workflow_automator,
    expected_output="Fluxo de desenvolvimento automatizado com prioridades atualizadas, planejamento de sprint e relatórios de status"
)

crew = Crew(
    agents=[workflow_automator],
    tasks=[automation_task]
)

## Solução de Problemas

**Erros de Permissão**

* Certifique-se de que sua conta Linear possui as permissões necessárias no workspace de destino
* Verifique se a conexão OAuth inclui os escopos requeridos pela API do Linear
* Confirme se você tem permissões para criar/editar issues e projetos no workspace

**IDs e Referências Inválidas**

* Verifique os IDs de equipes, IDs de issues e IDs de projetos para garantir o formato UUID correto
* Assegure que as entidades referenciadas (equipes, projetos, ciclos) existem e estão acessíveis
* Verifique se os identificadores de issues seguem o formato correto (ex: "ABC-1")

**Problemas de Associação entre Equipe e Projeto**

* Use LINEAR\_SEARCH\_TEAMS para obter IDs de equipe válidos antes de criar issues ou projetos
* Certifique-se de que as equipes existem e estão ativas no seu workspace
* Verifique se os IDs das equipes estão devidamente formatados como UUIDs

**Problemas com Status e Prioridade das Issues**

* Verifique se os IDs de status referenciam estados de workflow válidos para a equipe
* Certifique-se de que os valores de prioridade estão dentro do intervalo válido para sua configuração do Linear
* Confirme que campos personalizados e labels existem antes de referenciá-los

**Problemas com Formato de Data e Hora**

* Use o formato ISO 8601 para datas de vencimento e timestamps
* Certifique-se de que os fusos horários estão corretos para cálculos de datas de vencimento
* Verifique se os valores de data são válidos e posteriores à data atual para datas de vencimento

**Problemas de Pesquisa e Filtros**

* Garanta que as consultas de busca estejam formatadas corretamente e não estejam vazias
* Utilize nomes de campos válidos nas fórmulas de filtro: `title`, `number`, `project`, `createdAt`
* Teste filtros simples antes de montar consultas complexas com múltiplas condições
* Verifique se os tipos de operadores correspondem aos tipos de dados dos campos filtrados

**Problemas na Criação de Sub-issues**

* Certifique-se de que os IDs das issues pai são válidos e acessíveis
* Verifique se o ID da equipe para as sub-issues corresponde ou é compatível com o da issue pai
* Assegure-se de que as issues pai não estejam arquivadas ou excluídas

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nossa equipe de suporte para assistência na configuração ou solução de problemas da integração com o Linear.
</Card>

---

## Integração com ClickUp

**URL:** llms-txt#integração-com-clickup

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o ClickUp
  - 1. Conecte sua Conta ClickUp
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente ClickUp

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/clickup

Gerenciamento de tarefas e produtividade com integração ClickUp para CrewAI.

Permita que seus agentes gerenciem tarefas, projetos e fluxos de produtividade por meio do ClickUp. Crie e atualize tarefas, organize projetos, gerencie a designação de equipes e otimize o gerenciamento da sua produtividade com automação impulsionada por IA.

Antes de utilizar a integração com o ClickUp, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta ClickUp com as permissões apropriadas
* Sua conta ClickUp conectada pela [Página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com o ClickUp

### 1. Conecte sua Conta ClickUp

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **ClickUp** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de tarefas e projetos
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="clickup/search_tasks">
    **Descrição:** Busque tarefas no ClickUp utilizando filtros avançados.

* `taskFilterFormula` (objeto, opcional): Um filtro em forma normal disjuntiva - OU de grupos E de condições individuais.
      
      Campos disponíveis: `space_ids%5B%5D`, `project_ids%5B%5D`, `list_ids%5B%5D`, `statuses%5B%5D`, `include_closed`, `assignees%5B%5D`, `tags%5B%5D`, `due_date_gt`, `due_date_lt`, `date_created_gt`, `date_created_lt`, `date_updated_gt`, `date_updated_lt`
  </Accordion>

<Accordion title="clickup/get_task_in_list">
    **Descrição:** Obtenha tarefas em uma lista específica do ClickUp.

* `listId` (string, obrigatório): Lista - Selecione uma Lista da qual obter as tarefas. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem uma Lista ClickUp.
    * `taskFilterFormula` (string, opcional): Busque tarefas que correspondam aos filtros especificados. Por exemplo: name=task1.
  </Accordion>

<Accordion title="clickup/create_task">
    **Descrição:** Crie uma tarefa no ClickUp.

* `listId` (string, obrigatório): Lista - Selecione uma Lista para criar esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem uma Lista ClickUp.
    * `name` (string, obrigatório): Nome - O nome da tarefa.
    * `description` (string, opcional): Descrição - Descrição da tarefa.
    * `status` (string, opcional): Status - Selecione um Status para esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Status ClickUp.
    * `assignees` (string, opcional): Responsáveis - Selecione um Membro (ou um array de IDs de membros) para ser responsável por esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Membro ClickUp.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique uma data para a conclusão desta tarefa.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique campos adicionais para incluir nesta tarefa em formato JSON.
  </Accordion>

<Accordion title="clickup/update_task">
    **Descrição:** Atualize uma tarefa no ClickUp.

* `taskId` (string, obrigatório): ID da tarefa - O ID da tarefa a ser atualizada.
    * `listId` (string, obrigatório): Lista - Selecione uma Lista para criar esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem uma Lista ClickUp.
    * `name` (string, opcional): Nome - O nome da tarefa.
    * `description` (string, opcional): Descrição - Descrição da tarefa.
    * `status` (string, opcional): Status - Selecione um Status para esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Status ClickUp.
    * `assignees` (string, opcional): Responsáveis - Selecione um Membro (ou um array de IDs de membros) para ser responsável por esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Membro ClickUp.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique uma data para a conclusão desta tarefa.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique campos adicionais para incluir nesta tarefa em formato JSON.
  </Accordion>

<Accordion title="clickup/delete_task">
    **Descrição:** Exclua uma tarefa no ClickUp.

* `taskId` (string, obrigatório): ID da tarefa - O ID da tarefa a ser excluída.
  </Accordion>

<Accordion title="clickup/get_list">
    **Descrição:** Obtenha informações da Lista no ClickUp.

* `spaceId` (string, obrigatório): ID do Espaço - O ID do espaço que contém as listas.
  </Accordion>

<Accordion title="clickup/get_custom_fields_in_list">
    **Descrição:** Obtenha Campos Personalizados em uma Lista no ClickUp.

* `listId` (string, obrigatório): ID da Lista - O ID da lista da qual obter os campos personalizados.
  </Accordion>

<Accordion title="clickup/get_all_fields_in_list">
    **Descrição:** Obtenha Todos os Campos em uma Lista no ClickUp.

* `listId` (string, obrigatório): ID da Lista - O ID da lista da qual obter todos os campos.
  </Accordion>

<Accordion title="clickup/get_space">
    **Descrição:** Obtenha informações do Espaço no ClickUp.

* `spaceId` (string, opcional): ID do Espaço - O ID do espaço a ser recuperado.
  </Accordion>

<Accordion title="clickup/get_folders">
    **Descrição:** Obtenha Pastas no ClickUp.

* `spaceId` (string, obrigatório): ID do Espaço - O ID do espaço que contém as pastas.
  </Accordion>

<Accordion title="clickup/get_member">
    **Descrição:** Obtenha informações de Membro no ClickUp.

**Parâmetros:** Nenhum obrigatório.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente ClickUp

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="clickup/search_tasks">
    **Descrição:** Busque tarefas no ClickUp utilizando filtros avançados.

    **Parâmetros:**

    * `taskFilterFormula` (objeto, opcional): Um filtro em forma normal disjuntiva - OU de grupos E de condições individuais.
```

Example 4 (unknown):
```unknown
Campos disponíveis: `space_ids%5B%5D`, `project_ids%5B%5D`, `list_ids%5B%5D`, `statuses%5B%5D`, `include_closed`, `assignees%5B%5D`, `tags%5B%5D`, `due_date_gt`, `due_date_lt`, `date_created_gt`, `date_created_lt`, `date_updated_gt`, `date_updated_lt`
  </Accordion>

  <Accordion title="clickup/get_task_in_list">
    **Descrição:** Obtenha tarefas em uma lista específica do ClickUp.

    **Parâmetros:**

    * `listId` (string, obrigatório): Lista - Selecione uma Lista da qual obter as tarefas. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem uma Lista ClickUp.
    * `taskFilterFormula` (string, opcional): Busque tarefas que correspondam aos filtros especificados. Por exemplo: name=task1.
  </Accordion>

  <Accordion title="clickup/create_task">
    **Descrição:** Crie uma tarefa no ClickUp.

    **Parâmetros:**

    * `listId` (string, obrigatório): Lista - Selecione uma Lista para criar esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem uma Lista ClickUp.
    * `name` (string, obrigatório): Nome - O nome da tarefa.
    * `description` (string, opcional): Descrição - Descrição da tarefa.
    * `status` (string, opcional): Status - Selecione um Status para esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Status ClickUp.
    * `assignees` (string, opcional): Responsáveis - Selecione um Membro (ou um array de IDs de membros) para ser responsável por esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Membro ClickUp.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique uma data para a conclusão desta tarefa.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique campos adicionais para incluir nesta tarefa em formato JSON.
  </Accordion>

  <Accordion title="clickup/update_task">
    **Descrição:** Atualize uma tarefa no ClickUp.

    **Parâmetros:**

    * `taskId` (string, obrigatório): ID da tarefa - O ID da tarefa a ser atualizada.
    * `listId` (string, obrigatório): Lista - Selecione uma Lista para criar esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem uma Lista ClickUp.
    * `name` (string, opcional): Nome - O nome da tarefa.
    * `description` (string, opcional): Descrição - Descrição da tarefa.
    * `status` (string, opcional): Status - Selecione um Status para esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Status ClickUp.
    * `assignees` (string, opcional): Responsáveis - Selecione um Membro (ou um array de IDs de membros) para ser responsável por esta tarefa. Use as Configurações do Usuário no Portal de Conexão para permitir que os usuários selecionem um Membro ClickUp.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique uma data para a conclusão desta tarefa.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique campos adicionais para incluir nesta tarefa em formato JSON.
  </Accordion>

  <Accordion title="clickup/delete_task">
    **Descrição:** Exclua uma tarefa no ClickUp.

    **Parâmetros:**

    * `taskId` (string, obrigatório): ID da tarefa - O ID da tarefa a ser excluída.
  </Accordion>

  <Accordion title="clickup/get_list">
    **Descrição:** Obtenha informações da Lista no ClickUp.

    **Parâmetros:**

    * `spaceId` (string, obrigatório): ID do Espaço - O ID do espaço que contém as listas.
  </Accordion>

  <Accordion title="clickup/get_custom_fields_in_list">
    **Descrição:** Obtenha Campos Personalizados em uma Lista no ClickUp.

    **Parâmetros:**

    * `listId` (string, obrigatório): ID da Lista - O ID da lista da qual obter os campos personalizados.
  </Accordion>

  <Accordion title="clickup/get_all_fields_in_list">
    **Descrição:** Obtenha Todos os Campos em uma Lista no ClickUp.

    **Parâmetros:**

    * `listId` (string, obrigatório): ID da Lista - O ID da lista da qual obter todos os campos.
  </Accordion>

  <Accordion title="clickup/get_space">
    **Descrição:** Obtenha informações do Espaço no ClickUp.

    **Parâmetros:**

    * `spaceId` (string, opcional): ID do Espaço - O ID do espaço a ser recuperado.
  </Accordion>

  <Accordion title="clickup/get_folders">
    **Descrição:** Obtenha Pastas no ClickUp.

    **Parâmetros:**

    * `spaceId` (string, obrigatório): ID do Espaço - O ID do espaço que contém as pastas.
  </Accordion>

  <Accordion title="clickup/get_member">
    **Descrição:** Obtenha informações de Membro no ClickUp.

    **Parâmetros:** Nenhum obrigatório.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente ClickUp
```

---

## Research Agent

**URL:** llms-txt#research-agent

role: "Research Specialist for technical topics"
goal: "Gather comprehensive, accurate information from authoritative sources"
backstory: "You are a meticulous researcher with a background in library science..."

---

## Selenium Scraper

**URL:** llms-txt#selenium-scraper

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/seleniumscrapingtool

O `SeleniumScrapingTool` foi desenvolvido para extrair e ler o conteúdo de um site específico utilizando o Selenium.

---

## Fluxo de validação de saída da tarefa

**URL:** llms-txt#fluxo-de-validação-de-saída-da-tarefa

**Contents:**
  - Rastreamento de Eventos
- Melhores Práticas
  - Diretrizes para o Contexto
  - Seleção de Limiar
- Considerações de Performance
  - Impacto no Tempo de Execução
  - Otimização de Custos
- Solução de Problemas

task_output = meu_agente.execute_task(minha_tarefa)
resultado_validacao = protecao(task_output)

if resultado_validacao.valid:
    # Tarefa concluída com sucesso
    return task_output
else:
    # Tarefa falha com feedback de validação
    raise ValidationError(resultado_validacao.feedback)
python  theme={null}
    contexto = """
    Empresa XYZ foi fundada em 2020 e é especializada em soluções de energia renovável.
    Possui 150 funcionários e faturou R$ 50 milhões em 2023.
    Seus principais produtos incluem painéis solares e turbinas eólicas.
    """
    python  theme={null}
    # Bom: Contexto focado
    contexto = "O clima atual em Nova York é 18°C com chuva leve."

# Evite: Informações irrelevantes
    contexto = "The weather is 18°C. The city has 8 million people. Traffic is heavy."
    ```
  </Step>

<Step title="Atualize o Contexto Regularmente">
    Certifique-se de que seu contexto de referência reflita informações atuais e precisas.
  </Step>
</Steps>

### Seleção de Limiar

<Steps>
  <Step title="Comece com a Validação Padrão">
    Inicie sem limiares personalizados para entender a performance inicial.
  </Step>

<Step title="Ajuste Conforme as Necessidades">
    * **Conteúdo crítico**: Use limiar 8-10 para máxima precisão
    * **Conteúdo geral**: Use limiar 6-7 para validação equilibrada
    * **Conteúdo criativo**: Use limiar 4-5 ou validação padrão baseada em veredito
  </Step>

<Step title="Monitore e Itere">
    Acompanhe os resultados da validação e ajuste os limiares conforme falsos positivos/negativos.
  </Step>
</Steps>

## Considerações de Performance

### Impacto no Tempo de Execução

* **Sobrecarga de Validação**: Cada proteção adiciona \~1-3 segundos por tarefa
* **Eficiência do LLM**: Escolha modelos eficientes para avaliação (ex: gpt-4o-mini)

### Otimização de Custos

* **Seleção de Modelo**: Utilize modelos menores e eficientes para avaliação da proteção
* **Tamanho do Contexto**: Mantenha o contexto de referência conciso, mas abrangente
* **Cache**: Considere armazenar resultados de validação para conteúdos repetidos

## Solução de Problemas

<Accordion title="Validação Sempre Falha">
  **Possíveis Causas:**

* Contexto muito restrito ou não relacionado à saída da tarefa
  * Limiar configurado alto demais para o tipo de conteúdo
  * Contexto de referência desatualizado

* Revise e atualize o contexto para corresponder aos requisitos da tarefa
  * Reduza o limiar ou utilize validação padrão baseada em veredito
  * Certifique-se de que o contexto esteja atual e correto
</Accordion>

<Accordion title="Falsos Positivos (Conteúdo Válido Marcado como Inválido)">
  **Possíveis Causas:**

* Limiar alto demais para tarefas criativas ou interpretativas
  * Contexto não cobre todos os aspectos válidos da saída
  * Modelo de avaliação excessivamente conservador

* Reduza o limiar ou utilize validação padrão
  * Expanda o contexto para incluir um espectro maior do conteúdo aceitável
  * Teste com diferentes modelos de avaliação
</Accordion>

<Accordion title="Erros de Avaliação">
  **Possíveis Causas:**

* Problemas de conexão de rede
  * Modelo LLM indisponível ou com limite de uso
  * Saída ou contexto da tarefa em formato inadequado

* Verifique a conectividade de rede e o status do serviço LLM
  * Implemente lógica de retentativas para falhas transitórias
  * Valide o formato da saída da tarefa antes da avaliação da proteção
</Accordion>

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nosso suporte para assistência na configuração ou solução de problemas da proteção contra alucinações.
</Card>

**Examples:**

Example 1 (unknown):
```unknown
### Rastreamento de Eventos

A proteção se integra ao sistema de eventos do CrewAI para fornecer observabilidade:

* **Validação Iniciada**: Quando a avaliação da proteção começa
* **Validação Concluída**: Quando a avaliação termina com resultados
* **Falha na Validação**: Quando ocorrem erros técnicos durante a avaliação

## Melhores Práticas

### Diretrizes para o Contexto

<Steps>
  <Step title="Forneça Contexto Abrangente">
    Inclua todas as informações factuais relevantes nas quais a IA deve basear sua saída:
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Mantenha o Contexto Relevante">
    Inclua apenas informações diretamente relacionadas à tarefa para evitar confusão:
```

---

## ✅ Correct

**URL:** llms-txt#✅-correct

**Contents:**
- 커스텀 LLM 테스트하기

def __init__(self, model: str, api_key: str, temperature: Optional[float] = None):
    super().__init__(model=model, temperature=temperature)
python  theme={null}
from crewai import Agent, Task, Crew

def test_custom_llm():
    llm = CustomLLM(
        model="test-model",
        api_key="test-key",
        endpoint="https://api.test.com"
    )
    
    # Test basic call
    result = llm.call("Hello, world!")
    assert isinstance(result, str)
    assert len(result) > 0
    
    # Test with CrewAI agent
    agent = Agent(
        role="Test Agent",
        goal="Test custom LLM",
        backstory="A test agent.",
        llm=llm
    )
    
    task = Task(
        description="Say hello",
        expected_output="A greeting",
        agent=agent
    )
    
    crew = Crew(agents=[agent], tasks=[task])
    result = crew.kickoff()
    assert "hello" in result.raw.lower()
```

이 가이드는 CrewAI에서 커스텀 LLM을 구현하는 주요 사항을 다룹니다.

**Examples:**

Example 1 (unknown):
```unknown
**함수 호출이 작동하지 않음**

* `supports_function_calling()`이 `True`를 반환하는지 확인하세요
* 응답에서 `tool_calls`를 처리하는지 확인하세요
* `available_functions` 매개변수가 올바르게 사용되는지 검증하세요

**인증 실패**

* API 키 형식과 권한을 확인하세요
* 인증 헤더 형식을 점검하세요
* 엔드포인트 URL이 올바른지 확인하세요

**응답 파싱 오류**

* 중첩된 필드에 접근하기 전에 응답 구조를 검증하세요
* content가 None일 수 있는 경우를 처리하세요
* 잘못된 응답에 대한 적절한 오류 처리를 추가하세요

## 커스텀 LLM 테스트하기
```

---

## Segunda criação de agente (dentro de 5 minutos) - usa esquemas cacheados

**URL:** llms-txt#segunda-criação-de-agente-(dentro-de-5-minutos)---usa-esquemas-cacheados

**Contents:**
  - Conexões Sob Demanda

agente2 = Agent(role="Segundo", goal="Teste", backstory="Teste",
               mcps=["https://api.example.com/mcp"])  # Muito mais rápido!
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Conexões Sob Demanda

Conexões de ferramentas são estabelecidas apenas quando as ferramentas são realmente usadas:
```

---

## Website RAG Search

**URL:** llms-txt#website-rag-search

Source: https://docs.crewai.com/en/tools/search-research/websitesearchtool

The `WebsiteSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a website.

---

## Task to create a bug report

**URL:** llms-txt#task-to-create-a-bug-report

create_bug_task = Task(
    description="Create a high-priority bug report for the authentication system and assign it to the backend team",
    agent=linear_agent,
    expected_output="Bug report created successfully with issue ID"
)

---

## Second run - state is automatically loaded

**URL:** llms-txt#second-run---state-is-automatically-loaded

**Contents:**
- 고급 상태 패턴
  - 상태 기반 조건부 로직
  - 복잡한 상태 변환 처리
- Crews로 상태 관리하기
  - 크루에 상태 전달하기
  - State에서 Crew 출력 처리하기
- 상태 관리 모범 사례
  - 1. 상태를 집중적으로 유지하세요

flow2 = PersistentCounterFlow()
result2 = flow2.kickoff()
print(f"Second run result: {result2}")  # Will be higher due to persisted state
python  theme={null}
from crewai.flow.flow import Flow, listen, start
from crewai.flow.persistence import persist

class SelectivePersistFlow(Flow):
    @start()
    def first_step(self):
        self.state["count"] = 1
        return "First step"

@persist()  # Only persist after this method
    @listen(first_step)
    def important_step(self, prev_result):
        self.state["count"] += 1
        self.state["important_data"] = "This will be persisted"
        return "Important step completed"

@listen(important_step)
    def final_step(self, prev_result):
        self.state["count"] += 1
        return f"Complete with count {self.state['count']}"
python  theme={null}
from crewai.flow.flow import Flow, listen, router, start
from pydantic import BaseModel

class PaymentState(BaseModel):
    amount: float = 0.0
    is_approved: bool = False
    retry_count: int = 0

class PaymentFlow(Flow[PaymentState]):
    @start()
    def process_payment(self):
        # Simulate payment processing
        self.state.amount = 100.0
        self.state.is_approved = self.state.amount < 1000
        return "Payment processed"

@router(process_payment)
    def check_approval(self, previous_result):
        if self.state.is_approved:
            return "approved"
        elif self.state.retry_count < 3:
            return "retry"
        else:
            return "rejected"

@listen("approved")
    def handle_approval(self):
        return f"Payment of ${self.state.amount} approved!"

@listen("retry")
    def handle_retry(self):
        self.state.retry_count += 1
        print(f"Retrying payment (attempt {self.state.retry_count})...")
        # Could implement retry logic here
        return "Retry initiated"

@listen("rejected")
    def handle_rejection(self):
        return f"Payment of ${self.state.amount} rejected after {self.state.retry_count} retries."
python  theme={null}
from crewai.flow.flow import Flow, listen, start
from pydantic import BaseModel
from typing import List, Dict

class UserData(BaseModel):
    name: str
    active: bool = True
    login_count: int = 0

class ComplexState(BaseModel):
    users: Dict[str, UserData] = {}
    active_user_count: int = 0

class TransformationFlow(Flow[ComplexState]):
    @start()
    def initialize(self):
        # Add some users
        self.add_user("alice", "Alice")
        self.add_user("bob", "Bob")
        self.add_user("charlie", "Charlie")
        return "Initialized"

@listen(initialize)
    def process_users(self, _):
        # Increment login counts
        for user_id in self.state.users:
            self.increment_login(user_id)

# Deactivate one user
        self.deactivate_user("bob")

# Update active count
        self.update_active_count()

return f"Processed {len(self.state.users)} users"

# Helper methods for state transformations
    def add_user(self, user_id: str, name: str):
        self.state.users[user_id] = UserData(name=name)
        self.update_active_count()

def increment_login(self, user_id: str):
        if user_id in self.state.users:
            self.state.users[user_id].login_count += 1

def deactivate_user(self, user_id: str):
        if user_id in self.state.users:
            self.state.users[user_id].active = False
            self.update_active_count()

def update_active_count(self):
        self.state.active_user_count = sum(
            1 for user in self.state.users.values() if user.active
        )
python  theme={null}
from crewai.flow.flow import Flow, listen, start
from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

class ResearchState(BaseModel):
    topic: str = ""
    depth: str = "medium"
    results: str = ""

class ResearchFlow(Flow[ResearchState]):
    @start()
    def get_parameters(self):
        # In a real app, this might come from user input
        self.state.topic = "Artificial Intelligence Ethics"
        self.state.depth = "deep"
        return "Parameters set"

@listen(get_parameters)
    def execute_research(self, _):
        # Create agents
        researcher = Agent(
            role="Research Specialist",
            goal=f"Research {self.state.topic} in {self.state.depth} detail",
            backstory="You are an expert researcher with a talent for finding accurate information."
        )

writer = Agent(
            role="Content Writer",
            goal="Transform research into clear, engaging content",
            backstory="You excel at communicating complex ideas clearly and concisely."
        )

# Create tasks
        research_task = Task(
            description=f"Research {self.state.topic} with {self.state.depth} analysis",
            expected_output="Comprehensive research notes in markdown format",
            agent=researcher
        )

writing_task = Task(
            description=f"Create a summary on {self.state.topic} based on the research",
            expected_output="Well-written article in markdown format",
            agent=writer,
            context=[research_task]
        )

# Create and run crew
        research_crew = Crew(
            agents=[researcher, writer],
            tasks=[research_task, writing_task],
            process=Process.sequential,
            verbose=True
        )

# Run crew and store result in state
        result = research_crew.kickoff()
        self.state.results = result.raw

return "Research completed"

@listen(execute_research)
    def summarize_results(self, _):
        # Access the stored results
        result_length = len(self.state.results)
        return f"Research on {self.state.topic} completed with {result_length} characters of results."
python  theme={null}
@listen(execute_crew)
def process_crew_results(self, _):
    # Parse the raw results (assuming JSON output)
    import json
    try:
        results_dict = json.loads(self.state.raw_results)
        self.state.processed_results = {
            "title": results_dict.get("title", ""),
            "main_points": results_dict.get("main_points", []),
            "conclusion": results_dict.get("conclusion", "")
        }
        return "Results processed successfully"
    except json.JSONDecodeError:
        self.state.error = "Failed to parse crew results as JSON"
        return "Error processing results"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### 메서드 수준 지속성

더 세밀한 제어를 위해 `@persist()`를 특정 메서드에 적용할 수 있습니다:
```

Example 2 (unknown):
```unknown
## 고급 상태 패턴

### 상태 기반 조건부 로직

state를 사용하여 flow에서 복잡한 조건부 로직을 구현할 수 있습니다:
```

Example 3 (unknown):
```unknown
### 복잡한 상태 변환 처리

복잡한 상태 변환의 경우, 전용 메서드를 만들어 처리할 수 있습니다.
```

Example 4 (unknown):
```unknown
이와 같은 헬퍼 메서드 생성 패턴은 flow 메서드를 깔끔하게 유지하면서 복잡한 상태 조작을 가능하게 해줍니다.

## Crews로 상태 관리하기

CrewAI에서 가장 강력한 패턴 중 하나는 flow 상태 관리와 crew 실행을 결합하는 것입니다.

### 크루에 상태 전달하기

플로우 상태를 사용하여 크루에 매개변수를 전달할 수 있습니다:
```

---

## Snippet: … as ChatGPT, have the potential to play a critical role in advancing our understanding of climate

**URL:** llms-txt#snippet:-…-as-chatgpt,-have-the-potential-to-play-a-critical-role-in-advancing-our-understanding-of-climate

---

## For fixed directory searches

**URL:** llms-txt#for-fixed-directory-searches

**Contents:**
- Arguments
- Custom Model and Embeddings

tool = DirectorySearchTool(directory='/path/to/directory')
python Code theme={null}
from chromadb.config import Settings

tool = DirectorySearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # or "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Arguments

* `directory`: A string argument that specifies the search directory. This is optional during initialization but required for searches if not set initially.

## Custom Model and Embeddings

The DirectorySearchTool uses OpenAI for embeddings and summarization by default. Customization options for these settings include changing the model provider and configuration, enhancing flexibility for advanced users.
```

---

## Oxylabs 스크래퍼

**URL:** llms-txt#oxylabs-스크래퍼

**Contents:**
- 설치

Source: https://docs.crewai.com/ko/tools/web-scraping/oxylabsscraperstool

Oxylabs 스크래퍼를 사용하면 해당 소스에서 정보를 쉽게 접근할 수 있습니다. 아래에서 사용 가능한 소스 목록을 확인하세요:
  - `Amazon Product`
  - `Amazon Search`
  - `Google Seach`
  - `Universal`

[여기](https://oxylabs.io)에서 Oxylabs 계정을 생성하여 자격 증명을 받으세요.

API 매개변수에 대한 자세한 정보는 [Oxylabs 문서](https://developers.oxylabs.io/scraping-solutions/web-scraper-api/targets)를 참고하세요.

---

## Define a custom manager agent

**URL:** llms-txt#define-a-custom-manager-agent

manager = Agent(
    role="Project Manager",
    goal="Efficiently manage the crew and ensure high-quality task completion",
    backstory="You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success.",
    allow_delegation=True,
)

---

## Print the complete system prompt that will be sent to the LLM

**URL:** llms-txt#print-the-complete-system-prompt-that-will-be-sent-to-the-llm

if "system" in generated_prompt:
    print("=== SYSTEM PROMPT ===")
    print(generated_prompt["system"])
    print("\n=== USER PROMPT ===")
    print(generated_prompt["user"])
else:
    print("=== COMPLETE PROMPT ===")
    print(generated_prompt["prompt"])

---

## Agente gerenciado no Bedrock

**URL:** llms-txt#agente-gerenciado-no-bedrock

**Contents:**
- **Boas Práticas**

knowledge_router = BedrockInvokeAgentTool(
    agent_id="bedrock-agent-id",
    agent_alias_id="prod",
)

automation_strategist = Agent(
    role="Estrategista de Automação",
    goal="Orquestrar automações externas e resumir os resultados",
    backstory="Você coordena fluxos corporativos e sabe quando delegar tarefas a serviços especializados.",
    tools=[analysis_automation, knowledge_router],
    verbose=True,
)

execute_playbook = Task(
    description="Execute a automação de análise e peça ao agente Bedrock pontos principais para a diretoria.",
    agent=automation_strategist,
)

Crew(agents=[automation_strategist], tasks=[execute_playbook]).kickoff()
```

* **Proteja credenciais**: Armazene tokens e chaves de API em variáveis de ambiente ou no gerenciador de segredos
* **Planeje a latência**: Automações externas podem levar mais tempo — configure intervalos e timeouts adequados
* **Reutilize sessões**: Agentes Bedrock aceitam IDs de sessão para manter contexto entre chamadas
* **Valide respostas**: Normalize a saída remota (JSON, texto, códigos de status) antes de enviá-la a etapas seguintes
* **Monitore o uso**: Acompanhe logs no CrewAI Platform ou no AWS CloudWatch para evitar estouros de quota e falhas

---

## ✅ 구체적이고 실행 가능한 설명

**URL:** llms-txt#✅-구체적이고-실행-가능한-설명

Task(
    description="""Research competitors in the AI chatbot space.
    Focus on: pricing models, key features, target markets.
    Provide data in a structured format.""",
    ...
)

---

## Inicialize a ferramenta para buscas semânticas em um repositório GitHub específico

**URL:** llms-txt#inicialize-a-ferramenta-para-buscas-semânticas-em-um-repositório-github-específico

tool = GithubSearchTool(
	github_repo='https://github.com/example/repo',
	gh_token='your_github_personal_access_token',
	content_types=['code', 'issue'] # Opções: code, repo, pr, issue
)

---

## `MongoDBVectorSearchTool`

**URL:** llms-txt#`mongodbvectorsearchtool`

**Contents:**
- Description
- Installation
- Parameters
  - Initialization
  - Run Parameters
- Quick start
- Index creation helpers
- Common issues
- More examples
  - Basic initialization

Perform vector similarity queries on MongoDB Atlas collections. Supports index creation helpers and bulk insert of embedded texts.

MongoDB Atlas supports native vector search. Learn more:
[https://www.mongodb.com/docs/atlas/atlas-vector-search/vector-search-overview/](https://www.mongodb.com/docs/atlas/atlas-vector-search/vector-search-overview/)

Install with the MongoDB extra:

* `connection_string` (str, required)
* `database_name` (str, required)
* `collection_name` (str, required)
* `vector_index_name` (str, default `vector_index`)
* `text_key` (str, default `text`)
* `embedding_key` (str, default `embedding`)
* `dimensions` (int, default `1536`)

* `query` (str, required): Natural language query to embed and search.

## Index creation helpers

Use `create_vector_search_index(...)` to provision an Atlas Vector Search index with the correct dimensions and similarity.

* Authentication failures: ensure your Atlas IP Access List allows your runner and the connection string includes credentials.
* Index not found: create the vector index first; name must match `vector_index_name`.
* Dimensions mismatch: align embedding model dimensions with `dimensions`.

### Basic initialization

### Custom query configuration

### Preloading the database and creating the index

```python Code theme={null}
import os
from crewai_tools import MongoDBVectorSearchTool

tool = MongoDBVectorSearchTool(
    database_name="example_database",
    collection_name="example_collection",
    connection_string="<your_mongodb_connection_string>",
)

**Examples:**

Example 1 (unknown):
```unknown
or
```

Example 2 (unknown):
```unknown
## Parameters

### Initialization

* `connection_string` (str, required)
* `database_name` (str, required)
* `collection_name` (str, required)
* `vector_index_name` (str, default `vector_index`)
* `text_key` (str, default `text`)
* `embedding_key` (str, default `embedding`)
* `dimensions` (int, default `1536`)

### Run Parameters

* `query` (str, required): Natural language query to embed and search.

## Quick start
```

Example 3 (unknown):
```unknown
## Index creation helpers

Use `create_vector_search_index(...)` to provision an Atlas Vector Search index with the correct dimensions and similarity.

## Common issues

* Authentication failures: ensure your Atlas IP Access List allows your runner and the connection string includes credentials.
* Index not found: create the vector index first; name must match `vector_index_name`.
* Dimensions mismatch: align embedding model dimensions with `dimensions`.

## More examples

### Basic initialization
```

Example 4 (unknown):
```unknown
### Custom query configuration
```

---

## make sure OXYLABS_USERNAME and OXYLABS_PASSWORD variables are set

**URL:** llms-txt#make-sure-oxylabs_username-and-oxylabs_password-variables-are-set

tool = OxylabsUniversalScraperTool(
    config={
        "render": "html",
        "user_agent_type": "mobile",
        "context": [
            {"key": "force_headers", "value": True},
            {"key": "force_cookies", "value": True},
            {
                "key": "headers",
                "value": {
                    "Custom-Header-Name": "custom header content",
                },
            },
            {
                "key": "cookies",
                "value": [
                    {"key": "NID", "value": "1234567890"},
                    {"key": "1P JAR", "value": "0987654321"},
                ],
            },
            {"key": "http_method", "value": "get"},
            {"key": "follow_redirects", "value": True},
            {"key": "successful_status_codes", "value": [808, 909]},
        ],
    }
)

result = tool.run(url="https://ip.oxylabs.io")

---

## Criar agente com múltiplas fontes MCP

**URL:** llms-txt#criar-agente-com-múltiplas-fontes-mcp

agente_multi_fonte = Agent(
    role="Analista de Pesquisa Multi-Fonte",
    goal="Conduzir pesquisa abrangente usando múltiplas fontes de dados",
    backstory="""Pesquisador especialista com acesso a busca web, dados meteorológicos,
    informações financeiras e ferramentas de pesquisa acadêmica""",
    mcps=[
        # Servidores MCP externos
        "https://mcp.exa.ai/mcp?api_key=sua_chave_exa&profile=pesquisa",
        "https://weather.api.com/mcp#get_current_conditions",

# Marketplace CrewAI AMP
        "crewai-amp:financial-insights",
        "crewai-amp:academic-research#pubmed_search",
        "crewai-amp:market-intelligence#competitor_analysis"
    ]
)

---

## if the URL is known or discovered during its execution:

**URL:** llms-txt#if-the-url-is-known-or-discovered-during-its-execution:

tool = CodeDocsSearchTool()

---

## Initialize the tool so the agent can read any directory's content

**URL:** llms-txt#initialize-the-tool-so-the-agent-can-read-any-directory's-content

---

## Crie o gerador de prompt

**URL:** llms-txt#crie-o-gerador-de-prompt

prompt_generator = Prompts(
    agent=agent,
    has_tools=len(agent.tools) > 0,
    use_system_prompt=agent.use_system_prompt
)

---

## Visão Geral das Ferramentas

**URL:** llms-txt#visão-geral-das-ferramentas

**Contents:**
- **Categorias de Ferramentas**
- **Acesso Rápido**
- **Primeiros Passos**

Source: https://docs.crewai.com/pt-BR/tools/overview

Descubra a vasta biblioteca do CrewAI com mais de 40 ferramentas para potencializar seus agentes de IA

O CrewAI oferece uma biblioteca extensa de ferramentas pré-construídas para aprimorar as capacidades dos seus agentes. De processamento de arquivos a web scraping, consultas em bancos de dados a serviços de IA — temos tudo o que você precisa.

## **Categorias de Ferramentas**

<CardGroup cols={2}>
  <Card title="Arquivo & Documento" icon="folder-open" href="/pt-BR/tools/file-document/overview" color="#3B82F6">
    Leia, escreva e pesquise em diversos formatos de arquivo, incluindo PDF, DOCX, JSON, CSV e muito mais. Perfeito para fluxos de processamento de documentos.
  </Card>

<Card title="Web Scraping & Navegação" icon="globe" href="/pt-BR/tools/web-scraping/overview" color="#10B981">
    Extraia dados de sites, automatize interações com navegadores e faça scraping de conteúdo em escala com ferramentas como Firecrawl, Selenium e outras.
  </Card>

<Card title="Pesquisa & Busca" icon="magnifying-glass" href="/pt-BR/tools/search-research/overview" color="#F59E0B">
    Realize buscas na web, encontre repositórios de código, pesquise conteúdo no YouTube e descubra informações em toda a internet.
  </Card>

<Card title="Banco de Dados & Dados" icon="database" href="/pt-BR/tools/database-data/overview" color="#8B5CF6">
    Conecte-se a bancos de dados SQL, repositórios vetoriais e data warehouses. Consulte MySQL, PostgreSQL, Snowflake, Qdrant e Weaviate.
  </Card>

<Card title="IA & Aprendizado de Máquina" icon="brain" href="/pt-BR/tools/ai-ml/overview" color="#EF4444">
    Gere imagens com DALL-E, execute tarefas de visão computacional, integre com LangChain, construa sistemas RAG e aproveite interpretadores de código.
  </Card>

<Card title="Nuvem & Armazenamento" icon="cloud" href="/pt-BR/tools/cloud-storage/overview" color="#06B6D4">
    Interaja com serviços em nuvem incluindo AWS S3, Amazon Bedrock e outros serviços de armazenamento e IA na nuvem.
  </Card>

<Card title="Automação" icon="bolt" href="/pt-BR/tools/automation/overview" color="#84CC16">
    Automatize fluxos de trabalho com Apify, Composio e outras plataformas para conectar seus agentes a serviços externos.
  </Card>

<Card title="Integrações" icon="plug" href="/pt-BR/tools/tool-integrations/overview" color="#0891B2">
    Integre o CrewAI com sistemas externos como Amazon Bedrock e o toolkit de Automação do CrewAI.
  </Card>
</CardGroup>

Precisa de uma ferramenta específica? Aqui estão algumas opções populares:

<CardGroup cols={3}>
  <Card title="RAG Tool" icon="image" href="/pt-BR/tools/ai-ml/ragtool">
    Implemente Geração com Recuperação de Dados (RAG)
  </Card>

<Card title="Serper Dev" icon="book-atlas" href="/pt-BR/tools/search-research/serperdevtool">
    API de busca do Google
  </Card>

<Card title="File Read" icon="file" href="/pt-BR/tools/file-document/filereadtool">
    Leia qualquer tipo de arquivo
  </Card>

<Card title="Scrape Website" icon="globe" href="/pt-BR/tools/web-scraping/scrapewebsitetool">
    Extraia conteúdo da web
  </Card>

<Card title="Code Interpreter" icon="code" href="/pt-BR/tools/ai-ml/codeinterpretertool">
    Execute código Python
  </Card>

<Card title="S3 Reader" icon="cloud" href="/pt-BR/tools/cloud-storage/s3readertool">
    Acesse arquivos no AWS S3
  </Card>
</CardGroup>

## **Primeiros Passos**

Para usar qualquer ferramenta em seu projeto CrewAI:

1. **Importe** a ferramenta na configuração da sua crew
2. **Adicione** à lista de ferramentas do seu agente
3. **Configure** as chaves de API ou ajustes necessários

```python  theme={null}
from crewai_tools import FileReadTool, SerperDevTool

---

## 예시: 카테고리 필터를 사용한 검색

**URL:** llms-txt#예시:-카테고리-필터를-사용한-검색

---

## 사용 가능한 모든 조직 목록 확인

**URL:** llms-txt#사용-가능한-모든-조직-목록-확인

<Note>
  리포지토리에서 agent를 불러올 때는 인증이 완료되어 있어야 하며, 올바른 조직으로 전환되어 있어야 합니다. 오류가 발생하면 위의 CLI 명령어를 사용하여 인증 상태와 조직 설정을 확인하세요.
</Note>

---

## Create external memory instance with Mem0 Client

**URL:** llms-txt#create-external-memory-instance-with-mem0-client

**Contents:**
  - Implementação Personalizada de Armazenamento

external_memory = ExternalMemory(
    embedder_config={
        "provider": "mem0",
        "config": {
            "user_id": "john",
            "org_id": "my_org_id",        # Optional
            "project_id": "my_project_id", # Optional
            "api_key": "custom-api-key"    # Optional - overrides env var
            "run_id": "my_run_id",        # Optional - for short-term memory
            "includes": "include1",       # Optional 
            "excludes": "exclude1",       # Optional
            "infer": True                 # Optional defaults to True
            "custom_categories": new_categories  # Optional - custom categories for user memory
        },
    }
)

crew = Crew(
    agents=[...],
    tasks=[...],
    external_memory=external_memory,  # Separate from basic memory
    process=Process.sequential,
    verbose=True
)
python  theme={null}
from crewai.memory.external.external_memory import ExternalMemory
from crewai.memory.storage.interface import Storage

class CustomStorage(Storage):
    def __init__(self):
        self.memories = []

def save(self, value, metadata=None, agent=None):
        self.memories.append({
            "value": value, 
            "metadata": metadata, 
            "agent": agent
        })

def search(self, query, limit=10, score_threshold=0.5):
        # Implemente sua lógica de busca aqui
        return [m for m in self.memories if query.lower() in str(m["value"]).lower()]

def reset(self):
        self.memories = []

**Examples:**

Example 1 (unknown):
```unknown
### Implementação Personalizada de Armazenamento
```

---

## Create a knowledge source

**URL:** llms-txt#create-a-knowledge-source

content = "Users name is John. He is 30 years old and lives in San Francisco."
string_source = StringKnowledgeSource(content=content)

---

## Exemplo de evento enviado pelo webhook

**URL:** llms-txt#exemplo-de-evento-enviado-pelo-webhook

**Contents:**
- Eventos Suportados

A estrutura do objeto `data` varia conforme o tipo de evento. Consulte a [lista de eventos](https://github.com/crewAIInc/crewAI/tree/main/src/crewai/utilities/events) no GitHub.

Como as requisições são enviadas via HTTP, a ordem dos eventos não pode ser garantida. Caso precise de ordenação, utilize o campo `timestamp`.

## Eventos Suportados

O CrewAI oferece suporte a eventos do sistema e eventos personalizados no Enterprise Event Streaming. Esses eventos são enviados para o endpoint do seu webhook configurado durante a execução das crews e flows.

* `crew_kickoff_started`
* `crew_step_started`
* `crew_step_completed`
* `crew_execution_completed`
* `llm_call_started`
* `llm_call_completed`
* `tool_usage_started`
* `tool_usage_completed`
* `crew_test_failed`
* *...e outros*

Os nomes dos eventos correspondem ao event bus interno. Veja o [código fonte no GitHub](https://github.com/crewAIInc/crewAI/tree/main/src/crewai/utilities/events) para a lista completa.

Você pode emitir seus próprios eventos personalizados, e eles serão entregues através do webhook stream juntamente com os eventos do sistema.

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nossa equipe de suporte para assistência com integração de webhook ou solução de problemas.
</Card>

---

## Introdução

**URL:** llms-txt#introdução

**Contents:**
- Recursos
  - Capacidades do AI Gateway
  - Observabilidade e Rastreamento
- Instruções de Configuração
- Exemplo de Início Rápido

[LangDB AI Gateway](https://langdb.ai) fornece APIs compatíveis com OpenAI para conectar com múltiplos Modelos de Linguagem Grandes e serve como uma plataforma de observabilidade que torna effortless rastrear fluxos de trabalho CrewAI de ponta a ponta, proporcionando acesso a mais de 350 modelos de linguagem. Com uma única chamada `init()`, todas as interações de agentes, execuções de tarefas e chamadas LLM são capturadas, fornecendo observabilidade abrangente e infraestrutura de IA pronta para produção para suas aplicações.

<Frame caption="Exemplo de Rastreamento CrewAI LangDB">
  <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6303d15055c19a7a6ec9d0c664f15c9f" alt="Exemplo de rastreamento CrewAI LangDB" data-og-width="1576" width="1576" data-og-height="892" height="892" data-path="images/langdb-1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=da34c5dce0a82022f85feda11af459d4 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=902f87462033e4874e3d373953158a39 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=74c605bfb1a201c0f663d1c04b8daf60 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=880a223bb40e9c94724c6047b7a2e966 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=2c3dd2cac11506d6cc1aeba11c79759d 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langdb-1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a6d52809351409222de871b2f8018715 2500w" />
</Frame>

**Confira:** [Ver o exemplo de trace ao vivo](https://app.langdb.ai/sharing/threads/3becbfed-a1be-ae84-ea3c-4942867a3e22)

### Capacidades do AI Gateway

* **Acesso a mais de 350 LLMs**: Conecte-se a todos os principais modelos de linguagem através de uma única integração
* **Modelos Virtuais**: Crie configurações de modelo personalizadas com parâmetros específicos e regras de roteamento
* **MCP Virtual**: Habilite compatibilidade e integração com sistemas MCP (Model Context Protocol) para comunicação aprimorada de agentes
* **Guardrails**: Implemente medidas de segurança e controles de conformidade para comportamento de agentes

### Observabilidade e Rastreamento

* **Rastreamento Automático**: Uma única chamada `init()` captura todas as interações CrewAI
* **Visibilidade Ponta a Ponta**: Monitore fluxos de trabalho de agentes do início ao fim
* **Rastreamento de Uso de Ferramentas**: Rastreie quais ferramentas os agentes usam e seus resultados
* **Monitoramento de Chamadas de Modelo**: Insights detalhados sobre interações LLM
* **Análise de Performance**: Monitore latência, uso de tokens e custos
* **Suporte a Depuração**: Execução passo a passo para solução de problemas
* **Monitoramento em Tempo Real**: Dashboard de traces e métricas ao vivo

## Instruções de Configuração

<Steps>
  <Step title="Instalar LangDB">
    Instale o cliente LangDB com flag de recurso CrewAI:

<Step title="Definir Variáveis de Ambiente">
    Configure suas credenciais LangDB:

<Step title="Inicializar Rastreamento">
    Importe e inicialize LangDB antes de configurar seu código CrewAI:

<Step title="Configurar CrewAI com LangDB">
    Configure seu LLM com cabeçalhos LangDB:

## Exemplo de Início Rápido

Aqui está um exemplo simples para começar com LangDB e CrewAI:

```python  theme={null}
import os
from pylangdb.crewai import init
from crewai import Agent, Task, Crew, LLM

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Definir Variáveis de Ambiente">
    Configure suas credenciais LangDB:
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Inicializar Rastreamento">
    Importe e inicialize LangDB antes de configurar seu código CrewAI:
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="Configurar CrewAI com LangDB">
    Configure seu LLM com cabeçalhos LangDB:
```

Example 4 (unknown):
```unknown
</Step>
</Steps>

## Exemplo de Início Rápido

Aqui está um exemplo simples para começar com LangDB e CrewAI:
```

---

## Impressão digital

**URL:** llms-txt#impressão-digital

**Contents:**
- Visão geral
- Como funciona a impressão digital
- Uso básico
  - Acessando impressões digitais

Source: https://docs.crewai.com/pt-BR/guides/advanced/fingerprinting

Saiba como usar o sistema de impressão digital da CrewAI para identificar e rastrear componentes de forma única durante todo o seu ciclo de vida.

As impressões digitais na CrewAI fornecem uma maneira de identificar e rastrear componentes de forma única durante todo o seu ciclo de vida. Cada `Agent`, `Crew` e `Task` recebe automaticamente uma impressão digital única quando criado, que não pode ser sobrescrita manualmente.

Essas impressões digitais podem ser usadas para:

* Auditoria e rastreamento do uso de componentes
* Garantir a integridade da identidade dos componentes
* Anexar metadados aos componentes
* Criar uma cadeia rastreável de operações

## Como funciona a impressão digital

Uma impressão digital é uma instância da classe `Fingerprint` do módulo `crewai.security`. Cada impressão digital contém:

* Uma string UUID: Um identificador único para o componente, gerado automaticamente e que não pode ser definido manualmente
* Um timestamp de criação: Quando a impressão digital foi gerada, definido automaticamente e que não pode ser modificado manualmente
* Metadados: Um dicionário de informações adicionais que pode ser customizado

As impressões digitais são geradas e atribuídas automaticamente quando um componente é criado. Cada componente expõe sua impressão digital por meio de uma propriedade de somente leitura.

### Acessando impressões digitais

```python  theme={null}
from crewai import Agent, Crew, Task

---

## Compare performance

**URL:** llms-txt#compare-performance

**Contents:**
- 2. 외부 메모리
  - Mem0를 사용한 기본 외부 메모리

openai_time = test_embedding_performance({
    "provider": "openai",
    "config": {"model": "text-embedding-3-small"}
})

ollama_time = test_embedding_performance({
    "provider": "ollama",
    "config": {"model": "mxbai-embed-large"}
})

print(f"OpenAI: {openai_time:.2f}s")
print(f"Ollama: {ollama_time:.2f}s")
python  theme={null}
import os
from crewai import Agent, Crew, Process, Task
from crewai.memory.external.external_memory import ExternalMemory

**Examples:**

Example 1 (unknown):
```unknown
## 2. 외부 메모리

외부 메모리는 crew의 내장 메모리와 독립적으로 작동하는 독립형 메모리 시스템을 제공합니다. 이는 특화된 메모리 공급자나 응용 프로그램 간 메모리 공유에 이상적입니다.

### Mem0를 사용한 기본 외부 메모리
```

---

## Human-in-the-Loop (HITL) 워크플로우

**URL:** llms-txt#human-in-the-loop-(hitl)-워크플로우

**Contents:**
- HITL 워크플로우 설정
- 모범 사례
- 일반적인 사용 사례

Source: https://docs.crewai.com/ko/learn/human-in-the-loop

CrewAI에서 Human-in-the-Loop 워크플로우를 구현하여 의사결정을 향상시키는 방법을 알아보세요

휴먼 인 더 루프(HITL, Human-in-the-Loop)는 인공지능과 인간의 전문 지식을 결합하여 의사결정을 강화하고 작업 결과를 향상시키는 강력한 접근 방식입니다. 이 가이드에서는 CrewAI 내에서 HITL을 구현하는 방법을 안내합니다.

<Steps>
  <Step title="작업 구성">
    human input이 활성화된 상태로 작업을 설정하세요:

<Frame>
      <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=cb2e2bab131e9eff86b0c51dceb16e11" alt="Crew Human Input" data-og-width="624" width="624" data-og-height="165" height="165" data-path="images/enterprise/crew-human-input.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1bc2a85e5aa6e736a118fe2c91452dc6 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=137c8e9c09c9a93ba1b683ad3e247e0d 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=79c8be91790b117c1498568ca48f4287 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4da8411c0c26ee98c0dcdde6117353fe 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1b24b707df7ec697db2652d80ed3ff8f 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=39a7543043c397cf4ff84582216ddb65 2500w" />
    </Frame>
  </Step>

<Step title="Webhook URL 제공">
    crew를 시작할 때, human input을 위한 webhook URL을 포함하세요:

<Frame>
      <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f2d298c0b4c7b3a62e1dee4e2e6f1bb3" alt="Crew Webhook URL" data-og-width="624" width="624" data-og-height="259" height="259" data-path="images/enterprise/crew-webhook-url.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=80f52cbe2cd1c6a2a4cd3e2039c22971 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6496d6f5e1fe13fec8be8a406e635b26 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=27cfbbf1fecdab2540df4aeb7ddd15b6 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=57d3439e96917a0627189bfd188af4a0 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=cad1f034d8fd4113f08df6bf1a58f3fa 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=fba10cd375c57bcd9b2a216067b5bd44 2500w" />
    </Frame>
  </Step>

<Step title="Webhook 알림 수신">
    crew가 human input이 필요한 작업을 완료하면, 다음 내용을 포함하는 webhook 알림을 받게 됩니다:

* 실행 ID
    * 작업 ID
    * 작업 출력
  </Step>

<Step title="작업 출력 검토">
    시스템이 `Pending Human Input` 상태에서 일시정지됩니다. 작업 출력을 신중하게 검토하세요.
  </Step>

<Step title="Human Feedback 제출">
    다음 정보를 포함하여 crew의 resume endpoint를 호출하세요:

<Frame>
      <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1e1c2ca22a2d674426f8e663fed33eca" alt="Crew Resume Endpoint" data-og-width="624" width="624" data-og-height="261" height="261" data-path="images/enterprise/crew-resume-endpoint.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=09014207ae06e6522303b77e4648f0d4 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1ad53990ab04014e622b3acdb37ca604 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=afb11308edffa03de969712505cf95ab 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=9bd69f0d75ec47ac2c6280f24a550bff 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f81e1ebcdc8a9348133503eb5eb4e37a 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=b12843fa2b80cc86580220766a1f4cc4 2500w" />
    </Frame>

<Warning>
      **중요: Webhook URL을 다시 제공해야 합니다**:
      kickoff 호출에서 사용한 것과 동일한 webhook URL(`taskWebhookUrl`, `stepWebhookUrl`, `crewWebhookUrl`)을 resume 호출에서 **반드시** 제공해야 합니다. Webhook 설정은 kickoff에서 자동으로 전달되지 **않으므로**, 작업 완료, 에이전트 단계, crew 완료에 대한 알림을 계속 받으려면 resume 요청에 명시적으로 포함해야 합니다.
    </Warning>

Webhook을 포함한 resume 호출 예시:

<Warning>
      **피드백이 작업 실행에 미치는 영향**:
      피드백의 전체 내용이 추가 컨텍스트로서 이후 작업 실행에 통합되므로, 피드백 제공 시 신중을 기하는 것이 매우 중요합니다.
    </Warning>

* 피드백에 포함된 모든 정보가 작업의 컨텍스트의 일부가 됩니다.
    * 관련 없는 세부 정보는 작업에 부정적인 영향을 미칠 수 있습니다.
    * 간결하고 관련성 높은 피드백이 작업의 집중력과 효율성을 유지하는 데 도움이 됩니다.
    * 제출 전에 피드백을 항상 꼼꼼히 검토하여 작업 실행을 긍정적으로 이끌 수 있는 정보만 포함되어 있는지 확인하세요.
  </Step>

<Step title="부정적 피드백 처리">
    부정적인 피드백을 제공할 경우:

* crew는 피드백에서 얻은 추가 컨텍스트로 작업을 재시도합니다.
    * 추가 검토를 위한 또 다른 webhook 알림을 받게 됩니다.
    * 만족할 때까지 4-6단계를 반복하세요.
  </Step>

<Step title="실행 계속">
    긍정적인 피드백을 제출하면 실행이 다음 단계로 진행됩니다.
  </Step>
</Steps>

* **구체적으로 작성하세요**: 해당 작업에 직접적으로 관련된 명확하고 실행 가능한 피드백을 제공하세요
* **관련성을 유지하세요**: 작업 수행 개선에 도움이 되는 정보만 포함하세요
* **시기적절하게 응답하세요**: 워크플로우 지연을 방지하기 위해 HITL 프롬프트에 신속하게 응답하세요
* **신중하게 검토하세요**: 제출 전 피드백을 다시 확인하여 정확성을 확보하세요

HITL 워크플로우는 다음과 같은 경우에 특히 유용합니다:

* 품질 보증 및 검증
* 복잡한 의사결정 시나리오
* 민감하거나 고위험 작업
* 인간의 판단이 필요한 창의적 과제
* 컴플라이언스 및 규제 검토

---

## Bom - obter apenas as ferramentas necessárias

**URL:** llms-txt#bom---obter-apenas-as-ferramentas-necessárias

mcps=["https://weather.api.com/mcp#get_forecast"]

---

## Ao utilizar Claude como seu LLM...

**URL:** llms-txt#ao-utilizar-claude-como-seu-llm...

from crewai import Agent, LLM

agent = Agent(
    role="Analyst",
    goal="Analyze data",
    backstory="Expert analyst",
    llm=LLM(provider="anthropic", model="claude-3-sonnet")  # Usando Claude
)

---

## Initialize enhanced tracing

**URL:** llms-txt#initialize-enhanced-tracing

Traceloop.init(
    api_endpoint="https://your-truefoundry-endpoint/api/tracing",
    headers={
        "Authorization": f"Bearer {your_truefoundry_pat_token}",
        "TFY-Tracing-Project": "your_project_name",
    },
)
```

This provides additional trace correlation across your entire CrewAI workflow.
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=90623834e0ba9f4ccb09890f6824912d" alt="TrueFoundry CrewAI Tracing" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/tracing_crewai.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d05099079060dfd1588ac0c8de28e07b 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=645362e069e687f7dc6fd6c44a97a4ef 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=aac6d42bbd2f457b59f6a4b22d6a7be1 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=7f166e1329cef8da8c1e07a38dc75506 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6e91cffda555b8cc7ce1800ed1b508b1 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=bf6296110bd62d9bb30ae2d0822d4b8d 2500w" />

---

## View all available commands

**URL:** llms-txt#view-all-available-commands

---

## Servidor HTTPS básico

**URL:** llms-txt#servidor-https-básico

"https://api.example.com/mcp"

---

## Identify form fields

**URL:** llms-txt#identify-form-fields

**Contents:**
- Opções de Configuração
- Boas Práticas
- Solução de Problemas
- Recursos Adicionais

result = stagehand_tool.run(
    instruction="Identify all the input fields in the registration form", 
    url="https://example.com/register",
    command_type="observe",
    selector="#registration-form"
)
python  theme={null}
stagehand_tool = StagehandTool(
    api_key="your-browserbase-api-key",
    project_id="your-browserbase-project-id",
    model_api_key="your-llm-api-key",
    model_name=AvailableModel.CLAUDE_3_7_SONNET_LATEST,
    dom_settle_timeout_ms=5000,  # Wait longer for DOM to settle
    headless=True,  # Run browser in headless mode
    self_heal=True,  # Attempt to recover from errors
    wait_for_captcha_solves=True,  # Wait for CAPTCHA solving
    verbose=1,  # Control logging verbosity (0-3)
)
```

1. **Seja Específico**: Forneça instruções detalhadas para melhores resultados
2. **Escolha o Tipo de Comando Apropriado**: Selecione o comando correto para sua tarefa
3. **Use Selectors**: Utilize seletores CSS para aumentar a precisão
4. **Divida Tarefas Complexas**: Separe fluxos de trabalho complexos em múltiplas chamadas da ferramenta
5. **Implemente Tratamento de Erros**: Adicione tratamento de erros para possíveis problemas

## Solução de Problemas

Problemas comuns e soluções:

* **Problemas de Sessão**: Verifique as chaves de API tanto da Browserbase quanto do provedor de LLM
* **Elemento Não Encontrado**: Aumente o `dom_settle_timeout_ms` para páginas mais lentas
* **Falhas em Ações**: Use o `observe` para identificar corretamente os elementos antes
* **Dados Incompletos**: Refine as instruções ou forneça seletores específicos

## Recursos Adicionais

Para dúvidas sobre a integração com o CrewAI:

* Participe da comunidade [Slack do Stagehand](https://stagehand.dev/slack)
* Abra uma issue no [repositório Stagehand](https://github.com/browserbase/stagehand)
* Visite a [documentação do Stagehand](https://docs.stagehand.dev/)

**Examples:**

Example 1 (unknown):
```unknown
## Opções de Configuração

Personalize o comportamento da StagehandTool com estes parâmetros:
```

---

## Crie um agente que utiliza a ferramenta

**URL:** llms-txt#crie-um-agente-que-utiliza-a-ferramenta

agent = Agent(
    role="Research Assistant",
    goal="Find relevant information in documents",
    tools=[qdrant_tool]
)

---

## `SnowflakeSearchTool`

**URL:** llms-txt#`snowflakesearchtool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

O `SnowflakeSearchTool` foi desenvolvido para conectar-se a data warehouses Snowflake e executar consultas SQL com recursos avançados como pool de conexões, lógica de tentativas e execução assíncrona. Esta ferramenta permite que agentes CrewAI interajam com bases de dados Snowflake, sendo ideal para tarefas de análise de dados, relatórios e inteligência de negócios que requerem acesso a dados empresariais armazenados no Snowflake.

Para utilizar esta ferramenta, é necessário instalar as dependências requeridas:

Ou, alternativamente:

## Passos para Começar

Para usar eficazmente o `SnowflakeSearchTool`, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários usando um dos comandos acima.
2. **Configure a Conexão com o Snowflake**: Crie um objeto `SnowflakeConfig` com suas credenciais do Snowflake.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta com a configuração necessária.
4. **Execute Consultas**: Utilize a ferramenta para rodar consultas SQL no seu banco de dados Snowflake.

O exemplo a seguir demonstra como usar o `SnowflakeSearchTool` para consultar dados de um banco de dados Snowflake:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import SnowflakeSearchTool, SnowflakeConfig

**Examples:**

Example 1 (unknown):
```unknown
Ou, alternativamente:
```

Example 2 (unknown):
```unknown
## Passos para Começar

Para usar eficazmente o `SnowflakeSearchTool`, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários usando um dos comandos acima.
2. **Configure a Conexão com o Snowflake**: Crie um objeto `SnowflakeConfig` com suas credenciais do Snowflake.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta com a configuração necessária.
4. **Execute Consultas**: Utilize a ferramenta para rodar consultas SQL no seu banco de dados Snowflake.

## Exemplo

O exemplo a seguir demonstra como usar o `SnowflakeSearchTool` para consultar dados de um banco de dados Snowflake:
```

---

## Crie um agente carregando-o de um repositório

**URL:** llms-txt#crie-um-agente-carregando-o-de-um-repositório

---

## External automation

**URL:** llms-txt#external-automation

analysis_automation = InvokeCrewAIAutomationTool(
    crew_api_url="https://analysis-crew.acme.crewai.com",
    crew_bearer_token="YOUR_BEARER_TOKEN",
    crew_name="Analysis Automation",
    crew_description="Runs the production-grade analysis pipeline",
)

---

## Integração Microsoft Teams

**URL:** llms-txt#integração-microsoft-teams

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Microsoft Teams
  - 1. Conecte sua Conta Microsoft
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Microsoft Teams

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/microsoft_teams

Colaboração em equipe e comunicação com integração Microsoft Teams para CrewAI.

Permita que seus agentes acessem dados do Teams, enviem mensagens, criem reuniões e gerenciem canais. Automatize a comunicação da equipe, agende reuniões, recupere mensagens e simplifique seus fluxos de trabalho de colaboração com automação alimentada por IA.

Antes de usar a integração Microsoft Teams, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Microsoft com acesso ao Teams
* Conectado sua conta Microsoft através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Microsoft Teams

### 1. Conecte sua Conta Microsoft

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Microsoft Teams** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso ao Teams
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="microsoft_teams/get_teams">
    **Descrição:** Obter todas as equipes das quais o usuário é membro.

* Nenhum parâmetro necessário.
  </Accordion>

<Accordion title="microsoft_teams/get_channels">
    **Descrição:** Obter canais em uma equipe específica.

* `team_id` (string, obrigatório): O ID da equipe.
  </Accordion>

<Accordion title="microsoft_teams/send_message">
    **Descrição:** Enviar uma mensagem para um canal do Teams.

* `team_id` (string, obrigatório): O ID da equipe.
    * `channel_id` (string, obrigatório): O ID do canal.
    * `message` (string, obrigatório): O conteúdo da mensagem.
    * `content_type` (string, opcional): Tipo de conteúdo (html ou text). Opções: html, text. Padrão: text.
  </Accordion>

<Accordion title="microsoft_teams/get_messages">
    **Descrição:** Obter mensagens de um canal do Teams.

* `team_id` (string, obrigatório): O ID da equipe.
    * `channel_id` (string, obrigatório): O ID do canal.
    * `top` (integer, opcional): Número de mensagens a recuperar (máx 50). Padrão: 20.
  </Accordion>

<Accordion title="microsoft_teams/create_meeting">
    **Descrição:** Criar uma reunião do Teams.

* `subject` (string, obrigatório): Assunto/título da reunião.
    * `startDateTime` (string, obrigatório): Hora de início da reunião (formato ISO 8601 com fuso horário).
    * `endDateTime` (string, obrigatório): Hora de término da reunião (formato ISO 8601 com fuso horário).
  </Accordion>

<Accordion title="microsoft_teams/search_online_meetings_by_join_url">
    **Descrição:** Pesquisar reuniões online por URL de participação na web.

* `join_web_url` (string, obrigatório): A URL de participação na web da reunião a pesquisar.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Microsoft Teams

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="microsoft_teams/get_teams">
    **Descrição:** Obter todas as equipes das quais o usuário é membro.

    **Parâmetros:**

    * Nenhum parâmetro necessário.
  </Accordion>

  <Accordion title="microsoft_teams/get_channels">
    **Descrição:** Obter canais em uma equipe específica.

    **Parâmetros:**

    * `team_id` (string, obrigatório): O ID da equipe.
  </Accordion>

  <Accordion title="microsoft_teams/send_message">
    **Descrição:** Enviar uma mensagem para um canal do Teams.

    **Parâmetros:**

    * `team_id` (string, obrigatório): O ID da equipe.
    * `channel_id` (string, obrigatório): O ID do canal.
    * `message` (string, obrigatório): O conteúdo da mensagem.
    * `content_type` (string, opcional): Tipo de conteúdo (html ou text). Opções: html, text. Padrão: text.
  </Accordion>

  <Accordion title="microsoft_teams/get_messages">
    **Descrição:** Obter mensagens de um canal do Teams.

    **Parâmetros:**

    * `team_id` (string, obrigatório): O ID da equipe.
    * `channel_id` (string, obrigatório): O ID do canal.
    * `top` (integer, opcional): Número de mensagens a recuperar (máx 50). Padrão: 20.
  </Accordion>

  <Accordion title="microsoft_teams/create_meeting">
    **Descrição:** Criar uma reunião do Teams.

    **Parâmetros:**

    * `subject` (string, obrigatório): Assunto/título da reunião.
    * `startDateTime` (string, obrigatório): Hora de início da reunião (formato ISO 8601 com fuso horário).
    * `endDateTime` (string, obrigatório): Hora de término da reunião (formato ISO 8601 com fuso horário).
  </Accordion>

  <Accordion title="microsoft_teams/search_online_meetings_by_join_url">
    **Descrição:** Pesquisar reuniões online por URL de participação na web.

    **Parâmetros:**

    * `join_web_url` (string, obrigatório): A URL de participação na web da reunião a pesquisar.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Microsoft Teams
```

---

## Create external memory instance with local Mem0 Configuration

**URL:** llms-txt#create-external-memory-instance-with-local-mem0-configuration

**Contents:**
  - Memória Externa Avançada com o Cliente Mem0

external_memory = ExternalMemory(
    embedder_config={
        "provider": "mem0",
        "config": {
            "user_id": "john",
            "local_mem0_config": {
                "vector_store": {
                    "provider": "qdrant",
                    "config": {"host": "localhost", "port": 6333}
                },
                "llm": {
                    "provider": "openai",
                    "config": {"api_key": "your-api-key", "model": "gpt-4"}
                },
                "embedder": {
                    "provider": "openai",
                    "config": {"api_key": "your-api-key", "model": "text-embedding-3-small"}
                }
            },
            "infer": True # Optional defaults to True
        },
    }
)

crew = Crew(
    agents=[...],
    tasks=[...],
    external_memory=external_memory,  # Separate from basic memory
    process=Process.sequential,
    verbose=True
)
python  theme={null}
import os
from crewai import Agent, Crew, Process, Task
from crewai.memory.external.external_memory import ExternalMemory

new_categories = [
    {"lifestyle_management_concerns": "Tracks daily routines, habits, hobbies and interests including cooking, time management and work-life balance"},
    {"seeking_structure": "Documents goals around creating routines, schedules, and organized systems in various life areas"},
    {"personal_information": "Basic information about the user including name, preferences, and personality traits"}
]

os.environ["MEM0_API_KEY"] = "your-api-key"

**Examples:**

Example 1 (unknown):
```unknown
### Memória Externa Avançada com o Cliente Mem0

Ao usar o Cliente Mem0, você pode personalizar ainda mais a configuração de memória usando parâmetros como "includes", "excludes", "custom\_categories", "infer" e "run\_id" (apenas para memória de curto prazo).
Você pode encontrar mais detalhes na [documentação do Mem0](https://docs.mem0.ai/).
```

---

## Browserbase Web Loader

**URL:** llms-txt#browserbase-web-loader

Source: https://docs.crewai.com/en/tools/web-scraping/browserbaseloadtool

Browserbase is a developer platform to reliably run, manage, and monitor headless browsers.

---

## You can easily customize this to match your preferred provider

**URL:** llms-txt#you-can-easily-customize-this-to-match-your-preferred-provider

python  theme={null}
from crewai import Crew

**Examples:**

Example 1 (unknown):
```unknown
#### 임베딩 공급자 사용자 지정
```

---

## Inicialize a ferramenta com um caminho de arquivo específico, assim o agente poderá ler apenas o conteúdo do arquivo especificado

**URL:** llms-txt#inicialize-a-ferramenta-com-um-caminho-de-arquivo-específico,-assim-o-agente-poderá-ler-apenas-o-conteúdo-do-arquivo-especificado

**Contents:**
- Argumentos

file_read_tool = FileReadTool(file_path='path/to/your/file.txt')
```

* `file_path`: O caminho para o arquivo que você deseja ler. Aceita caminhos absolutos e relativos. Certifique-se de que o arquivo exista e de que você tenha as permissões necessárias para acessá-lo.

---

## Ferramenta DALL-E

**URL:** llms-txt#ferramenta-dall-e

Source: https://docs.crewai.com/pt-BR/tools/ai-ml/dalletool

A `DallETool` é uma ferramenta poderosa projetada para gerar imagens a partir de descrições textuais.

---

## 변경 로그

**URL:** llms-txt#변경-로그

Source: https://docs.crewai.com/ko/changelog

CrewAI의 제품 업데이트, 개선 사항 및 버그 수정

<Update label="2025년 9월 30일">
  ## v1.0.0a1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/1.0.0a1)

* 에이전트 설정에서 `actions` 속성 권한 처리를 수정했습니다
  * 새로운 모노레포 구조에 맞춰 CI 워크플로와 릴리스 프로세스를 업데이트했습니다
  * Python 지원 버전을 3.13으로 올리고 워크스페이스 메타데이터를 갱신했습니다

* 에이전트에 `apps`와 `actions` 속성을 추가하여 런타임 제어를 강화했습니다
  * `crewai-tools` 저장소를 메인 워크스페이스에 통합하여 모노레포 구조를 도입했습니다
  * 모든 패키지 버전을 1.0.0a1로 올려 알파 마일스톤을 표시했습니다

* 버전 고정과 배포 전략을 포함한 새로운 CI 파이프라인을 구축했습니다
  * 다중 패키지 관리를 지원하도록 코드베이스를 통합했습니다
</Update>

<Update label="2025년 9월 26일">
  ## v0.201.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.201.1)

* Watson 임베딩 프로바이더를 `watsonx`로 변경하고 환경 변수 접두사를 업데이트했습니다
  * `watsonx`와 `voyageai` 프로바이더에 대한 ChromaDB 호환성을 추가했습니다

* 모든 임베딩 프로바이더의 환경 변수 접두사를 표준화했습니다
  * CrewAI 버전을 0.201.1로 올리고 내부 의존성을 갱신했습니다
</Update>

<Update label="2025년 9월 24일">
  ## v0.201.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.201.0)

* `_create_reasoning_plan`의 `ready` 매개변수를 선택 사항으로 변경했습니다
  * 임베더 설정의 중첩된 구성 형식을 바로잡았습니다
  * 토큰 한도 오류를 방지하기 위해 `batch_size` 매개변수를 지원합니다
  * Quickstart 문서의 디렉터리 이름을 수정했습니다
  * 테스트 시간 캐시 및 이벤트 내보내기 문제를 해결했습니다
  * 크루 설정에 대한 폴백 로직을 추가했습니다

* 플랫폼 컨텍스트를 스레드 안전하게 관리하도록 개선했습니다
  * CLI에서 `uv`를 바로 실행할 수 있도록 `crewai uv` 래퍼 명령을 추가했습니다
  * 관찰 워크플로에서 트레이스를 실패 상태로 표시할 수 있도록 지원했습니다
  * 사용자 지정 임베딩 타입과 프로바이더 마이그레이션을 지원했습니다
  * ChromaDB를 v1.1.0으로 업그레이드하고 호환성 및 타입 개선을 적용했습니다
  * Pydantic 호환 임포트 검증을 도입하고 의존성 그룹을 재구성했습니다

* 최근 릴리스(0.193.x)의 변경 로그를 업데이트했습니다
  * LLM Guardrail 이벤트 소스 메타데이터 지원을 문서화했습니다
  * 폴백 동작과 구성 가시성에 대한 가이드를 추가했습니다

* 여러 모듈에서 Ruff 및 MyPy 문제를 해결했습니다
  * 타입 주석을 개선하고 유틸리티를 통합했습니다
  * Pydantic 호환 임포트를 사용하도록 기존 유틸리티를 대체했습니다

* 신규 기여자: @qizwiz (첫 커밋)
</Update>

<Update label="2025년 9월 20일">
  ## v0.193.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.193.2)

* 올바른 버전을 사용하도록 pyproject 템플릿 업데이트
</Update>

<Update label="2025년 9월 20일">
  ## v0.193.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.193.1)

* 일련의 사소한 수정 및 린터 개선
</Update>

<Update label="2025년 9월 19일">
  ## v0.193.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.193.0)

* OpenAI 어댑터 초기화 중 `model` 매개변수 처리 수정
  * CI 워크플로에서 테스트 소요 시간 캐시 문제 해결
  * 에이전트의 반복 도구 사용과 관련된 불안정한 테스트 수정
  * 일관된 모듈 동작을 위해 누락된 이벤트 내보내기를 `__init__.py`에 추가
  * 메타데이터 부하를 줄이기 위해 Mem0에서 메시지 저장 제거
  * 벡터 검색의 하위 호환성을 위해 L2 거리 메트릭 지원 수정

* 스레드 안전한 플랫폼 컨텍스트 관리 도입
  * `pytest-split` 실행 최적화를 위한 테스트 소요 시간 캐싱 추가
  * 더 나은 추적 제어를 위한 일시적(trace) 개선
  * RAG, 지식, 메모리 검색 매개변수를 완전 구성 가능하게 변경
  * ChromaDB가 임베딩 함수에 OpenAI API를 사용할 수 있도록 지원
  * 사용자 수준 인사이트를 위한 심화된 관찰 가능성 도구 추가
  * 인스턴스별 클라이언트를 지원하는 통합 RAG 스토리지 시스템

* CrewAI 네이티브 RAG 구현을 반영하도록 `RagTool` 참조 업데이트
  * 타입 주석과 도크스트링을 포함해 `langgraph` 및 `openai` 에이전트 어댑터 내부 문서 개선
</Update>

<Update label="2025년 9월 11일">
  ## v0.186.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.186.1)

* 버전을 찾지 못해 조용히 되돌리는(reversion) 문제 수정
  * CLI에서 CrewAI 버전을 0.186.1로 올리고 의존성 업데이트
</Update>

<Update label="2025년 9월 10일">
  ## v0.186.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.186.0)

* 자세한 변경 사항은 GitHub 릴리스 노트를 참조하세요
</Update>

<Update label="2025년 9월 4일">
  ## v0.177.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.177.0)

* `rag` 패키지와 현재 구현 간의 동등성 달성
  * 작업 및 에이전트 메타데이터를 통한 LLM 이벤트 처리 개선
  * 변경 가능한 기본 인수를 `None`으로 교체하여 수정
  * 초기화 중 Pydantic 사용 중단 경고 억제
  * `README.md`의 깨진 예제 링크 수정
  * 호환성을 위해 Python 3.12+ 전용 Ruff 규칙 제거
  * CI 워크플로를 `uv`를 사용하도록 마이그레이션하고 개발 도구 업데이트

* 추적 개선 및 정리 추가
  * `events` 모듈을 `crewai.events`로 이동하여 이벤트 로직 중앙 집중화

* 엔터프라이즈 액션 인증 토큰 섹션 문서 업데이트
  * `v0.175.0` 릴리스에 대한 문서 업데이트 게시

* 더 나은 구조를 위해 파서를 모듈화된 함수로 리팩토링
</Update>

<Update label="2025년 8월 28일">
  ## v0.175.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.175.0)

* `crewai update` 중 `tool` 섹션의 마이그레이션 수정
  * OpenAI 핀을 되돌림: 이제 고정된 가져오기 문제로 인해 `openai >=1.13.3`이 필요함
  * 불안정한 테스트 수정 및 테스트 안정성 향상
  * HITL 및 순환 흐름에 대한 `Flow` 리스너의 재개 가능성 개선
  * `PlusAPI` 및 `TraceBatchManager`에서 타임아웃 처리 향상
  * 중복 작업을 줄이기 위해 엔티티 메모리 항목을 배치 처리

* `Flow.start()` 메서드에 추가 매개변수 지원 추가
  * 자세한 CLI 출력에 작업 이름 표시
  * 중앙 집중식 임베딩 유형 추가 및 기본 임베딩 클라이언트 도입
  * ChromaDB 및 Qdrant에 대한 일반 클라이언트 도입
  * 토큰을 지우기 위한 `crewai config reset` 지원 추가
  * `crewai_trigger_payload` 자동 주입 활성화
  * RAG 클라이언트 초기화 간소화 및 RAG 구성 시스템 도입
  * Qdrant RAG 공급자 지원 추가
  * 더 나은 이벤트 데이터로 추적 개선
  * `crewai login`에서 Auth0 및 이메일 입력 제거 지원 추가

* 자동화 트리거에 대한 문서 추가
  * API 참조 OpenAPI 소스 및 리디렉션 수정
  * 문서에 하이브리드 검색 알파 매개변수 추가

* `Task.max_retries`에 대한 사용 중단 알림 추가
  * 로그인 흐름에서 Auth0 의존성 제거
</Update>

<Update label="2025년 8월 19일">
  ## v0.165.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.165.1)

* `configparser`를 위해 구성 값을 문자열로 변환하여 `XMLSearchTool`의 호환성 수정
  * `PytestUnraisableExceptionWarning`과 관련된 불안정한 Pytest 테스트 수정
  * 더 안정적인 CI 실행을 위해 테스트 스위트에서 텔레메트리 모의
  * Chroma 잠금 파일 처리를 `db_storage_path`로 이동
  * `chromadb`의 사용 중단 경고 무시
  * `ResponseTextConfigParam` 가져오기 문제로 인해 OpenAI 버전을 `<1.100.0`으로 고정

* 교환된 에이전트 메시지를 `ExternalMemory` 메타데이터에 포함
  * 자동으로 `crewai_trigger_payload` 주입
  * 내부 플래그 `inject_trigger_input`의 이름을 `allow_crewai_trigger_context`로 변경
  * 추적 개선 및 일시적인 추적 로직 지속
  * 추적 로직 조건 통합
  * `Mem0`에서 `agent_id`와 연결된 메모리 항목 지원 추가

* 도구 저장소 문서에 예제 추가
  * 단기 및 엔티티 메모리 통합을 위한 Mem0 문서 업데이트
  * 한국어 번역 수정 및 문장 구조 개선

* 사용 중단된 AgentOps 통합 제거
</Update>

<Update label="2025년 8월 19일">
  ## v0.165.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.165.0)

* `configparser`를 위해 구성 값을 문자열로 변환하여 `XMLSearchTool`의 호환성 수정
  * `PytestUnraisableExceptionWarning`과 관련된 불안정한 Pytest 테스트 수정
  * 더 안정적인 CI 실행을 위해 테스트 스위트에서 텔레메트리 모의
  * Chroma 잠금 파일 처리를 `db_storage_path`로 이동
  * `chromadb`의 사용 중단 경고 무시
  * `ResponseTextConfigParam` 가져오기 문제로 인해 OpenAI 버전을 `<1.100.0`으로 고정

* 교환된 에이전트 메시지를 `ExternalMemory` 메타데이터에 포함
  * 자동으로 `crewai_trigger_payload` 주입
  * 내부 플래그 `inject_trigger_input`의 이름을 `allow_crewai_trigger_context`로 변경
  * 추적 개선 및 일시적인 추적 로직 지속
  * 추적 로직 조건 통합
  * `Mem0`에서 `agent_id`와 연결된 메모리 항목 지원 추가

* 도구 저장소 문서에 예제 추가
  * 단기 및 엔티티 메모리 통합을 위한 Mem0 문서 업데이트
  * 한국어 번역 수정 및 문장 구조 개선

* 사용 중단된 AgentOps 통합 제거
</Update>

<Update label="2025년 8월 13일">
  ## v0.159.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.159.0)

## Core Improvements & Fixes

* LLM 메시지 포맷팅 성능 개선으로 더 나은 런타임 효율성 제공
  * 엔터프라이즈 구성 auth/parameters에서 잘못된 엔드포인트 사용 수정
  * 부분 흐름 재개 중 안정성을 위해 리스너 재개 가능성 체크 주석 처리

## New Features & Enhancements

* 간소화된 엔터프라이즈 설정을 위한 CLI에 `enterprise configure` 명령 추가
  * 부분 흐름 재개 지원 도입

## Documentation & Guides

* 새로운 도구에 대한 문서 추가
  * 한국어 번역 추가
  * TrueFoundry 통합 세부정보로 문서 업데이트
  * RBAC 문서 추가 및 일반 정리
  * EN, PT-BR, KO 전반에 걸쳐 API 참조 수정 및 예제/요리책 개편
</Update>

<Update label="2025년 8월 6일">
  ## v0.157.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.157.0)

* 긴 입력 도구에 대한 단어 줄 바꿈 활성화
  * `BaseModel` 항목으로 Flow 상태 지속 가능하도록 허용
  * 성능을 위해 `partition()`을 사용하여 문자열 작업 최적화
  * 더 이상 사용되지 않는 사용자 메모리 시스템에 대한 지원 중단
  * LiteLLM 버전을 `1.74.9`로 업데이트
  * CLI에서 모듈 누락 시 더 명확하게 표시하도록 수정
  * Okta를 통한 장치 인증 지원

* 테스트와 함께 `crewai config` CLI 명령 그룹 추가
  * `crew.name`에 대한 기본값 지원 추가
  * 초기 추적 기능 도입
  * LangDB 통합 지원 추가
  * CLI 구성 문서화 지원 추가

* `connect_timeout` 속성으로 MCP 문서 업데이트
  * LangDB 통합 문서 추가
  * CLI 구성 문서 추가
  * 일반 기능 문서 업데이트 및 정리
</Update>

<Update label="2025년 7월 30일">
  ## v0.152.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.152.0)

## Core Improvements & Fixes

* `crewai signup` 참조를 제거하고 `crewai login`으로 대체했습니다.
  * `agent_id`를 사용하여 Mem0에 메모리를 추가하는 지원을 수정했습니다.
  * Mem0 구성의 기본값을 변경했습니다.
  * 누락된 모듈 파일을 명확하게 표시하도록 가져오기 오류를 업데이트했습니다.
  * 이벤트 타임스탬프에 대한 시간대 지원을 추가했습니다.

## New Features & Enhancements

* 사용자 정의 흐름 이름을 지원하도록 `Flow` 클래스를 향상시켰습니다.
  * RAG 구성 요소를 전용 최상위 모듈로 리팩토링했습니다.

## Documentation & Guides

* Google Vertex AI 문서에서 잘못된 모델 이름을 수정했습니다.
</Update>

<Update label="2025년 7월 23일">
  ## v0.150.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.150.0)

* Chroma 클라이언트 초기화 주위에 파일 잠금 사용
  * FTS5 없이 SQLite와 관련된 우회 방법 제거
  * LLM 모델에 대해 자동으로 지원되지 않는 `stop` 매개변수 제거
  * `save` 메서드 수정 및 관련 테스트 케이스 업데이트
  * 마지막 메시지가 어시스턴트인 경우 Ollama 모델의 메시지 처리 수정
  * LLM 호출 오류에 대한 중복 출력 제거
  * `UserMemory`에 대한 사용 중단 알림 추가
  * LiteLLM을 버전 1.74.3으로 업그레이드

* 내부 LLM 클래스를 통한 임시 도구 호출 지원 추가
  * Mem0 Storage를 v1.1에서 v2로 업데이트

* neatlogs 문서 수정
  * Search-Research 스위트에 Tavily Search & Extractor 도구 추가
  * `SerperScrapeWebsiteTool`에 대한 문서 추가 및 Serper 섹션 재구성
  * 일반 문서 업데이트 및 개선

## crewai-tools v0.58.0

* **SerperScrapeWebsiteTool**: URL에서 깨끗한 콘텐츠를 추출하는 도구 추가
  * **Bedrock AgentCore**: Bedrock 에이전트를 위한 브라우저 및 코드 해석기 툴킷 통합
  * **Stagehand 업데이트**: Stagehand 통합 리팩토링 및 업데이트

* **FTS5 지원**: 테스트 워크플로우에서 개선된 텍스트 검색을 위한 SQLite FTS5 활성화
  * **테스트 속도 향상**: 더 빠른 CI 실행을 위해 GitHub Actions 테스트 스위트 병렬화
  * **정리**: FTS5 지원으로 인해 SQLite 우회 방법 제거
    **MongoDBVectorSearchTool**: 직렬화 및 스키마 처리 수정
</Update>

<Update label="2025년 7월 16일">
  ## v0.148.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.148.0)

* 프로덕션 WorkOS 환경 ID 사용
  * 테스트 워크플로우에 SQLite FTS5 지원 추가
  * 에이전트 지식 처리 수정
  * `LLM` 대신 `BaseLLM` 클래스를 사용하여 비교
  * `Task` 클래스에서 누락된 `create_directory` 매개변수 수정

* 에이전트 평가 기능 도입
  * 평가자 실험 및 회귀 테스트 방법 추가
  * 스레드 안전한 `AgentEvaluator` 구현
  * 에이전트 평가를 위한 이벤트 발생 활성화
  * 단일 `Agent` 및 `LiteAgent` 평가 지원
  * `neatlogs`와의 통합 추가
  * LLM 가드레일 이벤트에 대한 크루 컨텍스트 추적 추가

* `guardrail` 속성 및 사용 예제에 대한 문서 추가
  * `neatlogs`에 대한 통합 가이드 추가
  * 에이전트 리포지토리 및 `Agent.kickoff` 사용에 대한 문서 업데이트
</Update>

<Update label="2025년 7월 9일">
  ## v0.141.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.141.0)

* 병렬화를 통해 GitHub Actions 테스트 속도 향상

* LLM 가드레일 이벤트에 대한 크루 컨텍스트 추적 추가

* 에이전트 리포지토리 사용에 대한 문서 추가
  * `Agent.kickoff` 메서드에 대한 문서 추가
</Update>

<Update label="2025년 7월 2일">
  ## v0.140.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.140.0)

* 테스트 프롬프트의 오타 수정
  * 크루 생성 시 후행 슬래시를 제거하여 프로젝트 이름 정규화 수정
  * 환경 변수가 대문자로 작성되도록 보장
  * LiteLLM 의존성 업데이트
  * `RAGStorage`에서 컬렉션 처리 리팩토링
  * PEP 621 동적 버전 관리 구현

* 작업 및 에이전트별로 LLM 호출을 추적하는 기능 추가
  * 메모리 사용량 모니터링을 위한 `MemoryEvents` 도입
  * 메모리 시스템 및 LLM 가드레일 이벤트에 대한 콘솔 로깅 추가
  * 최대 7B 매개변수를 지원하는 모델에 대한 데이터 훈련 지원 개선
  * Scarf 및 Reo.dev 분석 추적 추가
  * CLI workos 로그인

* CLI LLM 문서 업데이트
  * 문서에 Nebius 통합 추가
  * 설치 및 pt-BR 문서의 오타 수정
  * `MemoryEvents`에 대한 문서 추가
  * 문서 리디렉션 구현 및 개발 도구 포함
</Update>

<Update label="2025년 6월 25일">
  ## v0.134.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.134.0)

* 도구 매개변수 구문 수정
  * `Task`의 타입 주석 수정
  * GitHub에서 LLM 데이터를 검색할 때 SSL 오류 수정
  * Pydantic 2.7.x와의 호환성 보장
  * 프로젝트 종속성에서 `mkdocs` 제거
  * Langfuse 코드 예제를 Python SDK v3로 업그레이드
  * `mem0` 저장소에 역할 정리 기능 추가
  * 메모리 재설정 중 Crew 검색 개선
  * 콘솔 프린터 출력 개선

* 정의된 `Tool` 속성에서 도구를 초기화하는 지원 추가
  * `CrewBase` 내에서 MCP 도구를 사용하는 공식 방법 추가
  * `CrewBase`에서 에이전트당 여러 도구를 선택할 수 있도록 MCP 도구 지원 향상
  * Oxylabs 웹 스크래핑 도구 추가

* `quickstart.mdx` 업데이트
  * `LLMGuardrail` 이벤트에 대한 문서 추가
  * 포괄적인 서비스 통합 세부정보로 문서 업데이트
  * MCP 및 Enterprise 도구에 대한 추천 필터 업데이트
  * Maxim 가시성에 대한 문서 업데이트
  * pt-BR 문서 번역 추가
  * 일반 문서 개선
</Update>

<Update label="2025년 6월 12일">
  ## v0.130.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.130.0)

* 도구 결과 출력과 관련된 중복 메시지 제거
  * 시작 시 `usage_metrics`에서 누락된 `manager_agent` 토큰 수정
  * 동적 환경 변수를 존중하도록 텔레메트리 싱글톤 수정
  * Flow 상태 로그가 인간 입력을 숨길 수 있는 문제 수정
  * 흐름 플로팅을 위한 기본 X축 간격 증가

* CLI에서 다중 조직 작업 지원 추가
  * 더 효율적인 워크플로를 위한 비동기 도구 실행 활성화
  * Guardrail 통합과 함께 `LiteAgent` 도입
  * 최신 OpenAI 버전을 지원하도록 `LiteLLM` 업그레이드

* 도구 저장소에 대한 최소 `UV` 버전 문서화
  * 환각 방지 가이드라인에 대한 예제 개선
  * LLM 사용을 위한 계획 문서 업데이트
  * 에이전트 가시성에서 Maxim 지원에 대한 문서 추가
  * 기업 기능에 대한 이미지와 함께 통합 문서 확장
  * 지속성에 대한 가이드 수정
  * Python 버전 지원을 python 3.13.x로 업데이트
</Update>

<Update label="2025년 6월 5일">
  ## v0.126.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.126.0)

* Python 3.13 지원 추가
  * 에이전트 지식 출처 문제 수정
  * 도구 저장소에서 사용 가능한 도구 지속화
  * 에이전트 저장소에서 자체 모듈을 통해 도구 로드 가능
  * LLM에 의해 호출될 때 도구 사용 기록

* MCP 통합에서 스트리밍 가능한 HTTP 전송 지원 추가
  * 커뮤니티 분석 지원 추가
  * Gemini 예제를 포함한 OpenAI 호환 섹션 확장
  * 프롬프트 및 메모리 시스템에 대한 투명성 기능 도입
  * 도구 게시를 위한 소규모 개선

* 더 나은 탐색을 위한 문서의 주요 구조 조정
  * MCP 통합 문서 확장
  * 메모리 문서 및 README 시각 자료 업데이트
  * 비동기 시작 예제에서 누락된 await 키워드 수정
  * Portkey 및 Azure 임베딩 문서 업데이트
  * LLM 가이드에 기업 테스트 이미지 추가
  * README에 대한 일반 업데이트
</Update>

<Update label="2025년 5월 27일">
  ## v0.121.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.121.1)

1. GitHub에서 리포지토리를 클론합니다.
     
  2. 필요한 종속성을 설치합니다.

기여를 원하시면, [기여 가이드](CONTRIBUTING.md)를 참조하세요.

이 프로젝트는 MIT 라이센스 하에 배포됩니다. 자세한 내용은 [LICENSE](LICENSE) 파일을 확인하세요.
</Update>

<Update label="2025년 5월 22일">
  ## v0.121.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.121.0)

* 도구 생성 시 인코딩 오류 수정
  * llama 테스트 실패 수정
  * 일관성을 위한 로깅 구성 업데이트
  * 텔레메트리 초기화 및 이벤트 처리 개선

* Task 클래스에 markdown 속성 추가
  * Agent 클래스에 reasoning 속성 추가
  * 자동 날짜 주입을 위한 Agent의 inject\_date 플래그 추가
  * HallucinationGuardrail 구현 (테스트 커버리지와 함께 no-op)

* StagehandTool에 대한 문서 추가 및 MDX 구조 개선
  * MCP 통합에 대한 문서 추가 및 기업 문서 업데이트
  * 지식 이벤트 문서화 및 reasoning 문서 업데이트
  * stop 매개변수 문서 추가
  * 문서 예제에서 import 참조 수정 (before\_kickoff, after\_kickoff)
  * 명확성을 위한 일반 문서 업데이트 및 구조 조정
</Update>

<Update label="2025년 5월 15일">
  ## v0.120.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.120.1)

* 하이픈이 있는 보간 수정
</Update>

<Update label="2025년 5월 14일">
  ## v0.120.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.120.0)

•	더 엄격한 린팅을 위해 기본적으로 전체 Ruff 규칙 세트를 활성화했습니다.
  •	컨텍스트 관리자를 사용하여 FilteredStream의 경쟁 조건을 해결했습니다.
  •	에이전트 지식 초기화 문제를 수정했습니다.
  •	에이전트 가져오기 로직을 유틸리티 모듈로 리팩토링했습니다.

•	저장소에서 에이전트를 직접 로드하는 기능을 추가했습니다.
  •	Task에 대해 빈 컨텍스트를 설정할 수 있도록 했습니다.
  •	에이전트 저장소 피드백을 향상시키고 Tool 자동 가져오기 동작을 수정했습니다.
  •	지식 소스를 우회하여 지식을 직접 초기화하는 기능을 도입했습니다.

•	현재 보안 관행에 대한 security.md를 업데이트했습니다.
  •	명확성을 위해 Google 설정 섹션을 정리했습니다.
  •	Gemini 키 입력 시 AI Studio에 대한 링크를 추가했습니다.
  •	Arize Phoenix 가시성 가이드를 업데이트했습니다.
  •	흐름 문서를 새로 고쳤습니다.
</Update>

<Update label="2025년 5월 8일">
  ## v0.119.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.119.0)

## Core Improvements & Fixes

* Improved test reliability by enhancing pytest handling for flaky tests
  * Fixed memory reset crash when embedding dimensions mismatch
  * Enabled parent flow identification for Crew and LiteAgent
  * Prevented telemetry-related crashes when unavailable
  * Upgraded LiteLLM version for better compatibility
  * Fixed llama converter tests by removing skip\_external\_api

## New Features & Enhancements

* Introduced knowledge retrieval prompt re-writting in Agent for improved tracking and debugging
  * Made LLM setup and quickstart guides model-agnostic

## Documentation & Guides

* Added advanced configuration docs for the RAG tool
  * Updated Windows troubleshooting guide
  * Refined documentation examples for better clarity
  * Fixed typos across docs and config files
</Update>

<Update label="2025년 4월 30일">
  ## v0.118.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.118.0)

* 누락된 프롬프트 또는 시스템 템플릿 문제를 수정했습니다.
  * 의도하지 않은 덮어쓰기를 방지하기 위해 전역 로깅 구성을 제거했습니다.
  * 명확성을 높이기 위해 TaskGuardrail의 이름을 LLMGuardrail로 변경했습니다.
  * 호환성을 위해 litellm을 버전 1.167.1로 다운그레이드했습니다.
  * 모듈 초기화를 보장하기 위해 누락된 **init**.py 파일을 추가했습니다.

* AI 행동 제어를 단순화하기 위해 코드 없는 Guardrail 생성을 지원합니다.

* 내부 사용을 반영하기 위해 CrewStructuredTool을 공개 문서에서 제거했습니다.
  * 개선된 온보딩 경험을 위해 기업 문서 및 YouTube 임베드를 업데이트했습니다.
</Update>

<Update label="2025년 4월 28일">
  ## v0.117.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.117.1)

* 빌드: crewai-tools 업그레이드
  * liteLLM을 최신 버전으로 업그레이드
  * Mem0 OSS 수정
</Update>

<Update label="2025년 4월 28일">
  ## v0.117.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.117.0)

* `@tool` 데코레이터에서 `result_as_answer` 매개변수 지원 추가.
  * 새로운 언어 모델 지원 도입: GPT-4.1, Gemini-2.0, Gemini-2.5 Pro.
  * 지식 관리 기능 향상.
  * CLI에서 Huggingface 제공자 옵션 추가.
  * Python 3.10+에 대한 호환성 및 CI 지원 개선.

* 잘못된 템플릿 매개변수 및 누락된 입력 문제 수정.
  * 코루틴 조건 검사를 통한 비동기 흐름 처리 개선.
  * 격리된 구성 및 올바른 메모리 객체 복사를 통한 메모리 관리 향상.
  * 올바른 참조로 라이트 에이전트 초기화 수정.
  * Python 타입 힌트 문제 해결 및 불필요한 임포트 제거.
  * 도구 사용 추적 개선을 위한 이벤트 배치 업데이트.
  * 흐름 실패 시 명시적 예외 발생.
  * 다양한 모듈에서 사용되지 않는 코드 및 불필요한 주석 제거.
  * GitHub App 토큰 작업을 v2로 업데이트.

* 기업 배포 지침을 포함한 문서 구조 향상.
  * 문서 생성을 위한 출력 폴더 자동 생성.
  * `WeaviateVectorSearchTool` 문서의 깨진 링크 수정.
  * JSON 검색 도구에 대한 가드레일 문서 사용 및 임포트 경로 수정.
  * `CodeInterpreterTool`에 대한 문서 업데이트.
  * 문서 페이지의 SEO, 맥락 내 탐색 및 오류 처리 개선.
</Update>

<Update label="2025년 4월 10일">
  ## v0.114.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.114.0)

* 에이전트를 원자 단위로 사용. (`Agent(...).kickoff()`)
  * 사용자 정의 LLM 구현 지원.
  * 외부 메모리 및 Opik 가시성 통합.
  * YAML 추출 향상.
  * 다중 모드 에이전트 검증.
  * 에이전트 및 크루를 위한 보안 지문 추가.

* 직렬화, 에이전트 복사 및 Python 호환성 개선.
  * emit()에 와일드카드 지원 추가.
  * 추가 라우터 호출 및 컨텍스트 창 조정 지원 추가.
  * 타입 문제, 검증 및 import 문 수정.
  * 메서드 성능 개선.
  * 에이전트 작업 처리, 이벤트 발생 및 메모리 관리 향상.
  * CLI 문제, 조건부 작업, 복제 동작 및 도구 출력 수정.

* 문서 구조, 테마 및 조직 개선.
  * WSL2, W\&B Weave 및 Arize Phoenix와 함께하는 로컬 NVIDIA NIM에 대한 가이드 추가.
  * 도구 구성 예제, 프롬프트 및 가시성 문서 업데이트.
  * Flows 내에서 단일 에이전트를 사용하는 방법에 대한 가이드.
</Update>

<Update label="2025년 3월 17일">
  ## v0.108.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.108.0)

* PR #2190에서 crew\.py 템플릿의 탭을 공백으로 변환했습니다.
  * PR #2266에서 LLM 스트리밍 응답 처리 및 이벤트 시스템을 개선했습니다.
  * PR #2310에서 model\_name을 포함했습니다.
  * PR #2321에서 풍부한 시각화와 개선된 로깅을 갖춘 이벤트 리스너를 강화했습니다.
  * PR #2332에서 지문을 추가했습니다.

* PR #2308에서 Mistral 문제를 수정했습니다.
  * PR #2370에서 문서의 버그를 수정했습니다.
  * PR #2369에서 지문 속성의 타입 검사 오류를 수정했습니다.

* PR #2259에서 도구 문서를 개선했습니다.
  * PR #2196에서 uv 도구 패키지의 설치 가이드를 업데이트했습니다.
  * PR #2363에서 uv 도구로 crewAI를 업그레이드하는 방법에 대한 지침을 추가했습니다.
  * PR #2254에서 ApifyActorsTool에 대한 문서를 추가했습니다.
</Update>

<Update label="2025년 3월 9일">
  ## v0.105.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.105.0)

* 누락된 템플릿 변수 및 사용자 메모리 구성 문제를 수정했습니다.
  * 비동기 흐름 지원을 개선하고 에이전트 응답 형식을 조정했습니다.
  * 메모리 초기화 기능을 강화하고 CLI 메모리 명령을 수정했습니다.
  * 타입 문제, 도구 호출 속성 및 텔레메트리 분리를 수정했습니다.

* 흐름 상태 내보내기를 추가하고 상태 유틸리티를 개선했습니다.
  * 선택적 크루 임베더를 사용한 에이전트 지식 설정을 강화했습니다.
  * 더 나은 관찰 가능성과 LLM 호출 추적을 위한 이벤트 발행기를 도입했습니다.
  * Python 3.10 및 langchain\_ollama의 ChatOllama에 대한 지원을 추가했습니다.
  * o3-mini 모델에 대한 컨텍스트 윈도우 크기 지원을 통합했습니다.
  * 여러 라우터 호출에 대한 지원을 추가했습니다.

* 문서 레이아웃 및 계층 구조를 개선했습니다.
  * QdrantVectorSearchTool 가이드를 추가하고 이벤트 리스너 사용을 명확히 했습니다.
  * 프롬프트의 오타를 수정하고 Amazon Bedrock 모델 목록을 업데이트했습니다.
</Update>

<Update label="2025년 2월 13일">
  ## v0.102.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.102.0)

* 향상된 LLM 지원: Anthropic 모델에 대한 구조화된 LLM 출력, 매개변수 처리 및 형식 개선.
  * Crew 및 Agent 안정성: 지식 소스를 사용하는 에이전트/크루 복제, 조건부 작업에서의 여러 작업 출력 및 무시된 Crew 작업 콜백과 관련된 문제 수정.
  * 메모리 및 저장소 수정: Bedrock과의 단기 메모리 처리 수정, 올바른 임베더 초기화 보장, 크루 클래스에 메모리 재설정 기능 추가.
  * 교육 및 실행 신뢰성: dict 및 list 입력 유형과 관련된 교육 및 보간 문제 수정.

* 고급 지식 관리: 명명 규칙 개선 및 사용자 정의 임베더 지원을 통한 임베딩 구성 향상.
  * 확장된 로깅 및 관찰 가능성: 로깅을 위한 JSON 형식 지원 추가 및 MLflow 추적 문서 통합.
  * 데이터 처리 개선: multi-tab 파일을 처리하기 위해 excel\_knowledge\_source.py 업데이트.
  * 일반 성능 및 코드베이스 정리: 기업 코드 정렬 간소화 및 린팅 문제 해결.
  * 새로운 도구 QdrantVectorSearchTool 추가.

* AI 및 메모리 문서 업데이트: Bedrock, Google AI 및 장기 메모리 문서 개선.
  * 작업 및 워크플로우 명확성: 작업 속성에 "인간 입력" 행 추가, Langfuse 가이드 및 FileWriterTool 문서.
  * 다양한 오타 및 형식 문제 수정.

* 올해의 Google Docs 통합 및 작업 처리 개선.
</Update>

<Update label="2025년 1월 28일">
  ## v0.100.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.100.0)

* 기능: Composio 문서 추가
  * 기능: SageMaker를 LLM 제공자로 추가
  * 수정: 전체 LLM 연결 문제 해결
  * 수정: 훈련 시 안전한 접근자 사용
  * 수정: crew\_chat.py에 버전 확인 추가
  * 문서: crewai 채팅에 대한 새로운 문서
  * 문서: CLI 및 Composio Tool 문서의 형식 및 명확성 개선
</Update>

<Update label="2025년 1월 20일">
  ## v0.98.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.98.0)

* 기능: Conversation crew v1
  * 기능: 흐름 상태에 고유 ID 추가
  * 기능: FlowPersistence 인터페이스와 함께 @persist 데코레이터 추가
  * 통합: SambaNova 통합 추가
  * 통합: cli에 NVIDIA NIM 제공자 추가
  * 통합: VoyageAI 소개
  * 작업: 템플릿의 날짜를 현재 연도로 업데이트
  * 수정: Mem0 통합에서 API 키 동작 및 엔티티 처리 수정
  * 수정: 핵심 호출 루프 논리 및 관련 테스트 수정
  * 수정: 도구 입력을 문자열이 아닌 실제 객체로 만들기
  * 수정: 도구 생성에 중요한 누락된 부분 추가
  * 수정: Windows 문제를 방지하기 위해 litellm 버전 하락
  * 수정: 시작 전에 입력이 없을 경우
  * 수정: 오타
  * 수정: 중첩된 pydantic 모델 문제
  * 수정: Docling 문제
  * 수정: union 문제
  * 문서 업데이트
</Update>

<Update label="2025년 1월 4일">
  ## v0.95.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.95.0)

* 기능: Crew에 다중 모드 기능 추가
  * 기능: 프로그래밍 가능한 가드레일
  * 기능: HITL 여러 라운드
  * 기능: Gemini 2.0 지원
  * 기능: CrewAI 흐름 개선
  * 기능: 워크플로우 권한 추가
  * 기능: litellm과 함께 langfuse 지원 추가
  * 기능: CrewAI와 Portkey 통합
  * 기능: interpolate\_only 메서드 추가 및 오류 처리 개선
  * 기능: Docling 지원
  * 기능: Weviate 지원
  * 수정: output\_file이 시스템 경로를 존중하지 않음
  * 수정: 단기 메모리 초기화 시 디스크 I/O 오류 수정
  * 수정: CrewJSONEncoder가 이제 enums를 허용함
  * 수정: Python 최대 버전
  * 수정: Task의 output\_file에 대한 보간 처리
  * 수정: 동료 역할 이름의 대소문자/공백을 제대로 처리
  * 수정: tiktoken을 명시적 종속성으로 추가하고 Rust 요구 사항 문서화
  * 수정: 계획 과정에 에이전트 지식 포함
  * 수정: KnowledgeStorage의 저장소 초기화를 None으로 변경
  * 수정: 선택적 저장소 확인 수정
  * 수정: 흐름에 이벤트 발신기 포함
  * 수정: Docstring, 오류 처리 및 타입 힌트 개선
  * 수정: litellm pydantic 문제로 인한 userWarnings 억제
</Update>

<Update label="2024년 12월 5일">
  ## v0.86.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.86.0)

* 모든 파이프라인 및 파이프라인 라우터에 대한 참조 제거
  * 문서: Custom LLM에 Nvidia NIM을 공급자로 추가
  * 지식 데모 추가 + 지식 문서 개선
  * Brandon/cre 509 HITL 여러 차례 후속 조치
  * 데코레이터가 있는 YAML 크루에 대한 새로운 문서. 템플릿 크루 단순화
</Update>

<Update label="2024년 12월 4일">
  ## v0.85.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.85.0)

* 에이전트 레벨에 지식 추가
  * 기능/언체인 제거
  * 타입이 지정된 작업 출력 개선
  * `crewai login`에서 도구 저장소에 로그인
  * 결과가 답변으로 LLM 루프를 제대로 종료하지 않는 문제 수정
  * 수정: ollama 제공자와 함께 실행할 때 누락된 키 이름
  * 발견된 철자 문제 수정
  * mypy 실행을 위한 README 업데이트
  * mint.json에 지식 추가
  * GitHub 액션 업데이트
  * 문서 업데이트: 에이전트 생성에 대한 두 가지 접근 방식을 포함하도록 에이전트 문서 업데이트
  * 문서 개선: LLM 구성 및 사용
</Update>

<Update label="2024년 11월 25일">
  ## v0.83.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.83.0)

* 새로운 `before_kickoff` 및 `after_kickoff` 크루 콜백
  * 지식으로 에이전트를 사전 주입하는 지원
  * Mem0를 사용하여 사용자 선호도 및 기억을 검색하는 지원 추가
  * 비동기 실행 수정
  * chroma 업그레이드 및 임베더 함수 생성기 조정
  * CLI Watson 지원 모델 및 문서 업데이트
  * Bandit의 레벨 감소
  * 모든 테스트 수정
  * 문서 업데이트
</Update>

<Update label="2024년 11월 14일">
  ## v0.80.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.80.0)

* 토큰 콜백 대체 버그 수정
  * 스텝 콜백 문제 수정
  * 사용 메트릭에 캐시된 프롬프트 토큰 정보 추가
  * crew\_train\_success 테스트 수정
</Update>

<Update label="2024년 11월 11일">
  ## v0.79.4

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.79.4)

# llms 지원 관련 작은 버그 수정 시리즈

* llms 지원에 대한 여러 작은 버그 수정이 포함되었습니다.
  * 성능 향상 및 안정성 개선이 이루어졌습니다.
  * 사용자 피드백을 반영하여 몇 가지 문제를 해결했습니다.

자세한 내용은 [GitHub](https://github.com)에서 확인하세요.
</Update>

<Update label="2024년 11월 10일">
  ## v0.79.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.79.0)

* 흐름에 입력 추가
  * 더 많은 데이터 유형을 지원하도록 로그 저장소 강화
  * IBM 메모리 지원 추가
  * CLI에서 Watson을 옵션으로 추가
  * security.md 파일 추가
  * .netrc를 uv 환경 변수로 교체
  * BaseTool을 메인 패키지로 이동하고 도구 설명 생성을 중앙 집중화
  * LLM이 응답을 반환하지 않으면 오류 발생
  * 흐름을 수정하여 사이클을 지원하고 테스트에 추가
  * 크루 이름 지정 방법 업데이트 및 누락된 구성 수정
  * 문서 업데이트
</Update>

<Update label="2024년 10월 30일">
  ## v0.76.9

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.76.9)

* flow에 대한 플롯 명령을 crewai flow plot로 업데이트
  * 3.10을 지원할 수 있도록 tomli 추가
  * `uv sync`에 설치 명령 옵션 전달
  * 도구 텍스트 설명 및 인수 개선
  * 도구 및 흐름 문서 개선
  * flows cli를 업데이트하여 crewai flow add-crew로 흐름에 추가 크루를 쉽게 추가할 수 있도록 함
  * 여러 개의 start 및 listen(and\_(..., ..., ...))을 사용할 때 flows 버그 수정
</Update>

<Update label="2024년 10월 23일">
  ## v0.76.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.76.2)

# crewai create 명령어 업데이트

`crewai create` 명령어는 새로운 CrewAI 프로젝트를 생성하는 데 사용됩니다. 이 문서에서는 이 명령어의 사용법과 업데이트된 기능에 대해 설명합니다.

다음 명령어를 사용하여 새로운 프로젝트를 생성할 수 있습니다:

* `--template <template-name>`: 특정 템플릿을 사용하여 프로젝트를 생성합니다.
  * `--description <description>`: 프로젝트에 대한 설명을 추가합니다.
  * `--private`: 프로젝트를 비공개로 설정합니다.

다음은 `crewai create` 명령어의 사용 예입니다:

* **템플릿 지원**: 이제 다양한 템플릿을 선택하여 프로젝트를 시작할 수 있습니다.
  * **비공개 프로젝트**: 비공식적인 작업을 위해 프로젝트를 비공개로 설정할 수 있는 옵션이 추가되었습니다.

자세한 내용은 [CrewAI 문서](https://crewai.com/docs)에서 확인할 수 있습니다.
</Update>

<Update label="2024년 10월 23일">
  ## v0.76.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.76.0)

* fix/fixed 누락된 API 프롬프트 + CLI 문서 업데이트
  * chore(readme): 기여에서 '테스트 실행' 단계 수정
  * 안전하지 않은 코드 실행 지원. 도커 설치 및 실행 검사 추가
  * 임베딩 함수에 대한 메모리 가져오기 수정
</Update>

<Update label="2024년 10월 23일">
  ## v0.75.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.75.1)

# new `--provider` option on crewai crewat

The `--provider` option has been added to the `crewai crewat` command. This option allows users to specify the provider they want to use when executing the command.

To use the `--provider` option, simply include it in your command as follows:

Here’s an example of how to use the new option:

## Available Providers

The following providers are currently supported:

* aws
  * azure
  * gcp

* Make sure to replace `<provider_name>` with the actual name of the provider you wish to use.
  * This option is optional; if not specified, the default provider will be used.

For more information, refer to the [CrewAI documentation](https://crewai.com/docs).
</Update>

<Update label="2024년 10월 23일">
  ## v0.75.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.75.0)

* 테스트 후 훈련 수정
  * 흐름 단순화
  * `crewai tool install <tool>` 조정
  * 원래의 임베딩 구성 작동 확인
  * 버그 수정
  * 문서 업데이트 - LLM 문서에 Cerebras LLM 예제 구성 추가 포함
  * 불필요한 테스트 제거
</Update>

<Update label="2024년 10월 18일">
  ## v0.74.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.74.2)

* feat: uv 마이그레이션에 poetry.lock 추가
  * fix: 도구 호출 문제 수정
</Update>

<Update label="2024년 10월 18일">
  ## v0.74.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.74.0)

* UV 마이그레이션
  * UV에 맞게 Adapt Tools CLI 조정
  * Poetry에서 UV로 경고 추가
  * 모델 선택 및 API 키 제출을 허용하는 CLI
  * 새로운 메모리 기반
  * 린팅 및 경고 수정
  * 문서 업데이트
  * 버그 수정
</Update>

<Update label="2024년 10월 11일">
  ## v0.70.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.70.1)

* 새로운 Flow 기능
  * Flow 시각화 도구
  * `crewai create flow` 명령어 생성
  * `crewai tool create <tool>` 명령어 생성
  * 도구 게시를 위한 Git 검증 추가
  * 수정: JSON 인코딩 날짜 객체
  * 새로운 문서
  * README 업데이트
  * 버그 수정
</Update>

<Update label="2024년 9월 27일">
  ## v0.65.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.65.2)

* 실험적인 Flows 기능 추가
  * 작업 순서 버그 수정
  * 템플릿 업데이트
</Update>

<Update label="2024년 9월 27일">
  ## v0.64.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.64.0)

* 작업 순서 정리
  * 요약 논리 수정
  * 불용어 논리 수정
  * 기본 최대 반복 횟수를 20으로 증가
  * 입력 보간 후 crew의 키 수정
  * 훈련 기능 수정
  * 초기 도구 API 추가
  * 오타 수정
  * 문서 업데이트

수정 사항: #1359 #1355 #1353 #1356 및 기타
</Update>

<Update label="2024년 9월 25일">
  ## v0.63.6

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.6)

* 프로젝트 템플릿 업데이트
</Update>

<Update label="2024년 9월 25일">
  ## v0.63.5

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.5)

* o1 패밀리에 대한 지원 복원 및 불용어를 지원하지 않는 모든 모델
  * 의존성 업데이트
  * 로그 업데이트
  * 문서 업데이트
</Update>

<Update label="2024년 9월 24일">
  ## v0.63.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.2)

* OPENAI\_BASE\_URL를 대체로 추가
  * 적절한 LLM 가져오기 추가
  * 문서 업데이트
</Update>

<Update label="2024년 9월 24일">
  ## v0.63.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.1)

* 향후 CrewAI 배포를 지원하기 위한 작은 버그 수정
</Update>

<Update label="2024년 9월 24일">
  ## v0.63.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.0)

* LLM과 상호작용하기 위한 새로운 LLM 클래스 추가 (LiteLLM 활용)
  * 사용자 정의 메모리 인터페이스 지원 추가
  * 기본 모델로 GPT-4o-mini 도입
  * 문서 업데이트
  * 의존성 업데이트
  * 버그 수정
    * `kickoff_for_each_async`에서 중복 작업 생성 제거
</Update>

<Update label="2024년 9월 18일">
  ## v0.61.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.61.0)

* 의존성 업데이트
  * 다른 색상으로 최대 rpm 메시지 출력
  * 테스트를 위한 모든 카세트 업데이트
  * 특정 모델(예: bedrock 모델)을 더 잘 지원하기 위해 항상 사용자 메시지로 종료
  * 전반적인 작은 버그 수정
</Update>

<Update label="2024년 9월 16일">
  ## v0.60.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.60.0)

* LangChain 제거 및 Executor 재구성
  * 모든 테스트를 다시 녹색으로 변경
  * 에이전트에서 시스템 프롬프트 사용 안 함(use\_system\_prompt) 기능 추가
  * 에이전트에서 불용어 사용 안 함(use\_stop\_words) 기능 추가 (o1 모델 지원)
  * 슬라이딩 컨텍스트 윈도우가 respect\_context\_window로 이름이 변경되었으며 기본적으로 활성화됨
  * 위임이 기본적으로 비활성화됨
  * 내부 프롬프트도 약간 변경됨
  * 전반적인 신뢰성과 결과 품질 향상
  * 새로운 지원:
    * 분당 최대 요청 수
    * 최종 답변을 제공하기 전 최대 반복 횟수
    * 시스템 프롬프트를 적절히 활용
    * 토큰 계산 흐름
    * 크루 및 에이전트 실행에 대한 새로운 로깅
</Update>

<Update label="2024년 9월 13일">
  ## v0.55.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.55.2)

* 자동 완성 기능 추가
  * TaskOutput에 name 및 expected\_output 추가
  * 새로운 `crewai install` CLI
  * 새로운 `crewai deploy` CLI
  * 파이프라인 기능 정리
  * 문서 업데이트
  * bandit CI 파이프라인과 같은 개발 경험 개선
  * 버그 수정:
    * `planning_llm` 사용 가능
    * YAML 기반 프로젝트 수정
    * Azure 지원 수정
    * Python 3.10 지원 추가
    * Pydantic v1에서 벗어나기
</Update>

<Update label="2024년 8월 11일">
  ## v0.51.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.51.0)

* crewAI 테스트 / 평가 - [https://docs.crewai.com/core-concepts/Testing/](https://docs.crewai.com/core-concepts/Testing/)
  * 새로운 슬라이딩 컨텍스트 윈도우 추가
  * YAML에서 모든 속성 허용 - [https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#customizing-your-project](https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#customizing-your-project)
  * 초기 파이프라인 구조 추가 - [https://docs.crewai.com/core-concepts/Pipeline/](https://docs.crewai.com/core-concepts/Pipeline/)
  * 계획 단계에 LLM 설정 가능 - [https://docs.crewai.com/core-concepts/Planning/](https://docs.crewai.com/core-concepts/Planning/)
  * 새로운 crew run 명령 - [https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#running-your-project](https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#running-your-project)
  * 파일 저장 시 이제 dict를 JSON으로 덤프 - [https://docs.crewai.com/core-concepts/Tasks/#creating-directories-when-saving-files](https://docs.crewai.com/core-concepts/Tasks/#creating-directories-when-saving-files)
  * 도구 출력에 대한 자세한 설정 사용
  * 새로운 GitHub 템플릿 추가
  * 새로운 Vision 도구 - [https://docs.crewai.com/tools/VisionTool/](https://docs.crewai.com/tools/VisionTool/)
  * 새로운 DALL-E 도구 - [https://docs.crewai.com/tools/DALL-ETool/](https://docs.crewai.com/tools/DALL-ETool/)
  * 새로운 MySQL 도구 - [https://docs.crewai.com/tools/MySQLTool/](https://docs.crewai.com/tools/MySQLTool/)
  * 새로운 NL2SQL 도구 - [https://docs.crewai.com/tools/NL2SQLTool.md](https://docs.crewai.com/tools/NL2SQLTool.md)
  * 버그 수정:
    * 계획 기능 출력의 버그
    * 계층적 프로세스를 위한 비동기 작업
    * 비 OAI 모델에 대한 더 나은 pydantic 출력
    * JSON 잘림 문제
    * 로깅 유형 수정
    * Env Key가 설정된 경우에만 AgentOps 가져오기
    * 유효한 디렉토리 이름을 보장하기 위해 에이전트 역할 정리 (Windows)
    * OpenAI의 도구 이름에 공백이 포함되지 않아야 함
    * 여러 가지 사소한 문제
</Update>

<Update label="2024년 7월 20일">
  ## v0.41.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.41.1)

* 계획 기능의 버그 수정
</Update>

<Update label="2024년 7월 19일">
  ## v0.41.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.41.0)

* **\[Breaking Change]** 타입 안전 출력
    * 모든 크루와 작업이 이제 적절한 객체 TaskOuput 및 CrewOutput을 반환합니다.
  * **\[Feature]** 크루를 위한 새로운 계획 기능 (행동 전에 계획하기)
    * Crew 인스턴스에 planning=True를 추가하여 사용합니다.
  * **\[Feature]** 재생 기능 도입
    * 마지막 실행에서 작업을 나열하고 특정 작업에서 재생할 수 있는 새로운 CLI입니다.
  * **\[Feature]** 메모리 초기화 기능
    * 크루를 다시 실행하기 전에 크루 메모리를 정리할 수 있습니다.
  * **\[Feature]** LLM 호출을 위한 재시도 기능 추가
    * LLM 호출을 재시도할 수 있으며 크루 실행을 중단하지 않습니다.
  * **\[Feature]** 변환기를 사용자 정의할 수 있는 기능 추가
  * **\[Tool]** 타입 힌팅 및 새로운 속성으로 도구 강화
  * **\[Tool]** MultiON 도구 추가
  * **\[Tool]** filecrawl 도구 수정
  * **\[Tool]** 스크래핑 도구의 버그 수정
  * **\[Tools]** crewAI-tools 의존성을 버전으로 업데이트
  * **\[Bugs]** 일반 버그 수정 및 개선
  * **\[Bugs]** 원격 측정 수정
  * **\[Bugs]** 맞춤법 검사 수정
  * **\[Docs]** 문서 업데이트
</Update>

<Update label="2024년 7월 6일">
  ## v0.36.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.36.0)

* 버그 수정
  * 문서 업데이트
  * 네이티브 프롬프트 업데이트
  * 프롬프트의 TYPO 수정
  * AgentOps 네이티브 지원 추가
  * Firecrawl Tools 추가
  * 도구 결과를 에이전트 결과로 반환하는 새로운 기능 추가
  * 코딩 인터프리터 도구 개선
  * 사용자 정의 코르베터 클래스 생성 옵션 추가 (문서 대기 중)
</Update>

<Update label="2024년 7월 4일">
  ## v0.35.8

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.8)

* embechain 의존성 문제 수정
</Update>

<Update label="2024년 7월 2일">
  ## v0.35.7

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.7)

* 새로운 @composiohq 통합이 출시되었습니다
  * 문서 업데이트
  * 커스텀 GPT 업데이트
  * 관리자 verbosity 수준 조정
  * 버그 수정
</Update>

<Update label="2024년 7월 1일">
  ## v0.35.5

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.5)

* embedchain 의존성 수정
</Update>

<Update label="2024년 7월 1일">
  ## v0.35.4

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.4)

* crewai create CLI를 새 버전을 사용하도록 업데이트하기
</Update>

<Update label="2024년 7월 1일">
  ## v0.35.3

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.3)

* 코드 실행 버그 수정
  * 전체 문서 업데이트
  * crewai-tools 버전 업그레이드
  * 여러 종속성 버전 업그레이드
  * 전반적인 버그 수정
</Update>

<Update label="2024년 6월 29일">
  ## v0.35.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.0)

* 이제 귀하의 에이전트가 코드를 실행할 수 있습니다.
  * 모든 3rd-party 에이전트, LlamaIndex, LangChain 및 Autogen 에이전트가 이제 귀하의 크루의 일원이 될 수 있습니다!
  * 실행하기 전에 귀하의 크루를 훈련시키고 일관된 결과를 얻으세요! 새로운 CLI `crewai train -n X`
  * 버그 수정 및 문서 업데이트 (곧 새로운 문서 업데이트가 추가될 예정입니다)
</Update>

<Update label="2024년 6월 22일">
  ## v0.32.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.32.2)

* `crewai create` CLI를 새 버전을 사용하도록 업데이트
  * 위임 에이전트 매칭 수정
</Update>

<Update label="2024년 6월 21일">
  ## v0.32.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.32.0)

* 새로운 `kickoff_for_each`, `kickoff_async` 및 `kickoff_for_each_async` 메서드로 kickoff 프로세스에 대한 더 나은 제어 제공
  * 모든 LlamaIndex 허브 통합에 대한 지원 추가
  * 전체 출력 또는 크루에 `usage_metrics` 추가
  * 새로운 YAML 형식에서 여러 크루에 대한 지원 추가
  * 의존성 업데이트
  * 버그 및 오타 수정
  * 문서 업데이트
  * 문서에서 검색 기능 추가
  * gpt-4o를 기본 모델로 설정
  * LangTrace, Browserbase 및 Exa Search에 대한 새로운 문서 추가
  * 로깅에 타임스탬프 추가
</Update>

<Update label="2024년 5월 23일">
  ## v0.30.11

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.30.11)

* 프로젝트 생성 템플릿 업데이트
</Update>

<Update label="2024년 5월 14일">
  ## v0.30.8

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.30.8)

* 의존성 업데이트
  * crewAI 프로젝트 구조에 대한 작은 버그 수정
  * 현재 사용자 정의 YAML 파서 제거
</Update>

<Update label="2024년 5월 14일">
  ## v0.30.5

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.30.5)

* 더 작은 모델을 위한 에이전트 위임의 다재다능성 향상
</Update>

<Update label="2024년 5월 13일">
  ## v0.30.4

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.30.4)

**문서 업데이트가 곧 진행될 예정입니다** 불편을 드려 죄송하며, 기다려 주셔서 감사합니다. 새로운 문서가 곧 출시됩니다!

➿  작업 콜백 수정
  🧙  크루가 자동으로 생성하는 대신 특정 에이전트를 관리자으로 설정할 수 있는 기능
  📄  시스템, 프롬프트 및 응답 템플릿을 설정할 수 있는 기능, 오픈소스 모델과 더 신뢰성 있게 작동하도록 (더 작은 모델과 더 잘 작동)
  👨‍💻  json 및 pydantic 출력 개선 (더 작은 모델과 더 잘 작동)
  🔎 도구 이름 인식 개선 (더 작은 모델과 더 잘 작동)
  🧰 도구 사용 개선 (더 작은 모델과 더 잘 작동)
  📃 사용자 정의 프롬프트를 가져오는 초기 지원
  2️⃣  중복 토큰 계산기 메트릭 수정
  🪚 새로운 도구 추가, Browserbase 및 Exa Search
  📁 파일로 저장할 때 디렉토리 생성 기능
  🔁 종속성 업데이트 - 도구를 다시 확인하세요
  📄 전반적인 작은 문서 개선
  🐛 작은 버그 수정 (오타 등)
  👬 동료 / 동료 문제 수정
  👀 작은 Readme 업데이트
</Update>

<Update label="2024년 4월 11일">
  ## v0.28.8

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.28.8)

* crewai CLI에서 사용되는 버전 업데이트
</Update>

<Update label="2024년 4월 11일">
  ## v0.28.7

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.28.7)

* 버그 수정
  * 버그 수정이 포함된 crewAI 도구 버전 업데이트
</Update>

<Update label="2024년 4월 8일">
  ## v0.28.5

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.5)

* 주요 장기 기억 보간 문제
  * 수정 사항으로 도구 패키지 종속성 업데이트
  * 불필요한 인증서 제거
</Update>

<Update label="2024년 4월 7일">
  ## v0.28.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.2)

* 주요 장기 기억 수정
</Update>

<Update label="2024년 4월 6일">
  ## v0.28.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.1)

* crewai-tools를 0.1.15로 업데이트하기
</Update>

<Update label="2024년 4월 5일">
  ## v0.28.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.0)

* LLM 콜백을 재정의하지 않음
  * `max_execution_time` 지원 추가
  * 특정 메모리 문서 추가
  * 도구 사용 로깅 색상을 노란색에서 보라색으로 변경
  * 문서 업데이트
</Update>

<Update label="2024년 4월 4일">
  ## v0.27.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.27.0)

* 🧠 **메모리 (공유 크루 메모리)** - 이를 활성화하려면 크루에 `memory=True`를 추가하세요. 투명하게 작동하며 결과를 더 좋고 신뢰할 수 있게 만듭니다. 현재 기본적으로 비활성화되어 있습니다.
  * 🤚🏼 **네이티브 인간 입력 지원:** [docs](https://docs.crewai.com/how-to/Human-Input-on-Execution/)
  * 🌐 **범용 RAG 도구 지원:** OpenAI를 넘어서는 모든 모델. [예시](https://docs.crewai.com/tools/DirectorySearchTool/#custom-model-and-embeddings)
  * 🔍 **향상된 캐시 제어:** 기발한 cache\_function 속성을 만나보세요: [docs](https://docs.crewai.com/core-concepts/Tools/#custom-caching-mechanism)
  * 🔁 **업데이트된 crewai-tools 의존성:** 항상 최신 상태를 유지합니다.
  * ⛓️ **크로스 에이전트 위임:** 에이전트 간의 원활한 협력.
  * 💠 **내부 프롬프트 개선:** 더 세련된 대화 흐름.
  * 📝 **더 나은 파싱으로 도구 사용 개선**
  * 🔒 **보안 개선 및 의존성 업데이트**
  * 📄 **문서 개선됨**
  * 🐛 **버그 수정**
</Update>

<Update label="2024년 3월 12일">
  ## v0.22.5

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.5)

* 새로운 템플릿에서의 기타 사소한 가져오기 문제
</Update>

<Update label="2024년 3월 12일">
  ## v0.22.4

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.4)

템플릿 문제를 수정하는 방법에 대한 지침입니다.

1. 템플릿이 올바르게 로드되지 않는 경우
  2. 템플릿의 스타일이 일관되지 않는 경우
  3. 템플릿의 데이터가 올바르게 표시되지 않는 경우

* 템플릿 파일 경로를 확인하십시오.
  * 필요한 모든 종속성이 설치되었는지 확인하십시오.

* CSS 파일을 검토하여 스타일 규칙이 일관되게 적용되었는지 확인하십시오.
  * 브라우저의 개발자 도구를 사용하여 스타일 충돌을 확인하십시오.

* 데이터 소스가 올바르게 연결되었는지 확인하십시오.
  * 데이터 형식이 템플릿에서 예상하는 형식과 일치하는지 확인하십시오.

* [GitHub Issues](https://github.com)에서 유사한 문제를 검색하십시오.
  * 공식 문서에서 템플릿 관련 정보를 확인하십시오.

문제가 지속되면 지원 팀에 문의하십시오.
</Update>

<Update label="2024년 3월 11일">
  ## v0.22.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.2)

* 새로운 CLI 템플릿의 버그 수정
  * 새로운 CLI 템플릿에서 작업 순서 보장
</Update>

<Update label="2024년 3월 11일">
  ## v0.22.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.0)

* 초기 CLI `crewai create` 명령 추가
  * 에이전트와 작업을 사전(dictionary)으로 정의할 수 있는 기능 추가
  * 더 명확한 에이전트 로깅 추가
  * 최대 재귀 깊이 초과 버그 수정
  * 문서 수정
  * README 업데이트
</Update>

<Update label="2024년 3월 4일">
  ## v0.19.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.19.0)

* 도구 사용 효율성 +1023.21%
  * 평균 사용 도구 +276%
  * 도구 오류 67% 감소, 그 어느 때보다 신뢰성 향상.
  * 위임 기능 강화
  * `function_calling_llm`을 Agent 또는 Crew로 설정하여 기능 호출로 되돌아갈 수 있는 능력
  * `kickoff` 후 `crew.usage_metrics`로 크루 실행 메트릭을 가져올 수 있는 능력
  * 이제 `crew.kickoff(inputs: {'key': 'value})`로 kickoff 시 입력을 전달할 수 있는 기능 추가
  * 문서 업데이트
</Update>

<Update label="2024년 2월 28일">
  ## v0.16.3

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.16.3)

* 전체 버그 수정
  * 코드가 이전 버전과 호환되는지 확인
</Update>

<Update label="2024년 2월 28일">
  ## v0.16.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.16.0)

* 남아있는 `crewai_tools` 의존성 제거
  * 입력 보간에 대한 초기 지원 추가 (문서 누락)
  * 도구 사용, 도구 오류, 형식 오류, 토큰 사용을 추적하는 기능 추가
  * README 업데이트
</Update>

<Update label="2024년 2월 26일">
  ## v0.14.4

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.4)

* 타임아웃 업데이트
  * 문서 업데이트
  * crewai\_tools를 필수 항목에서 제거
  * 토큰 수 감소를 위해 기본적으로 에이전트를 메모리 없는 상태로 설정 (이전에 이를 의존하던 사용자에게는 파괴적인 변경 사항)
</Update>

<Update label="2024년 2월 24일">
  ## v0.14.3

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.3)

* 고장난 문서 링크 수정
  * 도구 없이 에이전트 지원 추가
  * 빈 작업 출력 방지
</Update>

<Update label="2024년 2월 22일">
  ## v0.14.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.0)

# v0.14.0rc의 모든 개선 사항

* 오픈소스 모델에서 json 및 pydantic 내보내기 지원
</Update>

<Update label="2024년 2월 20일">
  ## v0.14.0rc

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.0rc0)

* crewai-tools에 대한 지원 추가
  * 작업 출력을 Pydantic 객체 또는 JSON 형식으로 포맷하는 지원 추가
  * 작업 출력을 파일에 저장하는 지원 추가
  * 에이전트 간 위임의 신뢰성 향상
  * 도구 사용 논리를 개선하여 함수 호출을 적절히 사용하도록 변경
  * 내부 프롬프트 업데이트
  * 인수가 없는 도구 지원
  * 버그 수정
</Update>

<Update label="2024년 2월 16일">
  ## v0.11.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.11.2)

* 도구가 실패할 경우 사용자가 상황을 이해할 수 있도록 추가적인 오류 로깅 추가
</Update>

<Update label="2024년 2월 16일">
  ## v0.11.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.11.1)

* 도구 사용 논리에서 버그를 수정하여 사용 중 오류가 발생하더라도 결과를 미리 캐싱하는 문제를 해결하였으며, 이로 인해 도구를 다시 사용할 수 없었습니다.
  * 또한 오류 메시지를 빨간색으로 출력하여 사용자가 도구의 문제를 이해할 수 있도록 합니다.
</Update>

<Update label="2024년 2월 13일">
  ## v0.11.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.11.0)

* 전체 크루와 개별 에이전트 모두에서 `function_calling_llm` 설정 가능
  * 비용 절감을 위한 초기 시도
  * 도구에 대한 함수 호출 개선
  * 문서 업데이트
</Update>

<Update label="2024년 2월 10일">
  ## v0.10.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.10.0)

* crew kickoff에서 모든 작업 출력과 함께 `full_output`을 가져오는 기능
  * 모든 중간 단계를 얻을 수 있도록 Agents와 Crews 모두에 대해 `step_callback` 함수를 설정하는 기능
  * 특정 도구 사용 횟수 이후 예상 형식의 Agent 기억
  * 이제 json을 사용하는 새로운 도구 사용 내부, 여러 인수를 가진 도구 잠금 해제
  * 전체 위임 논리 리팩토링, 이제 훨씬 더 신뢰할 수 있음
  * `max_inter` 버그 수정, 이제 llm이 그에 도달하면 제대로 응답하도록 강제
  * 여러 에이전트가 동일한 캐시를 사용할 수 있도록 캐싱 구조 재구성
  * 작업 반복 사용 방지 논리 리팩토링
  * 이제 불필요한 `CrewAgentOutputParser` 제거
  * crewAI 팀과 완전한 크루 관련 데이터를 공유하기 위한 선택적 기능
  * 전체 문서 업데이트
</Update>

<Update label="2024년 2월 8일">
  ## v0.5.5

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.5)

* 전체 문서 및 README 개선
  * 불필요하게 설정된 RPM 컨트롤러 수정
  * 라이브러리 개선을 위한 초기 단계 익명 텔레메트리 추가
</Update>

<Update label="2024년 2월 7일">
  ## v0.5.3

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.3)

* 계층적 관리자에 대한 빠른 수정
</Update>

<Update label="2024년 2월 6일">
  ## v0.5.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.2)

* 계층적 프로세스를 위한 `manager_llm` 추가
  * `max_inter` 및 `max_rpm` 로직 개선
  * README 및 문서 업데이트
</Update>

<Update label="2024년 2월 4일">
  ## v0.5.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.0)

이 새로운 버전은 라이브러리에 많은 새로운 기능과 개선 사항을 가져옵니다.

* Task Callbacks 추가.
  * 계층적 프로세스 지원 추가.
  * 다른 작업에서 특정 작업을 참조할 수 있는 기능 추가.
  * 병렬 작업 실행 기능 추가.

* 최대 반복 횟수 및 분당 최대 요청 수 개편.
  * 개발자 경험 개선, docstrings 등.
  * 작은 개선 사항 및 오타 수정.
  * 정적 타입 오류 수정.
  * README 및 문서 업데이트.
</Update>

<Update label="2024년 1월 14일">
  ## v0.1.32

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.32)

* LangChain 0.1.0으로 이동
  * 프롬프트 개선
  * 에이전트의 최대 반복 횟수를 제한하는 기능 추가
  * 에이전트와 크루 모두에 대한 분당 요청 제한 기능 추가
  * 번역에 대한 초기 지원 추가
  * 그리스어 번역 추가
  * 코드 가독성 향상
  * mkdocs로 새로운 문서 시작
</Update>

<Update label="2024년 1월 7일">
  ## v0.1.23

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.23)

* 많은 신뢰성 개선
  * 프롬프트 변경
  * 다국어 지원을 위한 초기 변경
  * 작업 반복 실행에 대한 버그 수정
  * 실행 오류 처리 개선
  * READMe 업데이트
</Update>

<Update label="2023년 12월 30일">
  ## v0.1.14

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.14)

* 도구 캐싱 추가 및 루프 실행 방지. (@joaomdmoura)
  * 에이전트 위임에 대한 더 많은 가이드라인 추가. (@joaomdmoura)
  * 새로운 openai 라이브러리 버전 사용으로 업데이트. (@joaomdmoura)
  * 로거에 자세한 수준 추가. (@joaomdmoura)
  * WIP 코드 제거. (@joaomdmoura)
  * 많은 개발자 생활 개선 (특별히 @greysonlalonde에게 감사드립니다).
  * pydantic v2로 업데이트 (특별히 @greysonlalonde에게도 감사드립니다).
</Update>

<Update label="2023년 11월 24일">
  ## v0.1.2

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.2)

* OpenAI가 아닌 다른 LLM을 사용할 수 있는 기능 추가
</Update>

<Update label="2023년 11월 19일">
  ## v0.1.1

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.1)

# CrewAI v0.1.1 릴리스 노트

* **Crew Verbose Mode**: 이제 실행 중인 작업을 검사할 수 있습니다.

* **README 및 문서 업데이트**: 문서에 대한 일련의 소규모 업데이트
</Update>

<Update label="2023년 11월 14일">
  ## v0.1.0

[GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.0)

# CrewAI v0.1.0 릴리스 노트

CrewAI의 초기 릴리스인 버전 0.1.0을 발표하게 되어 매우 기쁩니다! CrewAI는 복잡한 작업을 보다 효율적으로 수행하기 위해 역할 수행 및 협업이 가능한 자율 AI 에이전트를 조정하는 데 도움을 주기 위해 설계된 프레임워크입니다.

* **초기 출시**: CrewAI가 이제 공식적으로 출시되었습니다! 이 기초 릴리스는 AI 에이전트가 각자의 전문 역할과 목표를 가지고 협력할 수 있는 기반을 마련합니다.

* **역할 기반 에이전트 설계**: 특정 역할, 목표 및 성공에 필요한 도구를 갖춘 에이전트를 정의하고 사용자 정의할 수 있습니다.

* **에이전트 간 위임**: 에이전트는 이제 자율적으로 작업을 위임할 수 있는 기능을 갖추어 팀 간의 작업 부하를 동적으로 분배할 수 있습니다.

* **작업 관리**: 각 작업에 필요한 도구를 지정할 수 있는 유연성을 가지고 작업을 동적으로 생성하고 할당할 수 있습니다.

* **순차적 프로세스**: 에이전트를 설정하여 작업을 차례로 처리하도록 하여 조직적이고 예측 가능한 워크플로를 보장합니다.

* **문서화**: 프레임워크의 설정 및 사용을 안내하는 초기 문서를 통해 CrewAI를 탐색하기 시작하세요.

* `Agent`, `Task`, `Crew`, `Process` 클래스에 대한 상세 API 문서.
  * 첫 번째 CrewAI 애플리케이션을 구축하는 데 도움이 되는 예제 및 튜토리얼.
  * 에이전트 간의 협업 및 위임 메커니즘에 대한 기본 설정.

* 이번이 첫 번째 릴리스이므로 발견되지 않은 버그 및 최적화가 필요한 영역이 있을 수 있습니다. 사용 중 발견된 문제를 커뮤니티에 보고해 주시기 바랍니다.

* **고급 프로세스 관리**: 향후 릴리스에서는 합의 기반 및 계층적 워크플로를 포함한 작업 관리를 위한 보다 복잡한 프로세스를 도입할 예정입니다.
</Update>

**Examples:**

Example 1 (unknown):
```unknown
2. 필요한 종속성을 설치합니다.
```

Example 2 (unknown):
```unknown
## 사용법

  * 기본 사용법은 다음과 같습니다:
```

Example 3 (unknown):
```unknown
## 기여

  기여를 원하시면, [기여 가이드](CONTRIBUTING.md)를 참조하세요.

  ## 라이센스

  이 프로젝트는 MIT 라이센스 하에 배포됩니다. 자세한 내용은 [LICENSE](LICENSE) 파일을 확인하세요.
</Update>

<Update label="2025년 5월 22일">
  ## v0.121.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.121.0)

  # 변경 사항

  ## 핵심 개선 및 수정

  * 도구 생성 시 인코딩 오류 수정
  * llama 테스트 실패 수정
  * 일관성을 위한 로깅 구성 업데이트
  * 텔레메트리 초기화 및 이벤트 처리 개선

  ## 새로운 기능 및 향상

  * Task 클래스에 markdown 속성 추가
  * Agent 클래스에 reasoning 속성 추가
  * 자동 날짜 주입을 위한 Agent의 inject\_date 플래그 추가
  * HallucinationGuardrail 구현 (테스트 커버리지와 함께 no-op)

  ## 문서 및 가이드

  * StagehandTool에 대한 문서 추가 및 MDX 구조 개선
  * MCP 통합에 대한 문서 추가 및 기업 문서 업데이트
  * 지식 이벤트 문서화 및 reasoning 문서 업데이트
  * stop 매개변수 문서 추가
  * 문서 예제에서 import 참조 수정 (before\_kickoff, after\_kickoff)
  * 명확성을 위한 일반 문서 업데이트 및 구조 조정
</Update>

<Update label="2025년 5월 15일">
  ## v0.120.1

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.120.1)

  ## 새로운 기능

  * 하이픈이 있는 보간 수정
</Update>

<Update label="2025년 5월 14일">
  ## v0.120.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.120.0)

  ### 핵심 개선 사항 및 수정 사항

  •	더 엄격한 린팅을 위해 기본적으로 전체 Ruff 규칙 세트를 활성화했습니다.
  •	컨텍스트 관리자를 사용하여 FilteredStream의 경쟁 조건을 해결했습니다.
  •	에이전트 지식 초기화 문제를 수정했습니다.
  •	에이전트 가져오기 로직을 유틸리티 모듈로 리팩토링했습니다.

  ### 새로운 기능 및 향상된 사항

  •	저장소에서 에이전트를 직접 로드하는 기능을 추가했습니다.
  •	Task에 대해 빈 컨텍스트를 설정할 수 있도록 했습니다.
  •	에이전트 저장소 피드백을 향상시키고 Tool 자동 가져오기 동작을 수정했습니다.
  •	지식 소스를 우회하여 지식을 직접 초기화하는 기능을 도입했습니다.

  ### 문서 및 가이드

  •	현재 보안 관행에 대한 security.md를 업데이트했습니다.
  •	명확성을 위해 Google 설정 섹션을 정리했습니다.
  •	Gemini 키 입력 시 AI Studio에 대한 링크를 추가했습니다.
  •	Arize Phoenix 가시성 가이드를 업데이트했습니다.
  •	흐름 문서를 새로 고쳤습니다.
</Update>

<Update label="2025년 5월 8일">
  ## v0.119.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.119.0)

  What’s Changed

  ## Core Improvements & Fixes

  * Improved test reliability by enhancing pytest handling for flaky tests
  * Fixed memory reset crash when embedding dimensions mismatch
  * Enabled parent flow identification for Crew and LiteAgent
  * Prevented telemetry-related crashes when unavailable
  * Upgraded LiteLLM version for better compatibility
  * Fixed llama converter tests by removing skip\_external\_api

  ## New Features & Enhancements

  * Introduced knowledge retrieval prompt re-writting in Agent for improved tracking and debugging
  * Made LLM setup and quickstart guides model-agnostic

  ## Documentation & Guides

  * Added advanced configuration docs for the RAG tool
  * Updated Windows troubleshooting guide
  * Refined documentation examples for better clarity
  * Fixed typos across docs and config files
</Update>

<Update label="2025년 4월 30일">
  ## v0.118.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.118.0)

  ### 핵심 개선 사항 및 수정 사항

  * 누락된 프롬프트 또는 시스템 템플릿 문제를 수정했습니다.
  * 의도하지 않은 덮어쓰기를 방지하기 위해 전역 로깅 구성을 제거했습니다.
  * 명확성을 높이기 위해 TaskGuardrail의 이름을 LLMGuardrail로 변경했습니다.
  * 호환성을 위해 litellm을 버전 1.167.1로 다운그레이드했습니다.
  * 모듈 초기화를 보장하기 위해 누락된 **init**.py 파일을 추가했습니다.

  ### 새로운 기능 및 향상된 사항

  * AI 행동 제어를 단순화하기 위해 코드 없는 Guardrail 생성을 지원합니다.

  ### 문서 및 가이드

  * 내부 사용을 반영하기 위해 CrewStructuredTool을 공개 문서에서 제거했습니다.
  * 개선된 온보딩 경험을 위해 기업 문서 및 YouTube 임베드를 업데이트했습니다.
</Update>

<Update label="2025년 4월 28일">
  ## v0.117.1

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.117.1)

  * 빌드: crewai-tools 업그레이드
  * liteLLM을 최신 버전으로 업그레이드
  * Mem0 OSS 수정
</Update>

<Update label="2025년 4월 28일">
  ## v0.117.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.117.0)

  # 변경 사항

  ## 새로운 기능 및 향상

  * `@tool` 데코레이터에서 `result_as_answer` 매개변수 지원 추가.
  * 새로운 언어 모델 지원 도입: GPT-4.1, Gemini-2.0, Gemini-2.5 Pro.
  * 지식 관리 기능 향상.
  * CLI에서 Huggingface 제공자 옵션 추가.
  * Python 3.10+에 대한 호환성 및 CI 지원 개선.

  ## 핵심 개선 사항 및 수정

  * 잘못된 템플릿 매개변수 및 누락된 입력 문제 수정.
  * 코루틴 조건 검사를 통한 비동기 흐름 처리 개선.
  * 격리된 구성 및 올바른 메모리 객체 복사를 통한 메모리 관리 향상.
  * 올바른 참조로 라이트 에이전트 초기화 수정.
  * Python 타입 힌트 문제 해결 및 불필요한 임포트 제거.
  * 도구 사용 추적 개선을 위한 이벤트 배치 업데이트.
  * 흐름 실패 시 명시적 예외 발생.
  * 다양한 모듈에서 사용되지 않는 코드 및 불필요한 주석 제거.
  * GitHub App 토큰 작업을 v2로 업데이트.

  ## 문서 및 가이드

  * 기업 배포 지침을 포함한 문서 구조 향상.
  * 문서 생성을 위한 출력 폴더 자동 생성.
  * `WeaviateVectorSearchTool` 문서의 깨진 링크 수정.
  * JSON 검색 도구에 대한 가드레일 문서 사용 및 임포트 경로 수정.
  * `CodeInterpreterTool`에 대한 문서 업데이트.
  * 문서 페이지의 SEO, 맥락 내 탐색 및 오류 처리 개선.
</Update>

<Update label="2025년 4월 10일">
  ## v0.114.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.114.0)

  # 변경 사항

  ## 새로운 기능 및 향상

  * 에이전트를 원자 단위로 사용. (`Agent(...).kickoff()`)
  * 사용자 정의 LLM 구현 지원.
  * 외부 메모리 및 Opik 가시성 통합.
  * YAML 추출 향상.
  * 다중 모드 에이전트 검증.
  * 에이전트 및 크루를 위한 보안 지문 추가.

  ## 핵심 개선 사항 및 수정

  * 직렬화, 에이전트 복사 및 Python 호환성 개선.
  * emit()에 와일드카드 지원 추가.
  * 추가 라우터 호출 및 컨텍스트 창 조정 지원 추가.
  * 타입 문제, 검증 및 import 문 수정.
  * 메서드 성능 개선.
  * 에이전트 작업 처리, 이벤트 발생 및 메모리 관리 향상.
  * CLI 문제, 조건부 작업, 복제 동작 및 도구 출력 수정.

  ## 문서 및 가이드

  * 문서 구조, 테마 및 조직 개선.
  * WSL2, W\&B Weave 및 Arize Phoenix와 함께하는 로컬 NVIDIA NIM에 대한 가이드 추가.
  * 도구 구성 예제, 프롬프트 및 가시성 문서 업데이트.
  * Flows 내에서 단일 에이전트를 사용하는 방법에 대한 가이드.
</Update>

<Update label="2025년 3월 17일">
  ## v0.108.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.108.0)

  # 기능

  * PR #2190에서 crew\.py 템플릿의 탭을 공백으로 변환했습니다.
  * PR #2266에서 LLM 스트리밍 응답 처리 및 이벤트 시스템을 개선했습니다.
  * PR #2310에서 model\_name을 포함했습니다.
  * PR #2321에서 풍부한 시각화와 개선된 로깅을 갖춘 이벤트 리스너를 강화했습니다.
  * PR #2332에서 지문을 추가했습니다.

  # 버그 수정

  * PR #2308에서 Mistral 문제를 수정했습니다.
  * PR #2370에서 문서의 버그를 수정했습니다.
  * PR #2369에서 지문 속성의 타입 검사 오류를 수정했습니다.

  # 문서 업데이트

  * PR #2259에서 도구 문서를 개선했습니다.
  * PR #2196에서 uv 도구 패키지의 설치 가이드를 업데이트했습니다.
  * PR #2363에서 uv 도구로 crewAI를 업그레이드하는 방법에 대한 지침을 추가했습니다.
  * PR #2254에서 ApifyActorsTool에 대한 문서를 추가했습니다.
</Update>

<Update label="2025년 3월 9일">
  ## v0.105.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.105.0)

  **핵심 개선 사항 및 수정 사항**

  * 누락된 템플릿 변수 및 사용자 메모리 구성 문제를 수정했습니다.
  * 비동기 흐름 지원을 개선하고 에이전트 응답 형식을 조정했습니다.
  * 메모리 초기화 기능을 강화하고 CLI 메모리 명령을 수정했습니다.
  * 타입 문제, 도구 호출 속성 및 텔레메트리 분리를 수정했습니다.

  **새로운 기능 및 향상된 사항**

  * 흐름 상태 내보내기를 추가하고 상태 유틸리티를 개선했습니다.
  * 선택적 크루 임베더를 사용한 에이전트 지식 설정을 강화했습니다.
  * 더 나은 관찰 가능성과 LLM 호출 추적을 위한 이벤트 발행기를 도입했습니다.
  * Python 3.10 및 langchain\_ollama의 ChatOllama에 대한 지원을 추가했습니다.
  * o3-mini 모델에 대한 컨텍스트 윈도우 크기 지원을 통합했습니다.
  * 여러 라우터 호출에 대한 지원을 추가했습니다.

  **문서 및 가이드**

  * 문서 레이아웃 및 계층 구조를 개선했습니다.
  * QdrantVectorSearchTool 가이드를 추가하고 이벤트 리스너 사용을 명확히 했습니다.
  * 프롬프트의 오타를 수정하고 Amazon Bedrock 모델 목록을 업데이트했습니다.
</Update>

<Update label="2025년 2월 13일">
  ## v0.102.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.102.0)

  ### 핵심 개선 사항 및 수정 사항

  * 향상된 LLM 지원: Anthropic 모델에 대한 구조화된 LLM 출력, 매개변수 처리 및 형식 개선.
  * Crew 및 Agent 안정성: 지식 소스를 사용하는 에이전트/크루 복제, 조건부 작업에서의 여러 작업 출력 및 무시된 Crew 작업 콜백과 관련된 문제 수정.
  * 메모리 및 저장소 수정: Bedrock과의 단기 메모리 처리 수정, 올바른 임베더 초기화 보장, 크루 클래스에 메모리 재설정 기능 추가.
  * 교육 및 실행 신뢰성: dict 및 list 입력 유형과 관련된 교육 및 보간 문제 수정.

  ### 새로운 기능 및 개선 사항

  * 고급 지식 관리: 명명 규칙 개선 및 사용자 정의 임베더 지원을 통한 임베딩 구성 향상.
  * 확장된 로깅 및 관찰 가능성: 로깅을 위한 JSON 형식 지원 추가 및 MLflow 추적 문서 통합.
  * 데이터 처리 개선: multi-tab 파일을 처리하기 위해 excel\_knowledge\_source.py 업데이트.
  * 일반 성능 및 코드베이스 정리: 기업 코드 정렬 간소화 및 린팅 문제 해결.
  * 새로운 도구 QdrantVectorSearchTool 추가.

  ### 문서 및 가이드

  * AI 및 메모리 문서 업데이트: Bedrock, Google AI 및 장기 메모리 문서 개선.
  * 작업 및 워크플로우 명확성: 작업 속성에 "인간 입력" 행 추가, Langfuse 가이드 및 FileWriterTool 문서.
  * 다양한 오타 및 형식 문제 수정.

  ### 유지 관리 및 기타

  * 올해의 Google Docs 통합 및 작업 처리 개선.
</Update>

<Update label="2025년 1월 28일">
  ## v0.100.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.100.0)

  * 기능: Composio 문서 추가
  * 기능: SageMaker를 LLM 제공자로 추가
  * 수정: 전체 LLM 연결 문제 해결
  * 수정: 훈련 시 안전한 접근자 사용
  * 수정: crew\_chat.py에 버전 확인 추가
  * 문서: crewai 채팅에 대한 새로운 문서
  * 문서: CLI 및 Composio Tool 문서의 형식 및 명확성 개선
</Update>

<Update label="2025년 1월 20일">
  ## v0.98.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.98.0)

  * 기능: Conversation crew v1
  * 기능: 흐름 상태에 고유 ID 추가
  * 기능: FlowPersistence 인터페이스와 함께 @persist 데코레이터 추가
  * 통합: SambaNova 통합 추가
  * 통합: cli에 NVIDIA NIM 제공자 추가
  * 통합: VoyageAI 소개
  * 작업: 템플릿의 날짜를 현재 연도로 업데이트
  * 수정: Mem0 통합에서 API 키 동작 및 엔티티 처리 수정
  * 수정: 핵심 호출 루프 논리 및 관련 테스트 수정
  * 수정: 도구 입력을 문자열이 아닌 실제 객체로 만들기
  * 수정: 도구 생성에 중요한 누락된 부분 추가
  * 수정: Windows 문제를 방지하기 위해 litellm 버전 하락
  * 수정: 시작 전에 입력이 없을 경우
  * 수정: 오타
  * 수정: 중첩된 pydantic 모델 문제
  * 수정: Docling 문제
  * 수정: union 문제
  * 문서 업데이트
</Update>

<Update label="2025년 1월 4일">
  ## v0.95.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.95.0)

  * 기능: Crew에 다중 모드 기능 추가
  * 기능: 프로그래밍 가능한 가드레일
  * 기능: HITL 여러 라운드
  * 기능: Gemini 2.0 지원
  * 기능: CrewAI 흐름 개선
  * 기능: 워크플로우 권한 추가
  * 기능: litellm과 함께 langfuse 지원 추가
  * 기능: CrewAI와 Portkey 통합
  * 기능: interpolate\_only 메서드 추가 및 오류 처리 개선
  * 기능: Docling 지원
  * 기능: Weviate 지원
  * 수정: output\_file이 시스템 경로를 존중하지 않음
  * 수정: 단기 메모리 초기화 시 디스크 I/O 오류 수정
  * 수정: CrewJSONEncoder가 이제 enums를 허용함
  * 수정: Python 최대 버전
  * 수정: Task의 output\_file에 대한 보간 처리
  * 수정: 동료 역할 이름의 대소문자/공백을 제대로 처리
  * 수정: tiktoken을 명시적 종속성으로 추가하고 Rust 요구 사항 문서화
  * 수정: 계획 과정에 에이전트 지식 포함
  * 수정: KnowledgeStorage의 저장소 초기화를 None으로 변경
  * 수정: 선택적 저장소 확인 수정
  * 수정: 흐름에 이벤트 발신기 포함
  * 수정: Docstring, 오류 처리 및 타입 힌트 개선
  * 수정: litellm pydantic 문제로 인한 userWarnings 억제
</Update>

<Update label="2024년 12월 5일">
  ## v0.86.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.86.0)

  * 모든 파이프라인 및 파이프라인 라우터에 대한 참조 제거
  * 문서: Custom LLM에 Nvidia NIM을 공급자로 추가
  * 지식 데모 추가 + 지식 문서 개선
  * Brandon/cre 509 HITL 여러 차례 후속 조치
  * 데코레이터가 있는 YAML 크루에 대한 새로운 문서. 템플릿 크루 단순화
</Update>

<Update label="2024년 12월 4일">
  ## v0.85.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.85.0)

  * 에이전트 레벨에 지식 추가
  * 기능/언체인 제거
  * 타입이 지정된 작업 출력 개선
  * `crewai login`에서 도구 저장소에 로그인
  * 결과가 답변으로 LLM 루프를 제대로 종료하지 않는 문제 수정
  * 수정: ollama 제공자와 함께 실행할 때 누락된 키 이름
  * 발견된 철자 문제 수정
  * mypy 실행을 위한 README 업데이트
  * mint.json에 지식 추가
  * GitHub 액션 업데이트
  * 문서 업데이트: 에이전트 생성에 대한 두 가지 접근 방식을 포함하도록 에이전트 문서 업데이트
  * 문서 개선: LLM 구성 및 사용
</Update>

<Update label="2024년 11월 25일">
  ## v0.83.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/v0.83.0)

  * 새로운 `before_kickoff` 및 `after_kickoff` 크루 콜백
  * 지식으로 에이전트를 사전 주입하는 지원
  * Mem0를 사용하여 사용자 선호도 및 기억을 검색하는 지원 추가
  * 비동기 실행 수정
  * chroma 업그레이드 및 임베더 함수 생성기 조정
  * CLI Watson 지원 모델 및 문서 업데이트
  * Bandit의 레벨 감소
  * 모든 테스트 수정
  * 문서 업데이트
</Update>

<Update label="2024년 11월 14일">
  ## v0.80.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.80.0)

  * 토큰 콜백 대체 버그 수정
  * 스텝 콜백 문제 수정
  * 사용 메트릭에 캐시된 프롬프트 토큰 정보 추가
  * crew\_train\_success 테스트 수정
</Update>

<Update label="2024년 11월 11일">
  ## v0.79.4

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.79.4)

  # llms 지원 관련 작은 버그 수정 시리즈

  * llms 지원에 대한 여러 작은 버그 수정이 포함되었습니다.
  * 성능 향상 및 안정성 개선이 이루어졌습니다.
  * 사용자 피드백을 반영하여 몇 가지 문제를 해결했습니다.

  자세한 내용은 [GitHub](https://github.com)에서 확인하세요.
</Update>

<Update label="2024년 11월 10일">
  ## v0.79.0

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.79.0)

  * 흐름에 입력 추가
  * 더 많은 데이터 유형을 지원하도록 로그 저장소 강화
  * IBM 메모리 지원 추가
  * CLI에서 Watson을 옵션으로 추가
  * security.md 파일 추가
  * .netrc를 uv 환경 변수로 교체
  * BaseTool을 메인 패키지로 이동하고 도구 설명 생성을 중앙 집중화
  * LLM이 응답을 반환하지 않으면 오류 발생
  * 흐름을 수정하여 사이클을 지원하고 테스트에 추가
  * 크루 이름 지정 방법 업데이트 및 누락된 구성 수정
  * 문서 업데이트
</Update>

<Update label="2024년 10월 30일">
  ## v0.76.9

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.76.9)

  * flow에 대한 플롯 명령을 crewai flow plot로 업데이트
  * 3.10을 지원할 수 있도록 tomli 추가
  * `uv sync`에 설치 명령 옵션 전달
  * 도구 텍스트 설명 및 인수 개선
  * 도구 및 흐름 문서 개선
  * flows cli를 업데이트하여 crewai flow add-crew로 흐름에 추가 크루를 쉽게 추가할 수 있도록 함
  * 여러 개의 start 및 listen(and\_(..., ..., ...))을 사용할 때 flows 버그 수정
</Update>

<Update label="2024년 10월 23일">
  ## v0.76.2

  [GitHub 릴리스 보기](https://github.com/crewAIInc/crewAI/releases/tag/0.76.2)

  # crewai create 명령어 업데이트

  ## 개요

  `crewai create` 명령어는 새로운 CrewAI 프로젝트를 생성하는 데 사용됩니다. 이 문서에서는 이 명령어의 사용법과 업데이트된 기능에 대해 설명합니다.

  ## 사용법

  다음 명령어를 사용하여 새로운 프로젝트를 생성할 수 있습니다:
```

Example 4 (unknown):
```unknown
## 옵션

  * `--template <template-name>`: 특정 템플릿을 사용하여 프로젝트를 생성합니다.
  * `--description <description>`: 프로젝트에 대한 설명을 추가합니다.
  * `--private`: 프로젝트를 비공개로 설정합니다.

  ## 예제

  다음은 `crewai create` 명령어의 사용 예입니다:
```

---

## query="SELECT product_name, SUM(revenue) as total_revenue FROM sales GROUP BY product_name ORDER BY total_revenue DESC LIMIT 5"

**URL:** llms-txt#query="select-product_name,-sum(revenue)-as-total_revenue-from-sales-group-by-product_name-order-by-total_revenue-desc-limit-5"

---

## First run

**URL:** llms-txt#first-run

flow1 = PersistentCounterFlow()
result1 = flow1.kickoff()
print(f"First run result: {result1}")

---

## 인터넷 검색 기능을 위한 도구 초기화

**URL:** llms-txt#인터넷-검색-기능을-위한-도구-초기화

tool = BraveSearchTool()

---

## Create agent with specific Asana actions only

**URL:** llms-txt#create-agent-with-specific-asana-actions-only

task_manager_agent = Agent(
    role="Task Manager",
    goal="Create and manage tasks efficiently",
    backstory="An AI assistant that focuses on task creation and management.",
    apps=[
        'asana/create_task',
        'asana/update_task',
        'asana/get_tasks'
    ]  # Specific Asana actions
)

---

## Verify storage location is consistent

**URL:** llms-txt#verify-storage-location-is-consistent

**Contents:**
- 커스텀 임베더 설정
  - 왜 서로 다른 임베딩 제공업체를 선택해야 할까요?
  - OpenAI 임베딩 (기본값)

import os
print("CREWAI_STORAGE_DIR:", os.getenv("CREWAI_STORAGE_DIR"))
print("Current working directory:", os.getcwd())
print("Computed storage path:", db_storage_path())
python  theme={null}
from crewai import Crew

**Examples:**

Example 1 (unknown):
```unknown
## 커스텀 임베더 설정

CrewAI는 다양한 임베딩 공급자를 지원하여 사용 사례에 가장 적합한 옵션을 선택할 수 있는 유연성을 제공합니다. 메모리 시스템에 사용할 수 있는 다양한 임베딩 공급자를 설정하는 방법에 대한 종합적인 가이드를 아래에 제공합니다.

### 왜 서로 다른 임베딩 제공업체를 선택해야 할까요?

* **비용 최적화**: 로컬 임베딩(Ollama)은 초기 설정 후 무료입니다
* **프라이버시**: Ollama를 사용하여 데이터를 로컬에 보관하거나 선호하는 클라우드 제공업체를 사용할 수 있습니다
* **성능**: 일부 모델은 특정 도메인이나 언어에 더 잘 작동합니다
* **일관성**: 임베딩 제공업체와 LLM 제공업체를 맞출 수 있습니다
* **컴플라이언스**: 특정 규제 또는 조직 요구사항을 충족할 수 있습니다

### OpenAI 임베딩 (기본값)

OpenAI는 대부분의 사용 사례에 잘 작동하는 신뢰할 수 있고 고품질의 임베딩을 제공합니다.
```

---

## Serviço completo com todas as ferramentas

**URL:** llms-txt#serviço-completo-com-todas-as-ferramentas

"crewai-amp:financial-data"

---

## Obter apenas ferramentas específicas do Google Calendar

**URL:** llms-txt#obter-apenas-ferramentas-específicas-do-google-calendar

actions_list=["google_calendar/create_event", "google_calendar/view_events", "google_calendar/get_availability"]
)

meeting_coordinator = Agent(
    role="Meeting Coordinator",
    goal="Coordenar reuniões e verificar disponibilidade",
    backstory="Um assistente de IA que foca em agendamento de reuniões e gerenciamento de disponibilidade.",
    apps=['google_calendar']
)

---

## fornecendo sua URL:

**URL:** llms-txt#fornecendo-sua-url:

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')
python Code theme={null}
tool = CodeDocsSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # ou google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # ou openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  Substitua '[https://docs.example.com/reference](https://docs.example.com/reference)' pela URL da documentação desejada
  e 'How to use search tool' pela consulta de busca relevante às suas necessidades.
</Note>

## Argumentos

Os seguintes parâmetros podem ser usados para personalizar o comportamento do `CodeDocsSearchTool`:

| Argumento     | Tipo     | Descrição                                                                |
| :------------ | :------- | :----------------------------------------------------------------------- |
| **docs\_url** | `string` | *Opcional*. Especifica a URL da documentação de código a ser pesquisada. |

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza a OpenAI tanto para embeddings quanto para sumarização. Para customizar o modelo, você pode usar um dicionário de configuração conforme abaixo:
```

---

## 도구 인스턴스화

**URL:** llms-txt#도구-인스턴스화

docs_tool = DirectoryReadTool(directory='./blog-posts')
file_tool = FileReadTool()
search_tool = SerperDevTool()
web_rag_tool = WebsiteSearchTool()

---

## Criar um objeto StdioServerParameters

**URL:** llms-txt#criar-um-objeto-stdioserverparameters

stdio_params=StdioServerParameters(
    command="python3", 
    args=["servers/your_stdio_server.py"],
    env={"UV_PYTHON": "3.12", **os.environ},
)

mcp_server_adapter = MCPServerAdapter(server_params=stdio_params)
try:
    mcp_server_adapter.start()  # Inicia manualmente a conexão e o processo do servidor
    tools = mcp_server_adapter.tools
    print(f"Available tools (manual Stdio): {[tool.name for tool in tools]}")

# Exemplo: Usando as ferramentas com sua configuração de Agent, Task, Crew
    manual_agent = Agent(
        role="Executor Local de Tarefas",
        goal="Executar uma tarefa local específica usando uma ferramenta Stdio gerenciada manualmente.",
        backstory="Uma IA proficiente em controlar processos locais via MCP.",
        tools=tools,
        verbose=True
    )
    
    manual_task = Task(
        description="Executar o comando 'perform_analysis' via ferramenta Stdio.",
        expected_output="Resultados da análise.",
        agent=manual_agent
    )
    
    manual_crew = Crew(
        agents=[manual_agent],
        tasks=[manual_task],
        verbose=True,
        process=Process.sequential
    )
        
       
    result = manual_crew.kickoff() # As entradas reais dependem da sua ferramenta
    print("\nCrew Task Result (Stdio - Manual):\n", result)
            
except Exception as e:
    print(f"An error occurred during manual Stdio MCP integration: {e}")
finally:
    if mcp_server_adapter and mcp_server_adapter.is_connected: # Verifica se está conectado antes de parar
        print("Stopping Stdio MCP server connection (manual)...")
        mcp_server_adapter.stop()  # **Crucial: Assegure que stop seja chamado**
    elif mcp_server_adapter: # Se o adaptador existe mas não está conectado (ex.: start falhou)
        print("Stdio MCP server adapter was not connected. No stop needed or start failed.")

Lembre-se de substituir caminhos e comandos de exemplo pelos detalhes reais do seu servidor Stdio. O parâmetro `env` em `StdioServerParameters` pode ser usado para definir variáveis de ambiente para o processo do servidor, o que pode ser útil para configurar seu comportamento ou fornecer caminhos necessários (como `PYTHONPATH`).

---

## Example task to extract headlines from a news website

**URL:** llms-txt#example-task-to-extract-headlines-from-a-news-website

scrape_task = Task(
    description="Extract the main headlines from the CNN homepage. Use the CSS selector '.headline' to target the headline elements.",
    expected_output="A list of the main headlines from CNN.",
    agent=web_scraper_agent,
)

---

## Carregar variáveis de ambiente

**URL:** llms-txt#carregar-variáveis-de-ambiente

---

## 특정 JSON 파일로 검색 범위 제한

**URL:** llms-txt#특정-json-파일로-검색-범위-제한

---

## Contexto amplifica a efetividade do modelo

**URL:** llms-txt#contexto-amplifica-a-efetividade-do-modelo

domain_expert = Agent(
    role="B2B SaaS Marketing Strategist",
    goal="Develop comprehensive go-to-market strategies for enterprise software",
    backstory="""
    You have 10+ years of experience scaling B2B SaaS companies from Series A to IPO.
    You understand the nuances of enterprise sales cycles, the importance of product-market
    fit in different verticals, and how to balance growth metrics with unit economics.
    You've worked with companies like Salesforce, HubSpot, and emerging unicorns, giving
    you perspective on both established and disruptive go-to-market strategies.
    """,
    llm=LLM(model="claude-3-5-sonnet", temperature=0.3)  # Criatividade balanceada com conhecimento de domínio
)

---

## Automações

**URL:** llms-txt#automações

**Contents:**
- Visão geral
- Métodos de implantação
  - Implantar via GitHub
  - Implantar via ZIP
- Painel de Automações
- Boas práticas
- Relacionados

Source: https://docs.crewai.com/pt-BR/enterprise/features/automations

Gerencie, implante e monitore seus crews (automações) em um só lugar.

Automações é o hub operacional para seus crews implantados. Use para implantar via GitHub ou arquivo ZIP, gerenciar variáveis de ambiente, reimplantar quando necessário e monitorar o status de cada automação.

<Frame>
    <img src="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=a7d0655da82c70b0ca152715cb8253f4" alt="Visão Geral de Automações" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/automations-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=280&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=18456289664a18d4b83b2acdae616a44 280w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=560&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=4737cb32db15d7f121a1366ae5c80c0e 560w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=840&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=69473aff76b3ea16974be8226590d114 840w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=1100&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=a742c3a1f81537f0a2d9668e5671c1aa 1100w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=1650&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=6a9aed77a2491e2dc3da8f511f391487 1650w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=2500&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=c64e992c5464916085b9114abab0d7c0 2500w" />
</Frame>

## Métodos de implantação

### Implantar via GitHub

Use para projetos versionados e implantação contínua.

<Steps>
  <Step title="Conectar GitHub">
    Clique em <b>Configure GitHub</b> e autorize o acesso.
  </Step>

<Step title="Selecionar Repositório & Branch">
    Escolha o <b>Repositório</b> e a <b>Branch</b> que deseja implantar.
  </Step>

<Step title="Ativar Auto‑deploy (opcional)">
    Ative <b>Automatically deploy new commits</b> para publicar a cada push.
  </Step>

<Step title="Adicionar Variáveis de Ambiente">
    Adicione segredos individualmente ou use <b>Bulk View</b> para múltiplas variáveis.
  </Step>

<Step title="Implantar">
    Clique em <b>Deploy</b> para criar sua automação.
  </Step>
</Steps>

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=4fb72dc68799d5a0c35e2e74f1a7cc6c" alt="Implantação via GitHub" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/deploy-from-github.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b15575b0b30c64e8b7a20de9e97468e5 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=c041da5b5b79d38cb2a3f8d6f00e14a7 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=0783c12a6f83d09ce83e66aa34edcacd 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=d703da835283f7e73079ef66f664587c 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=f73b6afc4c3c3075ded4da6559676fa3 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=c3d82425923c1f57264b7cb5af9004b3 2500w" />
</Frame>

### Implantar via ZIP

Envie rapidamente sem Git — faça upload de um pacote ZIP do projeto.

<Steps>
  <Step title="Escolher arquivo">
    Selecione o arquivo ZIP do seu computador.
  </Step>

<Step title="Adicionar Variáveis de Ambiente">
    Informe as variáveis necessárias.
  </Step>

<Step title="Implantar">
    Clique em <b>Deploy</b> para criar sua automação.
  </Step>
</Steps>

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=8cea74868a553d34b0aa182ad5489099" alt="Implantação via ZIP" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/deploy-from-zip.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=961637aa95a2795071b4a54e921f3f03 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=62994bfdf5667fc17880ed33c32a7aa6 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b0c4ef28de74989c1fdbf1076d12ba3c 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=19fe8b770051a0426f120d6b661a6f40 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=a80e4bf6e8befdf57a5ea79840b45136 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=61e870a88f47df3e282a134e754fc09d 2500w" />
</Frame>

## Painel de Automações

A tabela lista todas as automações com detalhes chave:

* **CREW**: Nome da automação
* **STATUS**: Online / Failed / In Progress
* **URL**: Endpoint para kickoff/status
* **TOKEN**: Token da automação
* **ACTIONS**: Re‑deploy, delete e outros

Use os controles no canto superior direito para filtrar e pesquisar:

* Pesquisar por nome
* Filtrar por <b>Status</b>
* Filtrar por <b>Source</b> (GitHub / Studio / ZIP)

Após implantar, você pode ver os detalhes da automação e usar o menu **Options** para `chat with this crew`, `Export React Component` e `Export as MCP`.

<Frame>
    <img src="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=f7fb571e8473f5cb7940c3e3bb34f95c" alt="Tabela de Automações" data-og-width="2874" width="2874" data-og-height="932" height="932" data-path="images/enterprise/automations-table.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=280&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=5833733acf6f2e07d0a39abffe87de40 280w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=560&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=858a8b93744d4f23e07e9ec58227aac0 560w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=840&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=e0fe6df6d821e1edc729681e8d314d22 840w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=1100&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=cb68b81e23a169714985d93bb0913170 1100w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=1650&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=401736c16a6074de6b60de8234cbe206 1650w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=2500&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=1b9a5f852f474d6a68a5cf4dda5a0021 2500w" />
</Frame>

* Prefira implantações via GitHub para controle de versão e CI/CD
* Use re‑deploy para avançar após mudanças de código/config ou habilite auto‑deploy a cada push

<CardGroup cols={3}>
  <Card title="Implantar um Crew" href="/pt-BR/enterprise/guides/deploy-crew" icon="rocket">
    Implante um Crew via GitHub ou arquivo ZIP.
  </Card>

<Card title="Gatilhos de Automação" href="/pt-BR/enterprise/guides/automation-triggers" icon="trigger">
    Dispare automações por webhooks ou API.
  </Card>

<Card title="Automação com Webhook" href="/pt-BR/enterprise/guides/webhook-automation" icon="webhook">
    Transmita eventos e atualizações em tempo real.
  </Card>
</CardGroup>

---

## Create agent with specific Box actions only

**URL:** llms-txt#create-agent-with-specific-box-actions-only

file_organizer_agent = Agent(
    role="File Organizer",
    goal="Organize and manage file storage efficiently",
    backstory="An AI assistant that focuses on file organization and storage management.",
    apps=['box/create_folder', 'box/save_file', 'box/list_files']  # Specific Box actions
)

---

## 종합적인 연구 작업 생성

**URL:** llms-txt#종합적인-연구-작업-생성

research_task = Task(
    description="""AI 에이전트가 비즈니스 생산성에 미치는 영향을 연구하세요.
    원격 근무에 대한 현재 날씨 영향, 금융 시장 트렌드,
    AI 에이전트 프레임워크에 대한 최근 학술 발표를 포함하세요.""",
    expected_output="""다음을 다루는 종합 보고서:
    1. AI 에이전트 비즈니스 영향 분석
    2. 원격 근무를 위한 날씨 고려사항
    3. AI 관련 금융 시장 트렌드
    4. 학술 연구 인용 및 통찰
    5. 경쟁 환경 분석""",
    agent=multi_source_agent
)

---

## Ensure query parameters are properly URL encoded

**URL:** llms-txt#ensure-query-parameters-are-properly-url-encoded

**Contents:**
- Advanced: MCPServerAdapter

## Advanced: MCPServerAdapter

For complex scenarios requiring manual connection management, use the `MCPServerAdapter` class from `crewai-tools`. Using a Python context manager (`with` statement) is the recommended approach as it automatically handles starting and stopping the connection to the MCP server.

---

## Inicialize o logger do Maxim

**URL:** llms-txt#inicialize-o-logger-do-maxim

logger = Maxim().logger()

---

## 개요

**URL:** llms-txt#개요

**Contents:**
- 개요
- 사전 준비 사항
- 사용법
  - 기본 구현

`StagehandTool`은 [Stagehand](https://docs.stagehand.dev/get_started/introduction) 프레임워크를 CrewAI와 통합하여 에이전트가 자연어 지시를 사용해 웹사이트와 상호작용하고 브라우저 작업을 자동화할 수 있도록 합니다.

Stagehand는 Browserbase에서 개발한 강력한 브라우저 자동화 프레임워크로, AI 에이전트가 다음과 같은 작업을 수행할 수 있도록 합니다:

* 웹사이트 탐색
* 버튼, 링크, 기타 요소 클릭
* 폼 작성
* 웹 페이지에서 데이터 추출
* 요소 관찰 및 식별
* 복잡한 워크플로우 수행

StagehandTool은 Stagehand Python SDK를 감싸 CrewAI 에이전트에게 세 가지 핵심 원시 기능을 통해 브라우저 제어 능력을 제공합니다:

1. **Act**: 클릭, 입력, 탐색과 같은 액션 수행
2. **Extract**: 웹 페이지에서 구조화된 데이터 추출
3. **Observe**: 페이지의 요소 식별 및 분석

이 도구를 사용하기 전에 다음을 확인하세요:

1. API 키와 프로젝트 ID가 있는 [Browserbase](https://www.browserbase.com/) 계정
2. LLM(OpenAI 또는 Anthropic Claude)용 API 키
3. Stagehand Python SDK 설치

StagehandTool은 두 가지 방법으로 구현할 수 있습니다:

#### 1. 컨텍스트 매니저 사용하기 (권장)

<Tip>
  컨텍스트 매니저 방식은 예외가 발생하더라도 리소스가 적절하게 정리되므로 권장됩니다.
</Tip>

```python  theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import StagehandTool
from stagehand.schemas import AvailableModel

**Examples:**

Example 1 (unknown):
```unknown
## 사용법

### 기본 구현

StagehandTool은 두 가지 방법으로 구현할 수 있습니다:

#### 1. 컨텍스트 매니저 사용하기 (권장)

<Tip>
  컨텍스트 매니저 방식은 예외가 발생하더라도 리소스가 적절하게 정리되므로 권장됩니다.
</Tip>
```

---

## Example task to generate code

**URL:** llms-txt#example-task-to-generate-code

generate_code_task = Task(
    description="Crie um programa simples para gerar os N primeiros números da sequência de Fibonacci.",
    expected_output="Programa que gera os N primeiros números da sequência de Fibonacci.",
    agent=coding_agent,
)

---

## 1. Successfully connect to working servers

**URL:** llms-txt#1.-successfully-connect-to-working-servers

---

## Crie um agente com capacidades do Microsoft OneDrive

**URL:** llms-txt#crie-um-agente-com-capacidades-do-microsoft-onedrive

onedrive_agent = Agent(
    role="Gerenciador de Arquivos",
    goal="Gerenciar arquivos e pastas no OneDrive de forma eficiente",
    backstory="Um assistente IA especializado em operações de arquivos do Microsoft OneDrive e organização.",
    apps=['microsoft_onedrive']  # Todas as ações do OneDrive estarão disponíveis
)

---

## Servidor com autenticação

**URL:** llms-txt#servidor-com-autenticação

"https://mcp.exa.ai/mcp?api_key=sua_chave&profile=seu_perfil"

---

## Inicializa a ferramenta para buscas gerais em canais do YouTube

**URL:** llms-txt#inicializa-a-ferramenta-para-buscas-gerais-em-canais-do-youtube

youtube_channel_tool = YoutubeChannelSearchTool()

---

## 새 연락처 생성 작업

**URL:** llms-txt#새-연락처-생성-작업

create_contact_task = Task(
    description="'김철수'라는 이름으로 이메일 'kim.chulsoo@example.com'과 전화번호 '010-1234-5678'로 새 연락처를 만드세요",
    agent=contacts_agent,
    expected_output="새 연락처가 성공적으로 생성됨"
)

---

## View current organization

**URL:** llms-txt#view-current-organization

---

## Example task to generate and evaluate code

**URL:** llms-txt#example-task-to-generate-and-evaluate-code

generate_code_task = Task(
    description="Crie um programa simples para gerar os N primeiros números da sequência de Fibonacci. Selecione o avaliador e os critérios mais apropriados para avaliar sua saída.",
    expected_output="Programa que gera os N primeiros números da sequência de Fibonacci.",
    agent=coding_agent,
)

---

## SingleStore 검색 도구

**URL:** llms-txt#singlestore-검색-도구

Source: https://docs.crewai.com/ko/tools/database-data/singlestoresearchtool

SingleStoreSearchTool은 풀링과 함께 SingleStore에서 SELECT/SHOW 쿼리를 안전하게 실행합니다.

---

## Firecrawl 웹사이트 스크랩

**URL:** llms-txt#firecrawl-웹사이트-스크랩

Source: https://docs.crewai.com/ko/tools/web-scraping/firecrawlscrapewebsitetool

FirecrawlScrapeWebsiteTool은 웹사이트를 스크랩하여 깔끔한 마크다운이나 구조화된 데이터로 변환하도록 설계되었습니다.

---

## 계층적 프로세스

**URL:** llms-txt#계층적-프로세스

**Contents:**
- 소개
- 계층적 프로세스 개요
  - 주요 기능
- 계층적 프로세스 구현하기

Source: https://docs.crewai.com/ko/learn/hierarchical-process

최신 코딩 관행 및 기능을 반영하여 CrewAI 프로젝트 내에서 계층적 프로세스를 이해하고 적용하는 종합 가이드입니다.

CrewAI의 계층적 프로세스는 효율적인 작업 위임 및 실행을 위해 전통적인 조직의 계층 구조를 모방하는 구조화된 작업 관리 방식을 도입합니다.
이러한 체계적인 워크플로우는 작업이 최적의 효율성과 정확성으로 처리될 수 있도록 하여 프로젝트 성과를 향상시킵니다.

<Tip>
  계층적 프로세스는 GPT-4와 같은 고급 모델을 활용하도록 설계되었으며, 복잡한 작업을 보다 효율적으로 처리하는 동시에 토큰 사용을 최적화합니다.
</Tip>

기본적으로 CrewAI에서 task는 순차적인 프로세스를 통해 관리됩니다. 그러나 계층적 접근 방식을 채택하면 명확한 계층 구조의 task 관리를 할 수 있습니다.\
이 방식에서는 'manager' agent가 workflow를 조정하고, task를 위임하며, 결과를 검증하여 효율적이고 원활한 실행을 가능하게 합니다. 이 manager agent는 이제 CrewAI에서 자동으로 생성되거나 사용자가 명시적으로 설정할 수 있습니다.

* **작업 위임**: 매니저 에이전트가 역할과 역량에 따라 crew 멤버에게 작업을 할당합니다.
* **결과 검증**: 매니저가 결과물을 평가하여 요구되는 기준을 충족하는지 확인합니다.
* **효율적인 워크플로우**: 기업 구조를 모방하여 체계적인 작업 관리 방식을 제공합니다.
* **시스템 프롬프트 처리**: 시스템이 사전 정의된 prompt를 사용할지 옵션으로 지정할 수 있습니다.
* **불용어 제어**: 불용어 사용 여부를 옵션으로 지정할 수 있으며, o1 모델 등 다양한 모델을 지원합니다.
* **컨텍스트 윈도우 존중**: 중요한 컨텍스트를 우선시하며, 컨텍스트 윈도우를 존중하는 것이 기본 동작입니다.
* **위임 제어**: 사용자에게 명확한 제어권을 주기 위해 기본적으로 위임이 비활성화되어 있습니다.
* **분당 최대 요청 수**: 분당 최대 요청 수를 설정할 수 있는 구성 옵션입니다.
* **최대 반복 횟수**: 최종 답변을 얻기 위한 최대 반복 횟수를 제한합니다.

계층적 프로세스를 활용하려면, 프로세스 속성을 반드시 `Process.hierarchical`로 명시적으로 설정해야 합니다. 기본 동작은 `Process.sequential`입니다.
매니저가 지정된 crew를 정의하고, 명확한 명령 체계를 구축하세요.

<Tip>
  도구는 agent 수준에서 할당하여, 매니저의 지시에 따라 지정된 agent가 작업 위임 및 실행을 원활히 수행할 수 있도록 하십시오.
  도구는 작업 수준에서도 지정할 수 있어, 작업 수행 시 도구 가용성을 정밀하게 제어할 수 있습니다.
</Tip>

<Tip>
  계층적 프로세스에서는 `manager_llm` 파라미터 설정이 매우 중요합니다.
  시스템이 올바르게 작동하려면 매니저 LLM이 반드시 설정되어야 하며, 이를 통해 맞춤형 의사결정이 가능합니다.
</Tip>

```python Code theme={null}
from crewai import Crew, Process, Agent

---

## Configurar local de armazenamento personalizado

**URL:** llms-txt#configurar-local-de-armazenamento-personalizado

custom_storage_path = "./storage"
os.makedirs(custom_storage_path, exist_ok=True)

crew = Crew(
    memory=True,
    long_term_memory=LongTermMemory(
        storage=LTMSQLiteStorage(
            db_path=f"{custom_storage_path}/memory.db"
        )
    )
)
python  theme={null}
import os
from pathlib import Path

**Examples:**

Example 1 (unknown):
```unknown
#### Opção 3: Armazenamento Específico de Projeto
```

---

## Crie um agente com capacidades do Google Contacts

**URL:** llms-txt#crie-um-agente-com-capacidades-do-google-contacts

contacts_agent = Agent(
    role="Gerenciador de Contatos",
    goal="Gerenciar Google Contacts de forma eficiente",
    backstory="Um assistente IA especializado em gerenciamento e organização de contatos.",
    apps=['google_contacts']  # Todas as ações do Google Contacts estarão disponíveis
)

---

## CSV RAG 검색

**URL:** llms-txt#csv-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/csvsearchtool

CSVSearchTool은 CSV 파일의 콘텐츠 내에서 의미론적 검색을 수행하기 위해 설계된 강력한 RAG(Retrieval-Augmented Generation) 도구입니다.

---

## 실제 프롬프트 생성 및 확인

**URL:** llms-txt#실제-프롬프트-생성-및-확인

generated_prompt = prompt_generator.task_execution()

---

## Tarefa para criar um relatório de bug

**URL:** llms-txt#tarefa-para-criar-um-relatório-de-bug

create_bug_task = Task(
    description="Crie um relatório de bug de alta prioridade para o sistema de autenticação e atribua à equipe de backend",
    agent=linear_agent,
    expected_output="Bug report criado com sucesso com ID da issue"
)

---

## Criação de um agente com capacidades Jira

**URL:** llms-txt#criação-de-um-agente-com-capacidades-jira

jira_agent = Agent(
    role="Issue Manager",
    goal="Gerenciar issues do Jira e acompanhar o progresso do projeto de forma eficiente",
    backstory="Um assistente de IA especializado em rastreamento de issues e gestão de projetos.",
    apps=['jira']
)

---

## Google Slides 기능을 가진 에이전트 생성

**URL:** llms-txt#google-slides-기능을-가진-에이전트-생성

slides_agent = Agent(
    role="프레젠테이션 작성자",
    goal="Google Slides 프레젠테이션을 효율적으로 생성하고 관리",
    backstory="프레젠테이션 디자인 및 콘텐츠 관리 전문 AI 어시스턴트.",
    apps=['google_slides']  # 모든 Google Slides 작업을 사용할 수 있습니다
)

---

## Task to create a presentation

**URL:** llms-txt#task-to-create-a-presentation

create_presentation_task = Task(
    description="Create a new presentation for the quarterly business review with key slides",
    agent=slides_agent,
    expected_output="Quarterly business review presentation created with structured content"
)

---

## Integração com Jira

**URL:** llms-txt#integração-com-jira

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o Jira
  - 1. Conectar Sua Conta Jira
  - 2. Instalar o Pacote Necessário
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de um Agente Jira

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/jira

Rastreamento de problemas e gestão de projetos com a integração Jira para CrewAI.

Permita que seus agentes gerenciem problemas, projetos e fluxos de trabalho pelo Jira. Crie e atualize issues, acompanhe o progresso de projetos, gerencie atribuições e otimize sua gestão de projetos com automação potencializada por IA.

Antes de usar a integração com o Jira, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Jira com permissões adequadas para o projeto
* Sua conta Jira conectada pela [Página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com o Jira

### 1. Conectar Sua Conta Jira

1. Acesse [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Jira** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo do OAuth
4. Conceda as permissões necessárias para gestão de issues e projetos
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instalar o Pacote Necessário

<AccordionGroup>
  <Accordion title="jira/create_issue">
    **Descrição:** Cria uma issue no Jira.

* `summary` (string, obrigatório): Resumo - Um breve resumo da issue. (exemplo: "A impressora parou de funcionar").
    * `project` (string, opcional): Projeto - Projeto ao qual a issue pertence. Padrão para o primeiro projeto do usuário se não informado. Use as Configurações de Workflow do Portal de Conexão para permitir a seleção de Projeto.
    * `issueType` (string, opcional): Tipo de issue - Padrão para Task se não informado.
    * `jiraIssueStatus` (string, opcional): Status - Padrão para o primeiro status do projeto se não informado.
    * `assignee` (string, opcional): Responsável - Padrão para o usuário autenticado se não informado.
    * `descriptionType` (string, opcional): Tipo de Descrição - Selecione o Tipo de Descrição.
      * Opções: `description`, `descriptionJSON`
    * `description` (string, opcional): Descrição - Uma descrição detalhada da issue. Este campo aparece apenas se 'descriptionType' = 'description'.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique outros campos em formato JSON. Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar quais campos atualizar.
      
  </Accordion>

<Accordion title="jira/update_issue">
    **Descrição:** Atualiza uma issue no Jira.

* `issueKey` (string, obrigatório): Chave da Issue (exemplo: "TEST-1234").
    * `summary` (string, opcional): Resumo - Breve resumo da issue. (exemplo: "A impressora parou de funcionar").
    * `issueType` (string, opcional): Tipo de issue - Use as Configurações de Workflow do Portal de Conexão para permitir a seleção.
    * `jiraIssueStatus` (string, opcional): Status - Use as Configurações de Workflow do Portal de Conexão para permitir a seleção.
    * `assignee` (string, opcional): Responsável - Use as Configurações de Workflow do Portal de Conexão para permitir a seleção.
    * `descriptionType` (string, opcional): Tipo de Descrição - Selecione o Tipo de Descrição.
      * Opções: `description`, `descriptionJSON`
    * `description` (string, opcional): Descrição - Descrição detalhada da issue. Este campo aparece apenas se 'descriptionType' = 'description'.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique outros campos em formato JSON.
  </Accordion>

<Accordion title="jira/get_issue_by_key">
    **Descrição:** Obtém uma issue pelo identificador no Jira.

* `issueKey` (string, obrigatório): Chave da Issue (exemplo: "TEST-1234").
  </Accordion>

<Accordion title="jira/filter_issues">
    **Descrição:** Busca issues no Jira usando filtros.

* `jqlQuery` (object, opcional): Filtro em forma normal disjuntiva - OU de grupos E de condições simples.
      
      Operadores disponíveis: `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringIsIn`, `$stringIsNotIn`, `$stringContains`, `$stringDoesNotContain`, `$stringGreaterThan`, `$stringLessThan`
    * `limit` (string, opcional): Limitar resultados - Limite máximo de issues retornados. Padrão para 10 se estiver em branco.
  </Accordion>

<Accordion title="jira/search_by_jql">
    **Descrição:** Busca issues no Jira utilizando JQL.

* `jqlQuery` (string, obrigatório): Query JQL (exemplo: "project = PROJECT").
    * `paginationParameters` (object, opcional): Parâmetros de paginação para resultados paginados.
      
  </Accordion>

<Accordion title="jira/update_issue_any">
    **Descrição:** Atualiza qualquer issue no Jira. Use DESCRIBE\_ACTION\_SCHEMA para obter o schema de propriedades dessa função.

**Parâmetros:** Nenhum parâmetro específico - use JIRA\_DESCRIBE\_ACTION\_SCHEMA primeiro para obter o schema esperado.
  </Accordion>

<Accordion title="jira/describe_action_schema">
    **Descrição:** Obtém o schema esperado para um tipo de issue. Use esta função caso nenhuma outra função atenda ao tipo de issue que deseja operar.

* `issueTypeId` (string, obrigatório): ID do Tipo de Issue.
    * `projectKey` (string, obrigatório): Chave do projeto.
    * `operation` (string, obrigatório): Tipo de Operação, por exemplo CREATE\_ISSUE ou UPDATE\_ISSUE.
  </Accordion>

<Accordion title="jira/get_projects">
    **Descrição:** Obtém os projetos no Jira.

* `paginationParameters` (object, opcional): Parâmetros de Paginação.
      
  </Accordion>

<Accordion title="jira/get_issue_types_by_project">
    **Descrição:** Obtém os tipos de issues por projeto no Jira.

* `project` (string, obrigatório): Chave do projeto.
  </Accordion>

<Accordion title="jira/get_issue_types">
    **Descrição:** Obtém todos os tipos de issues no Jira.

**Parâmetros:** Nenhum obrigatório.
  </Accordion>

<Accordion title="jira/get_issue_status_by_project">
    **Descrição:** Obtém os status das issues de um projeto específico.

* `project` (string, obrigatório): Chave do projeto.
  </Accordion>

<Accordion title="jira/get_all_assignees_by_project">
    **Descrição:** Obtém os responsáveis por um projeto específico.

* `project` (string, obrigatório): Chave do projeto.
  </Accordion>
</AccordionGroup>

### Configuração Básica de um Agente Jira

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="jira/create_issue">
    **Descrição:** Cria uma issue no Jira.

    **Parâmetros:**

    * `summary` (string, obrigatório): Resumo - Um breve resumo da issue. (exemplo: "A impressora parou de funcionar").
    * `project` (string, opcional): Projeto - Projeto ao qual a issue pertence. Padrão para o primeiro projeto do usuário se não informado. Use as Configurações de Workflow do Portal de Conexão para permitir a seleção de Projeto.
    * `issueType` (string, opcional): Tipo de issue - Padrão para Task se não informado.
    * `jiraIssueStatus` (string, opcional): Status - Padrão para o primeiro status do projeto se não informado.
    * `assignee` (string, opcional): Responsável - Padrão para o usuário autenticado se não informado.
    * `descriptionType` (string, opcional): Tipo de Descrição - Selecione o Tipo de Descrição.
      * Opções: `description`, `descriptionJSON`
    * `description` (string, opcional): Descrição - Uma descrição detalhada da issue. Este campo aparece apenas se 'descriptionType' = 'description'.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique outros campos em formato JSON. Use as Configurações de Workflow do Portal de Conexão para permitir ao usuário selecionar quais campos atualizar.
```

Example 2 (unknown):
```unknown
</Accordion>

  <Accordion title="jira/update_issue">
    **Descrição:** Atualiza uma issue no Jira.

    **Parâmetros:**

    * `issueKey` (string, obrigatório): Chave da Issue (exemplo: "TEST-1234").
    * `summary` (string, opcional): Resumo - Breve resumo da issue. (exemplo: "A impressora parou de funcionar").
    * `issueType` (string, opcional): Tipo de issue - Use as Configurações de Workflow do Portal de Conexão para permitir a seleção.
    * `jiraIssueStatus` (string, opcional): Status - Use as Configurações de Workflow do Portal de Conexão para permitir a seleção.
    * `assignee` (string, opcional): Responsável - Use as Configurações de Workflow do Portal de Conexão para permitir a seleção.
    * `descriptionType` (string, opcional): Tipo de Descrição - Selecione o Tipo de Descrição.
      * Opções: `description`, `descriptionJSON`
    * `description` (string, opcional): Descrição - Descrição detalhada da issue. Este campo aparece apenas se 'descriptionType' = 'description'.
    * `additionalFields` (string, opcional): Campos Adicionais - Especifique outros campos em formato JSON.
  </Accordion>

  <Accordion title="jira/get_issue_by_key">
    **Descrição:** Obtém uma issue pelo identificador no Jira.

    **Parâmetros:**

    * `issueKey` (string, obrigatório): Chave da Issue (exemplo: "TEST-1234").
  </Accordion>

  <Accordion title="jira/filter_issues">
    **Descrição:** Busca issues no Jira usando filtros.

    **Parâmetros:**

    * `jqlQuery` (object, opcional): Filtro em forma normal disjuntiva - OU de grupos E de condições simples.
```

Example 3 (unknown):
```unknown
Operadores disponíveis: `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringIsIn`, `$stringIsNotIn`, `$stringContains`, `$stringDoesNotContain`, `$stringGreaterThan`, `$stringLessThan`
    * `limit` (string, opcional): Limitar resultados - Limite máximo de issues retornados. Padrão para 10 se estiver em branco.
  </Accordion>

  <Accordion title="jira/search_by_jql">
    **Descrição:** Busca issues no Jira utilizando JQL.

    **Parâmetros:**

    * `jqlQuery` (string, obrigatório): Query JQL (exemplo: "project = PROJECT").
    * `paginationParameters` (object, opcional): Parâmetros de paginação para resultados paginados.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="jira/update_issue_any">
    **Descrição:** Atualiza qualquer issue no Jira. Use DESCRIBE\_ACTION\_SCHEMA para obter o schema de propriedades dessa função.

    **Parâmetros:** Nenhum parâmetro específico - use JIRA\_DESCRIBE\_ACTION\_SCHEMA primeiro para obter o schema esperado.
  </Accordion>

  <Accordion title="jira/describe_action_schema">
    **Descrição:** Obtém o schema esperado para um tipo de issue. Use esta função caso nenhuma outra função atenda ao tipo de issue que deseja operar.

    **Parâmetros:**

    * `issueTypeId` (string, obrigatório): ID do Tipo de Issue.
    * `projectKey` (string, obrigatório): Chave do projeto.
    * `operation` (string, obrigatório): Tipo de Operação, por exemplo CREATE\_ISSUE ou UPDATE\_ISSUE.
  </Accordion>

  <Accordion title="jira/get_projects">
    **Descrição:** Obtém os projetos no Jira.

    **Parâmetros:**

    * `paginationParameters` (object, opcional): Parâmetros de Paginação.
```

---

## psycopg2 was installed to run this example with PostgreSQL

**URL:** llms-txt#psycopg2-was-installed-to-run-this-example-with-postgresql

**Contents:**
- 예시

nl2sql = NL2SQLTool(db_uri="postgresql://example@localhost:5432/test_db")

@agent
def researcher(self) -> Agent:
    return Agent(
        config=self.agents_config["researcher"],
        allow_delegation=False,
        tools=[nl2sql]
    )
md  theme={null}
 DB -> Agent -> ... -> Agent -> DB
```

**Examples:**

Example 1 (unknown):
```unknown
## 예시

주요 작업 목표는 다음과 같았습니다:

"각 도시에 대해 월별 평균, 최대, 최소 매출을 조회하되, 사용자 수가 1명 초과인 도시만 포함하세요. 또한 각 도시의 사용자 수를 세고, 평균 월 매출을 기준으로 내림차순 정렬하십시오."

그래서 에이전트는 DB에서 정보를 얻으려고 시도했고, 처음 시도는 잘못되었으므로 에이전트가 다시 시도하여 올바른 정보를 얻은 후 다음 에이전트로 전달합니다.

![alt text](https://github.com/crewAIInc/crewAI-tools/blob/main/crewai_tools/tools/nl2sql/images/image-2.png?raw=true)
![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-3.png)

두 번째 작업 목표는 다음과 같았습니다:

"데이터를 검토하고 상세한 보고서를 작성한 다음, 제공된 데이터를 기반으로 필드를 갖는 테이블을 데이터베이스에 생성하세요. 각 도시에 대해 월별 평균, 최대, 최소 매출 정보를 포함하되, 사용자 수가 1명 초과인 도시만 포함시키세요. 또한 각 도시의 사용자 수를 세고, 평균 월 매출을 기준으로 내림차순 정렬하십시오."

이제 상황이 흥미로워집니다. 에이전트는 테이블을 생성할 SQL 쿼리뿐만 아니라 데이터를 테이블에 삽입하는 쿼리도 생성합니다. 그리고 마지막에는 데이터베이스에 있던 것과 정확히 일치하는 최종 보고서도 반환합니다.

![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-4.png)
![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-5.png)

![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-9.png)
![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-7.png)

이것은 NL2SQLTool이 데이터베이스와 상호작용하고, 데이터베이스의 데이터를 기반으로 보고서를 생성하는 데 어떻게 사용될 수 있는지에 대한 간단한 예시입니다.

이 도구는 에이전트의 논리와 데이터베이스와 상호작용하는 방식에 대해 무한한 가능성을 제공합니다.
```

---

## Create agent with tracked LLM

**URL:** llms-txt#create-agent-with-tracked-llm

**Contents:**
  - 6. Caching for Efficient Crews
  - 7. Model Interoperability

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=portkey_llm
)
python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

# Configure LLM with simple caching
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
            config={
                "cache": {
                    "mode": "simple"
                }
            }
        )
    )

# Create agent with cached LLM
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

# Configure LLM with semantic caching
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
            config={
                "cache": {
                    "mode": "semantic"
                }
            }
        )
    )

# Create agent with semantically cached LLM
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
from crewai import Agent, LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
**Filter Analytics by User**

With metadata in place, you can filter analytics by user and analyze performance metrics on a per-user basis:

<Frame caption="Filter analytics by user">
  <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" />
</Frame>

This enables:

* Per-user cost tracking and budgeting
* Personalized user analytics
* Team or organization-level metrics
* Environment-specific monitoring (staging vs. production)

<Card title="Learn More About Metadata" icon="tags" href="https://portkey.ai/docs/product/observability/metadata">
  Explore how to use custom metadata to enhance your analytics
</Card>

### 6. Caching for Efficient Crews

Implement caching to make your CrewAI agents more efficient and cost-effective:

<Tabs>
  <Tab title="Simple Caching">
```

Example 2 (unknown):
```unknown
Simple caching performs exact matches on input prompts, caching identical requests to avoid redundant model executions.
  </Tab>

  <Tab title="Semantic Caching">
```

Example 3 (unknown):
```unknown
Semantic caching considers the contextual similarity between input requests, caching responses for semantically similar inputs.
  </Tab>
</Tabs>

### 7. Model Interoperability

CrewAI supports multiple LLM providers, and Portkey extends this capability by providing access to over 200 LLMs through a unified interface. You can easily switch between different models without changing your core agent logic:
```

---

## 모든 코드 문서 내용을 검색하려면:

**URL:** llms-txt#모든-코드-문서-내용을-검색하려면:

tool = CodeDocsSearchTool()

---

## Integração OpenLIT

**URL:** llms-txt#integração-openlit

Source: https://docs.crewai.com/pt-BR/observability/openlit

Comece a monitorar seus Agentes rapidamente com apenas uma linha de código usando OpenTelemetry.

---

## Inicializar ferramenta com filtro pré-definido

**URL:** llms-txt#inicializar-ferramenta-com-filtro-pré-definido

**Contents:**
  - Combinando Filtros

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_url",
        qdrant_api_key="your_key",
        collection_name="your_collection",
        filter=preset_filter  # Filtro pré-definido aplicado a todas as buscas
    )
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Combinando Filtros

A ferramenta combina automaticamente os filtros pré-definidos do `QdrantConfig` com os filtros dinâmicos de `filter_by` e `filter_value`:
```

---

## Create a RAG tool with default settings

**URL:** llms-txt#create-a-rag-tool-with-default-settings

---

## MCP DSL 통합

**URL:** llms-txt#mcp-dsl-통합

**Contents:**
- 개요
- 기본 사용법

Source: https://docs.crewai.com/ko/mcp/dsl-integration

CrewAI의 간단한 DSL 구문을 사용하여 mcps 필드로 MCP 서버를 에이전트와 직접 통합하는 방법을 알아보세요.

CrewAI의 MCP DSL(Domain Specific Language) 통합은 에이전트를 MCP(Model Context Protocol) 서버에 연결하는 **가장 간단한 방법**을 제공합니다. 에이전트에 `mcps` 필드만 추가하면 CrewAI가 모든 복잡성을 자동으로 처리합니다.

<Info>
  이는 대부분의 MCP 사용 사례에 **권장되는 접근 방식**입니다. 수동 연결 관리가 필요한 고급 시나리오의 경우 [MCPServerAdapter](/ko/mcp/overview#advanced-mcpserveradapter)를 참조하세요.
</Info>

`mcps` 필드를 사용하여 에이전트에 MCP 서버를 추가하세요:

```python  theme={null}
from crewai import Agent

agent = Agent(
    role="연구 보조원",
    goal="연구 및 분석 업무 지원",
    backstory="고급 연구 도구에 접근할 수 있는 전문가 보조원",
    mcps=[
        "https://mcp.exa.ai/mcp?api_key=your_key&profile=research"
    ]
)

---

## Define the agent

**URL:** llms-txt#define-the-agent

blog_agent = Agent(
    role="Blog Content Generator Agent",
    goal="Generate a blog title and content",
    backstory="""You are an expert content creator, skilled in crafting engaging and informative blog posts.""",
    verbose=False,
    allow_delegation=False,
    llm="gpt-4o",
)

---

## Integração Microsoft Excel

**URL:** llms-txt#integração-microsoft-excel

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Microsoft Excel
  - 1. Conecte sua Conta Microsoft
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Microsoft Excel

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/microsoft_excel

Gerenciamento de pastas de trabalho e dados com integração Microsoft Excel para CrewAI.

Permita que seus agentes criem e gerenciem pastas de trabalho, planilhas, tabelas e gráficos do Excel no OneDrive ou SharePoint. Manipule intervalos de dados, crie visualizações, gerencie tabelas e simplifique seus fluxos de trabalho de planilhas com automação alimentada por IA.

Antes de usar a integração Microsoft Excel, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Microsoft 365 com acesso ao Excel e OneDrive/SharePoint
* Conectado sua conta Microsoft através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Microsoft Excel

### 1. Conecte sua Conta Microsoft

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Microsoft Excel** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a arquivos e pastas de trabalho do Excel
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="microsoft_excel/create_workbook">
    **Descrição:** Criar uma nova pasta de trabalho do Excel no OneDrive ou SharePoint.

* `file_path` (string, obrigatório): Caminho onde criar a pasta de trabalho (ex: 'MinhaPastaDeTrabalho.xlsx')
    * `worksheets` (array, opcional): Planilhas iniciais para criar. Cada item é um objeto com `name` (string, nome da planilha).
  </Accordion>

<Accordion title="microsoft_excel/get_workbooks">
    **Descrição:** Obter todas as pastas de trabalho do Excel do OneDrive ou SharePoint.

* `select` (string, opcional): Selecionar propriedades específicas para retornar.
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas.
  </Accordion>

<Accordion title="microsoft_excel/get_worksheets">
    **Descrição:** Obter todas as planilhas em uma pasta de trabalho do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `select` (string, opcional): Selecionar propriedades específicas para retornar (ex: 'id,name,position').
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas.
  </Accordion>

<Accordion title="microsoft_excel/create_worksheet">
    **Descrição:** Criar uma nova planilha em uma pasta de trabalho do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `name` (string, obrigatório): Nome da nova planilha.
  </Accordion>

<Accordion title="microsoft_excel/get_range_data">
    **Descrição:** Obter dados de um intervalo específico em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `range` (string, obrigatório): Endereço do intervalo (ex: 'A1:C10').
  </Accordion>

<Accordion title="microsoft_excel/update_range_data">
    **Descrição:** Atualizar dados em um intervalo específico em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `range` (string, obrigatório): Endereço do intervalo (ex: 'A1:C10').
    * `values` (array, obrigatório): Array 2D de valores para definir no intervalo. Cada array interno representa uma linha, e elementos podem ser string, number ou integer.
  </Accordion>

<Accordion title="microsoft_excel/add_table">
    **Descrição:** Criar uma tabela em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `range` (string, obrigatório): Intervalo para a tabela (ex: 'A1:D10').
    * `has_headers` (boolean, opcional): Se a primeira linha contém cabeçalhos. Padrão: true.
  </Accordion>

<Accordion title="microsoft_excel/get_tables">
    **Descrição:** Obter todas as tabelas em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
  </Accordion>

<Accordion title="microsoft_excel/add_table_row">
    **Descrição:** Adicionar uma nova linha a uma tabela do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `table_name` (string, obrigatório): Nome da tabela.
    * `values` (array, obrigatório): Array de valores para a nova linha. Elementos podem ser string, number ou integer.
  </Accordion>

<Accordion title="microsoft_excel/create_chart">
    **Descrição:** Criar um gráfico em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `chart_type` (string, obrigatório): Tipo de gráfico (ex: 'ColumnClustered', 'Line', 'Pie').
    * `source_data` (string, obrigatório): Intervalo de dados para o gráfico (ex: 'A1:B10').
    * `series_by` (string, opcional): Como interpretar os dados ('Auto', 'Columns' ou 'Rows'). Padrão: 'Auto'.
  </Accordion>

<Accordion title="microsoft_excel/get_cell">
    **Descrição:** Obter o valor de uma única célula em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `row` (integer, obrigatório): Número da linha (baseado em 0).
    * `column` (integer, obrigatório): Número da coluna (baseado em 0).
  </Accordion>

<Accordion title="microsoft_excel/get_used_range">
    **Descrição:** Obter o intervalo usado de uma planilha do Excel (contém todos os dados).

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
  </Accordion>

<Accordion title="microsoft_excel/list_charts">
    **Descrição:** Obter todos os gráficos em uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
  </Accordion>

<Accordion title="microsoft_excel/delete_worksheet">
    **Descrição:** Excluir uma planilha de uma pasta de trabalho do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha a excluir.
  </Accordion>

<Accordion title="microsoft_excel/delete_table">
    **Descrição:** Excluir uma tabela de uma planilha do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `table_name` (string, obrigatório): Nome da tabela a excluir.
  </Accordion>

<Accordion title="microsoft_excel/list_names">
    **Descrição:** Obter todos os intervalos nomeados em uma pasta de trabalho do Excel.

* `file_id` (string, obrigatório): O ID do arquivo Excel.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Microsoft Excel

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="microsoft_excel/create_workbook">
    **Descrição:** Criar uma nova pasta de trabalho do Excel no OneDrive ou SharePoint.

    **Parâmetros:**

    * `file_path` (string, obrigatório): Caminho onde criar a pasta de trabalho (ex: 'MinhaPastaDeTrabalho.xlsx')
    * `worksheets` (array, opcional): Planilhas iniciais para criar. Cada item é um objeto com `name` (string, nome da planilha).
  </Accordion>

  <Accordion title="microsoft_excel/get_workbooks">
    **Descrição:** Obter todas as pastas de trabalho do Excel do OneDrive ou SharePoint.

    **Parâmetros:**

    * `select` (string, opcional): Selecionar propriedades específicas para retornar.
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas.
  </Accordion>

  <Accordion title="microsoft_excel/get_worksheets">
    **Descrição:** Obter todas as planilhas em uma pasta de trabalho do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `select` (string, opcional): Selecionar propriedades específicas para retornar (ex: 'id,name,position').
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas.
  </Accordion>

  <Accordion title="microsoft_excel/create_worksheet">
    **Descrição:** Criar uma nova planilha em uma pasta de trabalho do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `name` (string, obrigatório): Nome da nova planilha.
  </Accordion>

  <Accordion title="microsoft_excel/get_range_data">
    **Descrição:** Obter dados de um intervalo específico em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `range` (string, obrigatório): Endereço do intervalo (ex: 'A1:C10').
  </Accordion>

  <Accordion title="microsoft_excel/update_range_data">
    **Descrição:** Atualizar dados em um intervalo específico em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `range` (string, obrigatório): Endereço do intervalo (ex: 'A1:C10').
    * `values` (array, obrigatório): Array 2D de valores para definir no intervalo. Cada array interno representa uma linha, e elementos podem ser string, number ou integer.
  </Accordion>

  <Accordion title="microsoft_excel/add_table">
    **Descrição:** Criar uma tabela em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `range` (string, obrigatório): Intervalo para a tabela (ex: 'A1:D10').
    * `has_headers` (boolean, opcional): Se a primeira linha contém cabeçalhos. Padrão: true.
  </Accordion>

  <Accordion title="microsoft_excel/get_tables">
    **Descrição:** Obter todas as tabelas em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
  </Accordion>

  <Accordion title="microsoft_excel/add_table_row">
    **Descrição:** Adicionar uma nova linha a uma tabela do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `table_name` (string, obrigatório): Nome da tabela.
    * `values` (array, obrigatório): Array de valores para a nova linha. Elementos podem ser string, number ou integer.
  </Accordion>

  <Accordion title="microsoft_excel/create_chart">
    **Descrição:** Criar um gráfico em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `chart_type` (string, obrigatório): Tipo de gráfico (ex: 'ColumnClustered', 'Line', 'Pie').
    * `source_data` (string, obrigatório): Intervalo de dados para o gráfico (ex: 'A1:B10').
    * `series_by` (string, opcional): Como interpretar os dados ('Auto', 'Columns' ou 'Rows'). Padrão: 'Auto'.
  </Accordion>

  <Accordion title="microsoft_excel/get_cell">
    **Descrição:** Obter o valor de uma única célula em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `row` (integer, obrigatório): Número da linha (baseado em 0).
    * `column` (integer, obrigatório): Número da coluna (baseado em 0).
  </Accordion>

  <Accordion title="microsoft_excel/get_used_range">
    **Descrição:** Obter o intervalo usado de uma planilha do Excel (contém todos os dados).

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
  </Accordion>

  <Accordion title="microsoft_excel/list_charts">
    **Descrição:** Obter todos os gráficos em uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
  </Accordion>

  <Accordion title="microsoft_excel/delete_worksheet">
    **Descrição:** Excluir uma planilha de uma pasta de trabalho do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha a excluir.
  </Accordion>

  <Accordion title="microsoft_excel/delete_table">
    **Descrição:** Excluir uma tabela de uma planilha do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
    * `worksheet_name` (string, obrigatório): Nome da planilha.
    * `table_name` (string, obrigatório): Nome da tabela a excluir.
  </Accordion>

  <Accordion title="microsoft_excel/list_names">
    **Descrição:** Obter todos os intervalos nomeados em uma pasta de trabalho do Excel.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do arquivo Excel.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Microsoft Excel
```

---

## Usar embeddings personalizados com a ferramenta

**URL:** llms-txt#usar-embeddings-personalizados-com-a-ferramenta

**Contents:**
- Tratamento de Erros
- Variáveis de Ambiente

from crewai_tools import QdrantConfig

tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_url",
        qdrant_api_key="your_key",
        collection_name="your_collection"
    ),
    custom_embedding_fn=custom_embeddings  # Passe sua função personalizada
)
bash  theme={null}
export QDRANT_URL="your_qdrant_url"  # Se não for informado no construtor
export QDRANT_API_KEY="your_api_key"  # Se não for informado no construtor
export OPENAI_API_KEY="your_openai_key"  # Se estiver usando embeddings padrão
```

**Examples:**

Example 1 (unknown):
```unknown
## Tratamento de Erros

A ferramenta trata os seguintes erros específicos:

* Lança ImportError se `qdrant-client` não estiver instalado (com opção de instalar automaticamente)
* Lança ValueError se `QDRANT_URL` não estiver definido
* Solicita instalação de `qdrant-client` se estiver ausente utilizando `uv add qdrant-client`

## Variáveis de Ambiente

Variáveis de ambiente obrigatórias:
```

---

## 사용자 정의 설정으로 초기화

**URL:** llms-txt#사용자-정의-설정으로-초기화

**Contents:**
- 기능
- 응답 형식
- 사용 사례

extractor_tool = TavilyExtractorTool(
    extract_depth='advanced',  # 보다 포괄적인 추출
    include_images=True,       # 이미지 결과 포함
    timeout=90                 # 사용자 정의 타임아웃
)
```

* **단일 또는 여러 URL**: 하나의 URL에서 콘텐츠를 추출하거나 한 번의 요청으로 여러 URL을 처리할 수 있습니다
* **구성 가능한 깊이**: 기본(빠른) 및 고급(포괄적인) 추출 모드 중에서 선택할 수 있습니다
* **이미지 지원**: 원할 경우 추출 결과에 이미지를 포함할 수 있습니다
* **구조화된 출력**: 추출된 콘텐츠가 잘 포맷된 JSON으로 반환됩니다
* **오류 처리**: 네트워크 시간 초과 및 추출 오류에 대한 견고한 처리

도구는 제공된 URL에서 추출한 구조화된 데이터를 나타내는 JSON 문자열을 반환합니다. 정확한 구조는 페이지의 내용과 사용된 `extract_depth`에 따라 달라집니다.

일반적인 응답 요소는 다음과 같습니다:

* **Title**: 페이지 제목
* **Content**: 페이지의 주요 텍스트 내용
* **Images**: 이미지 URL 및 메타데이터 (`include_images=True`인 경우)
* **Metadata**: 저자, 설명 등 추가적인 페이지 정보

* **콘텐츠 분석**: 경쟁사 웹사이트에서 콘텐츠를 추출하고 분석
* **연구**: 다양한 소스에서 구조화된 데이터를 수집하여 분석
* **콘텐츠 마이그레이션**: 기존 웹사이트에서 콘텐츠를 추출하여 마이그레이션
* **모니터링**: 변경 감지를 위해 정기적으로 콘텐츠 추출
* **데이터 수집**: 웹 소스에서 정보를 체계적으로 추출

응답 구조와 사용 가능한 옵션에 대한 자세한 정보는 [Tavily API 문서](https://docs.tavily.com/docs/tavily-api/python-sdk#extract)를 참고하세요.

---

## DALL-E 도구

**URL:** llms-txt#dall-e-도구

Source: https://docs.crewai.com/ko/tools/ai-ml/dalletool

DallETool은(는) 텍스트 설명으로부터 이미지를 생성할 수 있도록 설계된 강력한 도구입니다.

---

## 특정 디렉터리로 도구를 초기화하여,

**URL:** llms-txt#특정-디렉터리로-도구를-초기화하여,

---

## Adicionar ferramentas ao agente

**URL:** llms-txt#adicionar-ferramentas-ao-agente

**Contents:**
- Memória e Contexto do Agente
- Gerenciamento da Janela de Contexto
  - Como Funciona o Gerenciamento de Janela de Contexto
  - Manipulação Automática de Contexto (`respect_context_window=True`)

researcher = Agent(
    role="Pesquisador de Tecnologia em IA",
    goal="Pesquisar os últimos avanços em IA",
    tools=[search_tool, wiki_tool],
    verbose=True
)
python Code theme={null}
from crewai import Agent

analyst = Agent(
    role="Analista de Dados",
    goal="Analisar e memorizar padrões complexos de dados",
    memory=True,  # Ativa memória
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Memória e Contexto do Agente

Agentes podem manter a memória de suas interações e usar contexto de tarefas anteriores. Isto é especialmente útil para fluxos de trabalho complexos onde é necessário reter informações ao longo de várias tarefas.
```

Example 2 (unknown):
```unknown
<Note>
  Quando `memory` está ativo, o agente manterá o contexto ao longo de múltiplas interações, melhorando a capacidade de lidar com tarefas complexas, em múltiplos passos.
</Note>

## Gerenciamento da Janela de Contexto

O CrewAI inclui um gerenciamento automático sofisticado de janela de contexto para lidar com situações onde as conversas excedem o limite de tokens do modelo de linguagem. Esse poderoso recurso é controlado pelo parâmetro `respect_context_window`.

### Como Funciona o Gerenciamento de Janela de Contexto

Quando o histórico de conversas de um agente se torna muito grande para a janela de contexto do LLM, o CrewAI detecta essa situação automaticamente e pode:

1. **Resumir o conteúdo automaticamente** (com `respect_context_window=True`)
2. **Parar a execução com erro** (com `respect_context_window=False`)

### Manipulação Automática de Contexto (`respect_context_window=True`)

Esta é a **configuração padrão e recomendada** para a maioria dos casos. Quando ativada, CrewAI irá:
```

---

## Integração com Portkey

**URL:** llms-txt#integração-com-portkey

**Contents:**
- Introdução
  - Instalação & Configuração
- Recursos para Produção
  - 1. Observabilidade Avançada
  - 2. Confiabilidade - Mantenha Seus Crews Funcionando Sem Interrupções

Source: https://docs.crewai.com/pt-BR/observability/portkey

Como usar Portkey com CrewAI

<img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/main/Portkey-CrewAI.png" alt="Portkey CrewAI Header Image" width="70%" />

Portkey aprimora o CrewAI com recursos prontos para produção, transformando seus crews de agentes experimentais em sistemas robustos ao fornecer:

* **Observabilidade completa** de cada etapa do agente, uso de ferramentas e interações
* **Confiabilidade incorporada** com fallbacks, tentativas automáticas e balanceamento de carga
* **Rastreamento e otimização de custos** para gerenciar seus gastos com IA
* **Acesso a mais de 200 LLMs** por meio de uma única integração
* **Guardrails** para manter o comportamento dos agentes seguro e em conformidade
* **Prompts versionados** para desempenho consistente dos agentes

### Instalação & Configuração

<Steps>
  <Step title="Instale os pacotes necessários">
    
  </Step>

<Step title="Gere a Chave de API" icon="lock">
    Crie uma chave de API Portkey com limites de orçamento/taxa opcionais no [painel da Portkey](https://app.portkey.ai/). Você também pode adicionar configurações para confiabilidade, cache e outros recursos a essa chave. Mais sobre isso em breve.
  </Step>

<Step title="Configure o CrewAI com Portkey">
    A integração é simples – basta atualizar a configuração do LLM no seu setup do CrewAI:

<Info>
      **O que são Virtual Keys?** Virtual keys no Portkey armazenam com segurança suas chaves de API dos provedores LLM (OpenAI, Anthropic, etc.) em um cofre criptografado. Elas facilitam a rotação de chaves e o gerenciamento de orçamento. [Saiba mais sobre virtual keys aqui](https://portkey.ai/docs/product/ai-gateway/virtual-keys).
    </Info>
  </Step>
</Steps>

## Recursos para Produção

### 1. Observabilidade Avançada

Portkey oferece observabilidade abrangente para seus agentes CrewAI, ajudando você a entender exatamente o que está acontecendo durante cada execução.

<Tabs>
  <Tab title="Traces">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Product%2011.1.webp" />
    </Frame>

Os traces fornecem uma visão hierárquica da execução do seu crew, mostrando a sequência de chamadas LLM, ativações de ferramentas e transições de estado.

<Tab title="Logs">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Metadata.png" />
    </Frame>

Portkey registra cada interação com LLMs, incluindo:

* Payloads completos das requisições e respostas
    * Métricas de latência e uso de tokens
    * Cálculos de custo
    * Chamadas de ferramentas e execuções de funções

Todos os logs podem ser filtrados por metadados, trace IDs, modelos e mais, tornando mais fácil depurar execuções específicas do crew.
  </Tab>

<Tab title="Métricas & Dashboards">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Dashboard.png" />
    </Frame>

Portkey oferece dashboards integrados que ajudam você a:

* Rastrear custos e uso de tokens em todas as execuções do crew
    * Analisar métricas de desempenho, como latência e taxas de sucesso
    * Identificar gargalos nos fluxos de trabalho dos agentes
    * Comparar diferentes configurações de crew e LLMs

Você pode filtrar e segmentar todas as métricas por metadados personalizados para analisar tipos de crew, grupos de usuários ou casos de uso específicos.
  </Tab>

<Tab title="Filtragem por Metadados">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" alt="Analytics with metadata filters" />
    </Frame>

Adicione metadados personalizados à configuração LLM do seu CrewAI para permitir filtragem e segmentação poderosas:

Esses metadados podem ser usados para filtrar logs, traces e métricas no painel do Portkey, permitindo analisar execuções específicas do crew, usuários ou ambientes.
  </Tab>
</Tabs>

### 2. Confiabilidade - Mantenha Seus Crews Funcionando Sem Interrupções

Ao executar crews em produção, problemas podem ocorrer – limites de taxa da API, problemas de rede ou indisponibilidade do provedor. Os recursos de confiabilidade do Portkey garantem que seus agentes continuem funcionando mesmo quando problemas surgem.

É simples habilitar fallback na sua configuração CrewAI usando um Config do Portkey:

```python  theme={null}
from crewai import LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Gere a Chave de API" icon="lock">
    Crie uma chave de API Portkey com limites de orçamento/taxa opcionais no [painel da Portkey](https://app.portkey.ai/). Você também pode adicionar configurações para confiabilidade, cache e outros recursos a essa chave. Mais sobre isso em breve.
  </Step>

  <Step title="Configure o CrewAI com Portkey">
    A integração é simples – basta atualizar a configuração do LLM no seu setup do CrewAI:
```

Example 2 (unknown):
```unknown
<Info>
      **O que são Virtual Keys?** Virtual keys no Portkey armazenam com segurança suas chaves de API dos provedores LLM (OpenAI, Anthropic, etc.) em um cofre criptografado. Elas facilitam a rotação de chaves e o gerenciamento de orçamento. [Saiba mais sobre virtual keys aqui](https://portkey.ai/docs/product/ai-gateway/virtual-keys).
    </Info>
  </Step>
</Steps>

## Recursos para Produção

### 1. Observabilidade Avançada

Portkey oferece observabilidade abrangente para seus agentes CrewAI, ajudando você a entender exatamente o que está acontecendo durante cada execução.

<Tabs>
  <Tab title="Traces">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Product%2011.1.webp" />
    </Frame>

    Os traces fornecem uma visão hierárquica da execução do seu crew, mostrando a sequência de chamadas LLM, ativações de ferramentas e transições de estado.
```

Example 3 (unknown):
```unknown
</Tab>

  <Tab title="Logs">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Metadata.png" />
    </Frame>

    Portkey registra cada interação com LLMs, incluindo:

    * Payloads completos das requisições e respostas
    * Métricas de latência e uso de tokens
    * Cálculos de custo
    * Chamadas de ferramentas e execuções de funções

    Todos os logs podem ser filtrados por metadados, trace IDs, modelos e mais, tornando mais fácil depurar execuções específicas do crew.
  </Tab>

  <Tab title="Métricas & Dashboards">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Dashboard.png" />
    </Frame>

    Portkey oferece dashboards integrados que ajudam você a:

    * Rastrear custos e uso de tokens em todas as execuções do crew
    * Analisar métricas de desempenho, como latência e taxas de sucesso
    * Identificar gargalos nos fluxos de trabalho dos agentes
    * Comparar diferentes configurações de crew e LLMs

    Você pode filtrar e segmentar todas as métricas por metadados personalizados para analisar tipos de crew, grupos de usuários ou casos de uso específicos.
  </Tab>

  <Tab title="Filtragem por Metadados">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" alt="Analytics with metadata filters" />
    </Frame>

    Adicione metadados personalizados à configuração LLM do seu CrewAI para permitir filtragem e segmentação poderosas:
```

Example 4 (unknown):
```unknown
Esses metadados podem ser usados para filtrar logs, traces e métricas no painel do Portkey, permitindo analisar execuções específicas do crew, usuários ou ambientes.
  </Tab>
</Tabs>

### 2. Confiabilidade - Mantenha Seus Crews Funcionando Sem Interrupções

Ao executar crews em produção, problemas podem ocorrer – limites de taxa da API, problemas de rede ou indisponibilidade do provedor. Os recursos de confiabilidade do Portkey garantem que seus agentes continuem funcionando mesmo quando problemas surgem.

É simples habilitar fallback na sua configuração CrewAI usando um Config do Portkey:
```

---

## Inicialize a ferramenta com parâmetros pré-definidos

**URL:** llms-txt#inicialize-a-ferramenta-com-parâmetros-pré-definidos

**Contents:**
- Parâmetros
- Uso

scrape_tool = ScrapeElementFromWebsiteTool(
    website_url="https://www.example.com",
    css_element=".main-content"
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros

A `ScrapeElementFromWebsiteTool` aceita os seguintes parâmetros durante a inicialização:

* **website\_url**: Opcional. A URL do website a ser extraído. Se fornecido na inicialização, o agente não precisará especificá-lo ao utilizar a ferramenta.
* **css\_element**: Opcional. O seletor CSS para os elementos a serem extraídos. Se fornecido na inicialização, o agente não precisará especificá-lo ao utilizar a ferramenta.
* **cookies**: Opcional. Um dicionário contendo cookies a serem enviados com a requisição. Isso pode ser útil para sites que requerem autenticação.

## Uso

Ao utilizar a `ScrapeElementFromWebsiteTool` com um agente, o agente precisará fornecer os seguintes parâmetros (a menos que já tenham sido especificados na inicialização):

* **website\_url**: A URL do website a ser extraído.
* **css\_element**: O seletor CSS dos elementos a serem extraídos.

A ferramenta retornará o conteúdo de texto de todos os elementos que correspondam ao seletor CSS, separados por quebras de linha.
```

---

## 예시 server_params (서버 유형에 따라 하나 선택):

**URL:** llms-txt#예시-server_params-(서버-유형에-따라-하나-선택):

---

## Crie tarefas

**URL:** llms-txt#crie-tarefas

research_task = Task(
    description="Pesquise as tendências mais recentes em IA",
    agent=researcher
)

writing_task = Task(
    description="Escreva um relatório abrangente com base na pesquisa",
    agent=writer
)

---

## ✅ Disable for focused specialists (optional)

**URL:** llms-txt#✅-disable-for-focused-specialists-(optional)

**Contents:**
  - 3. **컨텍스트 공유**

specialist_agent = Agent(
    role="Data Analyst", 
    allow_delegation=False,  # Focuses on core expertise
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 3. **컨텍스트 공유**
```

---

## Inicialize a ferramenta para buscas gerais em vídeos do YouTube

**URL:** llms-txt#inicialize-a-ferramenta-para-buscas-gerais-em-vídeos-do-youtube

youtube_search_tool = YoutubeVideoSearchTool()

---

## Telemetry

**URL:** llms-txt#telemetry

**Contents:**
- Telemetry
  - Examples:

Source: https://docs.crewai.com/en/telemetry

Understanding the telemetry data collected by CrewAI and how it contributes to the enhancement of the library.

<Note>
  By default, we collect no data that would be considered personal information under GDPR and other privacy regulations.
  We do collect Tool's names and Agent's roles, so be advised not to include any personal information in the tool's names or the Agent's roles.
  Because no personal information is collected, it's not necessary to worry about data residency.
  When `share_crew` is enabled, additional data is collected which may contain personal information if included by the user.
  Users should exercise caution when enabling this feature to ensure compliance with privacy regulations.
</Note>

CrewAI utilizes anonymous telemetry to gather usage statistics with the primary goal of enhancing the library.
Our focus is on improving and developing the features, integrations, and tools most utilized by our users.

It's pivotal to understand that by default, **NO personal data is collected** concerning prompts, task descriptions, agents' backstories or goals,
usage of tools, API calls, responses, any data processed by the agents, or secrets and environment variables.
When the `share_crew` feature is enabled, detailed data including task descriptions, agents' backstories or goals, and other specific attributes are collected
to provide deeper insights. This expanded data collection may include personal information if users have incorporated it into their crews or tasks.
Users should carefully consider the content of their crews and tasks before enabling `share_crew`.
Users can disable telemetry by setting the environment variable `CREWAI_DISABLE_TELEMETRY` to `true` or by setting `OTEL_SDK_DISABLED` to `true` (note that the latter disables all OpenTelemetry instrumentation globally).

```python  theme={null}

---

## ✅ Correto

**URL:** llms-txt#✅-correto

**Contents:**
- Testando Seu LLM Personalizado

def __init__(self, model: str, api_key: str, temperature: Optional[float] = None):
    super().__init__(model=model, temperature=temperature)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Chamada de Funções Não Funciona**

* Certifique-se de que `supports_function_calling()` retorna `True`
* Verifique se você lida com `tool_calls` na resposta
* Assegure-se de que o parâmetro `available_functions` está sendo corretamente utilizado

**Falhas de Autenticação**

* Verifique o formato e as permissões da chave de API
* Confira o formato do header de autenticação
* Certifique-se de que as URLs dos endpoints estão corretas

**Erros de Parsing de Resposta**

* Valide a estrutura da resposta antes de acessar campos aninhados
* Trate casos em que o content pode ser None
* Adicione tratamento de erros para respostas malformadas

## Testando Seu LLM Personalizado
```

---

## Verifique se o local do armazenamento é consistente

**URL:** llms-txt#verifique-se-o-local-do-armazenamento-é-consistente

**Contents:**
- Configuração Personalizada de Embedders
  - Por que Escolher Diferentes Provedores de Embeddings?
  - OpenAI Embeddings (Padrão)

import os
print("CREWAI_STORAGE_DIR:", os.getenv("CREWAI_STORAGE_DIR"))
print("Current working directory:", os.getcwd())
print("Computed storage path:", db_storage_path())
python  theme={null}
from crewai import Crew

**Examples:**

Example 1 (unknown):
```unknown
## Configuração Personalizada de Embedders

O CrewAI suporta múltiplos provedores de embeddings para oferecer flexibilidade na escolha da melhor opção para seu caso de uso. Aqui está um guia completo para configuração de diferentes provedores de embeddings para seu sistema de memória.

### Por que Escolher Diferentes Provedores de Embeddings?

* **Otimização de Custos**: Embeddings locais (Ollama) são gratuitos após configuração inicial
* **Privacidade**: Mantenha seus dados locais com Ollama ou use seu provedor preferido na nuvem
* **Desempenho**: Alguns modelos têm melhor desempenho para domínios ou idiomas específicos
* **Consistência**: Combine seu provedor de embedding com o de LLM
* **Conformidade**: Atenda a requisitos regulatórios ou organizacionais

### OpenAI Embeddings (Padrão)

A OpenAI oferece embeddings confiáveis e de alta qualidade para a maioria dos cenários.
```

---

## Create your custom LLM

**URL:** llms-txt#create-your-custom-llm

custom_llm = CustomLLM(
    model="my-custom-model",
    api_key="your-api-key",
    endpoint="https://api.example.com/v1/chat/completions",
    temperature=0.7
)

---

## Create task

**URL:** llms-txt#create-task

research_task = Task(
    description="Research the latest developments in AI agent frameworks",
    expected_output="Comprehensive research report with citations",
    agent=research_agent
)

---

## 대안: 작업을 더 작은 단위로 나누기

**URL:** llms-txt#대안:-작업을-더-작은-단위로-나누기

---

## Initialize the tool with a specific MDX file path for an exclusive search within that document

**URL:** llms-txt#initialize-the-tool-with-a-specific-mdx-file-path-for-an-exclusive-search-within-that-document

**Contents:**
- 매개변수
- 모델 및 임베딩 커스터마이징

tool = MDXSearchTool(mdx='path/to/your/document.mdx')
python Code theme={null}
from chromadb.config import Settings

tool = MDXSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 매개변수

* mdx: **선택 사항**. 검색에 사용할 MDX 파일 경로를 지정합니다. 초기화 시 제공할 수 있습니다.

## 모델 및 임베딩 커스터마이징

이 도구는 기본적으로 임베딩과 요약을 위해 OpenAI를 사용합니다. 커스터마이징을 위해 아래와 같이 설정 딕셔너리를 사용할 수 있습니다.
```

---

## Integração LangDB

**URL:** llms-txt#integração-langdb

Source: https://docs.crewai.com/pt-BR/observability/langdb

Governe, proteja e otimize seus fluxos de trabalho CrewAI com LangDB AI Gateway—acesse mais de 350 modelos, roteamento automático, otimização de custos e observabilidade completa.

---

## 사용자 정의 경로가 있는 서버

**URL:** llms-txt#사용자-정의-경로가-있는-서버

**Contents:**
  - 특정 도구 선택

"https://services.company.com/api/v1/mcp"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 특정 도구 선택

`#` 구문을 사용하여 서버에서 특정 도구를 선택하세요:
```

---

## Exemplo: busca com filtro de categoria

**URL:** llms-txt#exemplo:-busca-com-filtro-de-categoria

---

## Load documents

**URL:** llms-txt#load-documents

docs_to_load = os.listdir("knowledge")
with test_docs.batch.dynamic() as batch:
    for d in docs_to_load:
        with open(os.path.join("knowledge", d), "r") as f:
            content = f.read()
        batch.add_object(
            {
                "content": content,
                "year": d.split("_")[0],
            }
        )

---

## Option 3: Agent-level embedding customization

**URL:** llms-txt#option-3:-agent-level-embedding-customization

**Contents:**
- Recursos Avançados
  - Reescrita de Consulta

agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "google",
        "config": {
            "model": "models/text-embedding-004",
            "api_key": "your-google-key"
        }
    }
)
python  theme={null}
agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "azure",
        "config": {
            "api_key": "your-azure-api-key",
            "model": "text-embedding-ada-002", # change to the model you are using and is deployed in Azure
            "api_base": "https://your-azure-endpoint.openai.azure.com/",
            "api_version": "2024-02-01"
        }
    }
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### Configurando Embeddings do Azure OpenAI

Ao usar embeddings do Azure OpenAI:

1. Certifique-se de implantar o modelo de embedding na plataforma Azure primeiro
2. Então você precisa usar a seguinte configuração:
```

Example 2 (unknown):
```unknown
## Recursos Avançados

### Reescrita de Consulta

O CrewAI implementa um mecanismo inteligente de reescrita de consulta para otimizar a recuperação de knowledge. Quando um agente precisa pesquisar nas fontes de knowledge, o prompt da tarefa bruto é automaticamente transformado em uma consulta de pesquisa mais eficaz.

#### Como a Reescrita de Consulta Funciona

1. Quando um agente executa uma tarefa com fontes de knowledge disponíveis, o método `_get_knowledge_search_query` é acionado
2. O LLM do agente é usado para transformar o prompt original da tarefa em uma consulta de pesquisa otimizada
3. Esta consulta otimizada é então usada para recuperar informações relevantes das fontes de knowledge

#### Benefícios da Reescrita de Consulta

<CardGroup cols={2}>
  <Card title="Precisão de Recuperação Melhorada" icon="bullseye-arrow">
    Ao focar em conceitos-chave e remover conteúdo irrelevante, a reescrita de consulta ajuda a recuperar informações mais relevantes.
  </Card>

  <Card title="Consciência de Contexto" icon="brain">
    As consultas reescritas são projetadas para ser mais específicas e conscientes do contexto para recuperação de banco de dados vetorial.
  </Card>
</CardGroup>

#### Exemplo
```

---

## Salesforce 트리거

**URL:** llms-txt#salesforce-트리거

**Contents:**
- 개요
- 데모
- 시작하기
- 사용 사례
- 다음 단계

Source: https://docs.crewai.com/ko/enterprise/guides/salesforce-trigger

Salesforce 워크플로우에서 CrewAI crew를 트리거하여 CRM 자동화

CrewAI AMP는 Salesforce에서 트리거되어 고객 관계 관리 워크플로우를 자동화하고 영업 운영을 강화할 수 있습니다.

Salesforce는 기업이 영업, 서비스, 마케팅 운영을 효율화할 수 있도록 돕는 선도적인 고객 관계 관리(CRM) 플랫폼입니다. Salesforce에서 CrewAI 트리거를 설정하면 다음과 같은 작업을 수행할 수 있습니다:

* 리드 점수 산정 및 자격 심사 자동화
* 개인화된 영업 자료 생성
* AI 기반 응답으로 고객 서비스 강화
* 데이터 분석 및 보고 간소화

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/oJunVqjjfu4" title="CrewAI + Salesforce trigger demo" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

Salesforce 트리거를 설정하려면:

1. **지원팀 문의**: Salesforce 트리거 설정을 위해 CrewAI AMP 지원팀에 연락하세요.
2. **요구 사항 검토**: 필요한 Salesforce 권한과 API 액세스 권한이 있는지 확인하세요.
3. **연결 구성**: 지원팀과 협력하여 CrewAI와 귀하의 Salesforce 인스턴스 간의 연결을 설정하세요.
4. **트리거 테스트**: 트리거가 귀하의 특정 사용 사례에 맞게 올바르게 작동하는지 확인하세요.

일반적인 Salesforce + CrewAI 트리거 시나리오는 다음과 같습니다:

* **Lead 처리**: 들어오는 리드를 자동으로 분석하고 점수화
* **제안서 생성**: 기회 데이터를 기반으로 맞춤형 제안서 생성
* **고객 인사이트**: 고객 상호작용 이력에서 분석 보고서 생성
* **후속 조치 자동화**: 개인화된 후속 메시지 및 추천 생성

자세한 설정 지침 및 고급 구성 옵션에 대해서는 CrewAI AMP 지원팀에 문의해 주시기 바랍니다. 지원팀은 귀하의 특정 Salesforce 환경과 비즈니스 요구에 맞는 맞춤형 안내를 제공해 드릴 수 있습니다.

---

## Task to create a new task

**URL:** llms-txt#task-to-create-a-new-task

create_task = Task(
    description="Create a task called 'Review Q1 Reports' in the Marketing list with high priority",
    agent=clickup_agent,
    expected_output="Task created successfully with task ID"
)

---

## Create agent with specific Gmail actions only

**URL:** llms-txt#create-agent-with-specific-gmail-actions-only

email_coordinator = Agent(
    role="Email Coordinator",
    goal="Coordinate email communications and manage drafts",
    backstory="An AI assistant that focuses on email coordination and draft management.",
    apps=[
        'gmail/send_email',
        'gmail/fetch_emails',
        'gmail/create_draft'
    ]
)

---

## OpenAI 키

**URL:** llms-txt#openai-키

os.environ["OPENAI_API_KEY"] = "sk-proj-..."
python  theme={null}
from langfuse import get_client
 
langfuse = get_client()

**Examples:**

Example 1 (unknown):
```unknown
환경 변수를 설정하면 이제 Langfuse 클라이언트를 초기화할 수 있습니다. get\_client()는 환경 변수에 제공된 자격 증명을 사용하여 Langfuse 클라이언트를 초기화합니다.
```

---

## 리스트를 즉시 수정하는 대신:

**URL:** llms-txt#리스트를-즉시-수정하는-대신:

self.state.items.append(new_item)  # 변경 가능한 연산

---

## Original task prompt

**URL:** llms-txt#original-task-prompt

task_prompt = "Answer the following questions about the user's favorite movies: What movie did John watch last week? Format your answer in JSON."

---

## Busca Vetorial Weaviate

**URL:** llms-txt#busca-vetorial-weaviate

**Contents:**
- Visão Geral
- Instalação
- Etapas para Começar
- Exemplo

Source: https://docs.crewai.com/pt-BR/tools/database-data/weaviatevectorsearchtool

O `WeaviateVectorSearchTool` foi projetado para buscar documentos semanticamente similares em um banco de dados vetorial Weaviate.

O `WeaviateVectorSearchTool` foi especificamente desenvolvido para realizar buscas semânticas em documentos armazenados em um banco de dados vetorial Weaviate. Essa ferramenta permite encontrar documentos semanticamente similares a uma determinada consulta, aproveitando o poder das embeddings vetoriais para resultados de busca mais precisos e contextualmente relevantes.

[Weaviate](https://weaviate.io/) é um banco de dados vetorial que armazena e consulta embeddings vetoriais, possibilitando recursos de busca semântica.

Para incorporar esta ferramenta ao seu projeto, é necessário instalar o cliente Weaviate:

## Etapas para Começar

Para utilizar efetivamente o `WeaviateVectorSearchTool`, siga as etapas abaixo:

1. **Instalação dos Pacotes**: Confirme que os pacotes `crewai[tools]` e `weaviate-client` estão instalados em seu ambiente Python.
2. **Configuração do Weaviate**: Configure um cluster Weaviate. Você pode seguir as instruções na [documentação do Weaviate](https://weaviate.io/developers/wcs/manage-clusters/connect).
3. **Chaves de API**: Obtenha a URL do seu cluster Weaviate e a chave de API correspondente.
4. **Chave de API da OpenAI**: Certifique-se de que você tenha uma chave de API da OpenAI definida nas variáveis de ambiente como `OPENAI_API_KEY`.

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca:

```python Code theme={null}
from crewai_tools import WeaviateVectorSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Etapas para Começar

Para utilizar efetivamente o `WeaviateVectorSearchTool`, siga as etapas abaixo:

1. **Instalação dos Pacotes**: Confirme que os pacotes `crewai[tools]` e `weaviate-client` estão instalados em seu ambiente Python.
2. **Configuração do Weaviate**: Configure um cluster Weaviate. Você pode seguir as instruções na [documentação do Weaviate](https://weaviate.io/developers/wcs/manage-clusters/connect).
3. **Chaves de API**: Obtenha a URL do seu cluster Weaviate e a chave de API correspondente.
4. **Chave de API da OpenAI**: Certifique-se de que você tenha uma chave de API da OpenAI definida nas variáveis de ambiente como `OPENAI_API_KEY`.

## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca:
```

---

## Exemplo de uso da ferramenta com um agente

**URL:** llms-txt#exemplo-de-uso-da-ferramenta-com-um-agente

web_scraper_agent = Agent(
    role="Web Scraper",
    goal="Extrair elementos específicos de websites",
    backstory="Um especialista em web scraping capaz de extrair conteúdo direcionado por meio de seletores CSS.",
    tools=[scrape_tool],
    verbose=True,
)

---

## MLflow 통합

**URL:** llms-txt#mlflow-통합

Source: https://docs.crewai.com/ko/observability/mlflow

MLflow를 사용하여 에이전트 모니터링을 빠르게 시작하세요.

---

## 폼 필드 식별

**URL:** llms-txt#폼-필드-식별

**Contents:**
- 구성 옵션
- 모범 사례
- 문제 해결
- 추가 자료

result = stagehand_tool.run(
    instruction="Identify all the input fields in the registration form", 
    url="https://example.com/register",
    command_type="observe",
    selector="#registration-form"
)
python  theme={null}
stagehand_tool = StagehandTool(
    api_key="your-browserbase-api-key",
    project_id="your-browserbase-project-id",
    model_api_key="your-llm-api-key",
    model_name=AvailableModel.CLAUDE_3_7_SONNET_LATEST,
    dom_settle_timeout_ms=5000,  # DOM이 안정될 때까지 더 오래 대기
    headless=True,  # 브라우저를 헤드리스 모드로 실행
    self_heal=True,  # 오류에서 복구를 시도
    wait_for_captcha_solves=True,  # CAPTCHA 해결을 기다림
    verbose=1,  # 로깅 상세 수준 제어 (0-3)
)
```

1. **구체적으로 작성하기**: 더 나은 결과를 위해 상세한 지침을 제공하세요
2. **적절한 명령 유형 선택**: 작업에 맞는 올바른 명령 유형을 선택하세요
3. **셀렉터 사용하기**: CSS 셀렉터를 활용하여 정확성을 높이세요
4. **복잡한 작업 분할**: 복잡한 작업 흐름을 여러 번의 도구 호출로 분할하세요
5. **오류 처리 구현**: 잠재적인 문제를 대비하여 오류 처리를 추가하세요

* **세션 문제**: Browserbase와 LLM 공급자 모두의 API 키를 확인하세요.
* **요소를 찾을 수 없음**: 느린 페이지의 경우 `dom_settle_timeout_ms`를 늘리세요.
* **동작 실패**: 먼저 `observe`를 사용하여 올바른 요소를 식별하세요.
* **불완전한 데이터**: 지시사항을 개선하거나 구체적인 셀렉터를 제공하세요.

CrewAI 통합에 대한 질문이 있으신가요?

* Stagehand의 [Slack 커뮤니티](https://stagehand.dev/slack)에 참여하세요
* [Stagehand 저장소](https://github.com/browserbase/stagehand)에 이슈를 등록하세요
* [Stagehand 문서](https://docs.stagehand.dev/)를 방문하세요

**Examples:**

Example 1 (unknown):
```unknown
## 구성 옵션

다음 매개변수로 StagehandTool의 동작을 사용자 지정할 수 있습니다:
```

---

## para busca exclusiva dentro desse documento

**URL:** llms-txt#para-busca-exclusiva-dentro-desse-documento

**Contents:**
- Argumentos
- Modelo customizado e embeddings

tool = XMLSearchTool(xml='path/to/your/xmlfile.xml')
python Code   theme={null}
from chromadb.config import Settings

tool = XMLSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # ou "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `xml`: Este é o caminho para o arquivo XML que você deseja buscar.
  Este parâmetro é opcional durante a inicialização da ferramenta, mas deve ser fornecido ou na inicialização ou como parte dos argumentos do método `run` para executar a busca.

## Modelo customizado e embeddings

Por padrão, a ferramenta utiliza a OpenAI tanto para embeddings quanto para sumarização. Para personalizar o modelo, você pode usar um dicionário de configuração conforme o exemplo a seguir:
```

---

## Inicialize a ferramenta com a URI do banco de dados e o nome da tabela alvo

**URL:** llms-txt#inicialize-a-ferramenta-com-a-uri-do-banco-de-dados-e-o-nome-da-tabela-alvo

**Contents:**
- Argumentos
- Modelo Personalizado e Embeddings

tool = PGSearchTool(
    db_uri='postgresql://user:password@localhost:5432/mydatabase', 
    table_name='employees'
)
python Code theme={null}
tool = PGSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # ou google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # ou openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

O PGSearchTool foi projetado para exigir os seguintes argumentos para seu funcionamento:

| Argumento       | Tipo     | Descrição                                                                                                                                                                                                                 |
| :-------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **db\_uri**     | `string` | **Obrigatório**. Uma string que representa a URI do banco de dados PostgreSQL a ser consultado. Este argumento será obrigatório e deve incluir os detalhes necessários de autenticação e a localização do banco de dados. |
| **table\_name** | `string` | **Obrigatório**. Uma string que especifica o nome da tabela dentro do banco de dados na qual a busca semântica será realizada. Este argumento também será obrigatório.                                                    |

## Modelo Personalizado e Embeddings

A ferramenta pretende usar OpenAI tanto para embeddings quanto para sumarização por padrão. Os usuários terão a opção de personalizar o modelo usando um dicionário de configuração, conforme mostrado abaixo:
```

---

## Create with proper permissions

**URL:** llms-txt#create-with-proper-permissions

if not os.path.exists(storage_path):
    os.makedirs(storage_path, mode=0o755, exist_ok=True)
    print(f"Created storage directory: {storage_path}")
python  theme={null}
import chromadb
from crewai.utilities.paths import db_storage_path

**Examples:**

Example 1 (unknown):
```unknown
#### ChromaDB 컬렉션 검사하기
```

---

## 사용자 지정 구성으로 RAG 도구 생성

**URL:** llms-txt#사용자-지정-구성으로-rag-도구-생성

**Contents:**
- 결론

config = {
    "app": {
        "name": "custom_app",
    },
    "llm": {
        "provider": "openai",
        "config": {
            "model": "gpt-4",
        }
    },
    "embedding_model": {
        "provider": "openai",
        "config": {
            "model": "text-embedding-ada-002"
        }
    },
    "vectordb": {
        "provider": "elasticsearch",
        "config": {
            "collection_name": "my-collection",
            "cloud_id": "deployment-name:xxxx",
            "api_key": "your-key",
            "verify_certs": False
        }
    },
    "chunker": {
        "chunk_size": 400,
        "chunk_overlap": 100,
        "length_function": "len",
        "min_chunk_size": 0
    }
}

rag_tool = RagTool(config=config, summarize=True)
```

내부 RAG 도구는 Embedchain 어댑터를 사용하므로 Embedchain에서 지원하는 모든 구성 옵션을 전달할 수 있습니다.
자세한 내용은 [Embedchain 문서](https://docs.embedchain.ai/components/introduction)를 참조하세요.
.yaml 파일에서 제공되는 구성 옵션을 반드시 검토하시기 바랍니다.

`RagTool`은 다양한 데이터 소스에서 지식 베이스를 생성하고 질의할 수 있는 강력한 방법을 제공합니다. Retrieval-Augmented Generation을 활용하여, 에이전트가 관련 정보를 효율적으로 접근하고 검색할 수 있게 하여, 보다 정확하고 상황에 맞는 응답을 제공하는 능력을 향상시킵니다.

---

## Exemplo 1: Inicializando a partir do FunctionTool

**URL:** llms-txt#exemplo-1:-inicializando-a-partir-do-functiontool

def search_data(query: str) -> str:
    """Busca por informações nos dados."""
    # Sua implementação aqui
    return f"Results for: {query}"

---

## Scrape Website

**URL:** llms-txt#scrape-website

Source: https://docs.crewai.com/en/tools/web-scraping/scrapewebsitetool

The `ScrapeWebsiteTool` is designed to extract and read the content of a specified website.

---

## Create a task for the agent to read a specific file

**URL:** llms-txt#create-a-task-for-the-agent-to-read-a-specific-file

read_config_task = Task(
    description="Read the application configuration file from {my_bucket} and extract the database connection settings.",
    expected_output="The database connection settings from the configuration file.",
    agent=file_reader_agent,
)

---

## ❌ Errado - parâmetros obrigatórios ausentes

**URL:** llms-txt#❌-errado---parâmetros-obrigatórios-ausentes

def __init__(self, api_key: str):
    super().__init__()

---

## Oxylabs Scrapers

**URL:** llms-txt#oxylabs-scrapers

**Contents:**
- Instalação

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/oxylabsscraperstool

Os Scrapers da Oxylabs permitem acessar facilmente informações de fontes específicas. Veja abaixo a lista de fontes disponíveis:
  - `Amazon Product`
  - `Amazon Search`
  - `Google Seach`
  - `Universal`

Obtenha as credenciais criando uma conta na Oxylabs [aqui](https://oxylabs.io).

Confira a [Documentação da Oxylabs](https://developers.oxylabs.io/scraping-solutions/web-scraper-api/targets) para mais informações sobre os parâmetros da API.

---

## 실제 payload로 Microsoft Teams 트리거 시뮬레이션

**URL:** llms-txt#실제-payload로-microsoft-teams-트리거-시뮬레이션

**Contents:**
- Troubleshooting

crewai triggers run microsoft_teams/teams_message_created
```

`crewai triggers run` 명령은 완전한 Teams payload로 크루를 실행하여 배포 전에 파싱 로직을 테스트할 수 있게 해줍니다.

<Warning>
  개발 중에는 `crewai triggers run microsoft_teams/teams_message_created`를 사용하세요 (`crewai run`이 아님). 배포 후에는 크루가 자동으로 트리거 payload를 받습니다.
</Warning>

* Ensure the Teams connection is active; it must be refreshed if the tenant revokes permissions
* `crewai triggers run microsoft_teams/teams_message_created`로 로컬 테스트하여 정확한 payload 구조를 확인하세요
* Confirm the webhook subscription in Microsoft 365 is still valid if payloads stop arriving
* Review execution logs for payload shape mismatches—Graph notifications may omit fields when a chat is private or restricted
* 주의: 트리거 실행을 시뮬레이션하려면 `crewai triggers run`을 사용하세요 (`crewai run`이 아님)

---

## Escrita de Arquivo

**URL:** llms-txt#escrita-de-arquivo

Source: https://docs.crewai.com/pt-BR/tools/file-document/filewritetool

O `FileWriterTool` foi projetado para escrever conteúdo em arquivos.

---

## Microsoft Outlook 통합

**URL:** llms-txt#microsoft-outlook-통합

**Contents:**
- 개요
- 전제 조건
- Microsoft Outlook 통합 설정
  - 1. Microsoft 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Microsoft Outlook 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/microsoft_outlook

CrewAI를 위한 Microsoft Outlook 통합으로 이메일, 캘린더 및 연락처 관리.

에이전트가 Outlook 이메일, 캘린더 이벤트 및 연락처에 액세스하고 관리할 수 있도록 합니다. AI 기반 자동화로 이메일을 보내고, 메시지를 검색하고, 캘린더 이벤트를 관리하며, 연락처를 구성합니다.

Microsoft Outlook 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Outlook 액세스 권한이 있는 Microsoft 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Microsoft 계정 연결

## Microsoft Outlook 통합 설정

### 1. Microsoft 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Microsoft Outlook** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 이메일, 캘린더 및 연락처 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="microsoft_outlook/get_messages">
    **설명:** 사용자의 사서함에서 이메일 메시지를 가져옵니다.

* `top` (integer, 선택사항): 검색할 메시지 수 (최대 1000). 기본값: 10.
    * `filter` (string, 선택사항): OData 필터 표현식 (예: "isRead eq false").
    * `search` (string, 선택사항): 검색 쿼리 문자열.
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "receivedDateTime desc"). 기본값: "receivedDateTime desc".
    * `select` (string, 선택사항): 반환할 특정 속성 선택.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
  </Accordion>

<Accordion title="microsoft_outlook/send_email">
    **설명:** 이메일 메시지를 보냅니다.

* `to_recipients` (array, 필수): 받는 사람의 이메일 주소 배열.
    * `cc_recipients` (array, 선택사항): 참조 받는 사람의 이메일 주소 배열.
    * `bcc_recipients` (array, 선택사항): 숨은 참조 받는 사람의 이메일 주소 배열.
    * `subject` (string, 필수): 이메일 제목.
    * `body` (string, 필수): 이메일 본문 내용.
    * `body_type` (string, 선택사항): 본문 내용 유형. 옵션: Text, HTML. 기본값: HTML.
    * `importance` (string, 선택사항): 메시지 중요도 수준. 옵션: low, normal, high. 기본값: normal.
    * `reply_to` (array, 선택사항): 회신용 이메일 주소 배열.
    * `save_to_sent_items` (boolean, 선택사항): 보낸 편지함 폴더에 메시지를 저장할지 여부. 기본값: true.
  </Accordion>

<Accordion title="microsoft_outlook/get_calendar_events">
    **설명:** 사용자의 캘린더에서 캘린더 이벤트를 가져옵니다.

* `top` (integer, 선택사항): 검색할 이벤트 수 (최대 1000). 기본값: 10.
    * `skip` (integer, 선택사항): 건너뛸 이벤트 수. 기본값: 0.
    * `filter` (string, 선택사항): OData 필터 표현식 (예: "start/dateTime ge '2024-01-01T00:00:00Z'").
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "start/dateTime asc"). 기본값: "start/dateTime asc".
  </Accordion>

<Accordion title="microsoft_outlook/create_calendar_event">
    **설명:** 새 캘린더 이벤트를 만듭니다.

* `subject` (string, 필수): 이벤트 제목/제목.
    * `body` (string, 선택사항): 이벤트 본문/설명.
    * `start_datetime` (string, 필수): ISO 8601 형식의 시작 날짜 및 시간 (예: '2024-01-20T10:00:00').
    * `end_datetime` (string, 필수): ISO 8601 형식의 종료 날짜 및 시간.
    * `timezone` (string, 선택사항): 시간대 (예: 'Pacific Standard Time'). 기본값: UTC.
    * `location` (string, 선택사항): 이벤트 위치.
    * `attendees` (array, 선택사항): 참석자의 이메일 주소 배열.
  </Accordion>

<Accordion title="microsoft_outlook/get_contacts">
    **설명:** 사용자의 주소록에서 연락처를 가져옵니다.

* `top` (integer, 선택사항): 검색할 연락처 수 (최대 1000). 기본값: 10.
    * `skip` (integer, 선택사항): 건너뛸 연락처 수. 기본값: 0.
    * `filter` (string, 선택사항): OData 필터 표현식.
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "displayName asc"). 기본값: "displayName asc".
  </Accordion>

<Accordion title="microsoft_outlook/create_contact">
    **설명:** 사용자의 주소록에 새 연락처를 만듭니다.

* `displayName` (string, 필수): 연락처의 표시 이름.
    * `givenName` (string, 선택사항): 연락처의 이름.
    * `surname` (string, 선택사항): 연락처의 성.
    * `emailAddresses` (array, 선택사항): 이메일 주소 배열. 각 항목은 `address` (string)와 `name` (string)이 있는 객체.
    * `businessPhones` (array, 선택사항): 사업용 전화번호 배열.
    * `homePhones` (array, 선택사항): 집 전화번호 배열.
    * `jobTitle` (string, 선택사항): 연락처의 직책.
    * `companyName` (string, 선택사항): 연락처의 회사 이름.
  </Accordion>
</AccordionGroup>

### 기본 Microsoft Outlook 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="microsoft_outlook/get_messages">
    **설명:** 사용자의 사서함에서 이메일 메시지를 가져옵니다.

    **매개변수:**

    * `top` (integer, 선택사항): 검색할 메시지 수 (최대 1000). 기본값: 10.
    * `filter` (string, 선택사항): OData 필터 표현식 (예: "isRead eq false").
    * `search` (string, 선택사항): 검색 쿼리 문자열.
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "receivedDateTime desc"). 기본값: "receivedDateTime desc".
    * `select` (string, 선택사항): 반환할 특정 속성 선택.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
  </Accordion>

  <Accordion title="microsoft_outlook/send_email">
    **설명:** 이메일 메시지를 보냅니다.

    **매개변수:**

    * `to_recipients` (array, 필수): 받는 사람의 이메일 주소 배열.
    * `cc_recipients` (array, 선택사항): 참조 받는 사람의 이메일 주소 배열.
    * `bcc_recipients` (array, 선택사항): 숨은 참조 받는 사람의 이메일 주소 배열.
    * `subject` (string, 필수): 이메일 제목.
    * `body` (string, 필수): 이메일 본문 내용.
    * `body_type` (string, 선택사항): 본문 내용 유형. 옵션: Text, HTML. 기본값: HTML.
    * `importance` (string, 선택사항): 메시지 중요도 수준. 옵션: low, normal, high. 기본값: normal.
    * `reply_to` (array, 선택사항): 회신용 이메일 주소 배열.
    * `save_to_sent_items` (boolean, 선택사항): 보낸 편지함 폴더에 메시지를 저장할지 여부. 기본값: true.
  </Accordion>

  <Accordion title="microsoft_outlook/get_calendar_events">
    **설명:** 사용자의 캘린더에서 캘린더 이벤트를 가져옵니다.

    **매개변수:**

    * `top` (integer, 선택사항): 검색할 이벤트 수 (최대 1000). 기본값: 10.
    * `skip` (integer, 선택사항): 건너뛸 이벤트 수. 기본값: 0.
    * `filter` (string, 선택사항): OData 필터 표현식 (예: "start/dateTime ge '2024-01-01T00:00:00Z'").
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "start/dateTime asc"). 기본값: "start/dateTime asc".
  </Accordion>

  <Accordion title="microsoft_outlook/create_calendar_event">
    **설명:** 새 캘린더 이벤트를 만듭니다.

    **매개변수:**

    * `subject` (string, 필수): 이벤트 제목/제목.
    * `body` (string, 선택사항): 이벤트 본문/설명.
    * `start_datetime` (string, 필수): ISO 8601 형식의 시작 날짜 및 시간 (예: '2024-01-20T10:00:00').
    * `end_datetime` (string, 필수): ISO 8601 형식의 종료 날짜 및 시간.
    * `timezone` (string, 선택사항): 시간대 (예: 'Pacific Standard Time'). 기본값: UTC.
    * `location` (string, 선택사항): 이벤트 위치.
    * `attendees` (array, 선택사항): 참석자의 이메일 주소 배열.
  </Accordion>

  <Accordion title="microsoft_outlook/get_contacts">
    **설명:** 사용자의 주소록에서 연락처를 가져옵니다.

    **매개변수:**

    * `top` (integer, 선택사항): 검색할 연락처 수 (최대 1000). 기본값: 10.
    * `skip` (integer, 선택사항): 건너뛸 연락처 수. 기본값: 0.
    * `filter` (string, 선택사항): OData 필터 표현식.
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "displayName asc"). 기본값: "displayName asc".
  </Accordion>

  <Accordion title="microsoft_outlook/create_contact">
    **설명:** 사용자의 주소록에 새 연락처를 만듭니다.

    **매개변수:**

    * `displayName` (string, 필수): 연락처의 표시 이름.
    * `givenName` (string, 선택사항): 연락처의 이름.
    * `surname` (string, 선택사항): 연락처의 성.
    * `emailAddresses` (array, 선택사항): 이메일 주소 배열. 각 항목은 `address` (string)와 `name` (string)이 있는 객체.
    * `businessPhones` (array, 선택사항): 사업용 전화번호 배열.
    * `homePhones` (array, 선택사항): 집 전화번호 배열.
    * `jobTitle` (string, 선택사항): 연락처의 직책.
    * `companyName` (string, 선택사항): 연락처의 회사 이름.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Microsoft Outlook 에이전트 설정
```

---

## Initialize the tool

**URL:** llms-txt#initialize-the-tool

scrape_tool = ScrapflyScrapeWebsiteTool(api_key="your_scrapfly_api_key")

---

## LlamaIndex Tool

**URL:** llms-txt#llamaindex-tool

Source: https://docs.crewai.com/en/tools/ai-ml/llamaindextool

The `LlamaIndexTool` is a wrapper for LlamaIndex tools and query engines.

---

## Execute a search

**URL:** llms-txt#execute-a-search

**Contents:**
- 에이전트 통합 예시

results = tool.run(search_query="Latest AI developments")
print(results)
python Code theme={null}
from crewai import Agent
from crewai.project import agent
from crewai_tools import BraveSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## 에이전트 통합 예시

다음은 `BraveSearchTool`을 CrewAI 에이전트와 통합하는 방법입니다:
```

---

## 런타임에 동적으로 디렉토리를 지정할 때

**URL:** llms-txt#런타임에-동적으로-디렉토리를-지정할-때

tool = DirectorySearchTool()

---

## Definir local de armazenamento personalizado

**URL:** llms-txt#definir-local-de-armazenamento-personalizado

os.environ["CREWAI_STORAGE_DIR"] = "./my_project_storage"

---

## Task to add new data to a spreadsheet

**URL:** llms-txt#task-to-add-new-data-to-a-spreadsheet

data_entry_task = Task(
    description="Add a new customer record to the customer database spreadsheet with name, email, and signup date",
    agent=sheets_agent,
    expected_output="New customer record added successfully to the spreadsheet"
)

---

## Fill out a form

**URL:** llms-txt#fill-out-a-form

**Contents:**
  - 2. Comando Extract

result = stagehand_tool.run(
    instruction="Fill the contact form with name 'John Doe', email 'john@example.com', and message 'Hello world'", 
    url="https://example.com/contact"
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 2. Comando Extract

O tipo de comando `extract` recupera dados estruturados de páginas web.
```

---

## Write content to a file in a specified directory

**URL:** llms-txt#write-content-to-a-file-in-a-specified-directory

**Contents:**
- 인자
- 결론

result = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')
print(result)
```

* `filename`: 생성하거나 덮어쓸 파일의 이름입니다.
* `content`: 파일에 쓸 내용입니다.
* `directory` (선택 사항): 파일이 생성될 디렉터리의 경로입니다. 기본값은 현재 디렉터리(`.`)입니다. 디렉터리가 존재하지 않으면 생성됩니다.

`FileWriterTool`을 crew에 통합함으로써, 에이전트는 다양한 운영 체제에서 파일에 내용을 안정적으로 쓸 수 있습니다.
이 도구는 출력 데이터를 저장하거나, 구조화된 파일 시스템을 생성하거나, 크로스 플랫폼 파일 작업을 처리해야 하는 작업에 필수적입니다.
특히 표준 Python 파일 작업에서 파일 쓰기 이슈가 발생할 수 있는 Windows 사용자에게 권장됩니다.

제공된 설정 및 사용 가이드라인을 준수하면, 이 도구를 프로젝트에 통합하는 과정이 간단하며 모든 플랫폼에서 일관된 파일 쓰기 동작을 보장합니다.

---

## ├── Especialista Técnico/    # Agent knowledge collection

**URL:** llms-txt#├──-especialista-técnico/----#-agent-knowledge-collection

---

## OR

**URL:** llms-txt#or

---

## Integração Microsoft Word

**URL:** llms-txt#integração-microsoft-word

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Microsoft Word
  - 1. Conecte sua Conta Microsoft
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Microsoft Word

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/microsoft_word

Criação e gerenciamento de documentos com integração Microsoft Word para CrewAI.

Permita que seus agentes criem, leiam e gerenciem documentos do Word e arquivos de texto no OneDrive ou SharePoint. Automatize a criação de documentos, recupere conteúdo, gerencie propriedades de documentos e simplifique seus fluxos de trabalho de documentos com automação alimentada por IA.

Antes de usar a integração Microsoft Word, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Microsoft com acesso ao Word e OneDrive/SharePoint
* Conectado sua conta Microsoft através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Microsoft Word

### 1. Conecte sua Conta Microsoft

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Microsoft Word** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a arquivos
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="microsoft_word/get_documents">
    **Descrição:** Obter todos os documentos do Word do OneDrive ou SharePoint.

* `select` (string, opcional): Selecionar propriedades específicas para retornar.
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas.
  </Accordion>

<Accordion title="microsoft_word/create_text_document">
    **Descrição:** Criar um documento de texto (.txt) com conteúdo. RECOMENDADO para criação de conteúdo programático que precisa ser legível e editável.

* `file_name` (string, obrigatório): Nome do documento de texto (deve terminar com .txt).
    * `content` (string, opcional): Conteúdo de texto para o documento. Padrão: "Este é um novo documento de texto criado via API."
  </Accordion>

<Accordion title="microsoft_word/get_document_content">
    **Descrição:** Obter o conteúdo de um documento (funciona melhor com arquivos de texto).

* `file_id` (string, obrigatório): O ID do documento.
  </Accordion>

<Accordion title="microsoft_word/get_document_properties">
    **Descrição:** Obter propriedades e metadados de um documento.

* `file_id` (string, obrigatório): O ID do documento.
  </Accordion>

<Accordion title="microsoft_word/delete_document">
    **Descrição:** Excluir um documento.

* `file_id` (string, obrigatório): O ID do documento a excluir.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Microsoft Word

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="microsoft_word/get_documents">
    **Descrição:** Obter todos os documentos do Word do OneDrive ou SharePoint.

    **Parâmetros:**

    * `select` (string, opcional): Selecionar propriedades específicas para retornar.
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas.
  </Accordion>

  <Accordion title="microsoft_word/create_text_document">
    **Descrição:** Criar um documento de texto (.txt) com conteúdo. RECOMENDADO para criação de conteúdo programático que precisa ser legível e editável.

    **Parâmetros:**

    * `file_name` (string, obrigatório): Nome do documento de texto (deve terminar com .txt).
    * `content` (string, opcional): Conteúdo de texto para o documento. Padrão: "Este é um novo documento de texto criado via API."
  </Accordion>

  <Accordion title="microsoft_word/get_document_content">
    **Descrição:** Obter o conteúdo de um documento (funciona melhor com arquivos de texto).

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do documento.
  </Accordion>

  <Accordion title="microsoft_word/get_document_properties">
    **Descrição:** Obter propriedades e metadados de um documento.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do documento.
  </Accordion>

  <Accordion title="microsoft_word/delete_document">
    **Descrição:** Excluir um documento.

    **Parâmetros:**

    * `file_id` (string, obrigatório): O ID do documento a excluir.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Microsoft Word
```

---

## Initialize the tool with a specific CSV file.

**URL:** llms-txt#initialize-the-tool-with-a-specific-csv-file.

---

## 자동 요약 비활성화 후 RAG 사용

**URL:** llms-txt#자동-요약-비활성화-후-rag-사용

**Contents:**
- `kickoff()`을 사용한 에이전트 직접 상호작용
  - `kickoff()` 작동 방식

agent = Agent(
    role="Detailed Analyst",
    goal="Maintain complete information accuracy",
    backstory="Expert requiring full context",
    respect_context_window=False,  # 요약 안 함
    tools=[RagTool()],  # 대용량 데이터에는 RAG 사용
    verbose=True
)
python Code theme={null}
from crewai import Agent
from crewai_tools import SerperDevTool

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  컨텍스트 윈도우 관리 기능은 백그라운드에서 자동으로 작동합니다. 특별한 함수를 호출할 필요가 없으며, 원하는 동작에 맞게 `respect_context_window`만 설정하면 CrewAI가 나머지를 처리합니다!
</Note>

## `kickoff()`을 사용한 에이전트 직접 상호작용

에이전트는 `kickoff()` 메서드를 사용하여 작업(task)이나 crew 워크플로우를 거치지 않고 직접 사용할 수 있습니다. 이는 전체 crew 오케스트레이션 기능이 필요하지 않을 때 에이전트와 상호작용하는 더 간단한 방법을 제공합니다.

### `kickoff()` 작동 방식

`kickoff()` 메서드는 메시지를 에이전트에게 직접 보내고 응답을 받을 수 있게 해줍니다. 이는 LLM과 상호 작용하는 것과 유사하지만, 에이전트의 모든 기능(도구, 추론 등)을 활용할 수 있다는 점이 다릅니다.
```

---

## Perform an action (default behavior)

**URL:** llms-txt#perform-an-action-(default-behavior)

result = stagehand_tool.run(
    instruction="Click the login button", 
    url="https://example.com",
    command_type="act"  # Default, so can be omitted
)

---

## 이는 연결 오버헤드를 최소화하고 시작 성능을 개선합니다

**URL:** llms-txt#이는-연결-오버헤드를-최소화하고-시작-성능을-개선합니다

**Contents:**
- 모범 사례
  - 1. 가능하면 특정 도구 사용

**Examples:**

Example 1 (unknown):
```unknown
## 모범 사례

### 1. 가능하면 특정 도구 사용
```

---

## Create a filter for specific conditions

**URL:** llms-txt#create-a-filter-for-specific-conditions

preset_filter = qmodels.Filter(
    must=[
        qmodels.FieldCondition(
            key="category",
            match=qmodels.MatchValue(value="research")
        ),
        qmodels.FieldCondition(
            key="year",
            match=qmodels.MatchValue(value=2024)
        )
    ]
)

---

## Opik 통합

**URL:** llms-txt#opik-통합

Source: https://docs.crewai.com/ko/observability/opik

Comet Opik을 사용하여 CrewAI 애플리케이션을 포괄적인 트레이싱, 자동 평가, 프로덕션 준비 대시보드로 디버그, 평가 및 모니터링하는 방법을 알아보세요.

---

## Integração Opik

**URL:** llms-txt#integração-opik

Source: https://docs.crewai.com/pt-BR/observability/opik

Saiba como usar o Comet Opik para depurar, avaliar e monitorar suas aplicações CrewAI com rastreamento abrangente, avaliações automatizadas e dashboards prontos para produção.

---

## os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # 🇺🇸 US region

**URL:** llms-txt#os.environ["langfuse_host"]-=-"https://us.cloud.langfuse.com"-#-🇺🇸-us-region

---

## 환경 변수 설정

**URL:** llms-txt#환경-변수-설정

**Contents:**
  - 3단계: Braintrust와 함께 OpenTelemetry 초기화하기
  - 4단계: CrewAI 애플리케이션 생성하기

os.environ["BRAINTRUST_API_KEY"] = BRAINTRUST_API_KEY
os.environ["BRAINTRUST_PARENT"] = "project_name:crewai-demo"
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
python  theme={null}
import os
from typing import Any, Dict

from braintrust.otel import BraintrustSpanProcessor
from crewai import Agent, Crew, Task
from crewai.llm import LLM
from opentelemetry import trace
from opentelemetry.instrumentation.crewai import CrewAIInstrumentor
from opentelemetry.instrumentation.openai import OpenAIInstrumentor
from opentelemetry.sdk.trace import TracerProvider

def setup_tracing() -> None:
    """Braintrust와 함께 OpenTelemetry 추적 설정."""
    current_provider = trace.get_tracer_provider()
    if isinstance(current_provider, TracerProvider):
        provider = current_provider
    else:
        provider = TracerProvider()
        trace.set_tracer_provider(provider)

provider.add_span_processor(BraintrustSpanProcessor())
    CrewAIInstrumentor().instrument(tracer_provider=provider)
    OpenAIInstrumentor().instrument(tracer_provider=provider)

setup_tracing()
python  theme={null}
from crewai import Agent, Crew, Process, Task
from crewai_tools import SerperDevTool

def create_crew() -> Crew:
    """포괄적인 추적을 위한 다중 agent가 있는 crew 생성."""
    llm = LLM(model="gpt-4o-mini")
    search_tool = SerperDevTool()

# 특정 역할을 가진 agent 정의
    researcher = Agent(
        role="시니어 연구 분석가",
        goal="AI 및 데이터 과학의 최첨단 발전 사항 발견",
        backstory="""당신은 최고 수준의 기술 싱크탱크에서 근무합니다.
        새로운 트렌드를 식별하는 데 전문성이 있습니다.
        복잡한 데이터를 분석하고 실행 가능한 인사이트로 제시하는 데 뛰어납니다.""",
        verbose=True,
        allow_delegation=False,
        llm=llm,
        tools=[search_tool],
    )

writer = Agent(
        role="기술 콘텐츠 전략가",
        goal="기술 발전에 대한 매력적인 콘텐츠 작성",
        backstory="""당신은 통찰력 있고 흥미로운 기사로 유명한 콘텐츠 전략가입니다.
        복잡한 개념을 매력적인 스토리로 전환합니다.""",
        verbose=True,
        allow_delegation=True,
        llm=llm,
    )

# agent를 위한 작업 생성
    research_task = Task(
        description="""{topic} 분야의 최신 발전 상황에 대한 포괄적인 분석을 수행하세요.
        주요 트렌드, 획기적 기술, 산업에 미칠 잠재적 영향을 식별하세요.""",
        expected_output="주요 내용을 불릿 포인트로 정리한 전체 분석 보고서",
        agent=researcher,
    )

writing_task = Task(
        description="""제공된 인사이트를 활용하여
        가장 중요한 {topic} 발전 내용을 강조하는 흥미로운 블로그 글을 작성하세요.
        글은 정보성 있고, 기술에 밝은 독자를 대상으로 하면서 읽기 쉽게 써야 합니다.
        멋지게 들리도록 쓰되, 복잡한 단어는 피하여 AI처럼 들리지 않게 하세요.""",
        expected_output="최소 4개의 단락으로 구성된 전체 블로그 글",
        agent=writer,
        context=[research_task],
    )

# 순차 프로세스 방식으로 crew 인스턴스화
    crew = Crew(
        agents=[researcher, writer], 
        tasks=[research_task, writing_task], 
        verbose=True, 
        process=Process.sequential
    )

def run_crew():
    """crew를 실행하고 결과 반환."""
    crew = create_crew()
    result = crew.kickoff(inputs={"topic": "AI 발전"})
    return result

**Examples:**

Example 1 (unknown):
```unknown
### 3단계: Braintrust와 함께 OpenTelemetry 초기화하기

추적을 캡처하고 Braintrust로 전송하기 시작하도록 Braintrust OpenTelemetry 계측을 초기화합니다.
```

Example 2 (unknown):
```unknown
### 4단계: CrewAI 애플리케이션 생성하기

포괄적인 추적이 활성화된 CrewAI 애플리케이션을 생성합니다.
```

---

## Get only the search tool from Exa

**URL:** llms-txt#get-only-the-search-tool-from-exa

**Contents:**
  - CrewAI AMP Marketplace

"https://mcp.exa.ai/mcp?api_key=your_key#web_search_exa"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### CrewAI AMP Marketplace

Access tools from the CrewAI AMP marketplace:
```

---

## Integração Google Slides

**URL:** llms-txt#integração-google-slides

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Google Slides
  - 1. Conecte sua Conta Google
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Google Slides

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/google_slides

Criação e gerenciamento de apresentações com integração Google Slides para CrewAI.

Permita que seus agentes criem, editem e gerenciem apresentações do Google Slides. Crie apresentações, atualize conteúdo, importe dados do Google Sheets, gerencie páginas e miniaturas, e simplifique seus fluxos de trabalho de apresentações com automação alimentada por IA.

Antes de usar a integração Google Slides, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Google com acesso ao Google Slides
* Conectado sua conta Google através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Google Slides

### 1. Conecte sua Conta Google

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Google Slides** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a apresentações, planilhas e drive
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="google_slides/create_blank_presentation">
    **Descrição:** Cria uma apresentação em branco sem conteúdo.

* `title` (string, obrigatório): O título da apresentação.
  </Accordion>

<Accordion title="google_slides/get_presentation">
    **Descrição:** Recupera uma apresentação por ID.

* `presentationId` (string, obrigatório): O ID da apresentação a ser recuperada.
    * `fields` (string, opcional): Os campos a incluir na resposta. Use isso para melhorar o desempenho retornando apenas os dados necessários.
  </Accordion>

<Accordion title="google_slides/batch_update_presentation">
    **Descrição:** Aplica atualizações, adiciona conteúdo ou remove conteúdo de uma apresentação.

* `presentationId` (string, obrigatório): O ID da apresentação a ser atualizada.
    * `requests` (array, obrigatório): Uma lista de atualizações a aplicar à apresentação. Cada item é um objeto representando uma solicitação.
    * `writeControl` (object, opcional): Fornece controle sobre como as solicitações de escrita são executadas. Contém `requiredRevisionId` (string).
  </Accordion>

<Accordion title="google_slides/get_page">
    **Descrição:** Recupera uma página específica por seu ID.

* `presentationId` (string, obrigatório): O ID da apresentação.
    * `pageObjectId` (string, obrigatório): O ID da página a ser recuperada.
  </Accordion>

<Accordion title="google_slides/get_thumbnail">
    **Descrição:** Gera uma miniatura da página.

* `presentationId` (string, obrigatório): O ID da apresentação.
    * `pageObjectId` (string, obrigatório): O ID da página para geração de miniatura.
  </Accordion>

<Accordion title="google_slides/import_data_from_sheet">
    **Descrição:** Importa dados de uma planilha do Google para uma apresentação.

* `presentationId` (string, obrigatório): O ID da apresentação.
    * `sheetId` (string, obrigatório): O ID da planilha do Google para importar.
    * `dataRange` (string, obrigatório): O intervalo de dados a importar da planilha.
  </Accordion>

<Accordion title="google_slides/upload_file_to_drive">
    **Descrição:** Faz upload de um arquivo para o Google Drive associado à apresentação.

* `file` (string, obrigatório): Os dados do arquivo a fazer upload.
    * `presentationId` (string, obrigatório): O ID da apresentação para vincular o arquivo carregado.
  </Accordion>

<Accordion title="google_slides/link_file_to_presentation">
    **Descrição:** Vincula um arquivo no Google Drive a uma apresentação.

* `presentationId` (string, obrigatório): O ID da apresentação.
    * `fileId` (string, obrigatório): O ID do arquivo a vincular.
  </Accordion>

<Accordion title="google_slides/get_all_presentations">
    **Descrição:** Lista todas as apresentações acessíveis ao usuário.

* `pageSize` (integer, opcional): O número de apresentações a retornar por página.
    * `pageToken` (string, opcional): Um token para paginação.
  </Accordion>

<Accordion title="google_slides/delete_presentation">
    **Descrição:** Exclui uma apresentação por ID.

* `presentationId` (string, obrigatório): O ID da apresentação a ser excluída.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Google Slides

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="google_slides/create_blank_presentation">
    **Descrição:** Cria uma apresentação em branco sem conteúdo.

    **Parâmetros:**

    * `title` (string, obrigatório): O título da apresentação.
  </Accordion>

  <Accordion title="google_slides/get_presentation">
    **Descrição:** Recupera uma apresentação por ID.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação a ser recuperada.
    * `fields` (string, opcional): Os campos a incluir na resposta. Use isso para melhorar o desempenho retornando apenas os dados necessários.
  </Accordion>

  <Accordion title="google_slides/batch_update_presentation">
    **Descrição:** Aplica atualizações, adiciona conteúdo ou remove conteúdo de uma apresentação.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação a ser atualizada.
    * `requests` (array, obrigatório): Uma lista de atualizações a aplicar à apresentação. Cada item é um objeto representando uma solicitação.
    * `writeControl` (object, opcional): Fornece controle sobre como as solicitações de escrita são executadas. Contém `requiredRevisionId` (string).
  </Accordion>

  <Accordion title="google_slides/get_page">
    **Descrição:** Recupera uma página específica por seu ID.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação.
    * `pageObjectId` (string, obrigatório): O ID da página a ser recuperada.
  </Accordion>

  <Accordion title="google_slides/get_thumbnail">
    **Descrição:** Gera uma miniatura da página.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação.
    * `pageObjectId` (string, obrigatório): O ID da página para geração de miniatura.
  </Accordion>

  <Accordion title="google_slides/import_data_from_sheet">
    **Descrição:** Importa dados de uma planilha do Google para uma apresentação.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação.
    * `sheetId` (string, obrigatório): O ID da planilha do Google para importar.
    * `dataRange` (string, obrigatório): O intervalo de dados a importar da planilha.
  </Accordion>

  <Accordion title="google_slides/upload_file_to_drive">
    **Descrição:** Faz upload de um arquivo para o Google Drive associado à apresentação.

    **Parâmetros:**

    * `file` (string, obrigatório): Os dados do arquivo a fazer upload.
    * `presentationId` (string, obrigatório): O ID da apresentação para vincular o arquivo carregado.
  </Accordion>

  <Accordion title="google_slides/link_file_to_presentation">
    **Descrição:** Vincula um arquivo no Google Drive a uma apresentação.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação.
    * `fileId` (string, obrigatório): O ID do arquivo a vincular.
  </Accordion>

  <Accordion title="google_slides/get_all_presentations">
    **Descrição:** Lista todas as apresentações acessíveis ao usuário.

    **Parâmetros:**

    * `pageSize` (integer, opcional): O número de apresentações a retornar por página.
    * `pageToken` (string, opcional): Um token para paginação.
  </Accordion>

  <Accordion title="google_slides/delete_presentation">
    **Descrição:** Exclui uma apresentação por ID.

    **Parâmetros:**

    * `presentationId` (string, obrigatório): O ID da apresentação a ser excluída.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Google Slides
```

---

## `ArxivPaperTool`

**URL:** llms-txt#`arxivpapertool`

**Contents:**
- Description
- Installation
- Steps to Get Started
- Example
  - Direct usage (without Agent)
- Parameters
  - Initialization Parameters
  - Run Parameters
- Output format
- Usage Notes

The `ArxivPaperTool` queries the arXiv API for academic papers and returns compact, readable results. It can also optionally download PDFs to disk.

This tool has no special installation beyond `crewai-tools`.

No API key is required. This tool uses the public arXiv Atom API.

## Steps to Get Started

1. Initialize the tool.
2. Provide a `search_query` (e.g., "transformer neural network").
3. Optionally set `max_results` (1–100) and enable PDF downloads in the constructor.

### Direct usage (without Agent)

### Initialization Parameters

* `download_pdfs` (bool, default `False`): Whether to download PDFs.
* `save_dir` (str, default `./arxiv_pdfs`): Directory to save PDFs.
* `use_title_as_filename` (bool, default `False`): Use paper titles for filenames.

* `search_query` (str, required): The arXiv search query.
* `max_results` (int, default `5`, range 1–100): Number of results.

The tool returns a human‑readable list of papers with:

* Title
* Link (abs page)
* Snippet/summary (truncated)

When `download_pdfs=True`, PDFs are saved to disk and the summary mentions saved files.

* The tool returns formatted text with key metadata and links.
* When `download_pdfs=True`, PDFs will be stored in `save_dir`.

* If you receive a network timeout, re‑try or reduce `max_results`.
* Invalid XML errors indicate an arXiv response parse issue; try a simpler query.
* File system errors (e.g., permission denied) may occur when saving PDFs; ensure `save_dir` is writable.

* arXiv API docs: [https://info.arxiv.org/help/api/index.html](https://info.arxiv.org/help/api/index.html)

* Network issues, invalid XML, and OS errors are handled with informative messages.

**Examples:**

Example 1 (unknown):
```unknown
No API key is required. This tool uses the public arXiv Atom API.

## Steps to Get Started

1. Initialize the tool.
2. Provide a `search_query` (e.g., "transformer neural network").
3. Optionally set `max_results` (1–100) and enable PDF downloads in the constructor.

## Example
```

Example 2 (unknown):
```unknown
### Direct usage (without Agent)
```

---

## Criar tarefas

**URL:** llms-txt#criar-tarefas

research_task = Task(
    description='Pesquisar tendências do mercado de IA para 2024',
    agent=researcher,
    expected_output='Resumo de pesquisa abrangente'
)

writing_task = Task(
    description='Criar um relatório de pesquisa de mercado',
    agent=writer,
    expected_output='Relatório bem estruturado com insights',
    context=[research_task]
)

---

## Set up logging to capture any reasoning errors

**URL:** llms-txt#set-up-logging-to-capture-any-reasoning-errors

logging.basicConfig(level=logging.INFO)

---

## Inicializar cliente Qdrant e carregar dados

**URL:** llms-txt#inicializar-cliente-qdrant-e-carregar-dados

qdrant = QdrantClient(
    url=os.getenv("QDRANT_URL"),
    api_key=os.getenv("QDRANT_API_KEY")
)
collection_name = "example_collection"
pdf_path = "path/to/your/document.pdf"
load_pdf_to_qdrant(pdf_path, qdrant, collection_name)

---

## `DirectorySearchTool`

**URL:** llms-txt#`directorysearchtool`

**Contents:**
- Descrição
- Instalação
- Inicialização e Uso

<Note>
  **Experimental**: O DirectorySearchTool está em desenvolvimento contínuo. As funcionalidades e recursos podem evoluir, e comportamentos inesperados podem ocorrer enquanto aprimoramos a ferramenta.
</Note>

O DirectorySearchTool permite a busca semântica dentro do conteúdo de diretórios especificados, aproveitando a metodologia de Recuperação com Geração Aumentada (RAG) para uma navegação eficiente entre arquivos. Projetada para flexibilidade, a ferramenta possibilita que usuários especifiquem dinamicamente os diretórios de busca em tempo de execução ou definam um diretório fixo durante a configuração inicial.

Para utilizar o DirectorySearchTool, comece instalando o pacote crewai\_tools. Execute o seguinte comando no seu terminal:

## Inicialização e Uso

Importe o DirectorySearchTool do pacote `crewai_tools` para começar. Você pode inicializar a ferramenta sem especificar um diretório, permitindo definir o diretório de busca em tempo de execução. Alternativamente, a ferramenta pode ser inicializada já com um diretório predefinido.

```python Code theme={null}
from crewai_tools import DirectorySearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Inicialização e Uso

Importe o DirectorySearchTool do pacote `crewai_tools` para começar. Você pode inicializar a ferramenta sem especificar um diretório, permitindo definir o diretório de busca em tempo de execução. Alternativamente, a ferramenta pode ser inicializada já com um diretório predefinido.
```

---

## Linear 연동

**URL:** llms-txt#linear-연동

**Contents:**
- 개요
- 필수 조건
- 리니어 통합 설정
  - 1. Linear 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 Linear 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/linear

CrewAI를 위한 Linear 연동을 통한 소프트웨어 프로젝트 및 버그 추적.

에이전트가 Linear를 통해 이슈, 프로젝트, 개발 워크플로우를 관리할 수 있도록 지원합니다. 이슈를 생성 및 업데이트하고, 프로젝트 타임라인을 관리하며, 팀을 조직하고, AI 기반 자동화로 소프트웨어 개발 프로세스를 간소화할 수 있습니다.

Linear 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 워크스페이스 권한이 있는 Linear 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)에서 Linear 계정 연결

### 1. Linear 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합( Authentication Integrations ) 섹션에서 **Linear**를 찾습니다.
3. **Connect**를 클릭하고 OAuth 절차를 완료합니다.
4. 이슈 및 프로젝트 관리를 위한 필수 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="linear/create_issue">
    **설명:** Linear에서 새로운 이슈를 생성합니다.

* `teamId` (string, 필수): 팀 ID - 이 새로운 이슈의 상위 팀 ID를 지정합니다. Connect Portal Workflow Settings를 사용하여 사용자가 팀 ID를 선택할 수 있도록 하세요. (예: "a70bdf0f-530a-4887-857d-46151b52b47c").
    * `title` (string, 필수): 제목 - 이 이슈의 제목을 지정합니다.
    * `description` (string, 선택): 설명 - 이 이슈의 설명을 지정합니다.
    * `statusId` (string, 선택): 상태 - 이 이슈의 상태를 지정합니다.
    * `priority` (string, 선택): 우선순위 - 이 이슈의 우선순위를 정수로 지정합니다.
    * `dueDate` (string, 선택): 마감일 - 이 이슈의 마감일을 ISO 8601 형식으로 지정합니다.
    * `cycleId` (string, 선택): 사이클 ID - 이 이슈가 속한 사이클을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
      
  </Accordion>

<Accordion title="linear/update_issue">
    **설명:** Linear에서 이슈를 업데이트합니다.

* `issueId` (string, 필수): 이슈 ID - 업데이트할 이슈의 ID를 지정합니다. (예: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
    * `title` (string, 선택): 제목 - 이 이슈의 제목을 지정합니다.
    * `description` (string, 선택): 설명 - 이 이슈의 설명을 지정합니다.
    * `statusId` (string, 선택): 상태 - 이 이슈의 상태를 지정합니다.
    * `priority` (string, 선택): 우선순위 - 이 이슈의 우선순위를 정수로 지정합니다.
    * `dueDate` (string, 선택): 마감일 - 이 이슈의 마감일을 ISO 8601 형식으로 지정합니다.
    * `cycleId` (string, 선택): 사이클 ID - 이 이슈가 속한 사이클을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
      
  </Accordion>

<Accordion title="linear/get_issue_by_id">
    **설명:** Linear에서 ID로 이슈를 가져옵니다.

* `issueId` (string, 필수): 이슈 ID - 가져올 이슈의 레코드 ID를 지정합니다. (예: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
  </Accordion>

<Accordion title="linear/get_issue_by_issue_identifier">
    **설명:** Linear에서 이슈 식별자로 이슈를 가져옵니다.

* `externalId` (string, 필수): 외부 ID - 가져올 이슈의 사람이 읽을 수 있는 이슈 식별자를 지정합니다. (예: "ABC-1").
  </Accordion>

<Accordion title="linear/search_issue">
    **설명:** Linear에서 이슈를 검색합니다.

* `queryTerm` (string, 필수): 검색어 - 찾을 검색어입니다.
    * `issueFilterFormula` (object, 선택): 부정합적 정규형(DNF)의 필터 - 단일 조건의 AND 그룹들에 대한 OR.
      
      사용 가능한 필드: `title`, `number`, `project`, `createdAt`
      사용 가능한 연산자: `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringIsIn`, `$stringIsNotIn`, `$stringStartsWith`, `$stringDoesNotStartWith`, `$stringEndsWith`, `$stringDoesNotEndWith`, `$stringContains`, `$stringDoesNotContain`, `$stringGreaterThan`, `$stringLessThan`, `$numberGreaterThanOrEqualTo`, `$numberLessThanOrEqualTo`, `$numberGreaterThan`, `$numberLessThan`, `$dateTimeAfter`, `$dateTimeBefore`
  </Accordion>

<Accordion title="linear/delete_issue">
    **설명:** Linear에서 이슈를 삭제합니다.

* `issueId` (string, 필수): 이슈 ID - 삭제할 이슈의 레코드 ID를 지정합니다. (예: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
  </Accordion>

<Accordion title="linear/archive_issue">
    **설명:** Linear에서 이슈를 아카이브합니다.

* `issueId` (string, 필수): 이슈 ID - 아카이브할 이슈의 레코드 ID를 지정합니다. (예: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
  </Accordion>

<Accordion title="linear/create_sub_issue">
    **설명:** Linear에서 하위 이슈를 생성합니다.

* `parentId` (string, 필수): 상위 ID - 이 새로운 이슈의 상위 이슈 ID를 지정합니다.
    * `teamId` (string, 필수): 팀 ID - 이 새로운 하위 이슈의 상위 팀 ID를 지정합니다. Connect Portal Workflow Settings를 사용하여 사용자가 팀 ID를 선택할 수 있도록 하세요. (예: "a70bdf0f-530a-4887-857d-46151b52b47c").
    * `title` (string, 필수): 제목 - 이 이슈의 제목을 지정합니다.
    * `description` (string, 선택): 설명 - 이 이슈의 설명을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
      
  </Accordion>

<Accordion title="linear/create_project">
    **설명:** Linear에서 새로운 프로젝트를 생성합니다.

* `teamIds` (object, 필수): 팀 ID - 이 프로젝트와 연관된 팀 ID 혹은 팀 ID의 JSON 배열을 문자열로 지정합니다. Connect Portal User Settings를 사용하여 사용자가 팀 ID를 선택할 수 있도록 하세요.
      
    * `projectName` (string, 필수): 프로젝트 이름 - 프로젝트의 이름을 지정합니다. (예: "My Linear Project").
    * `description` (string, 선택): 프로젝트 설명 - 프로젝트에 대한 설명을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
      
  </Accordion>

<Accordion title="linear/update_project">
    **설명:** Linear에서 프로젝트를 업데이트합니다.

* `projectId` (string, 필수): 프로젝트 ID - 업데이트할 프로젝트의 ID를 지정합니다. (예: "a6634484-6061-4ac7-9739-7dc5e52c796b").
    * `projectName` (string, 선택): 프로젝트 이름 - 업데이트할 프로젝트의 이름을 지정합니다. (예: "My Linear Project").
    * `description` (string, 선택): 프로젝트 설명 - 프로젝트에 대한 설명을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
      
  </Accordion>

<Accordion title="linear/get_project_by_id">
    **설명:** Linear에서 ID로 프로젝트를 가져옵니다.

* `projectId` (string, 필수): 프로젝트 ID - 가져올 프로젝트의 프로젝트 ID를 지정합니다. (예: "a6634484-6061-4ac7-9739-7dc5e52c796b").
  </Accordion>

<Accordion title="linear/delete_project">
    **설명:** Linear에서 프로젝트를 삭제합니다.

* `projectId` (string, 필수): 프로젝트 ID - 삭제할 프로젝트의 프로젝트 ID를 지정합니다. (예: "a6634484-6061-4ac7-9739-7dc5e52c796b").
  </Accordion>

<Accordion title="linear/search_teams">
    **설명:** Linear에서 팀을 검색합니다.

* `teamFilterFormula` (object, 선택): 부정합적 정규형(DNF)의 필터 - 단일 조건의 AND 그룹들에 대한 OR.
      
      사용 가능한 필드: `id`, `name`
  </Accordion>
</AccordionGroup>

### 기본 Linear 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="linear/create_issue">
    **설명:** Linear에서 새로운 이슈를 생성합니다.

    **파라미터:**

    * `teamId` (string, 필수): 팀 ID - 이 새로운 이슈의 상위 팀 ID를 지정합니다. Connect Portal Workflow Settings를 사용하여 사용자가 팀 ID를 선택할 수 있도록 하세요. (예: "a70bdf0f-530a-4887-857d-46151b52b47c").
    * `title` (string, 필수): 제목 - 이 이슈의 제목을 지정합니다.
    * `description` (string, 선택): 설명 - 이 이슈의 설명을 지정합니다.
    * `statusId` (string, 선택): 상태 - 이 이슈의 상태를 지정합니다.
    * `priority` (string, 선택): 우선순위 - 이 이슈의 우선순위를 정수로 지정합니다.
    * `dueDate` (string, 선택): 마감일 - 이 이슈의 마감일을 ISO 8601 형식으로 지정합니다.
    * `cycleId` (string, 선택): 사이클 ID - 이 이슈가 속한 사이클을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="linear/update_issue">
    **설명:** Linear에서 이슈를 업데이트합니다.

    **파라미터:**

    * `issueId` (string, 필수): 이슈 ID - 업데이트할 이슈의 ID를 지정합니다. (예: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
    * `title` (string, 선택): 제목 - 이 이슈의 제목을 지정합니다.
    * `description` (string, 선택): 설명 - 이 이슈의 설명을 지정합니다.
    * `statusId` (string, 선택): 상태 - 이 이슈의 상태를 지정합니다.
    * `priority` (string, 선택): 우선순위 - 이 이슈의 우선순위를 정수로 지정합니다.
    * `dueDate` (string, 선택): 마감일 - 이 이슈의 마감일을 ISO 8601 형식으로 지정합니다.
    * `cycleId` (string, 선택): 사이클 ID - 이 이슈가 속한 사이클을 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드.
```

---

## Find interactive elements

**URL:** llms-txt#find-interactive-elements

result = stagehand_tool.run(
    instruction="Find all interactive elements in the navigation menu", 
    url="https://example.com",
    command_type="observe"
)

---

## Initialize the AIMindTool

**URL:** llms-txt#initialize-the-aimindtool

aimind_tool = AIMindTool(
    datasources=[
        {
            "description": "house sales data",
            "engine": "postgres",
            "connection_data": {
                "user": "demo_user",
                "password": "demo_password",
                "host": "samples.mindsdb.com",
                "port": 5432,
                "database": "demo",
                "schema": "demo_data"
            },
            "tables": ["house_sales"]
        }
    ]
)

---

## 또는 대용량 프롬프트 대신 knowledge 소스 사용

**URL:** llms-txt#또는-대용량-프롬프트-대신-knowledge-소스-사용

python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**자동 요약 기능이 중요한 정보를 놓치는 경우:**
```

---

## Results will be filtered where category == "technology"

**URL:** llms-txt#results-will-be-filtered-where-category-==-"technology"

**Contents:**
  - Preset Filters with QdrantConfig

python  theme={null}
from qdrant_client.http import models as qmodels
from crewai_tools import QdrantVectorSearchTool, QdrantConfig

**Examples:**

Example 1 (unknown):
```unknown
### Preset Filters with QdrantConfig

For complex filtering, use Qdrant Filter instances in your configuration:
```

---

## Get the knowledge storage path

**URL:** llms-txt#get-the-knowledge-storage-path

knowledge_path = os.path.join(db_storage_path(), "knowledge")
print(f"Knowledge storage location: {knowledge_path}")

---

## `RagTool`

**URL:** llms-txt#`ragtool`

**Contents:**
- Descrição
- Exemplo

O `RagTool` foi desenvolvido para responder perguntas aproveitando o poder da Geração Aumentada por Recuperação (RAG) através do EmbedChain.
Ele fornece uma base de conhecimento dinâmica que pode ser consultada para recuperar informações relevantes de várias fontes de dados.
Esta ferramenta é particularmente útil para aplicações que exigem acesso a uma ampla variedade de informações e precisam fornecer respostas contextualmente relevantes.

O exemplo a seguir demonstra como inicializar a ferramenta e usá-la com diferentes fontes de dados:

```python Code theme={null}
from crewai_tools import RagTool

---

## Exemplo com timeout personalizado para conexão

**URL:** llms-txt#exemplo-com-timeout-personalizado-para-conexão

with MCPServerAdapter(server_params, connect_timeout=60) as tools:
    # A conexão terá timeout após 60 segundos se não estabelecida
    pass
python  theme={null}
from crewai import Agent
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters # Para servidor Stdio

**Examples:**

Example 1 (unknown):
```unknown

```

---

## Create a LlamaIndexTool from the query engine

**URL:** llms-txt#create-a-llamaindextool-from-the-query-engine

**Contents:**
- 클래스 메서드
  - from\_tool
  - from\_query\_engine
- 파라미터
- 결론

query_tool = LlamaIndexTool.from_query_engine(
    query_engine,
    name="Company Data Query Tool",
    description="Use this tool to lookup information in company documents"
)
python Code theme={null}
@classmethod
def from_tool(cls, tool: Any, **kwargs: Any) -> "LlamaIndexTool":
    # Implementation details
python Code theme={null}
@classmethod
def from_query_engine(
    cls,
    query_engine: Any,
    name: Optional[str] = None,
    description: Optional[str] = None,
    return_direct: bool = False,
    **kwargs: Any,
) -> "LlamaIndexTool":
    # Implementation details
```

`from_query_engine` 메서드는 다음과 같은 파라미터를 받습니다:

* **query\_engine**: 필수. 래핑할 LlamaIndex 쿼리 엔진입니다.
* **name**: 선택 사항. 도구의 이름입니다.
* **description**: 선택 사항. 도구의 설명입니다.
* **return\_direct**: 선택 사항. 응답을 직접 반환할지 여부입니다. 기본값은 `False`입니다.

`LlamaIndexTool`은 LlamaIndex의 기능을 CrewAI 에이전트에 통합할 수 있는 강력한 방법을 제공합니다. LlamaIndex 도구와 쿼리 엔진을 래핑함으로써, 에이전트가 정교한 데이터 검색 및 처리 기능을 활용할 수 있게 하여, 복잡한 정보 소스를 다루는 능력을 강화합니다.

**Examples:**

Example 1 (unknown):
```unknown
## 클래스 메서드

`LlamaIndexTool`은 인스턴스를 생성하기 위한 두 가지 주요 클래스 메서드를 제공합니다:

### from\_tool

LlamaIndex tool에서 `LlamaIndexTool`을 생성합니다.
```

Example 2 (unknown):
```unknown
### from\_query\_engine

LlamaIndex query engine에서 `LlamaIndexTool`을 생성합니다.
```

---

## Too broad

**URL:** llms-txt#too-broad

class BloatedState(BaseModel):
    user_data: Dict = {}
    system_settings: Dict = {}
    temporary_calculations: List = []
    debug_info: Dict = {}
    # ...many more fields

---

## Obtenha apenas ferramentas Salesforce específicas

**URL:** llms-txt#obtenha-apenas-ferramentas-salesforce-específicas

actions_list=["salesforce/create_record_lead", "salesforce/update_record_opportunity", "salesforce/search_records_contact"]
)

sales_manager = Agent(
    role="Sales Manager",
    goal="Manage leads and opportunities in the sales pipeline",
    backstory="An experienced sales manager who handles lead qualification and opportunity management.",
    apps=['salesforce']
)

---

## Geração de Imagens com DALL-E

**URL:** llms-txt#geração-de-imagens-com-dall-e

**Contents:**
- Pré-requisitos
- Configurando a Ferramenta DALL-E
- Utilizando a Ferramenta DALL-E
  - Exemplo de Configuração de Agente
  - Resultado Esperado
- Boas Práticas
- Solução de Problemas

Source: https://docs.crewai.com/pt-BR/learn/dalle-image-generation

Aprenda a usar o DALL-E para geração de imagens com IA em seus projetos CrewAI

O CrewAI oferece integração com o DALL-E da OpenAI, permitindo que seus agentes de IA gerem imagens como parte de suas tarefas. Este guia irá orientá-lo sobre como configurar e utilizar a ferramenta DALL-E em seus projetos CrewAI.

* crewAI instalado (última versão)
* Chave de API OpenAI com acesso ao DALL-E

## Configurando a Ferramenta DALL-E

<Steps>
  <Step title="Importe a ferramenta DALL-E">
    
  </Step>

<Step title="Adicione a ferramenta DALL-E na configuração do seu agente">
    
  </Step>
</Steps>

## Utilizando a Ferramenta DALL-E

Depois de adicionar a ferramenta DALL-E ao seu agente, ele poderá gerar imagens baseadas em prompts de texto. A ferramenta retornará uma URL para a imagem gerada, que pode ser utilizada na resposta do agente ou repassada para outros agentes para processamento adicional.

### Exemplo de Configuração de Agente

### Resultado Esperado

O agente com a ferramenta DALL-E conseguirá gerar a imagem e fornecer uma URL em sua resposta. Você poderá então baixar a imagem.

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=7b6378a1ee0aad5d3941193c6802312c" alt="Imagem DALL-E" data-og-width="670" width="670" data-og-height="670" height="670" data-path="images/enterprise/dall-e-image.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=95b3ae8ec53f789746846831fa981b32 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f880f86fa3b648a257ac74fcc7838dce 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c98e8fd36d462d3806c398c1f074efb2 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=68af7edd51913d04723c0fbae774ea1d 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=07c15be8399f83239d49e28f6667a28d 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=619edc0ffc57a1eddd3cd7f9715b6b0a 2500w" />
</Frame>

1. **Seja específico nos prompts de geração de imagem** para obter melhores resultados.
2. **Considere o tempo de geração** - A geração de imagens pode levar algum tempo, então inclua isso no seu planejamento de tarefas.
3. **Siga as políticas de uso** - Sempre cumpra as políticas de uso da OpenAI ao gerar imagens.

## Solução de Problemas

1. **Verifique o acesso à API** - Certifique-se de que sua chave de API OpenAI possui acesso ao DALL-E.
2. **Compatibilidade de versões** - Verifique se você está utilizando a versão mais recente do crewAI e crewai-tools.
3. **Configuração da ferramenta** - Confirme que a ferramenta DALL-E foi corretamente adicionada à lista de ferramentas do agente.

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Adicione a ferramenta DALL-E na configuração do seu agente">
```

Example 2 (unknown):
```unknown
</Step>
</Steps>

## Utilizando a Ferramenta DALL-E

Depois de adicionar a ferramenta DALL-E ao seu agente, ele poderá gerar imagens baseadas em prompts de texto. A ferramenta retornará uma URL para a imagem gerada, que pode ser utilizada na resposta do agente ou repassada para outros agentes para processamento adicional.

### Exemplo de Configuração de Agente
```

---

## ✅ Specific role - clear LLM requirements

**URL:** llms-txt#✅-specific-role---clear-llm-requirements

**Contents:**
  - b. Backstory as Model Context Amplifier

specific_agent = Agent(
    role="SaaS Revenue Operations Analyst",  # Clear domain expertise needed
    goal="Analyze recurring revenue metrics and identify growth opportunities",
    backstory="Specialist in SaaS business models with deep understanding of ARR, churn, and expansion revenue",
    llm=LLM(model="gpt-4o")  # Reasoning model justified for complex analysis
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Role-to-Model Mapping Strategy:**

* **"Research Analyst"** → Reasoning model (GPT-4o, Claude Sonnet) for complex analysis
* **"Content Editor"** → Creative model (Claude, GPT-4o) for writing quality
* **"Data Processor"** → Efficient model (GPT-4o-mini, Gemini Flash) for structured tasks
* **"API Coordinator"** → Function-calling optimized model (GPT-4o, Claude) for tool usage

### b. Backstory as Model Context Amplifier

<Info>
  Strategic backstories multiply your chosen LLM's effectiveness by providing domain-specific context that generic prompting cannot achieve.
</Info>

A well-crafted backstory transforms your LLM choice from generic capability to specialized expertise. This is especially crucial for cost optimization - a well-contextualized efficient model can outperform a premium model without proper context.

**Context-Driven Performance Example:**
```

---

## Inicialize a ferramenta com a URL do site,

**URL:** llms-txt#inicialize-a-ferramenta-com-a-url-do-site,

---

## Create a task that encourages collaboration

**URL:** llms-txt#create-a-task-that-encourages-collaboration

article_task = Task(
    description="""Escreva um artigo abrangente de 1000 palavras sobre 'O Futuro da IA na Saúde'.

O artigo deve incluir:
- Aplicações atuais de IA na saúde
- Tendências e tecnologias emergentes
- Desafios potenciais e considerações éticas
- Previsões de especialistas para os próximos 5 anos

Colabore com seus colegas para garantir precisão e qualidade.""",
    expected_output="Um artigo bem pesquisado, envolvente, com 1000 palavras, estrutura adequada e citações",
    agent=writer  # O redator lidera, mas pode delegar pesquisa ao pesquisador
)

---

## 태스크 설명이 어떻게 포맷되는지도 확인할 수 있습니다

**URL:** llms-txt#태스크-설명이-어떻게-포맷되는지도-확인할-수-있습니다

**Contents:**
  - 기본 지침 재정의

print("\n=== TASK CONTEXT ===")
print(f"Task Description: {task.description}")
print(f"Expected Output: {task.expected_output}")
python  theme={null}
from crewai import Agent

**Examples:**

Example 1 (unknown):
```unknown
### 기본 지침 재정의

프롬프트에 대한 완전한 제어를 얻기 위해 여러 가지 옵션이 있습니다:

#### 옵션 1: 커스텀 템플릿 (권장)
```

---

## Crie um agente com capacidades Zendesk

**URL:** llms-txt#crie-um-agente-com-capacidades-zendesk

zendesk_agent = Agent(
    role="Gerente de Suporte",
    goal="Gerenciar tickets de suporte ao cliente e oferecer excelente atendimento",
    backstory="Um assistente de IA especializado em operações de suporte ao cliente e gerenciamento de tickets.",
    apps=['zendesk']
)

---

## Inicialize a ferramenta para pesquisar qualquer conteúdo MDX que ela conheça durante a execução

**URL:** llms-txt#inicialize-a-ferramenta-para-pesquisar-qualquer-conteúdo-mdx-que-ela-conheça-durante-a-execução

tool = MDXSearchTool()

---

## The agent will use the tool with parameters like:

**URL:** llms-txt#the-agent-will-use-the-tool-with-parameters-like:

---

## Inicialize a ferramenta sem um arquivo CSV específico.

**URL:** llms-txt#inicialize-a-ferramenta-sem-um-arquivo-csv-específico.

---

## 구조화된 데이터 접근

**URL:** llms-txt#구조화된-데이터-접근

**Contents:**
- 모범 사례
- 조직 관리

print(f"Key Trends: {structured_result.pydantic.key_trends}")
print(f"Recommendation: {structured_result.pydantic.recommendation}")
bash  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 모범 사례

1. **명명 규칙**: 리포지토리 에이전트에 대해 명확하고 설명적인 이름을 사용하세요.
2. **문서화**: 각 에이전트에 대한 포괄적인 설명을 포함하세요.
3. **도구 관리**: 리포지토리 에이전트가 참조하는 도구들이 환경에 제공되는지 확인하세요.
4. **접근 제어**: 권한이 있는 팀원만 리포지토리 에이전트를 수정할 수 있도록 권한을 관리하세요.

## 조직 관리

조직을 전환하거나 현재 조직을 확인하려면 CrewAI CLI를 사용하세요:
```

---

## Bedrock Knowledge Base Retriever

**URL:** llms-txt#bedrock-knowledge-base-retriever

Source: https://docs.crewai.com/pt-BR/tools/cloud-storage/bedrockkbretriever

Recupere informações das Bases de Conhecimento do Amazon Bedrock usando consultas em linguagem natural

---

## Criar uma LlamaIndexTool a partir do mecanismo de consulta

**URL:** llms-txt#criar-uma-llamaindextool-a-partir-do-mecanismo-de-consulta

**Contents:**
- Métodos da Classe
  - from\_tool
  - from\_query\_engine
- Parâmetros
- Conclusão

query_tool = LlamaIndexTool.from_query_engine(
    query_engine,
    name="Company Data Query Tool",
    description="Use this tool to lookup information in company documents"
)
python Code theme={null}
@classmethod
def from_tool(cls, tool: Any, **kwargs: Any) -> "LlamaIndexTool":
    # Implementation details
python Code theme={null}
@classmethod
def from_query_engine(
    cls,
    query_engine: Any,
    name: Optional[str] = None,
    description: Optional[str] = None,
    return_direct: bool = False,
    **kwargs: Any,
) -> "LlamaIndexTool":
    # Implementation details
```

O método `from_query_engine` aceita os seguintes parâmetros:

* **query\_engine**: Obrigatório. O mecanismo de consulta do LlamaIndex a ser envolvido.
* **name**: Opcional. O nome da ferramenta.
* **description**: Opcional. A descrição da ferramenta.
* **return\_direct**: Opcional. Define se deve retornar a resposta diretamente. O padrão é `False`.

A `LlamaIndexTool` oferece uma maneira poderosa de integrar as capacidades do LlamaIndex aos agentes do CrewAI. Ao envolver ferramentas e mecanismos de consulta do LlamaIndex, ela permite que os agentes utilizem funcionalidades sofisticadas de recuperação e processamento de dados, aprimorando sua capacidade de trabalhar com fontes de informação complexas.

**Examples:**

Example 1 (unknown):
```unknown
## Métodos da Classe

A `LlamaIndexTool` oferece dois métodos de classe principais para criar instâncias:

### from\_tool

Cria uma `LlamaIndexTool` a partir de uma ferramenta do LlamaIndex.
```

Example 2 (unknown):
```unknown
### from\_query\_engine

Cria uma `LlamaIndexTool` a partir de um mecanismo de consulta do LlamaIndex.
```

---

## Crie um agente com capacidades do Microsoft Outlook

**URL:** llms-txt#crie-um-agente-com-capacidades-do-microsoft-outlook

outlook_agent = Agent(
    role="Assistente de Email",
    goal="Gerenciar emails, eventos de calendário e contatos de forma eficiente",
    backstory="Um assistente IA especializado em operações do Microsoft Outlook e gerenciamento de comunicação.",
    apps=['microsoft_outlook']  # Todas as ações do Outlook estarão disponíveis
)

---

## Acessar as impressões digitais

**URL:** llms-txt#acessar-as-impressões-digitais

agent_fingerprint = agent.fingerprint
crew_fingerprint = crew.fingerprint
task_fingerprint = task.fingerprint

---

## Crie o diretório de saída se não existir

**URL:** llms-txt#crie-o-diretório-de-saída-se-não-existir

**Contents:**
- Passo 7: Defina suas Variáveis de Ambiente

os.makedirs('output', exist_ok=True)

def run():
    """
    Rodar a crew de pesquisa.
    """
    inputs = {
        'topic': 'Inteligência Artificial na Saúde'
    }

# Criar e rodar a crew
    result = ResearchCrew().crew().kickoff(inputs=inputs)

# Imprimir o resultado
    print("\n\n=== RELATÓRIO FINAL ===\n\n")
    print(result.raw)

print("\n\nRelatório salvo em output/report.md")

if __name__ == "__main__":
    run()
sh  theme={null}
SERPER_API_KEY=sua_serper_api_key

**Examples:**

Example 1 (unknown):
```unknown
Este script prepara o ambiente, define o tema de pesquisa e inicia o trabalho da crew. O poder da CrewAI fica evidente em como esse código é simples – toda a complexidade do gerenciamento de múltiplos agentes de IA é tratada pelo framework.

## Passo 7: Defina suas Variáveis de Ambiente

Crie um arquivo `.env` na raiz do seu projeto com suas chaves de API:
```

---

## Sempre incluir opções de backup

**URL:** llms-txt#sempre-incluir-opções-de-backup

mcps=[
    "https://api-principal.com/mcp",       # Escolha principal
    "https://api-backup.com/mcp",          # Opção de backup
    "crewai-amp:servico-confiavel"         # Fallback AMP
]
```

---

## 전체 YouTube 채널 검색을 위한 도구를 초기화합니다

**URL:** llms-txt#전체-youtube-채널-검색을-위한-도구를-초기화합니다

youtube_channel_tool = YoutubeChannelSearchTool()

---

## Adicionar metadados à impressão digital do agente

**URL:** llms-txt#adicionar-metadados-à-impressão-digital-do-agente

agent.security_config.fingerprint.metadata = {
    "version": "1.0",
    "department": "Data Science",
    "project": "Customer Analysis"
}

---

## Tarefa para enviar um email

**URL:** llms-txt#tarefa-para-enviar-um-email

send_email_task = Task(
    description="Enviar um email para 'colega@exemplo.com' com assunto 'Atualização do Projeto' e corpo 'Olá, aqui está a última atualização do projeto. Atenciosamente.'",
    agent=outlook_agent,
    expected_output="Email enviado com sucesso para colega@exemplo.com"
)

---

## 코드 변경 후 업데이트 푸시

**URL:** llms-txt#코드-변경-후-업데이트-푸시

---

## Crie um agente para importação de dados e gerenciamento de arquivos

**URL:** llms-txt#crie-um-agente-para-importação-de-dados-e-gerenciamento-de-arquivos

data_presenter = Agent(
    role="Apresentador de Dados",
    goal="Importar dados para apresentações e gerenciar arquivos vinculados",
    backstory="Um assistente IA que integra dados de várias fontes em apresentações.",
    apps=['google_slides/import_data_from_sheet', 'google_slides/upload_file_to_drive']
)

---

## 2. Servidor SSE:

**URL:** llms-txt#2.-servidor-sse:

server_params = {
    "url": "http://localhost:8000/sse",
    "transport": "sse"
}

---

## Adicione as ferramentas ao seu agente

**URL:** llms-txt#adicione-as-ferramentas-ao-seu-agente

agent = Agent(
    role="Research Analyst",
    tools=[FileReadTool(), SerperDevTool()],
    # ... outrAs configurações
)
```

Pronto para explorar? Escolha uma categoria acima para descobrir as ferramentas que se encaixam no seu caso de uso!

---

## Add a directory of files

**URL:** llms-txt#add-a-directory-of-files

**Contents:**
- Exemplo de Integração com Agente

rag_tool.add(data_type="directory", path="path/to/your/directory")
python Code theme={null}
from crewai import Agent
from crewai.project import agent
from crewai_tools import RagTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo de Integração com Agente

Veja como integrar o `RagTool` com um agente do CrewAI:
```

---

## or

**URL:** llms-txt#or

**Contents:**
- 7단계: 의존성 설치
- 8단계: Flow 실행하기
- 9단계: Flow 시각화하기
- 10단계: 출력물 검토하기
- 가능한 것의 예술: 첫 번째 Flow 그 이상
  - 사용자 상호작용 향상
  - 추가 처리 단계 추가하기
  - 더 복잡한 Flows 생성하기
  - 다양한 도메인에 적용하기
- 주요 특징 시연

ANTHROPIC_API_KEY=your_anthropic_api_key
bash  theme={null}
crewai install
bash  theme={null}
crewai flow kickoff
bash  theme={null}
crewai flow plot
python  theme={null}
llm = LLM(
    model="model-id-here",  # gpt-4o, gemini-2.0-flash, anthropic/claude...
    response_format=GuideOutline
)
response = llm.call(messages=messages)
python  theme={null}
@start()
def get_user_input(self):
    # First step in the flow
    # ...

@listen(get_user_input)
def create_guide_outline(self, state):
    # This runs when get_user_input completes
    # ...
python  theme={null}
class GuideCreatorState(BaseModel):
    topic: str = ""
    audience_level: str = ""
    guide_outline: GuideOutline = None
    sections_content: Dict[str, str] = {}
python  theme={null}
result = ContentCrew().crew().kickoff(inputs={
    "section_title": section.title,
    # ...
})
```

이를 통해 애플리케이션의 각 부분에 적합한 도구를 사용할 수 있습니다. 단순한 작업에는 직접적인 LLM 호출을, 복잡한 협업에는 crew를 사용할 수 있습니다.

이제 첫 번째 flow를 구축했으니 다음을 시도해 볼 수 있습니다:

1. 더 복잡한 flow 구조와 패턴을 실험해 보세요.
2. `@router()`를 사용하여 flow에서 조건부 분기를 만들어 보세요.
3. 더 복잡한 병렬 실행을 위해 `and_` 및 `or_` 함수를 탐색해 보세요.
4. flow를 외부 API, 데이터베이스 또는 사용자 인터페이스에 연결해 보세요.
5. 여러 전문화된 crew를 하나의 flow에서 결합해 보세요.

<Check>
  축하합니다! 정규 코드, 직접적인 LLM 호출, crew 기반 처리를 결합하여 포괄적인 가이드를 생성하는 첫 번째 CrewAI Flow를 성공적으로 구축하셨습니다. 이러한 기초적인 역량을 바탕으로 절차적 제어와 협업적 인텔리전스를 결합하여 복잡하고 다단계의 문제를 해결할 수 있는 점점 더 정교한 AI 애플리케이션을 만들 수 있습니다.
</Check>

**Examples:**

Example 1 (unknown):
```unknown
## 7단계: 의존성 설치

필수 의존성을 설치합니다:
```

Example 2 (unknown):
```unknown
## 8단계: Flow 실행하기

이제 여러분의 flow가 실제로 작동하는 모습을 볼 차례입니다! CrewAI CLI를 사용하여 flow를 실행하세요:
```

Example 3 (unknown):
```unknown
이 명령어를 실행하면 flow가 다음과 같이 작동하는 것을 확인할 수 있습니다:

1. 주제와 대상 수준을 입력하라는 메시지가 표시됩니다.
2. 가이드의 체계적인 개요를 생성합니다.
3. 각 섹션을 처리할 때 content writer와 reviewer가 협업합니다.
4. 마지막으로 모든 내용을 종합하여 완성도 높은 가이드를 만듭니다.

이는 여러 구성요소(인공지능 및 비인공지능 모두)가 포함된 복잡한 프로세스를 flows가 어떻게 조정할 수 있는지 보여줍니다.

## 9단계: Flow 시각화하기

flow의 강력한 기능 중 하나는 구조를 시각화할 수 있다는 점입니다.
```

Example 4 (unknown):
```unknown
이 명령은 flow의 구조를 보여주는 HTML 파일을 생성하며, 각 단계 간의 관계와 그 사이에 흐르는 데이터를 확인할 수 있습니다. 이러한 시각화는 복잡한 flow를 이해하고 디버깅하는 데 매우 유용합니다.

## 10단계: 출력물 검토하기

flow가 완료되면 `output` 디렉토리에서 두 개의 파일을 찾을 수 있습니다:

1. `guide_outline.json`: 가이드의 구조화된 개요가 포함되어 있습니다
2. `complete_guide.md`: 모든 섹션이 포함된 종합적인 가이드입니다

이 파일들을 잠시 검토하고 여러분이 구축한 시스템을 되돌아보세요. 이 시스템은 사용자 입력, 직접적인 AI 상호작용, 협업 에이전트 작업을 결합하여 복잡하고 고품질의 결과물을 만들어냅니다.

## 가능한 것의 예술: 첫 번째 Flow 그 이상

이 가이드에서 배운 내용은 훨씬 더 정교한 AI 시스템을 만드는 데 기반이 됩니다. 다음은 이 기본 flow를 확장할 수 있는 몇 가지 방법입니다:

### 사용자 상호작용 향상

더욱 인터랙티브한 플로우를 만들 수 있습니다:

* 입력 및 출력을 위한 웹 인터페이스
* 실시간 진행 상황 업데이트
* 인터랙티브한 피드백 및 개선 루프
* 다단계 사용자 상호작용

### 추가 처리 단계 추가하기

다음과 같은 추가 단계로 flow를 확장할 수 있습니다:

* 개요 작성 전 사전 리서치
* 일러스트를 위한 이미지 생성
* 기술 가이드용 코드 스니펫 생성
* 최종 품질 보증 및 사실 확인

### 더 복잡한 Flows 생성하기

더 정교한 flow 패턴을 구현할 수 있습니다:

* 사용자 선호도나 콘텐츠 유형에 따른 조건 분기
* 독립적인 섹션의 병렬 처리
* 피드백과 함께하는 반복적 개선 루프
* 외부 API 및 서비스와의 통합

### 다양한 도메인에 적용하기

동일한 패턴을 사용하여 다음과 같은 flow를 만들 수 있습니다:

* **대화형 스토리텔링**: 사용자 입력을 바탕으로 개인화된 이야기를 생성
* **비즈니스 인텔리전스**: 데이터를 처리하고, 인사이트를 도출하며, 리포트를 생성
* **제품 개발**: 아이디어 구상, 디자인, 기획을 지원
* **교육 시스템**: 개인화된 학습 경험을 제공

## 주요 특징 시연

이 guide creator flow에서는 CrewAI의 여러 강력한 기능을 시연합니다:

1. **사용자 상호작용**: flow는 사용자로부터 직접 입력을 수집합니다
2. **직접적인 LLM 호출**: 효율적이고 단일 목적의 AI 상호작용을 위해 LLM 클래스를 사용합니다
3. **Pydantic을 통한 구조화된 데이터**: 타입 안정성을 보장하기 위해 Pydantic 모델을 사용합니다
4. **컨텍스트를 활용한 순차 처리**: 섹션을 순서대로 작성하면서 이전 섹션을 컨텍스트로 제공합니다
5. **멀티 에이전트 crew**: 콘텐츠 생성을 위해 특화된 에이전트(writer 및 reviewer)를 활용합니다
6. **상태 관리**: 프로세스의 다양한 단계에 걸쳐 상태를 유지합니다
7. **이벤트 기반 아키텍처**: 이벤트에 응답하기 위해 `@listen` 데코레이터를 사용합니다

## 플로우 구조 이해하기

플로우의 주요 구성 요소를 분해하여 자신만의 플로우를 만드는 방법을 이해할 수 있도록 도와드리겠습니다:

### 1. 직접 LLM 호출

Flow를 사용하면 간단하고 구조화된 응답이 필요할 때 언어 모델에 직접 호출할 수 있습니다:
```

---

## 평소와 같이 에이전트와 태스크를 생성

**URL:** llms-txt#평소와-같이-에이전트와-태스크를-생성

researcher = Agent(
    role="Research Specialist",
    goal="Find information on quantum computing",
    backstory="You are a quantum physics expert",
    verbose=True
)

research_task = Task(
    description="Research quantum computing applications",
    expected_output="A summary of practical applications",
    agent=researcher
)

---

## Example: Initialize with specific parameters

**URL:** llms-txt#example:-initialize-with-specific-parameters

custom_tavily_tool = TavilySearchTool(
    search_depth='advanced',
    max_results=10,
    include_answer=True
)

---

## Agent creation is fast - no MCP connections made yet

**URL:** llms-txt#agent-creation-is-fast---no-mcp-connections-made-yet

agent = Agent(
    role="On-Demand Agent",
    goal="Use tools efficiently",
    backstory="Efficient agent that connects only when needed",
    mcps=["https://api.example.com/mcp"]
)

---

## 메타데이터도 설정할 수 있음

**URL:** llms-txt#메타데이터도-설정할-수-있음

**Contents:**
- 고급 사용
  - Fingerprint 구조

custom_fingerprint = Fingerprint.generate(
    seed="my-agent-id",
    metadata={"version": "1.0"}
)
python  theme={null}
from crewai.security import Fingerprint

fingerprint = agent.fingerprint

**Examples:**

Example 1 (unknown):
```unknown
## 고급 사용

### Fingerprint 구조

각 fingerprint는 다음과 같은 구조를 가지고 있습니다:
```

---

## Criar uma impressão digital determinística usando uma string seed

**URL:** llms-txt#criar-uma-impressão-digital-determinística-usando-uma-string-seed

deterministic_fingerprint = Fingerprint.generate(seed="my-agent-id")

---

## If QdrantConfig has a preset filter for category="research"

**URL:** llms-txt#if-qdrantconfig-has-a-preset-filter-for-category="research"

---

## Check storage structure

**URL:** llms-txt#check-storage-structure

storage_path = db_storage_path()
knowledge_path = os.path.join(storage_path, "knowledge")

if os.path.exists(knowledge_path):
    print("Knowledge collections found:")
    for collection in os.listdir(knowledge_path):
        collection_path = os.path.join(knowledge_path, collection)
        if os.path.isdir(collection_path):
            print(f"  - {collection}/")
            # Show collection contents
            for item in os.listdir(collection_path):
                print(f"    └── {item}")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### Testar Recuperação de Knowledge
```

---

## Initialize the tool to search any MDX content it learns about during execution

**URL:** llms-txt#initialize-the-tool-to-search-any-mdx-content-it-learns-about-during-execution

tool = MDXSearchTool()

---

## MySQL RAG 검색

**URL:** llms-txt#mysql-rag-검색

**Contents:**
- 개요
- 설치
- 예시

Source: https://docs.crewai.com/ko/tools/database-data/mysqltool

MySQLSearchTool은 MySQL 데이터베이스를 검색하고 가장 관련성 높은 결과를 반환하도록 설계되었습니다.

이 도구는 MySQL 데이터베이스 테이블 내에서 시맨틱 검색을 용이하게 하기 위해 설계되었습니다. RAG(Retrieve and Generate) 기술을 활용하여,
MySQLSearchTool은 사용자가 MySQL 데이터베이스에 특화된 데이터베이스 테이블 콘텐츠를 효율적으로 쿼리할 수 있는 수단을 제공합니다.
시맨틱 검색 쿼리를 통해 관련 데이터를 쉽게 찾을 수 있도록 하여, MySQL 데이터베이스 내의 방대한 데이터셋에 대해 고급 쿼리를 수행해야 하는 사용자를 위한
소중한 리소스가 됩니다.

`crewai_tools` 패키지를 설치하고 MySQLSearchTool을 사용하려면, 터미널에서 다음 명령어를 실행하세요:

아래는 MySQL 데이터베이스 내의 테이블에서 MySQLSearchTool을 사용하여 시맨틱 검색을 수행하는 방법을 보여주는 예시입니다:

```python Code theme={null}
from crewai_tools import MySQLSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## 예시

아래는 MySQL 데이터베이스 내의 테이블에서 MySQLSearchTool을 사용하여 시맨틱 검색을 수행하는 방법을 보여주는 예시입니다:
```

---

## Multiple AMP services

**URL:** llms-txt#multiple-amp-services

**Contents:**
- Complete Example

mcps=[
    "crewai-amp:weather-insights",
    "crewai-amp:market-analysis",
    "crewai-amp:social-media-monitoring"
]
python  theme={null}
from crewai import Agent, Task, Crew, Process

**Examples:**

Example 1 (unknown):
```unknown
## Complete Example

Here's a complete example using multiple MCP servers:
```

---

## Each agent gets only their specific knowledge

**URL:** llms-txt#each-agent-gets-only-their-specific-knowledge

---

## Create agent with specific Zendesk actions only

**URL:** llms-txt#create-agent-with-specific-zendesk-actions-only

support_agent = Agent(
    role="Customer Support Agent",
    goal="Handle customer inquiries and resolve support issues efficiently",
    backstory="An experienced support agent who specializes in ticket resolution and customer communication.",
    apps=['zendesk/create_ticket']  # Specific Zendesk actions
)

---

## Inicializar rastreamento avançado

**URL:** llms-txt#inicializar-rastreamento-avançado

Traceloop.init(
    api_endpoint="https://your-truefoundry-endpoint/api/tracing",
    headers={
        "Authorization": f"Bearer {your_truefoundry_pat_token}",
        "TFY-Tracing-Project": "your_project_name",
    },
)
```

Isso oferece correlação adicional de rastreamentos em todo o seu fluxo de trabalho com o CrewAI.
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=90623834e0ba9f4ccb09890f6824912d" alt="Rastreamento do CrewAI na TrueFoundry" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/tracing_crewai.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d05099079060dfd1588ac0c8de28e07b 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=645362e069e687f7dc6fd6c44a97a4ef 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=aac6d42bbd2f457b59f6a4b22d6a7be1 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=7f166e1329cef8da8c1e07a38dc75506 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6e91cffda555b8cc7ce1800ed1b508b1 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/tracing_crewai.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=bf6296110bd62d9bb30ae2d0822d4b8d 2500w" />

---

## Todo o armazenamento ficará agora na pasta do projeto

**URL:** llms-txt#todo-o-armazenamento-ficará-agora-na-pasta-do-projeto

**Contents:**
  - Padrão do Provedor de Embedding

**Examples:**

Example 1 (unknown):
```unknown
### Padrão do Provedor de Embedding

<Info>
  **Provedor de Embedding Padrão**: O CrewAI utiliza embeddings do OpenAI por padrão para garantir consistência e confiabilidade. Você pode facilmente customizar para combinar com seu provedor LLM ou utilizar embeddings locais.
</Info>

#### Compreendendo o Comportamento Padrão
```

---

## the agent learns about during its execution

**URL:** llms-txt#the-agent-learns-about-during-its-execution

tool = TXTSearchTool()

---

## Push updates after code changes

**URL:** llms-txt#push-updates-after-code-changes

---

## Task to create a new support ticket

**URL:** llms-txt#task-to-create-a-new-support-ticket

create_ticket_task = Task(
    description="Create a high-priority support ticket for John Smith who is unable to access his account after password reset",
    agent=zendesk_agent,
    expected_output="Support ticket created successfully with ticket ID"
)

---

## Slack 연동

**URL:** llms-txt#slack-연동

**Contents:**
- 개요
- 사전 준비 사항
- Slack 통합 설정
  - 1. Slack 워크스페이스 연결
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 도구
  - **사용자 관리**
  - **채널 관리**
  - **메시징**

Source: https://docs.crewai.com/ko/enterprise/integrations/slack

CrewAI를 위한 Slack 연동으로 팀 커뮤니케이션 및 협업 지원.

에이전트가 Slack을 통해 팀 커뮤니케이션을 관리할 수 있도록 지원합니다. 메시지를 보내고, 대화를 검색하며, 채널을 관리하고, AI 기반 자동화를 통해 팀 활동을 조율하여 협업 워크플로우를 효율적으로 최적화하세요.

Slack 통합을 사용하기 전에 다음을 확인하십시오:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 Slack 워크스페이스
* [통합 페이지](https://app.crewai.com/integrations)를 통해 Slack 워크스페이스를 연결함

### 1. Slack 워크스페이스 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동합니다.
2. 인증 통합 섹션에서 **Slack**을 찾습니다.
3. **연결**을 클릭하고 OAuth 과정을 완료합니다.
4. 팀 커뮤니케이션에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="slack/list_members">
    **설명:** Slack 채널의 모든 멤버를 나열합니다.

* 파라미터 없음 - 모든 채널 멤버를 조회합니다
  </Accordion>

<Accordion title="slack/get_user_by_email">
    **설명:** 이메일 주소로 Slack 워크스페이스에서 사용자를 찾습니다.

* `email` (string, 필수): 워크스페이스 내 사용자의 이메일 주소
  </Accordion>

<Accordion title="slack/get_users_by_name">
    **설명:** 이름 또는 표시 이름으로 사용자를 검색합니다.

* `name` (string, 필수): 검색할 사용자의 실제 이름
    * `displayName` (string, 필수): 검색할 사용자의 표시 이름
    * `paginationParameters` (object, 선택): 페이지네이션 설정
      * `pageCursor` (string, 선택): 페이지네이션을 위한 페이지 커서
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="slack/list_channels">
    **설명:** Slack 워크스페이스의 모든 채널을 나열합니다.

* 파라미터가 필요하지 않습니다 - 접근 가능한 모든 채널을 조회합니다
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="slack/send_message">
    **설명:** Slack 채널에 메시지를 전송합니다.

* `channel` (string, 필수): 채널 이름 또는 ID - Connect Portal Workflow Settings를 사용하여 사용자가 채널을 선택하도록 하거나, 채널 이름을 입력하여 새 채널을 생성할 수 있습니다.
    * `message` (string, 필수): 전송할 메시지 텍스트
    * `botName` (string, 필수): 이 메시지를 전송하는 봇의 이름
    * `botIcon` (string, 필수): 봇 아이콘 - 이미지 URL 또는 이모지(e.g., ":dog:") 모두 가능합니다.
    * `blocks` (object, 선택): 첨부파일 및 인터랙티브 요소 등이 포함된 풍부한 메시지 포맷팅을 위한 Slack Block Kit JSON
    * `authenticatedUser` (boolean, 선택): true이면 메시지가 애플리케이션이 아니라 인증된 Slack 사용자로부터 보낸 것처럼 표시됩니다(기본값은 false)
  </Accordion>

<Accordion title="slack/send_direct_message">
    **설명:** Slack에서 특정 사용자에게 다이렉트 메시지를 전송합니다.

* `memberId` (string, 필수): 수신자 사용자 ID - Connect Portal Workflow Settings를 사용하여 사용자가 워크스페이스 멤버를 선택하도록 합니다.
    * `message` (string, 필수): 전송할 메시지 텍스트
    * `botName` (string, 필수): 이 메시지를 전송하는 봇의 이름
    * `botIcon` (string, 필수): 봇 아이콘 - 이미지 URL 또는 이모지(e.g., ":dog:") 모두 가능합니다.
    * `blocks` (object, 선택): 첨부파일 및 인터랙티브 요소 등이 포함된 풍부한 메시지 포맷팅을 위한 Slack Block Kit JSON
    * `authenticatedUser` (boolean, 선택): true이면 메시지가 애플리케이션이 아니라 인증된 Slack 사용자로부터 보낸 것처럼 표시됩니다(기본값은 false)
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="slack/search_messages">
    **설명:** Slack 워크스페이스 전체에서 메시지를 검색합니다.

* `query` (string, 필수): 지정된 기준과 일치하는 메시지를 찾기 위해 Slack 검색 구문을 사용한 검색 쿼리

* `"project update"` - "project update"가 포함된 메시지 검색
    * `from:@john in:#general` - #general 채널에서 John이 보낸 메시지 검색
    * `has:link after:2023-01-01` - 2023년 1월 1일 이후에 링크가 포함된 메시지 검색
    * `in:@channel before:yesterday` - 특정 채널에서 어제 이전에 작성된 메시지 검색
  </Accordion>
</AccordionGroup>

Slack의 Block Kit을 사용하면 풍부하고 상호작용이 가능한 메시지를 생성할 수 있습니다. 다음은 `blocks` 매개변수를 사용하는 방법에 대한 몇 가지 예시입니다:

### 첨부 파일이 있는 간단한 텍스트

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 도구

### **사용자 관리**

<AccordionGroup>
  <Accordion title="slack/list_members">
    **설명:** Slack 채널의 모든 멤버를 나열합니다.

    **파라미터:**

    * 파라미터 없음 - 모든 채널 멤버를 조회합니다
  </Accordion>

  <Accordion title="slack/get_user_by_email">
    **설명:** 이메일 주소로 Slack 워크스페이스에서 사용자를 찾습니다.

    **파라미터:**

    * `email` (string, 필수): 워크스페이스 내 사용자의 이메일 주소
  </Accordion>

  <Accordion title="slack/get_users_by_name">
    **설명:** 이름 또는 표시 이름으로 사용자를 검색합니다.

    **파라미터:**

    * `name` (string, 필수): 검색할 사용자의 실제 이름
    * `displayName` (string, 필수): 검색할 사용자의 표시 이름
    * `paginationParameters` (object, 선택): 페이지네이션 설정
      * `pageCursor` (string, 선택): 페이지네이션을 위한 페이지 커서
  </Accordion>
</AccordionGroup>

### **채널 관리**

<AccordionGroup>
  <Accordion title="slack/list_channels">
    **설명:** Slack 워크스페이스의 모든 채널을 나열합니다.

    **파라미터:**

    * 파라미터가 필요하지 않습니다 - 접근 가능한 모든 채널을 조회합니다
  </Accordion>
</AccordionGroup>

### **메시징**

<AccordionGroup>
  <Accordion title="slack/send_message">
    **설명:** Slack 채널에 메시지를 전송합니다.

    **파라미터:**

    * `channel` (string, 필수): 채널 이름 또는 ID - Connect Portal Workflow Settings를 사용하여 사용자가 채널을 선택하도록 하거나, 채널 이름을 입력하여 새 채널을 생성할 수 있습니다.
    * `message` (string, 필수): 전송할 메시지 텍스트
    * `botName` (string, 필수): 이 메시지를 전송하는 봇의 이름
    * `botIcon` (string, 필수): 봇 아이콘 - 이미지 URL 또는 이모지(e.g., ":dog:") 모두 가능합니다.
    * `blocks` (object, 선택): 첨부파일 및 인터랙티브 요소 등이 포함된 풍부한 메시지 포맷팅을 위한 Slack Block Kit JSON
    * `authenticatedUser` (boolean, 선택): true이면 메시지가 애플리케이션이 아니라 인증된 Slack 사용자로부터 보낸 것처럼 표시됩니다(기본값은 false)
  </Accordion>

  <Accordion title="slack/send_direct_message">
    **설명:** Slack에서 특정 사용자에게 다이렉트 메시지를 전송합니다.

    **파라미터:**

    * `memberId` (string, 필수): 수신자 사용자 ID - Connect Portal Workflow Settings를 사용하여 사용자가 워크스페이스 멤버를 선택하도록 합니다.
    * `message` (string, 필수): 전송할 메시지 텍스트
    * `botName` (string, 필수): 이 메시지를 전송하는 봇의 이름
    * `botIcon` (string, 필수): 봇 아이콘 - 이미지 URL 또는 이모지(e.g., ":dog:") 모두 가능합니다.
    * `blocks` (object, 선택): 첨부파일 및 인터랙티브 요소 등이 포함된 풍부한 메시지 포맷팅을 위한 Slack Block Kit JSON
    * `authenticatedUser` (boolean, 선택): true이면 메시지가 애플리케이션이 아니라 인증된 Slack 사용자로부터 보낸 것처럼 표시됩니다(기본값은 false)
  </Accordion>
</AccordionGroup>

### **검색 및 탐색**

<AccordionGroup>
  <Accordion title="slack/search_messages">
    **설명:** Slack 워크스페이스 전체에서 메시지를 검색합니다.

    **매개변수:**

    * `query` (string, 필수): 지정된 기준과 일치하는 메시지를 찾기 위해 Slack 검색 구문을 사용한 검색 쿼리

    **검색 쿼리 예시:**

    * `"project update"` - "project update"가 포함된 메시지 검색
    * `from:@john in:#general` - #general 채널에서 John이 보낸 메시지 검색
    * `has:link after:2023-01-01` - 2023년 1월 1일 이후에 링크가 포함된 메시지 검색
    * `in:@channel before:yesterday` - 특정 채널에서 어제 이전에 작성된 메시지 검색
  </Accordion>
</AccordionGroup>

## Block Kit 통합

Slack의 Block Kit을 사용하면 풍부하고 상호작용이 가능한 메시지를 생성할 수 있습니다. 다음은 `blocks` 매개변수를 사용하는 방법에 대한 몇 가지 예시입니다:

### 첨부 파일이 있는 간단한 텍스트
```

Example 4 (unknown):
```unknown
### 섹션을 활용한 리치 포매팅
```

---

## "auto_scroll": True,  # Auto scroll the page

**URL:** llms-txt#"auto_scroll":-true,--#-auto-scroll-the-page

---

## Proteção rigorosa exigindo alta pontuação de fidelidade

**URL:** llms-txt#proteção-rigorosa-exigindo-alta-pontuação-de-fidelidade

**Contents:**
  - Incluindo Contexto da Resposta de Ferramentas

protecao_rigorosa = HallucinationGuardrail(
    context="Computação quântica utiliza qubits que existem em estados de superposição.",
    llm=LLM(model="gpt-4o-mini"),
    threshold=8.0  # Requer pontuação >= 8 para validar
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Incluindo Contexto da Resposta de Ferramentas

Se sua tarefa utiliza ferramentas, você pode incluir as respostas das ferramentas para validação mais precisa:
```

---

## Use knowledge sources instead of large prompts

**URL:** llms-txt#use-knowledge-sources-instead-of-large-prompts

**Contents:**
  - 컨텍스트 윈도우 모범 사례
  - 컨텍스트 문제 해결

knowledge_agent = Agent(
    role="Knowledge Expert",
    goal="Answer questions using curated knowledge",
    backstory="Expert at leveraging structured knowledge sources",
    knowledge_sources=[your_knowledge_sources],  # Pre-processed knowledge
    respect_context_window=True,
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 컨텍스트 윈도우 모범 사례

1. **컨텍스트 사용 모니터링**: `verbose=True`를 활성화하여 컨텍스트 관리 과정을 확인하세요
2. **효율성 설계**: 작업 구조를 효과적으로 설계하여 컨텍스트 누적을 최소화하세요
3. **적절한 모델 사용**: 작업에 적합한 컨텍스트 윈도우를 가진 LLM을 선택하세요
4. **두 가지 설정 모두 테스트**: `True`와 `False` 모두 시도하여 어떤 것이 더 효과적인지 확인하세요
5. **RAG와 조합 사용**: 매우 큰 데이터셋의 경우 컨텍스트 윈도우에만 의존하지 말고 RAG 도구도 함께 사용하세요

### 컨텍스트 문제 해결

**컨텍스트 제한 오류가 발생하는 경우:**
```

---

## Returns a TaskOutput object with the description and results of the task

**URL:** llms-txt#returns-a-taskoutput-object-with-the-description-and-results-of-the-task

**Contents:**
- 도구 재정의 메커니즘
- 오류 처리 및 검증 메커니즘
- 파일 저장 시 디렉토리 생성
  - 기본 동작

print(f"""
    Task completed!
    Task: {task1.output.description}
    Output: {task1.output.raw}
""")
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 도구 재정의 메커니즘

작업에서 도구를 지정하면 에이전트의 기능을 동적으로 조정할 수 있어 CrewAI의 유연성이 강조됩니다.

## 오류 처리 및 검증 메커니즘

작업을 생성하고 실행하는 동안, 작업 속성의 견고성과 신뢰성을 보장하기 위해 특정 검증 메커니즘이 마련되어 있습니다. 이는 다음에 국한되지 않습니다:

* 작업마다 한 가지 출력 유형만 설정하여 명확한 출력 기대치를 유지함
* 고유 식별자 시스템의 무결성을 유지하기 위해 `id` 속성의 수동 할당을 방지함

이러한 검증 절차는 crewAI 프레임워크 내에서 작업 실행의 일관성과 신뢰성을 유지하는 데 도움이 됩니다.

## 파일 저장 시 디렉토리 생성

`create_directory` 매개변수는 CrewAI가 작업 결과를 파일로 저장할 때 디렉토리를 자동으로 생성할지 여부를 제어합니다. 이 기능은 출력물을 체계적으로 정리하고, 특히 복잡한 프로젝트 계층 구조에서 파일 경로가 올바르게 구조화되도록 보장하는 데 매우 유용합니다.

### 기본 동작

기본적으로 `create_directory=True`로 설정되어 있으며, 이는 CrewAI가 출력 파일 경로에 누락된 디렉토리를 자동으로 생성함을 의미합니다:
```

---

## Configure o LLM com rastreamento de usuário

**URL:** llms-txt#configure-o-llm-com-rastreamento-de-usuário

portkey_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
        metadata={
            "_user": "user_123",  # Campo especial _user para analytics de usuários
            "user_tier": "premium",
            "user_company": "Acme Corp",
            "session_id": "abc-123"
        }
    )
)

---

## Exemplo com kickoff_async

**URL:** llms-txt#exemplo-com-kickoff_async

inputs = {'topic': 'AI in healthcare'}
async_result = await my_crew.kickoff_async(inputs=inputs)
print(async_result)

---

## 사이트에서 텍스트 추출

**URL:** llms-txt#사이트에서-텍스트-추출

**Contents:**
- 인자

text = tool.run()
print(text)
```

| 인자               | 타입       | 설명                                                                                  |
| :--------------- | :------- | :---------------------------------------------------------------------------------- |
| **website\_url** | `string` | **필수** 웹사이트 URL로, 파일을 읽기 위한 주소입니다. 이 값은 도구의 주요 입력값으로, 어떤 웹사이트의 콘텐츠를 수집하고 읽을지 지정합니다. |

---

## 1. Stdio 서버:

**URL:** llms-txt#1.-stdio-서버:

server_params=StdioServerParameters(
    command="python3",
    args=["servers/your_server.py"],
    env={"UV_PYTHON": "3.12", **os.environ},
)

---

## Define a condition function for the conditional task

**URL:** llms-txt#define-a-condition-function-for-the-conditional-task

---

## For creative content

**URL:** llms-txt#for-creative-content

**Contents:**
- Testando e Iterando no Design de Agentes
- Conclusão
- Próximos Passos

writer:
  role: "Creative Content Writer"
  goal: "..."
  backstory: "..."
  llm: anthropic/claude-3-opus
```

## Testando e Iterando no Design de Agentes

A construção de agentes geralmente é um processo iterativo. Veja como colocar em prática:

1. **Comece com um protótipo**: Crie uma definição inicial do agente
2. **Teste com tarefas de exemplo**: Avalie o desempenho em tarefas representativas
3. **Analise os resultados**: Identifique pontos fortes e fracos
4. **Refine a definição**: Ajuste papel, objetivo e histórico conforme suas observações
5. **Teste em colaboração**: Avalie como o agente se sai em conjunto no crew

Criar agentes eficazes é tanto arte quanto ciência. Ao definir cuidadosamente papéis, objetivos e históricos alinhados às suas necessidades, e combinar isso com tarefas bem projetadas, você constrói colaboradores de IA especializados capazes de gerar resultados excepcionais.

Lembre-se de que o design de agentes e tarefas é um processo iterativo. Comece com essas boas práticas, observe os agentes em ação e refine sua abordagem conforme necessário. E sempre tenha em mente a regra 80/20 – concentre a maior parte do esforço em criar tarefas claras e focadas para tirar o melhor de seus agentes.

<Check>
  Parabéns! Agora você entende os princípios e práticas do design eficaz de agentes. Aplique estas técnicas para criar agentes poderosos e especializados que trabalham juntos perfeitamente e realizam tarefas complexas.
</Check>

* Experimente diferentes configurações de agentes para o seu caso de uso
* Aprenda sobre [como construir seu primeiro crew](/pt-BR/guides/crews/first-crew) para ver como agentes trabalham juntos
* Explore os [CrewAI Flows](/pt-BR/guides/flows/first-flow) para uma orquestração mais avançada

---

## Get a free-form response

**URL:** llms-txt#get-a-free-form-response

result = analyst.kickoff("Analyze the AI market in 2025")
print(result.raw)  # Access the raw response

---

## Assuming you have the CustomLLM class defined above

**URL:** llms-txt#assuming-you-have-the-customllm-class-defined-above

---

## 다른 곳에서 접근이 필요하다면 익스포트할 수도 있습니다

**URL:** llms-txt#다른-곳에서-접근이-필요하다면-익스포트할-수도-있습니다

__all__ = ['my_custom_listener', 'another_listener']
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
4. Crew나 Flow 파일에서 리스너 패키지를 임포트합니다:
```

---

## Crie tarefas para seus agentes

**URL:** llms-txt#crie-tarefas-para-seus-agentes

task1 = Task(
    description="Realize uma análise abrangente dos avanços mais recentes em IA em 2024. Identifique tendências-chave, tecnologias inovadoras e impactos potenciais na indústria.",
    expected_output="Relatório analítico completo em tópicos",
    agent=pesquisador,
)

task2 = Task(
    description="Utilizando os insights fornecidos, desenvolva um blog envolvente destacando os avanços mais significativos em IA. O post deve ser informativo e acessível, voltado para um público técnico. Dê um tom interessante, evite palavras complexas para não soar como IA.",
    expected_output="Post de blog completo com pelo menos 4 parágrafos",
    agent=writer,
)

---

## Reset knowledge storage to clear old embeddings

**URL:** llms-txt#reset-knowledge-storage-to-clear-old-embeddings

crew.reset_memories(command_type='knowledge')

---

## O schema da ferramenta aceita filter_by e filter_value

**URL:** llms-txt#o-schema-da-ferramenta-aceita-filter_by-e-filter_value

---

## NL2SQL 도구

**URL:** llms-txt#nl2sql-도구

**Contents:**
- 개요
- 요구 사항
- 설치
- 사용법

Source: https://docs.crewai.com/ko/tools/database-data/nl2sqltool

NL2SQLTool은 자연어를 SQL 쿼리로 변환하도록 설계되었습니다.

이 도구는 자연어를 SQL 쿼리로 변환하는 데 사용됩니다. 에이전트에 전달되면 쿼리를 생성하고 이를 사용하여 데이터베이스와 상호작용합니다.

이를 통해 에이전트가 데이터베이스에 접근하여 목표에 따라 정보를 가져오고, 해당 정보를 사용해 응답, 보고서 또는 기타 출력물을 생성하는 다양한 워크플로우가 가능해집니다. 또한 에이전트가 자신의 목표에 맞춰 데이터베이스를 업데이트할 수 있는 기능도 제공합니다.

**주의**: 에이전트가 Read-Replica에 접근할 수 있거나, 에이전트가 데이터베이스에 insert/update 쿼리를 실행해도 괜찮은지 반드시 확인하십시오.

* SqlAlchemy
* 모든 DB 호환 라이브러리(예: psycopg2, mysql-connector-python)

NL2SQLTool을 사용하려면 데이터베이스 URI를 도구에 전달해야 합니다. URI는 `dialect+driver://username:password@host:port/database` 형식이어야 합니다.

```python Code theme={null}
from crewai_tools import NL2SQLTool

**Examples:**

Example 1 (unknown):
```unknown
## 사용법

NL2SQLTool을 사용하려면 데이터베이스 URI를 도구에 전달해야 합니다. URI는 `dialect+driver://username:password@host:port/database` 형식이어야 합니다.
```

---

## 빠른 해결책: 자동 처리 활성화

**URL:** llms-txt#빠른-해결책:-자동-처리-활성화

agent.respect_context_window = True

---

## ✅ Specific, actionable descriptions

**URL:** llms-txt#✅-specific,-actionable-descriptions

Task(
    description="""Research competitors in the AI chatbot space.
    Focus on: pricing models, key features, target markets.
    Provide data in a structured format.""",
    ...
)

---

## Proteção com contexto de resposta da ferramenta

**URL:** llms-txt#proteção-com-contexto-de-resposta-da-ferramenta

**Contents:**
- Como Funciona
  - Processo de Validação
  - Lógica de Validação
- Resultados da Proteção

protecao_clima = HallucinationGuardrail(
    context="Informações meteorológicas atuais para o local solicitado",
    llm=LLM(model="gpt-4o-mini"),
    tool_response="API do Clima retornou: Temperatura 22°C, Umidade 65%, Céu limpo"
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Como Funciona

### Processo de Validação

1. **Análise de Contexto**: A proteção compara a saída da tarefa com o contexto de referência fornecido
2. **Pontuação de Fidelidade**: Usa um avaliador interno para atribuir uma pontuação de fidelidade (0-10)
3. **Determinação do Veredito**: Determina se o conteúdo é fiel ou contém alucinações
4. **Verificação de Limiar**: Se um limiar personalizado for definido, valida contra essa pontuação
5. **Geração de Feedback**: Fornece motivos detalhados caso a validação falhe

### Lógica de Validação

* **Modo Padrão**: Utiliza validação baseada em veredito (FIÉL vs ALUCINADO)
* **Modo com Limiar**: Requer que a pontuação de fidelidade atinja ou supere o limiar especificado
* **Tratamento de Erros**: Lida com erros de avaliação de forma elegante e fornece feedback informativo

## Resultados da Proteção

A proteção retorna resultados estruturados indicando o status da validação:
```

---

## ou

**URL:** llms-txt#ou

**Contents:**
- Passo 7: Instale as Dependências
- Passo 8: Execute Seu Flow
- Passo 9: Visualize Seu Flow
- Passo 10: Revise o Resultado
- A Arte do Possível: Além do Seu Primeiro Flow
  - Aprimorando a Interação com o Usuário
  - Adicionando Mais Etapas de Processamento
  - Criando Flows Mais Complexos
  - Aplicando a Diferentes Domínios
- Principais Funcionalidades Demonstradas

ANTHROPIC_API_KEY=sua_chave_anthropic
bash  theme={null}
crewai install
bash  theme={null}
crewai flow kickoff
bash  theme={null}
crewai flow plot
python  theme={null}
llm = LLM(
    model="model-id-here",  # gpt-4o, gemini-2.0-flash, anthropic/claude...
    response_format=GuideOutline
)
response = llm.call(messages=messages)
python  theme={null}
@start()
def get_user_input(self):
    # Primeira etapa no flow
    # ...

@listen(get_user_input)
def create_guide_outline(self, state):
    # Esta roda quando get_user_input é concluída
    # ...
python  theme={null}
class GuideCreatorState(BaseModel):
    topic: str = ""
    audience_level: str = ""
    guide_outline: GuideOutline = None
    sections_content: Dict[str, str] = {}
python  theme={null}
result = ContentCrew().crew().kickoff(inputs={
    "section_title": section.title,
    # ...
})
```

Assim, você usa a ferramenta certa para cada parte da aplicação – chamadas diretas para tarefas simples e crews para colaboração avançada.

Agora que você construiu seu primeiro flow, pode:

1. Experimentar estruturas e padrões mais complexos de flow
2. Testar o uso do `@router()` para criar ramificações condicionais em seus flows
3. Explorar as funções `and_` e `or_` para execuções paralelas e mais complexas
4. Conectar seu flow a APIs externas, bancos de dados ou interfaces de usuário
5. Combinar múltiplos crews especializados em um único flow

<Check>
  Parabéns! Você construiu seu primeiro CrewAI Flow que combina código regular, chamadas diretas a LLM e processamento baseado em crews para criar um guia abrangente. Essas habilidades fundamentais permitem criar aplicações de IA cada vez mais sofisticadas, capazes de resolver problemas complexos de múltiplas etapas por meio de controle procedural e inteligência colaborativa.
</Check>

**Examples:**

Example 1 (unknown):
```unknown
## Passo 7: Instale as Dependências

Instale as dependências necessárias:
```

Example 2 (unknown):
```unknown
## Passo 8: Execute Seu Flow

Agora é hora de ver seu flow em ação! Execute-o usando a CLI do CrewAI:
```

Example 3 (unknown):
```unknown
Quando você rodar esse comando, verá seu flow ganhando vida:

1. Ele solicitará um tema e o nível do público para você
2. Criará um roteiro estruturado para o seu guia
3. Processará cada seção, com o redator e o revisor colaborando em cada uma
4. Por fim, irá compilar tudo em um guia abrangente

Isso demonstra o poder dos flows para orquestrar processos complexos envolvendo múltiplos componentes, tanto de IA quanto não-IA.

## Passo 9: Visualize Seu Flow

Uma das funcionalidades mais poderosas dos flows é a possibilidade de visualizar sua estrutura:
```

Example 4 (unknown):
```unknown
Isso irá criar um arquivo HTML que mostra a estrutura do seu flow, incluindo os relacionamentos entre etapas e o fluxo de dados. Essa visualização pode ser inestimável para entender e depurar flows complexos.

## Passo 10: Revise o Resultado

Depois que o flow finalizar, você encontrará dois arquivos no diretório `output`:

1. `guide_outline.json`: Contém o roteiro estruturado do guia
2. `complete_guide.md`: O guia abrangente com todas as seções

Reserve um momento para revisar esses arquivos e apreciar o que você construiu – um sistema que combina entrada do usuário, interações diretas com IA e trabalho colaborativo de agents para produzir um output complexo e de alta qualidade.

## A Arte do Possível: Além do Seu Primeiro Flow

O que você aprendeu neste guia é uma base para criar sistemas de IA muito mais sofisticados. Veja algumas formas de expandir este flow básico:

### Aprimorando a Interação com o Usuário

Você pode criar flows mais interativos com:

* Interfaces web para entrada e saída de dados
* Atualizações em tempo real de progresso
* Loops de feedback e refinamento interativos
* Interações multi-stage com o usuário

### Adicionando Mais Etapas de Processamento

Você pode expandir seu flow com etapas adicionais para:

* Pesquisa antes da criação do roteiro
* Geração de imagens para ilustrações
* Geração de snippets de código para guias técnicos
* Garantia de qualidade e checagem final de fatos

### Criando Flows Mais Complexos

Você pode implementar padrões de flow mais sofisticados:

* Ramificações condicionais com base na preferência do usuário ou tipo de conteúdo
* Processamento paralelo de seções independentes
* Loops de refinamento iterativo com feedback
* Integração a APIs e serviços externos

### Aplicando a Diferentes Domínios

Os mesmos padrões podem ser usados para criar flows de:

* **Narrativas interativas**: criação de histórias personalizadas com base na entrada do usuário
* **Inteligência de negócios**: processamento de dados, geração de insights e criação de relatórios
* **Desenvolvimento de produtos**: facilitação de ideação, design e planejamento
* **Sistemas educacionais**: criação de experiências de aprendizagem personalizadas

## Principais Funcionalidades Demonstradas

Este flow de criação de guia demonstra diversos recursos poderosos do CrewAI:

1. **Interação com o usuário**: O flow coleta input diretamente do usuário
2. **Chamadas diretas à LLM**: Usa a classe LLM para interações eficientes e direcionadas com IA
3. **Dados estruturados com Pydantic**: Usa Pydantic para garantir segurança de tipos
4. **Processamento sequencial com contexto**: Escreve seções em ordem, fornecendo as anteriores como contexto
5. **Crews multiagentes**: Utiliza agents especializados (redator e revisor) para criação de conteúdo
6. **Gerenciamento de estado**: Mantém estado entre diferentes etapas do processo
7. **Arquitetura orientada a eventos**: Usa o decorator `@listen` para responder a eventos

## Entendendo a Estrutura do Flow

Vamos decompor os principais componentes dos flows para ajudá-lo a entender como construir o seu:

### 1. Chamadas Diretas à LLM

Flows permitem que você faça chamadas diretas a modelos de linguagem quando precisa de respostas simples e estruturadas:
```

---

## 기본 HTTPS 서버

**URL:** llms-txt#기본-https-서버

"https://api.example.com/mcp"

---

## `SerperScrapeWebsiteTool`

**URL:** llms-txt#`serperscrapewebsitetool`

**Contents:**
- Description
- Installation
- Example

This tool is designed to scrape website content and extract clean, readable text from any website URL. It utilizes the [serper.dev](https://serper.dev) scraping API to fetch and process web pages, optionally including markdown formatting for better structure and readability.

To effectively use the `SerperScrapeWebsiteTool`, follow these steps:

1. **Package Installation**: Confirm that the `crewai[tools]` package is installed in your Python environment.
2. **API Key Acquisition**: Acquire a `serper.dev` API key by registering for an account at `serper.dev`.
3. **Environment Configuration**: Store your obtained API key in an environment variable named `SERPER_API_KEY` to facilitate its use by the tool.

To incorporate this tool into your project, follow the installation instructions below:

The following example demonstrates how to initialize the tool and scrape a website:

```python Code theme={null}
from crewai_tools import SerperScrapeWebsiteTool

**Examples:**

Example 1 (unknown):
```unknown
## Example

The following example demonstrates how to initialize the tool and scrape a website:
```

---

## 저장소에서 agent 불러오기

**URL:** llms-txt#저장소에서-agent-불러오기

analyst = Agent(
    from_repository="market-analyst-agent",
    verbose=True
)

---

## scrape_format="markdown"

**URL:** llms-txt#scrape_format="markdown"

---

## Use caminhos seguros para armazenamento

**URL:** llms-txt#use-caminhos-seguros-para-armazenamento

**Contents:**
- Solução de Problemas
  - Problemas Comuns
  - Dicas de Desempenho
- Benefícios do Sistema de Memória do CrewAI
- Conclusão

storage_path = os.getenv("CREWAI_STORAGE_DIR", "./storage")
os.makedirs(storage_path, mode=0o700, exist_ok=True)  # Permissões restritas

crew = Crew(
    memory=True,
    long_term_memory=LongTermMemory(
        storage=LTMSQLiteStorage(
            db_path=f"{storage_path}/memory.db"
        )
    )
)
```

## Solução de Problemas

**A memória não está persistindo entre sessões?**

* Verifique a variável de ambiente `CREWAI_STORAGE_DIR`
* Garanta permissões de escrita no diretório de armazenamento
* Certifique-se que a memória está ativada com `memory=True`

**Erros de autenticação no Mem0?**

* Verifique se a variável de ambiente `MEM0_API_KEY` está definida
* Confira permissões da chave de API no painel do Mem0
* Certifique-se de que o pacote `mem0ai` está instalado

**Alto uso de memória com grandes volumes de dados?**

* Considere usar Memória Externa com armazenamento personalizado
* Implemente paginação nos métodos de busca do armazenamento customizado
* Utilize modelos de embedding menores para menor consumo de memória

### Dicas de Desempenho

* Use `memory=True` para a maioria dos casos (mais simples e rápido)
* Só utilize Memória de Usuário se precisar de persistência específica por usuário
* Considere Memória Externa para necessidades de grande escala ou especializadas
* Prefira modelos de embedding menores para maior rapidez
* Defina limites apropriados de busca para controlar o tamanho da recuperação

## Benefícios do Sistema de Memória do CrewAI

* 🦾 **Aprendizado Adaptativo:** As crews tornam-se mais eficientes ao longo do tempo, adaptando-se a novas informações e refinando sua abordagem para tarefas.
* 🫡 **Personalização Avançada:** A memória permite que agentes lembrem preferências do usuário e interações passadas, proporcionando experiências personalizadas.
* 🧠 **Melhoria na Resolução de Problemas:** O acesso a um rico acervo de memória auxilia os agentes a tomar decisões mais informadas, recorrendo a aprendizados prévios e contextuais.

Integrar o sistema de memória do CrewAI em seus projetos é simples. Ao aproveitar os componentes e configurações oferecidos,
você rapidamente capacita seus agentes a lembrar, raciocinar e aprender com suas interações, desbloqueando novos níveis de inteligência e capacidade.

---

## Initialize a search tool

**URL:** llms-txt#initialize-a-search-tool

search_tool = SerperDevTool()

---

## 에이전트 저장소

**URL:** llms-txt#에이전트-저장소

**Contents:**
- 에이전트 저장소의 이점
- 에이전트 저장소 사용하기
  - 사전 준비 사항
  - 저장소에서 에이전트 생성 및 관리
  - 리포지토리에서 에이전트 불러오기

Source: https://docs.crewai.com/ko/enterprise/features/agent-repositories

에이전트 저장소를 사용하여 팀과 프로젝트 전반에 걸쳐 에이전트를 공유하고 재사용하는 방법을 알아보세요

생각: 이제 훌륭한 답변을 드릴 수 있습니다.
최종 답변:
Agent Repositories는 엔터프라이즈 사용자가 팀과 프로젝트 전반에 걸쳐 agent 정의를 저장, 공유, 재사용할 수 있도록 합니다. 이 기능을 통해 조직은 표준화된 agent의 중앙 라이브러리를 유지할 수 있어 일관성을 높이고 중복 작업을 줄일 수 있습니다.

* **표준화**: 조직 전반에서 일관된 에이전트 정의를 유지합니다
* **재사용성**: 한 번 에이전트를 생성하여 여러 crew 및 프로젝트에서 사용할 수 있습니다
* **거버넌스**: 조직 전체에 적용되는 에이전트 구성 정책을 구현합니다
* **협업**: 여러 팀이 서로의 작업을 공유하고 발전시킬 수 있도록 지원합니다

1. CrewAI 계정이 있어야 하며, [무료 플랜](https://app.crewai.com)을 이용해보세요.
2. CrewAI CLI를 사용하여 인증되어 있어야 합니다.
3. 여러 개의 조직이 있는 경우, CLI 명령어를 사용하여 올바른 조직으로 전환했는지 확인하세요:

### 저장소에서 에이전트 생성 및 관리

저장소에서 에이전트를 생성하고 관리하려면 Enterprise Dashboard를 사용하세요.

### 리포지토리에서 에이전트 불러오기

코드에서 `from_repository` 파라미터를 사용하여 리포지토리에서 에이전트를 불러올 수 있습니다:

```python  theme={null}
from crewai import Agent

**Examples:**

Example 1 (unknown):
```unknown
### 저장소에서 에이전트 생성 및 관리

저장소에서 에이전트를 생성하고 관리하려면 Enterprise Dashboard를 사용하세요.

### 리포지토리에서 에이전트 불러오기

코드에서 `from_repository` 파라미터를 사용하여 리포지토리에서 에이전트를 불러올 수 있습니다:
```

---

## 특정 task에서 재실행

**URL:** llms-txt#특정-task에서-재실행

**Contents:**
- 가능한 것의 예술: 당신의 첫 crew를 넘어서
  - 팀원 확장하기
  - 도구 및 기능 추가
  - 더 복잡한 워크플로우 생성
  - 다양한 도메인에 적용하기
- 다음 단계

crewai replay -t <task_id>
```

## 가능한 것의 예술: 당신의 첫 crew를 넘어서

이 가이드에서 구축한 것은 시작에 불과합니다. 여러분이 배운 기술과 패턴은 점점 더 정교한 AI 시스템을 만드는 데 적용할 수 있습니다. 다음은 이 기본 research crew를 확장할 수 있는 몇 가지 방법입니다:

더 전문화된 에이전트를 팀원으로 추가할 수 있습니다:

* 연구 결과를 검증하는 **팩트체커**
* 차트와 그래프를 만드는 **데이터 시각화 담당자**
* 특정 분야에 전문 지식을 가진 **도메인 전문가**
* 분석의 약점을 파악하는 **비평가**

에이전트에 추가 도구를 통해 기능을 확장할 수 있습니다:

* 실시간 연구를 위한 웹 브라우징 도구
* 데이터 분석을 위한 CSV/데이터베이스 도구
* 데이터 처리를 위한 코드 실행 도구
* 외부 서비스와의 API 연결

더 정교한 프로세스를 구현할 수 있습니다:

* 매니저 에이전트가 워커 에이전트에게 위임하는 계층적 프로세스
* 반복적 피드백 루프로 정제하는 반복 프로세스
* 여러 에이전트가 동시에 작업하는 병렬 프로세스
* 중간 결과에 따라 적응하는 동적 프로세스

동일한 패턴은 다음과 같은 분야에서 crew를 구성하는 데 적용할 수 있습니다:

* **콘텐츠 제작**: 작가, 에디터, 팩트체커, 디자이너가 함께 협업
* **고객 서비스**: 분류 담당자, 전문가, 품질 관리자가 함께 협업
* **제품 개발**: 연구원, 디자이너, 기획자가 협업
* **데이터 분석**: 데이터 수집가, 분석가, 시각화 전문가

이제 첫 crew를 구축했으니, 다음과 같은 작업을 시도해 볼 수 있습니다:

1. 다양한 에이전트 구성 및 성격을 실험해 보세요
2. 더 복잡한 작업 구조와 워크플로우를 시도해 보세요
3. 맞춤 도구를 구현하여 에이전트에게 새로운 기능을 제공하세요
4. crew를 다양한 주제나 문제 도메인에 적용해 보세요
5. [CrewAI Flows](/ko/guides/flows/first-flow)를 탐색하여 절차적 프로그래밍을 활용한 더 고급 워크플로우를 경험해 보세요

<Check>
  축하합니다! 이제 주어진 모든 주제를 조사하고 분석할 수 있는 첫 번째 CrewAI crew를 성공적으로 구축하셨습니다. 이 기본적인 경험은 협업 인텔리전스를 통해 복잡하고 다단계의 문제를 해결할 수 있는 점점 더 정교한 AI 시스템을 제작하는 데 필요한 역량을 갖추는 데 도움이 됩니다.
</Check>

---

## Example: search with category filter

**URL:** llms-txt#example:-search-with-category-filter

---

## `OCRTool`

**URL:** llms-txt#`ocrtool`

**Contents:**
- Description
- Installation
- Parameters
  - Run Parameters
- Examples
  - Direct usage
  - With an agent
- Notes
- Example

Extract text from images (local path or URL). Uses a vision‑capable LLM via CrewAI’s LLM interface.

No extra install beyond `crewai-tools`. Ensure your selected LLM supports vision.

* `image_path_url` (str, required): Local image path or HTTP(S) URL.

* Ensure the selected LLM supports image inputs.
* For large images, consider downscaling to reduce token usage.
* You can pass a specific LLM instance to the tool (e.g., `LLM(model="gpt-4o")`) if needed, matching the README guidance.

**Examples:**

Example 1 (unknown):
```unknown
### With an agent
```

Example 2 (unknown):
```unknown
## Notes

* Ensure the selected LLM supports image inputs.
* For large images, consider downscaling to reduce token usage.
* You can pass a specific LLM instance to the tool (e.g., `LLM(model="gpt-4o")`) if needed, matching the README guidance.

## Example
```

---

## `XMLSearchTool`

**URL:** llms-txt#`xmlsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando na melhoria das ferramentas, então pode haver comportamentos inesperados ou mudanças no futuro.
</Note>

O XMLSearchTool é uma ferramenta RAG de ponta, desenvolvida para realizar buscas semânticas em arquivos XML.
Ideal para usuários que precisam analisar e extrair informações do conteúdo XML de forma eficiente, esta ferramenta permite inserir uma consulta de busca e um caminho opcional para o arquivo XML.
Ao especificar um caminho de arquivo XML, o usuário pode direcionar sua busca de forma mais precisa ao conteúdo daquele arquivo, obtendo assim resultados mais relevantes.

Para começar a usar o XMLSearchTool, é necessário instalar primeiro o pacote crewai\_tools. Isso pode ser feito facilmente com o seguinte comando:

Aqui estão dois exemplos demonstrando como usar o XMLSearchTool.
O primeiro exemplo mostra a busca dentro de um arquivo XML específico, enquanto o segundo exemplo ilustra como iniciar uma busca sem definir previamente um caminho XML, oferecendo flexibilidade no escopo da busca.

```python Code theme={null}
from crewai_tools import XMLSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Aqui estão dois exemplos demonstrando como usar o XMLSearchTool.
O primeiro exemplo mostra a busca dentro de um arquivo XML específico, enquanto o segundo exemplo ilustra como iniciar uma busca sem definir previamente um caminho XML, oferecendo flexibilidade no escopo da busca.
```

---

## Add to your agent

**URL:** llms-txt#add-to-your-agent

**Contents:**
- **Boas Práticas de Scraping**
- **Guia de Seleção de Ferramentas**

agent = Agent(
    role="Web Research Specialist",
    tools=[simple_scraper, advanced_scraper, browser_automation],
    goal="Extract and analyze web data efficiently"
)
```

## **Boas Práticas de Scraping**

* **Respeite o robots.txt**: Sempre verifique e siga as políticas de scraping do website
* **Controle de Taxa (Rate Limiting)**: Implemente atrasos entre as requisições para evitar sobrecarregar servidores
* **User Agents**: Use strings de user agent apropriadas para identificar o seu bot
* **Conformidade Legal**: Certifique-se de que suas atividades de scraping estejam em conformidade com os termos de serviço
* **Tratamento de Erros**: Implemente um tratamento de erros robusto para problemas de rede e requisições bloqueadas
* **Qualidade dos Dados**: Valide e limpe os dados extraídos antes de processar

## **Guia de Seleção de Ferramentas**

* **Tarefas Simples**: Use `ScrapeWebsiteTool` para extração básica de conteúdo
* **Sites Dinâmicos com JavaScript**: Use `SeleniumScrapingTool` para conteúdo dinâmico
* **Escala & Performance**: Use `FirecrawlScrapeWebsiteTool` para scraping em grande volume
* **Infraestrutura em Nuvem**: Use `BrowserBaseLoadTool` para automação de navegador escalável
* **Fluxos Complexos**: Use `StagehandTool` para interações inteligentes com o navegador

---

## Exemplo de inicialização da ferramenta que agentes podem usar

**URL:** llms-txt#exemplo-de-inicialização-da-ferramenta-que-agentes-podem-usar

---

## EXA Search Web Loader

**URL:** llms-txt#exa-search-web-loader

Source: https://docs.crewai.com/en/tools/search-research/exasearchtool

The `EXASearchTool` is designed to perform a semantic search for a specified query from a text's content across the internet.

---

## 1. Servidor Stdio:

**URL:** llms-txt#1.-servidor-stdio:

server_params=StdioServerParameters(
    command="python3",
    args=["servers/your_server.py"],
    env={"UV_PYTHON": "3.12", **os.environ},
)

---

## `ScrapflyScrapeWebsiteTool`

**URL:** llms-txt#`scrapflyscrapewebsitetool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

A `ScrapflyScrapeWebsiteTool` foi desenvolvida para aproveitar a API de web scraping da [Scrapfly](https://scrapfly.io/) para extrair conteúdo de sites. Esta ferramenta oferece recursos avançados de raspagem com suporte a navegador headless, proxies e recursos de bypass de anti-bot. Permite extrair dados de páginas web em vários formatos, incluindo HTML bruto, markdown e texto simples, sendo ideal para uma ampla variedade de tarefas de raspagem de sites.

Para utilizar esta ferramenta, é necessário instalar o Scrapfly SDK:

Você também precisará obter uma chave de API da Scrapfly registrando-se em [scrapfly.io/register](https://www.scrapfly.io/register/).

## Passos para Começar

Para usar a `ScrapflyScrapeWebsiteTool` de forma eficaz, siga estas etapas:

1. **Instale as Dependências**: Instale o Scrapfly SDK usando o comando acima.
2. **Obtenha a Chave de API**: Cadastre-se na Scrapfly para obter sua chave de API.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta com sua chave de API.
4. **Configure os Parâmetros de Raspagem**: Personalize os parâmetros de raspagem conforme suas necessidades.

O exemplo a seguir demonstra como usar a `ScrapflyScrapeWebsiteTool` para extrair conteúdo de um site:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import ScrapflyScrapeWebsiteTool

**Examples:**

Example 1 (unknown):
```unknown
Você também precisará obter uma chave de API da Scrapfly registrando-se em [scrapfly.io/register](https://www.scrapfly.io/register/).

## Passos para Começar

Para usar a `ScrapflyScrapeWebsiteTool` de forma eficaz, siga estas etapas:

1. **Instale as Dependências**: Instale o Scrapfly SDK usando o comando acima.
2. **Obtenha a Chave de API**: Cadastre-se na Scrapfly para obter sua chave de API.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta com sua chave de API.
4. **Configure os Parâmetros de Raspagem**: Personalize os parâmetros de raspagem conforme suas necessidades.

## Exemplo

O exemplo a seguir demonstra como usar a `ScrapflyScrapeWebsiteTool` para extrair conteúdo de um site:
```

---

## Define our models for structured data

**URL:** llms-txt#define-our-models-for-structured-data

class Section(BaseModel):
    title: str = Field(description="Title of the section")
    description: str = Field(description="Brief description of what the section should cover")

class GuideOutline(BaseModel):
    title: str = Field(description="Title of the guide")
    introduction: str = Field(description="Introduction to the topic")
    target_audience: str = Field(description="Description of the target audience")
    sections: List[Section] = Field(description="List of sections in the guide")
    conclusion: str = Field(description="Conclusion or summary of the guide")

---

## Create an agent focused on file operations

**URL:** llms-txt#create-an-agent-focused-on-file-operations

file_operator = Agent(
    role="File Operator",
    goal="Upload, download, and manage files with precision",
    backstory="An AI assistant skilled in file handling and content management.",
    apps=['microsoft_onedrive/upload_file', 'microsoft_onedrive/download_file', 'microsoft_onedrive/get_file_info']
)

---

## Para especificação dinâmica de diretório em tempo de execução

**URL:** llms-txt#para-especificação-dinâmica-de-diretório-em-tempo-de-execução

tool = DirectorySearchTool()

---

## Initialize tool with preset filter

**URL:** llms-txt#initialize-tool-with-preset-filter

**Contents:**
  - Combining Filters

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_url",
        qdrant_api_key="your_key",
        collection_name="your_collection",
        filter=preset_filter  # Preset filter applied to all searches
    )
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Combining Filters

The tool automatically combines preset filters from `QdrantConfig` with dynamic filters from `filter_by` and `filter_value`:
```

---

## rest of the code ...

**URL:** llms-txt#rest-of-the-code-...

**Contents:**
- Conclusão

As ferramentas são fundamentais para ampliar as capacidades dos agentes CrewAI, permitindo que realizem uma ampla variedade de tarefas e colaborem de forma eficaz.
Ao construir soluções com CrewAI, aproveite tanto ferramentas personalizadas quanto existentes para potencializar seus agentes e aprimorar o ecossistema de IA. Considere utilizar tratamento de erros, mecanismos de cache e a flexibilidade dos argumentos das ferramentas para otimizar o desempenho e as capacidades dos seus agentes.

---

## QdrantConfig에 category="research"에 대한 사전 설정 필터가 있고

**URL:** llms-txt#qdrantconfig에-category="research"에-대한-사전-설정-필터가-있고

---

## Alternar para outra organização

**URL:** llms-txt#alternar-para-outra-organização

crewai org switch <org_id>

---

## 프로젝트에 대한 키를 프로젝트 설정 페이지에서 확인하세요: https://cloud.langfuse.com

**URL:** llms-txt#프로젝트에-대한-키를-프로젝트-설정-페이지에서-확인하세요:-https://cloud.langfuse.com

os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..."
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # 🇪🇺 EU 지역

---

## Initialize the tool with a specific file path, so the agent can only read the content of the specified file

**URL:** llms-txt#initialize-the-tool-with-a-specific-file-path,-so-the-agent-can-only-read-the-content-of-the-specified-file

**Contents:**
- Arguments

file_read_tool = FileReadTool(file_path='path/to/your/file.txt')
```

* `file_path`: The path to the file you want to read. It accepts both absolute and relative paths. Ensure the file exists and you have the necessary permissions to access it.

---

## Microsoft Word 기능을 가진 에이전트 생성

**URL:** llms-txt#microsoft-word-기능을-가진-에이전트-생성

word_agent = Agent(
    role="문서 관리자",
    goal="Word 문서와 텍스트 파일을 효율적으로 관리",
    backstory="Microsoft Word 문서 작업 및 콘텐츠 관리 전문 AI 어시스턴트.",
    apps=['microsoft_word']  # 모든 Word 작업을 사용할 수 있습니다
)

---

## Run the flow

**URL:** llms-txt#run-the-flow

**Contents:**
- Framework Prático de Avaliação
  - Passo 1: Avalie a Complexidade
  - Passo 2: Avalie os Requisitos de Precisão
  - Passo 3: Mapeie na Matriz
  - Passo 4: Considere Fatores Adicionais
- Conclusão
- Próximos Passos

content_flow = ContentProductionFlow()
result = content_flow.kickoff()
```

## Framework Prático de Avaliação

Para determinar a abordagem certa para seu caso de uso específico, siga este framework passo a passo:

### Passo 1: Avalie a Complexidade

Classifique a complexidade do seu aplicativo numa escala de 1-10 considerando:

1. **Número de etapas**: Quantas operações distintas são necessárias?
   * 1-3 etapas: Baixa complexidade (1-3)
   * 4-7 etapas: Média complexidade (4-7)
   * 8+ etapas: Alta complexidade (8-10)

2. **Interdependências**: Quão interligadas estão as partes diferentes?
   * Poucas dependências: Baixa complexidade (1-3)
   * Algumas dependências: Média complexidade (4-7)
   * Muitas dependências complexas: Alta complexidade (8-10)

3. **Lógica condicional**: Quanto de ramificação e tomada de decisão é necessário?
   * Processo linear: Baixa complexidade (1-3)
   * Alguma ramificação: Média complexidade (4-7)
   * Árvores de decisão complexas: Alta complexidade (8-10)

4. **Conhecimento de domínio**: Quão especializado deve ser o conhecimento requerido?
   * Conhecimento geral: Baixa complexidade (1-3)
   * Algum conhecimento especializado: Média complexidade (4-7)
   * Grande especialização em múltiplos domínios: Alta complexidade (8-10)

Calcule a média das pontuações para determinar sua complexidade geral.

### Passo 2: Avalie os Requisitos de Precisão

Classifique seus requisitos de precisão numa escala de 1-10 considerando:

1. **Estrutura da saída**: Quão estruturado o resultado deve ser?
   * Texto livre: Baixa precisão (1-3)
   * Semi-estruturado: Média precisão (4-7)
   * Estritamente formatado (JSON, XML): Alta precisão (8-10)

2. **Necessidade de exatidão**: Qual a importância da precisão factual?
   * Conteúdo criativo: Baixa precisão (1-3)
   * Conteúdo informacional: Média precisão (4-7)
   * Informação crítica: Alta precisão (8-10)

3. **Reprodutibilidade**: Quão consistentes devem ser os resultados entre execuções?
   * Variação aceitável: Baixa precisão (1-3)
   * Alguma consistência necessária: Média precisão (4-7)
   * Exata reprodutibilidade: Alta precisão (8-10)

4. **Tolerância a erros**: Qual o impacto de erros?
   * Baixo impacto: Baixa precisão (1-3)
   * Impacto moderado: Média precisão (4-7)
   * Alto impacto: Alta precisão (8-10)

Calcule a média das pontuações para determinar seu requisito geral de precisão.

### Passo 3: Mapeie na Matriz

Plote as pontuações de complexidade e precisão na matriz:

* **Baixa Complexidade (1-4), Baixa Precisão (1-4)**: Crews simples
* **Baixa Complexidade (1-4), Alta Precisão (5-10)**: Flows com chamadas diretas a LLM
* **Alta Complexidade (5-10), Baixa Precisão (1-4)**: Crews complexas
* **Alta Complexidade (5-10), Alta Precisão (5-10)**: Flows orquestrando Crews

### Passo 4: Considere Fatores Adicionais

Além de complexidade e precisão, considere:

1. **Tempo de desenvolvimento**: Crews costumam ser mais rápidas para prototipar
2. **Necessidades de manutenção**: Flows proporcionam melhor manutenção a longo prazo
3. **Expertise do time**: Considere a familiaridade de sua equipe com as abordagens
4. **Requisitos de escalabilidade**: Flows normalmente escalam melhor para aplicações complexas
5. **Necessidades de integração**: Considere como a solução se integrará aos sistemas existentes

Escolher entre Crews e Flows — ou combiná-los — é uma decisão arquitetônica crítica que impacta a efetividade, manutenibilidade e escalabilidade da sua aplicação CrewAI. Ao avaliar seu caso de uso nas dimensões de complexidade e precisão, você toma decisões inteligentes que alinham-se aos seus requisitos.

Lembre-se de que a melhor abordagem geralmente evolui na medida em que sua aplicação amadurece. Comece com a solução mais simples que atenda às suas necessidades e esteja preparado para refinar sua arquitetura conforme for ganhando experiência e seus requisitos se tornarem mais claros.

<Check>
  Agora você tem um framework para avaliar casos de uso CrewAI e escolher a abordagem certa de acordo com requisitos de complexidade e precisão. Isso vai ajudar você a construir aplicações de IA mais eficientes, de fácil manutenção e escaláveis.
</Check>

* Saiba mais sobre [como criar agentes eficazes](/pt-BR/guides/agents/crafting-effective-agents)
* Explore [como construir sua primeira crew](/pt-BR/guides/crews/first-crew)
* Aprofunde-se em [gerenciamento de estado em flows](/pt-BR/guides/flows/mastering-flow-state)
* Confira os [conceitos centrais](/pt-BR/concepts/agents) para um entendimento mais aprofundado

---

## 자주 묻는 질문

**URL:** llms-txt#자주-묻는-질문

Source: https://docs.crewai.com/ko/enterprise/resources/frequently-asked-questions

CrewAI AMP에 대한 자주 묻는 질문

<AccordionGroup>
  <Accordion title="계층적 프로세스에서 작업 실행은 어떻게 처리됩니까?">
    계층적 프로세스에서는 매니저 에이전트가 자동으로 생성되어 워크플로우를 조정하고, 작업을 위임하며 결과를 검증하여 효율적이고 체계적으로 작업이 수행되도록 합니다. 매니저 에이전트는 하위 에이전트에게 작업을 위임하고 실행을 지원하기 위해 도구를 활용합니다. 매니저 LLM은 계층적 프로세스에서 매우 중요하며, 적절한 작동을 위해 반드시 올바르게 설정되어야 합니다.
  </Accordion>

<Accordion title="가장 최신의 CrewAI 문서는 어디에서 확인할 수 있습니까?">
    CrewAI에 대한 최신 문서는 공식 문서 사이트에서 확인하실 수 있습니다: [https://docs.crewai.com/](https://docs.crewai.com/)
    <Card href="https://docs.crewai.com/" icon="books">CrewAI 문서</Card>
  </Accordion>

<Accordion title="CrewAI의 계층적 프로세스와 순차적 프로세스의 주요 차이점은 무엇입니까?">
    #### 계층적 프로세스:

* 명확한 지휘 체계에 따라 작업이 위임 및 실행됨
    * 매니저 에이전트에 대해 manager language model(`manager_llm`)을 반드시 지정해야 함
    * 매니저 에이전트가 작업 실행, 계획, 위임, 검증을 총괄함
    * 작업이 사전에 지정되지 않으며, 매니저가 각 에이전트의 역량에 따라 작업을 할당함

* 작업이 순서대로 하나씩 실행되어 작업들이 순차적으로 진행됨
    * 이전 작업의 결과가 다음 작업의 맥락이 됨
    * 작업 실행이 작업 리스트에 정의된 순서대로 진행됨

#### 복잡한 프로젝트에 더 적합한 프로세스는 무엇입니까?

계층적 프로세스는 다음과 같은 이유로 복잡한 프로젝트에 더 적합합니다:

* **동적 작업 할당과 위임**: 매니저 에이전트가 에이전트의 역량에 따라 작업을 할당할 수 있음
    * **구조화된 검증과 감독**: 매니저 에이전트가 작업 결과를 검토하고 완료를 보장함
    * **복잡한 작업 관리**: 에이전트 수준에서의 도구 사용 제어 등 세밀한 관리 가능
  </Accordion>

<Accordion title="CrewAI 프레임워크에서 메모리를 사용할 때의 이점은 무엇입니까?">
    * **적응적 학습**: crew는 시간이 지날수록 더 효율적으로 적응하며, 새로운 정보에 맞춰 작업 방식을 개선하게 됩니다.
    * **개인화된 경험 강화**: 메모리를 통해 에이전트가 사용자 선호도나 과거 상호작용을 기억하여 더욱 개인화된 경험을 제공합니다.
    * **문제 해결력 향상**: 풍부한 메모리 접근을 통해 과거의 학습이나 맥락적 인사이트를 적용하여 에이전트가 더 나은 결정을 내릴 수 있습니다.
  </Accordion>

<Accordion title="에이전트의 최대 RPM 제한을 설정하는 목적은 무엇입니까?">
    에이전트의 최대 RPM 제한을 설정하면 외부 서비스에 과도하게 요청을 보내지 않도록 하여, 제한에 걸리는 일을 예방하고 성능을 향상시킬 수 있습니다.
  </Accordion>

<Accordion title="CrewAI crew 내에서 작업 실행 시 인간 입력은 어떤 역할을 하나요?">
    인간 입력을 통해 에이전트는 필요할 때 추가 정보나 설명을 요청할 수 있습니다. 이 기능은 복잡한 의사결정 과정이나, 에이전트가 작업을 효과적으로 완료하는 데 더 많은 세부 정보가 필요할 때 매우 중요합니다.

에이전트 실행에 인간 입력을 통합하려면 작업 정의에서 `human_input` 플래그를 설정하세요. 활성화하면, 에이전트가 최종 답변을 제공하기 전에 사용자에게 입력을 요청합니다. 이 입력은 추가 맥락을 제공하거나, 애매함을 해소하거나, 에이전트의 출력을 검증해야 할 때 활용될 수 있습니다.

자세한 구현 방법은 [Human-in-the-Loop 가이드](/ko/how-to/human-in-the-loop)를 참고해 주세요.
  </Accordion>

<Accordion title="CrewAI에서 에이전트의 행동과 역량을 맞춤화하고 향상시키기 위한 고급 커스터마이징 옵션에는 어떤 것이 있나요?">
    CrewAI는 다양한 고급 커스터마이징 옵션을 제공합니다:

* **Language Model 커스터마이징**: 에이전트별로 특정 language model(`llm`) 및 function-calling language model(`function_calling_llm`)을 지정 가능
    * **성능 및 디버깅 설정**: 에이전트의 성능을 조정하고 동작을 모니터링할 수 있음
    * **Verbose 모드**: 에이전트의 작업 로그를 자세하게 기록하여 디버깅 및 최적화에 활용할 수 있음
    * **RPM 제한**: 분당 최대 요청 수(`max_rpm`) 설정
    * **최대 반복 횟수**: `max_iter` 속성으로 에이전트가 한 작업에서 허용되는 반복 횟수를 지정
    * **위임 및 자율성 제어**: `allow_delegation` 속성(기본값: True)으로 에이전트의 위임 또는 질문 가능 여부 제어
    * **인간 입력 통합**: 필요 시 추가 정보나 설명을 사용자에게 요청할 수 있음
  </Accordion>

<Accordion title="에이전트 실행 시 어떤 상황에서 인간 입력이 특히 유용합니까?">
    인간 입력이 특히 유용한 경우는 다음과 같습니다:

* **에이전트가 추가 정보나 설명이 필요할 때**: 에이전트가 애매하거나 불완전한 데이터를 만날 때
    * **에이전트가 복잡하거나 민감한 결정을 내려야 할 때**: 윤리적이거나 미묘한 결정이 필요한 경우 인간 입력이 보조할 수 있음
    * **에이전트 출력의 감독 및 검증이 필요할 때**: 결과 검증과 오류 방지에 도움
    * **에이전트 행동을 커스터마이징 할 때**: 피드백을 통해 에이전트의 응답을 지속적으로 개선
    * **오류 및 한계 식별 및 해결 시**: 에이전트의 한계점이나 오류를 인간 입력으로 해결 가능
  </Accordion>

<Accordion title="crewAI에서 사용할 수 있는 메모리의 종류는 무엇입니까?">
    CrewAI에서 제공되는 메모리의 종류는 다음과 같습니다:

* **단기 메모리**: 즉각적인 맥락을 위한 임시 저장소
    * **장기 메모리**: 학습된 패턴 및 정보의 영구 저장소
    * **엔티티 메모리**: 특정 엔티티와 그 속성에 집중하는 저장소
    * **컨텍스추얼 메모리**: 상호작용 간 맥락을 유지하는 메모리

다른 메모리 유형에 대해 자세히 알아보려면:
    <Card href="https://docs.crewai.com/concepts/memory" icon="brain">CrewAI 메모리</Card>
  </Accordion>

<Accordion title="작업에서 Output Pydantic을 사용하는 방법은 무엇입니까?">
    작업에서 Output Pydantic을 사용하려면, 해당 작업의 예상 결과를 Pydantic 모델로 정의해야 합니다. 빠른 예시는 다음과 같습니다:

<Steps>
      <Step title="Pydantic 모델 정의하기">
        
      </Step>

<Step title="Output Pydantic으로 작업 생성하기">
        
      </Step>

<Step title="에이전트에서 output_pydantic 속성 설정">
        
      </Step>
    </Steps>

에이전트가 항상 구조화된 출력을 내도록 만드는 방법 관련 튜토리얼은 아래 영상을 참고하세요:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/dNpKQk5uxHw" title="CrewAI 구조화된 출력" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />
  </Accordion>

<Accordion title="CrewAI 에이전트를 위한 커스텀 도구는 어떻게 만들 수 있습니까?">
    CrewAI에서 제공하는 `BaseTool` 클래스를 상속받아 커스텀 도구를 직접 만들거나, tool 데코레이터를 활용할 수 있습니다. 상속 방식은 `BaseTool`을 상속하는 새로운 클래스를 정의해 이름, 설명, 그리고 실제 논리를 처리하는 `_run` 메서드를 작성합니다. tool 데코레이터를 사용하면 필수 속성과 운영 로직만 정의해 바로 `Tool` 객체를 만들 수 있습니다.

<Card href="https://docs.crewai.com/how-to/create-custom-tools" icon="code">CrewAI 도구 가이드</Card>
  </Accordion>

<Accordion title="전체 crew가 수행할 수 있는 분당 최대 요청 수는 어떻게 제한할 수 있나요?">
    `max_rpm` 속성을 설정하면 crew 전체가 분당 보낼 수 있는 최대 요청 수를 제한할 수 있습니다. 이를 설정하면 개별 에이전트의 `max_rpm` 값보다 우선적으로 적용됩니다.
  </Accordion>
</AccordionGroup>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

      <Step title="Output Pydantic으로 작업 생성하기">
```

Example 2 (unknown):
```unknown
</Step>

      <Step title="에이전트에서 output_pydantic 속성 설정">
```

---

## Múltiplos serviços AMP

**URL:** llms-txt#múltiplos-serviços-amp

**Contents:**
- Exemplo Completo

mcps=[
    "crewai-amp:weather-insights",
    "crewai-amp:market-analysis",
    "crewai-amp:social-media-monitoring"
]
python  theme={null}
from crewai import Agent, Task, Crew, Process

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo Completo

Aqui está um exemplo completo usando múltiplos servidores MCP:
```

---

## Example task to search for information in a specific channel

**URL:** llms-txt#example-task-to-search-for-information-in-a-specific-channel

research_task = Task(
    description="Search for information about machine learning tutorials in the YouTube channel {youtube_channel_handle}",
    expected_output="A summary of the key machine learning tutorials available on the channel.",
    agent=channel_researcher,
)

---

## And the search uses filter_by="year", filter_value=2024

**URL:** llms-txt#and-the-search-uses-filter_by="year",-filter_value=2024

---

## `SpiderTool`

**URL:** llms-txt#`spidertool`

**Contents:**
- Descrição
- Instalação
- Exemplo
- Argumentos

[Spider](https://spider.cloud/?ref=crewai) é o [scraper](https://github.com/spider-rs/spider/blob/main/benches/BENCHMARKS.md#benchmark-results) e crawler de código aberto mais rápido que retorna dados prontos para LLM.\
Ele converte qualquer site em HTML puro, markdown, metadados ou texto e permite que você faça crawling com ações personalizadas utilizando IA.

Para usar o `SpiderTool` você precisa baixar o [Spider SDK](https://pypi.org/project/spider-client/)\
e também o SDK `crewai[tools]`:

Este exemplo mostra como você pode usar o `SpiderTool` para permitir que seu agente faça scraping e crawling de websites.\
Os dados retornados pela API do Spider já estão prontos para LLM, então não é necessário fazer nenhuma limpeza adicional.

| Argumento               | Tipo     | Descrição                                                                                                                                                       |
| :---------------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **api\_key**            | `string` | Especifica a chave da API do Spider. Se não for definida, procura por `SPIDER_API_KEY` nas variáveis de ambiente.                                               |
| **params**              | `object` | Parâmetros opcionais para a requisição. O padrão é `{"return_format": "markdown"}` para otimizar o conteúdo para LLMs.                                          |
| **request**             | `string` | Tipo de requisição a ser realizada (`http`, `chrome`, `smart`). `smart` tem como padrão HTTP, alterando para renderização JavaScript se necessário.             |
| **limit**               | `int`    | Máximo de páginas a serem rastreadas por site. Defina como `0` ou omita para ilimitado.                                                                         |
| **depth**               | `int`    | Profundidade máxima do crawl. Defina como `0` para sem limite.                                                                                                  |
| **cache**               | `bool`   | Habilita cache HTTP para acelerar execuções repetidas. O padrão é `true`.                                                                                       |
| **budget**              | `object` | Define limites baseados em caminho para páginas rastreadas, ex.: `{"*":1}` apenas para a página raiz.                                                           |
| **locale**              | `string` | Localidade da requisição, ex.: `en-US`.                                                                                                                         |
| **cookies**             | `string` | Cookies HTTP para a requisição.                                                                                                                                 |
| **stealth**             | `bool`   | Habilita modo furtivo para requisições Chrome para evitar detecção. O padrão é `true`.                                                                          |
| **headers**             | `object` | Headers HTTP como um mapa de chave-valor para todas as requisições.                                                                                             |
| **metadata**            | `bool`   | Armazena metadados sobre as páginas e conteúdos, auxiliando interoperabilidade com IA. O padrão é `false`.                                                      |
| **viewport**            | `object` | Define as dimensões de viewport do Chrome. O padrão é `800x600`.                                                                                                |
| **encoding**            | `string` | Especifica o tipo de codificação, ex.: `UTF-8`, `SHIFT_JIS`.                                                                                                    |
| **subdomains**          | `bool`   | Inclui subdomínios no crawl. O padrão é `false`.                                                                                                                |
| **user\_agent**         | `string` | User agent HTTP personalizado. Padrão é um agente aleatório.                                                                                                    |
| **store\_data**         | `bool`   | Habilita o armazenamento dos dados para a requisição. Sobrescreve `storageless` quando definido. O padrão é `false`.                                            |
| **gpt\_config**         | `object` | Permite à IA gerar ações de crawl, com encadeamento de etapas opcional via array para `"prompt"`.                                                               |
| **fingerprint**         | `bool`   | Habilita fingerprint avançado para o Chrome.                                                                                                                    |
| **storageless**         | `bool`   | Impede todo o armazenamento de dados, incluindo embeddings de IA. O padrão é `false`.                                                                           |
| **readability**         | `bool`   | Pré-processa conteúdo para leitura via [Mozilla’s readability](https://github.com/mozilla/readability). Melhora o conteúdo para LLMs.                           |
| **return\_format**      | `string` | Formato para retorno dos dados: `markdown`, `raw`, `text`, `html2text`. Use `raw` para formato padrão da página.                                                |
| **proxy\_enabled**      | `bool`   | Habilita proxies de alta performance para evitar bloqueios em nível de rede.                                                                                    |
| **query\_selector**     | `string` | CSS query selector para extração de conteúdo a partir do markup.                                                                                                |
| **full\_resources**     | `bool`   | Baixa todos os recursos vinculados ao site.                                                                                                                     |
| **request\_timeout**    | `int`    | Timeout em segundos para as requisições (5-60). O padrão é `30`.                                                                                                |
| **run\_in\_background** | `bool`   | Executa a requisição em segundo plano. Útil para armazenamento de dados e acionamento de crawls no dashboard. Não tem efeito se `storageless` estiver definido. |

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Este exemplo mostra como você pode usar o `SpiderTool` para permitir que seu agente faça scraping e crawling de websites.\
Os dados retornados pela API do Spider já estão prontos para LLM, então não é necessário fazer nenhuma limpeza adicional.
```

---

## Gmail 연동

**URL:** llms-txt#gmail-연동

**Contents:**
- 개요
- 사전 준비 사항
- Gmail 연동 설정
  - 1. Gmail 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 Gmail 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/gmail

CrewAI를 위한 Gmail 연동을 통한 이메일 및 연락처 관리.

에이전트가 Gmail을 통해 이메일, 연락처, 임시 저장 메시지를 관리할 수 있도록 합니다. 이메일을 보내고, 메시지를 검색하며, 연락처를 관리하고, 임시 저장 메시지를 작성하며, AI 기반 자동화를 통해 이메일 커뮤니케이션을 효율화하세요.

Gmail 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 Gmail 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Gmail 계정 연결

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **Gmail**을 찾습니다.
3. **Connect**를 클릭하고 OAuth 흐름을 완료합니다.
4. 이메일 및 연락처 관리를 위한 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="gmail/send_email">
    **설명:** Gmail에서 이메일을 보냅니다.

* `toRecipients` (array, 필수): 받는 사람 - 하나의 문자열 또는 JSON 배열로 받는 사람을 지정합니다.
      
    * `from` (string, 필수): 보내는 사람 - 발신자의 이메일을 지정합니다.
    * `subject` (string, 필수): 제목 - 메시지의 제목을 지정합니다.
    * `messageContent` (string, 필수): 메시지 내용 - 이메일 메시지의 내용을 일반 텍스트 또는 HTML로 지정합니다.
    * `attachments` (string, 선택): 첨부파일 - 단일 파일 객체 또는 파일 객체의 JSON 배열을 허용합니다.
    * `additionalHeaders` (object, 선택): 추가 헤더 - 추가 헤더 필드를 지정할 수 있습니다.
      
  </Accordion>

<Accordion title="gmail/get_email_by_id">
    **설명:** Gmail에서 ID로 이메일을 조회합니다.

* `userId` (string, 필수): 사용자 ID - 사용자의 이메일 주소를 지정합니다. (예: "[user@domain.com](mailto:user@domain.com)").
    * `messageId` (string, 필수): 메시지 ID - 조회할 메시지의 ID를 지정합니다.
  </Accordion>

<Accordion title="gmail/fetch_emails">
    **설명:** 고급 필터를 사용하여 Gmail에서 이메일을 검색합니다.

* `emailFilterFormula` (object, 선택): 불리언 식(OR로 연결된 AND 그룹의 단일 조건)으로 된 필터.
      
      사용 가능한 필드: `from`, `to`, `date`, `label`, `subject`, `cc`, `bcc`, `category`, `deliveredto:`, `size`, `filename`, `older_than`, `newer_than`, `list`, `is:important`, `is:unread`, `is:snoozed`, `is:starred`, `is:read`, `has:drive`, `has:document`, `has:spreadsheet`, `has:presentation`, `has:attachment`, `has:youtube`, `has:userlabels`
    * `paginationParameters` (object, 선택): 페이지네이션 파라미터.
      
  </Accordion>

<Accordion title="gmail/delete_email">
    **설명:** Gmail에서 이메일을 삭제합니다.

* `userId` (string, 필수): 사용자 ID - 사용자의 이메일 주소를 지정합니다. (예: "[user@domain.com](mailto:user@domain.com)").
    * `messageId` (string, 필수): 메시지 ID - 휴지통으로 보낼 메시지의 ID를 지정합니다.
  </Accordion>

<Accordion title="gmail/create_a_contact">
    **설명:** Gmail에서 연락처를 생성합니다.

* `givenName` (string, 필수): 이름 - 생성할 연락처의 이름을 지정합니다. (예: "John").
    * `familyName` (string, 필수): 성 - 생성할 연락처의 성을 지정합니다. (예: "Doe").
    * `email` (string, 필수): 이메일 - 생성할 연락처의 이메일 주소를 지정합니다.
    * `additionalFields` (object, 선택): 추가 필드 - 기타 연락처 정보를 입력할 수 있습니다.
      
  </Accordion>

<Accordion title="gmail/get_contact_by_resource_name">
    **설명:** Gmail에서 리소스 이름으로 연락처를 조회합니다.

* `resourceName` (string, 필수): 리소스 이름 - 조회할 연락처의 리소스 이름을 지정합니다.
  </Accordion>

<Accordion title="gmail/search_for_contact">
    **설명:** Gmail에서 연락처를 검색합니다.

* `searchTerm` (string, 필수): 검색어 - 이름, 닉네임, 이메일 주소, 전화번호 또는 조직 연락처 속성에서 유사하거나 정확히 일치하는 항목을 검색할 검색어를 지정합니다.
  </Accordion>

<Accordion title="gmail/delete_contact">
    **설명:** Gmail에서 연락처를 삭제합니다.

* `resourceName` (string, 필수): 리소스 이름 - 삭제할 연락처의 리소스 이름을 지정합니다.
  </Accordion>

<Accordion title="gmail/create_draft">
    **설명:** Gmail에서 임시 저장 메일을 만듭니다.

* `toRecipients` (array, 선택): 받는 사람 - 하나의 문자열 또는 JSON 배열로 받는 사람을 지정합니다.
      
    * `from` (string, 선택): 보내는 사람 - 발신자의 이메일을 지정합니다.
    * `subject` (string, 선택): 제목 - 메시지의 제목을 지정합니다.
    * `messageContent` (string, 선택): 메시지 내용 - 이메일 메시지의 내용을 일반 텍스트 또는 HTML로 지정합니다.
    * `attachments` (string, 선택): 첨부파일 - 단일 파일 객체 또는 파일 객체의 JSON 배열을 허용합니다.
    * `additionalHeaders` (object, 선택): 추가 헤더 - 추가 헤더 필드를 지정할 수 있습니다.
      
  </Accordion>
</AccordionGroup>

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="gmail/send_email">
    **설명:** Gmail에서 이메일을 보냅니다.

    **파라미터:**

    * `toRecipients` (array, 필수): 받는 사람 - 하나의 문자열 또는 JSON 배열로 받는 사람을 지정합니다.
```

Example 4 (unknown):
```unknown
* `from` (string, 필수): 보내는 사람 - 발신자의 이메일을 지정합니다.
    * `subject` (string, 필수): 제목 - 메시지의 제목을 지정합니다.
    * `messageContent` (string, 필수): 메시지 내용 - 이메일 메시지의 내용을 일반 텍스트 또는 HTML로 지정합니다.
    * `attachments` (string, 선택): 첨부파일 - 단일 파일 객체 또는 파일 객체의 JSON 배열을 허용합니다.
    * `additionalHeaders` (object, 선택): 추가 헤더 - 추가 헤더 필드를 지정할 수 있습니다.
```

---

## `VisionTool`

**URL:** llms-txt#`visiontool`

**Contents:**
- Descrição
- Instalação
- Uso
- Argumentos

Esta ferramenta é utilizada para extrair texto de imagens. Quando passada para o agente, ela extrai o texto da imagem e depois o utiliza para gerar uma resposta, relatório ou qualquer outra saída.
A URL ou o CAMINHO da imagem deve ser passado para o Agente.

Instale o pacote crewai\_tools

Para usar o VisionTool, a chave da API da OpenAI deve ser definida na variável de ambiente `OPENAI_API_KEY`.

O VisionTool requer os seguintes argumentos:

| Argumento            | Tipo     | Descrição                                                                          |
| :------------------- | :------- | :--------------------------------------------------------------------------------- |
| **image\_path\_url** | `string` | **Obrigatório**. O caminho para o arquivo de imagem do qual o texto será extraído. |

**Examples:**

Example 1 (unknown):
```unknown
## Uso

Para usar o VisionTool, a chave da API da OpenAI deve ser definida na variável de ambiente `OPENAI_API_KEY`.
```

---

## Integração com HubSpot

**URL:** llms-txt#integração-com-hubspot

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o HubSpot
  - 1. Conecte Sua Conta HubSpot
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de Agente HubSpot

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/hubspot

Gerencie empresas e contatos no HubSpot com o CrewAI.

Permita que seus agentes gerenciem empresas e contatos dentro do HubSpot. Crie novos registros e otimize seus processos de CRM com automação baseada em IA.

Antes de utilizar a integração com o HubSpot, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa.
* Uma conta HubSpot com permissões adequadas.
* Sua conta HubSpot conectada pela [página de Integrações](https://app.crewai.com/crewai_plus/connectors).

## Configurando a Integração com o HubSpot

### 1. Conecte Sua Conta HubSpot

1. Navegue até [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors).
2. Encontre **HubSpot** na seção de Integrações de Autenticação.
3. Clique em **Conectar** e complete o fluxo OAuth.
4. Conceda as permissões necessárias para gerenciamento de empresas e contatos.
5. Copie o seu Token Enterprise nas [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="hubspot/create_company">
    **Descrição:** Crie um novo registro de empresa no HubSpot.

* `name` (string, obrigatório): Nome da empresa.
    * `domain` (string, opcional): Nome do domínio da empresa.
    * `industry` (string, opcional): Setor. Deve ser um dos valores predefinidos do HubSpot.
    * `phone` (string, opcional): Telefone.
    * `hubspot_owner_id` (string, opcional): ID do responsável pela empresa.
    * `type` (string, opcional): Tipo da empresa. Valores disponíveis: `PROSPECT`, `PARTNER`, `RESELLER`, `VENDOR`, `OTHER`.
    * `city` (string, opcional): Cidade.
    * `state` (string, opcional): Estado/Região.
    * `zip` (string, opcional): CEP.
    * `numberofemployees` (number, opcional): Número de funcionários.
    * `annualrevenue` (number, opcional): Receita anual.
    * `timezone` (string, opcional): Fuso horário.
    * `description` (string, opcional): Descrição.
    * `linkedin_company_page` (string, opcional): URL da página da empresa no LinkedIn.
    * `company_email` (string, opcional): E-mail da empresa.
    * `first_name` (string, opcional): Nome do contato na empresa.
    * `last_name` (string, opcional): Sobrenome do contato na empresa.
    * `about_us` (string, opcional): Sobre nós.
    * `hs_csm_sentiment` (string, opcional): Sentimento CSM. Valores disponíveis: `at_risk`, `neutral`, `healthy`.
    * `closedate` (string, opcional): Data de fechamento.
    * `hs_keywords` (string, opcional): Palavras-chave da empresa. Deve ser um dos valores predefinidos.
    * `country` (string, opcional): País/Região.
    * `hs_country_code` (string, opcional): Código do País/Região.
    * `hs_employee_range` (string, opcional): Faixa de funcionários.
    * `facebook_company_page` (string, opcional): URL da página da empresa no Facebook.
    * `facebookfans` (number, opcional): Número de fãs no Facebook.
    * `hs_gps_coordinates` (string, opcional): Coordenadas GPS.
    * `hs_gps_error` (string, opcional): Erro de GPS.
    * `googleplus_page` (string, opcional): URL da página do Google Plus.
    * `owneremail` (string, opcional): E-mail do proprietário no HubSpot.
    * `ownername` (string, opcional): Nome do proprietário no HubSpot.
    * `hs_ideal_customer_profile` (string, opcional): Tier de Perfil de Cliente Ideal. Valores disponíveis: `tier_1`, `tier_2`, `tier_3`.
    * `hs_industry_group` (string, opcional): Grupo do setor.
    * `is_public` (boolean, opcional): É público.
    * `hs_last_metered_enrichment_timestamp` (string, opcional): Último registro de enriquecimento medido.
    * `hs_lead_status` (string, opcional): Status do lead. Valores disponíveis: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `lifecyclestage` (string, opcional): Estágio no ciclo de vida. Valores disponíveis: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `linkedinbio` (string, opcional): Bio do LinkedIn.
    * `hs_linkedin_handle` (string, opcional): Handle do LinkedIn.
    * `hs_live_enrichment_deadline` (string, opcional): Prazo para enriquecimento ao vivo.
    * `hs_logo_url` (string, opcional): URL do logotipo.
    * `hs_analytics_source` (string, opcional): Fonte original do tráfego.
    * `hs_pinned_engagement_id` (number, opcional): ID do engajamento fixado.
    * `hs_quick_context` (string, opcional): Contexto rápido.
    * `hs_revenue_range` (string, opcional): Faixa de receita.
    * `hs_state_code` (string, opcional): Código do Estado/Região.
    * `address` (string, opcional): Endereço.
    * `address2` (string, opcional): Complemento de endereço.
    * `hs_is_target_account` (boolean, opcional): Conta alvo.
    * `hs_target_account` (string, opcional): Tier da Conta Alvo. Valores disponíveis: `tier_1`, `tier_2`, `tier_3`.
    * `hs_target_account_recommendation_snooze_time` (string, opcional): Tempo para adiar recomendação de conta alvo.
    * `hs_target_account_recommendation_state` (string, opcional): Estado da recomendação da conta alvo. Valores disponíveis: `DISMISSED`, `NONE`, `SNOOZED`.
    * `total_money_raised` (string, opcional): Total arrecadado.
    * `twitterbio` (string, opcional): Bio do Twitter.
    * `twitterfollowers` (number, opcional): Seguidores no Twitter.
    * `twitterhandle` (string, opcional): Usuário do Twitter.
    * `web_technologies` (string, opcional): Tecnologias web utilizadas. Deve ser um dos valores predefinidos.
    * `website` (string, opcional): URL do site.
    * `founded_year` (string, opcional): Ano de fundação.
  </Accordion>

<Accordion title="hubspot/create_contact">
    **Descrição:** Crie um novo registro de contato no HubSpot.

* `email` (string, obrigatório): E-mail do contato.
    * `firstname` (string, opcional): Nome.
    * `lastname` (string, opcional): Sobrenome.
    * `phone` (string, opcional): Telefone.
    * `hubspot_owner_id` (string, opcional): Responsável pelo contato.
    * `lifecyclestage` (string, opcional): Estágio no ciclo de vida. Valores disponíveis: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `hs_lead_status` (string, opcional): Status do lead. Valores disponíveis: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `annualrevenue` (string, opcional): Receita anual.
    * `hs_buying_role` (string, opcional): Papel na compra.
    * `cc_emails` (string, opcional): E-mails em cópia.
    * `ch_customer_id` (string, opcional): ID do cliente no Chargify.
    * `ch_customer_reference` (string, opcional): Referência do cliente no Chargify.
    * `chargify_sites` (string, opcional): Sites Chargify.
    * `city` (string, opcional): Cidade.
    * `hs_facebook_ad_clicked` (boolean, opcional): Clicou em anúncio do Facebook.
    * `hs_linkedin_ad_clicked` (string, opcional): Clicou em anúncio do LinkedIn.
    * `hs_clicked_linkedin_ad` (string, opcional): Clicou em anúncio do LinkedIn.
    * `closedate` (string, opcional): Data de fechamento.
    * `company` (string, opcional): Nome da empresa.
    * `company_size` (string, opcional): Tamanho da empresa.
    * `country` (string, opcional): País/Região.
    * `hs_country_region_code` (string, opcional): Código do País/Região.
    * `date_of_birth` (string, opcional): Data de nascimento.
    * `degree` (string, opcional): Grau de instrução.
    * `hs_email_customer_quarantined_reason` (string, opcional): Motivo da quarentena de e-mail.
    * `hs_role` (string, opcional): Cargo. Deve ser um dos valores predefinidos.
    * `hs_seniority` (string, opcional): Senioridade. Deve ser um dos valores predefinidos.
    * `hs_sub_role` (string, opcional): Sub papel. Deve ser um dos valores predefinidos.
    * `hs_employment_change_detected_date` (string, opcional): Data da detecção de mudança de emprego.
    * `hs_enriched_email_bounce_detected` (boolean, opcional): Bounce de e-mail enriquecido detectado.
    * `hs_facebookid` (string, opcional): Facebook ID.
    * `hs_facebook_click_id` (string, opcional): ID de clique no Facebook.
    * `fax` (string, opcional): Fax.
    * `field_of_study` (string, opcional): Área de estudo.
    * `followercount` (number, opcional): Número de seguidores.
    * `gender` (string, opcional): Gênero.
    * `hs_google_click_id` (string, opcional): ID de clique no Google.
    * `graduation_date` (string, opcional): Data de graduação.
    * `owneremail` (string, opcional): E-mail do proprietário no HubSpot (legado).
    * `ownername` (string, opcional): Nome do proprietário no HubSpot (legado).
    * `industry` (string, opcional): Setor.
    * `hs_inferred_language_codes` (string, opcional): Códigos de idioma inferido. Deve ser um dos valores predefinidos.
    * `jobtitle` (string, opcional): Cargo.
    * `hs_job_change_detected_date` (string, opcional): Data de detecção de mudança de emprego.
    * `job_function` (string, opcional): Função.
    * `hs_journey_stage` (string, opcional): Estágio da jornada. Deve ser um dos valores predefinidos.
    * `kloutscoregeneral` (number, opcional): Klout Score.
    * `hs_last_metered_enrichment_timestamp` (string, opcional): Último registro de enriquecimento medido.
    * `hs_latest_source` (string, opcional): Fonte de tráfego mais recente.
    * `hs_latest_source_timestamp` (string, opcional): Data da fonte mais recente.
    * `hs_legal_basis` (string, opcional): Base legal para o processamento dos dados do contato.
    * `linkedinbio` (string, opcional): Bio do LinkedIn.
    * `linkedinconnections` (number, opcional): Conexões no LinkedIn.
    * `hs_linkedin_url` (string, opcional): URL do LinkedIn.
    * `hs_linkedinid` (string, opcional): Linkedin ID.
    * `hs_live_enrichment_deadline` (string, opcional): Prazo para enriquecimento ao vivo.
    * `marital_status` (string, opcional): Estado civil.
    * `hs_content_membership_email` (string, opcional): E-mail de membro.
    * `hs_content_membership_notes` (string, opcional): Notas de associação.
    * `message` (string, opcional): Mensagem.
    * `military_status` (string, opcional): Status militar.
    * `mobilephone` (string, opcional): Celular.
    * `numemployees` (string, opcional): Número de funcionários.
    * `hs_analytics_source` (string, opcional): Fonte original do tráfego.
    * `photo` (string, opcional): Foto.
    * `hs_pinned_engagement_id` (number, opcional): ID de engajamento fixado.
    * `zip` (string, opcional): CEP.
    * `hs_language` (string, opcional): Idioma preferencial. Deve ser um dos valores predefinidos.
    * `associatedcompanyid` (number, opcional): ID da empresa associada primária.
    * `hs_email_optout_survey_reason` (string, opcional): Motivo da recusa de e-mail.
    * `relationship_status` (string, opcional): Status de relacionamento.
    * `hs_returning_to_office_detected_date` (string, opcional): Data de retorno ao escritório detectada.
    * `salutation` (string, opcional): Saudação.
    * `school` (string, opcional): Escola.
    * `seniority` (string, opcional): Senioridade.
    * `hs_feedback_show_nps_web_survey` (boolean, opcional): Mostrar pesquisa NPS na web.
    * `start_date` (string, opcional): Data de início.
    * `state` (string, opcional): Estado/Região.
    * `hs_state_code` (string, opcional): Código do Estado/Região.
    * `hs_content_membership_status` (string, opcional): Status.
    * `address` (string, opcional): Endereço.
    * `tax_exempt` (string, opcional): Isento de impostos.
    * `hs_timezone` (string, opcional): Fuso horário. Deve ser um dos valores predefinidos.
    * `twitterbio` (string, opcional): Bio do Twitter.
    * `hs_twitterid` (string, opcional): Twitter ID.
    * `twitterprofilephoto` (string, opcional): Foto de perfil do Twitter.
    * `twitterhandle` (string, opcional): Usuário do Twitter.
    * `vat_number` (string, opcional): Número VAT.
    * `ch_verified` (string, opcional): Verificado para pagamentos ACH/eCheck.
    * `website` (string, opcional): URL do site.
    * `hs_whatsapp_phone_number` (string, opcional): Número do WhatsApp.
    * `work_email` (string, opcional): E-mail corporativo.
    * `hs_googleplusid` (string, opcional): googleplus ID.
  </Accordion>

<Accordion title="hubspot/create_deal">
    **Descrição:** Crie um novo registro de negócio (deal) no HubSpot.

* `dealname` (string, obrigatório): Nome do negócio.
    * `amount` (number, opcional): Valor do negócio.
    * `dealstage` (string, opcional): Estágio no pipeline.
    * `pipeline` (string, opcional): Pipeline ao qual o negócio pertence.
    * `closedate` (string, opcional): Data prevista de fechamento do negócio.
    * `hubspot_owner_id` (string, opcional): Responsável pelo negócio.
    * `dealtype` (string, opcional): Tipo do negócio. Valores disponíveis: `newbusiness`, `existingbusiness`.
    * `description` (string, opcional): Descrição do negócio.
    * `hs_priority` (string, opcional): Prioridade do negócio. Valores disponíveis: `low`, `medium`, `high`.
  </Accordion>

<Accordion title="hubspot/create_record_engagements">
    **Descrição:** Crie um novo engajamento (ex: nota, e-mail, ligação, reunião, tarefa) no HubSpot.

* `engagementType` (string, obrigatório): Tipo de engajamento. Valores disponíveis: `NOTE`, `EMAIL`, `CALL`, `MEETING`, `TASK`.
    * `hubspot_owner_id` (string, opcional): Usuário responsável pela atividade.
    * `hs_timestamp` (string, opcional): Data e hora da atividade.
    * `hs_note_body` (string, opcional): Corpo da nota. (Utilizado para `NOTE`)
    * `hs_task_subject` (string, opcional): Título da tarefa. (Utilizado para `TASK`)
    * `hs_task_body` (string, opcional): Notas da tarefa. (Utilizado para `TASK`)
    * `hs_task_status` (string, opcional): Status da tarefa. (Utilizado para `TASK`)
    * `hs_meeting_title` (string, opcional): Título da reunião. (Utilizado para `MEETING`)
    * `hs_meeting_body` (string, opcional): Descrição da reunião. (Utilizado para `MEETING`)
    * `hs_meeting_start_time` (string, opcional): Horário de início da reunião. (Utilizado para `MEETING`)
    * `hs_meeting_end_time` (string, opcional): Horário de término da reunião. (Utilizado para `MEETING`)
  </Accordion>

<Accordion title="hubspot/update_company">
    **Descrição:** Atualize um registro de empresa existente no HubSpot.

* `recordId` (string, obrigatório): ID da empresa a ser atualizada.
    * `name` (string, opcional): Nome da empresa.
    * `domain` (string, opcional): Nome do domínio da empresa.
    * `industry` (string, opcional): Setor.
    * `phone` (string, opcional): Telefone.
    * `city` (string, opcional): Cidade.
    * `state` (string, opcional): Estado/Região.
    * `zip` (string, opcional): CEP.
    * `numberofemployees` (number, opcional): Número de funcionários.
    * `annualrevenue` (number, opcional): Receita anual.
    * `description` (string, opcional): Descrição.
  </Accordion>

<Accordion title="hubspot/create_record_any">
    **Descrição:** Crie um registro para um tipo de objeto especificado no HubSpot.

* `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * Parâmetros adicionais dependem do esquema do objeto personalizado.
  </Accordion>

<Accordion title="hubspot/update_contact">
    **Descrição:** Atualize um registro de contato existente no HubSpot.

* `recordId` (string, obrigatório): ID do contato a ser atualizado.
    * `firstname` (string, opcional): Nome.
    * `lastname` (string, opcional): Sobrenome.
    * `email` (string, opcional): E-mail.
    * `phone` (string, opcional): Telefone.
    * `company` (string, opcional): Nome da empresa.
    * `jobtitle` (string, opcional): Cargo.
    * `lifecyclestage` (string, opcional): Estágio no ciclo de vida.
  </Accordion>

<Accordion title="hubspot/update_deal">
    **Descrição:** Atualize um registro de negócio existente no HubSpot.

* `recordId` (string, obrigatório): ID do negócio a ser atualizado.
    * `dealname` (string, opcional): Nome do negócio.
    * `amount` (number, opcional): Valor do negócio.
    * `dealstage` (string, opcional): Estágio do pipeline.
    * `pipeline` (string, opcional): Pipeline ao qual o negócio pertence.
    * `closedate` (string, opcional): Data prevista de fechamento.
    * `dealtype` (string, opcional): Tipo de negócio.
  </Accordion>

<Accordion title="hubspot/update_record_engagements">
    **Descrição:** Atualize um engajamento existente no HubSpot.

* `recordId` (string, obrigatório): ID do engajamento a ser atualizado.
    * `hs_note_body` (string, opcional): Corpo da nota.
    * `hs_task_subject` (string, opcional): Título da tarefa.
    * `hs_task_body` (string, opcional): Notas da tarefa.
    * `hs_task_status` (string, opcional): Status da tarefa.
  </Accordion>

<Accordion title="hubspot/update_record_any">
    **Descrição:** Atualize um registro para um tipo de objeto especificado no HubSpot.

* `recordId` (string, obrigatório): ID do registro a ser atualizado.
    * `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * Parâmetros adicionais dependem do esquema do objeto personalizado.
  </Accordion>

<Accordion title="hubspot/list_companies">
    **Descrição:** Obtenha uma lista de registros de empresas do HubSpot.

* `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/list_contacts">
    **Descrição:** Obtenha uma lista de registros de contatos do HubSpot.

* `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/list_deals">
    **Descrição:** Obtenha uma lista de registros de negócios do HubSpot.

* `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/get_records_engagements">
    **Descrição:** Obtenha uma lista de registros de engajamentos do HubSpot.

* `objectName` (string, obrigatório): O tipo de engajamento a ser buscado (ex.: "notes").
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/get_records_any">
    **Descrição:** Obtenha uma lista de registros de qualquer tipo de objeto no HubSpot.

* `recordType` (string, obrigatório): O ID do tipo de objeto personalizado.
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/get_company">
    **Descrição:** Obtenha um registro de empresa pelo seu ID.

* `recordId` (string, obrigatório): ID da empresa a ser consultada.
  </Accordion>

<Accordion title="hubspot/get_contact">
    **Descrição:** Obtenha um registro de contato pelo seu ID.

* `recordId` (string, obrigatório): ID do contato a ser consultado.
  </Accordion>

<Accordion title="hubspot/get_deal">
    **Descrição:** Obtenha um registro de negócio pelo seu ID.

* `recordId` (string, obrigatório): ID do negócio a ser consultado.
  </Accordion>

<Accordion title="hubspot/get_record_by_id_engagements">
    **Descrição:** Obtenha um registro de engajamento pelo seu ID.

* `recordId` (string, obrigatório): ID do engajamento a ser consultado.
  </Accordion>

<Accordion title="hubspot/get_record_by_id_any">
    **Descrição:** Obtenha um registro de qualquer tipo de objeto especificado pelo seu ID.

* `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * `recordId` (string, obrigatório): ID do registro a ser consultado.
  </Accordion>

<Accordion title="hubspot/search_companies">
    **Descrição:** Pesquise registros de empresas no HubSpot utilizando uma fórmula de filtro.

* `filterFormula` (object, opcional): Filtro em forma normal disjuntiva (OU de E).
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/search_contacts">
    **Descrição:** Pesquise registros de contatos no HubSpot utilizando uma fórmula de filtro.

* `filterFormula` (object, opcional): Filtro em forma normal disjuntiva (OU de E).
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/search_deals">
    **Descrição:** Pesquise registros de negócios no HubSpot utilizando uma fórmula de filtro.

* `filterFormula` (object, opcional): Filtro em forma normal disjuntiva (OU de E).
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/search_records_engagements">
    **Descrição:** Pesquise registros de engajamento no HubSpot utilizando uma fórmula de filtro.

* `engagementFilterFormula` (object, opcional): Filtro para engajamentos.
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/search_records_any">
    **Descrição:** Pesquise registros de qualquer tipo de objeto no HubSpot.

* `recordType` (string, obrigatório): O ID do tipo de objeto para pesquisa.
    * `filterFormula` (string, opcional): Fórmula de filtro a aplicar.
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/delete_record_companies">
    **Descrição:** Exclua um registro de empresa pelo seu ID.

* `recordId` (string, obrigatório): ID da empresa a ser excluída.
  </Accordion>

<Accordion title="hubspot/delete_record_contacts">
    **Descrição:** Exclua um registro de contato pelo seu ID.

* `recordId` (string, obrigatório): ID do contato a ser excluído.
  </Accordion>

<Accordion title="hubspot/delete_record_deals">
    **Descrição:** Exclua um registro de negócio pelo seu ID.

* `recordId` (string, obrigatório): ID do negócio a ser excluído.
  </Accordion>

<Accordion title="hubspot/delete_record_engagements">
    **Descrição:** Exclua um registro de engajamento pelo seu ID.

* `recordId` (string, obrigatório): ID do engajamento a ser excluído.
  </Accordion>

<Accordion title="hubspot/delete_record_any">
    **Descrição:** Exclua um registro de qualquer tipo de objeto especificado pelo seu ID.

* `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * `recordId` (string, obrigatório): ID do registro a ser excluído.
  </Accordion>

<Accordion title="hubspot/get_contacts_by_list_id">
    **Descrição:** Obtenha contatos de uma lista específica pelo seu ID.

* `listId` (string, obrigatório): ID da lista da qual obter os contatos.
    * `paginationParameters` (object, opcional): Use `pageCursor` para páginas subsequentes.
  </Accordion>

<Accordion title="hubspot/describe_action_schema">
    **Descrição:** Obtenha o esquema esperado para um dado tipo de objeto e operação.

* `recordType` (string, obrigatório): ID do tipo de objeto (ex.: 'companies').
    * `operation` (string, obrigatório): Tipo de operação (ex.: 'CREATE\_RECORD').
  </Accordion>
</AccordionGroup>

### Configuração Básica de Agente HubSpot

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="hubspot/create_company">
    **Descrição:** Crie um novo registro de empresa no HubSpot.

    **Parâmetros:**

    * `name` (string, obrigatório): Nome da empresa.
    * `domain` (string, opcional): Nome do domínio da empresa.
    * `industry` (string, opcional): Setor. Deve ser um dos valores predefinidos do HubSpot.
    * `phone` (string, opcional): Telefone.
    * `hubspot_owner_id` (string, opcional): ID do responsável pela empresa.
    * `type` (string, opcional): Tipo da empresa. Valores disponíveis: `PROSPECT`, `PARTNER`, `RESELLER`, `VENDOR`, `OTHER`.
    * `city` (string, opcional): Cidade.
    * `state` (string, opcional): Estado/Região.
    * `zip` (string, opcional): CEP.
    * `numberofemployees` (number, opcional): Número de funcionários.
    * `annualrevenue` (number, opcional): Receita anual.
    * `timezone` (string, opcional): Fuso horário.
    * `description` (string, opcional): Descrição.
    * `linkedin_company_page` (string, opcional): URL da página da empresa no LinkedIn.
    * `company_email` (string, opcional): E-mail da empresa.
    * `first_name` (string, opcional): Nome do contato na empresa.
    * `last_name` (string, opcional): Sobrenome do contato na empresa.
    * `about_us` (string, opcional): Sobre nós.
    * `hs_csm_sentiment` (string, opcional): Sentimento CSM. Valores disponíveis: `at_risk`, `neutral`, `healthy`.
    * `closedate` (string, opcional): Data de fechamento.
    * `hs_keywords` (string, opcional): Palavras-chave da empresa. Deve ser um dos valores predefinidos.
    * `country` (string, opcional): País/Região.
    * `hs_country_code` (string, opcional): Código do País/Região.
    * `hs_employee_range` (string, opcional): Faixa de funcionários.
    * `facebook_company_page` (string, opcional): URL da página da empresa no Facebook.
    * `facebookfans` (number, opcional): Número de fãs no Facebook.
    * `hs_gps_coordinates` (string, opcional): Coordenadas GPS.
    * `hs_gps_error` (string, opcional): Erro de GPS.
    * `googleplus_page` (string, opcional): URL da página do Google Plus.
    * `owneremail` (string, opcional): E-mail do proprietário no HubSpot.
    * `ownername` (string, opcional): Nome do proprietário no HubSpot.
    * `hs_ideal_customer_profile` (string, opcional): Tier de Perfil de Cliente Ideal. Valores disponíveis: `tier_1`, `tier_2`, `tier_3`.
    * `hs_industry_group` (string, opcional): Grupo do setor.
    * `is_public` (boolean, opcional): É público.
    * `hs_last_metered_enrichment_timestamp` (string, opcional): Último registro de enriquecimento medido.
    * `hs_lead_status` (string, opcional): Status do lead. Valores disponíveis: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `lifecyclestage` (string, opcional): Estágio no ciclo de vida. Valores disponíveis: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `linkedinbio` (string, opcional): Bio do LinkedIn.
    * `hs_linkedin_handle` (string, opcional): Handle do LinkedIn.
    * `hs_live_enrichment_deadline` (string, opcional): Prazo para enriquecimento ao vivo.
    * `hs_logo_url` (string, opcional): URL do logotipo.
    * `hs_analytics_source` (string, opcional): Fonte original do tráfego.
    * `hs_pinned_engagement_id` (number, opcional): ID do engajamento fixado.
    * `hs_quick_context` (string, opcional): Contexto rápido.
    * `hs_revenue_range` (string, opcional): Faixa de receita.
    * `hs_state_code` (string, opcional): Código do Estado/Região.
    * `address` (string, opcional): Endereço.
    * `address2` (string, opcional): Complemento de endereço.
    * `hs_is_target_account` (boolean, opcional): Conta alvo.
    * `hs_target_account` (string, opcional): Tier da Conta Alvo. Valores disponíveis: `tier_1`, `tier_2`, `tier_3`.
    * `hs_target_account_recommendation_snooze_time` (string, opcional): Tempo para adiar recomendação de conta alvo.
    * `hs_target_account_recommendation_state` (string, opcional): Estado da recomendação da conta alvo. Valores disponíveis: `DISMISSED`, `NONE`, `SNOOZED`.
    * `total_money_raised` (string, opcional): Total arrecadado.
    * `twitterbio` (string, opcional): Bio do Twitter.
    * `twitterfollowers` (number, opcional): Seguidores no Twitter.
    * `twitterhandle` (string, opcional): Usuário do Twitter.
    * `web_technologies` (string, opcional): Tecnologias web utilizadas. Deve ser um dos valores predefinidos.
    * `website` (string, opcional): URL do site.
    * `founded_year` (string, opcional): Ano de fundação.
  </Accordion>

  <Accordion title="hubspot/create_contact">
    **Descrição:** Crie um novo registro de contato no HubSpot.

    **Parâmetros:**

    * `email` (string, obrigatório): E-mail do contato.
    * `firstname` (string, opcional): Nome.
    * `lastname` (string, opcional): Sobrenome.
    * `phone` (string, opcional): Telefone.
    * `hubspot_owner_id` (string, opcional): Responsável pelo contato.
    * `lifecyclestage` (string, opcional): Estágio no ciclo de vida. Valores disponíveis: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `hs_lead_status` (string, opcional): Status do lead. Valores disponíveis: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `annualrevenue` (string, opcional): Receita anual.
    * `hs_buying_role` (string, opcional): Papel na compra.
    * `cc_emails` (string, opcional): E-mails em cópia.
    * `ch_customer_id` (string, opcional): ID do cliente no Chargify.
    * `ch_customer_reference` (string, opcional): Referência do cliente no Chargify.
    * `chargify_sites` (string, opcional): Sites Chargify.
    * `city` (string, opcional): Cidade.
    * `hs_facebook_ad_clicked` (boolean, opcional): Clicou em anúncio do Facebook.
    * `hs_linkedin_ad_clicked` (string, opcional): Clicou em anúncio do LinkedIn.
    * `hs_clicked_linkedin_ad` (string, opcional): Clicou em anúncio do LinkedIn.
    * `closedate` (string, opcional): Data de fechamento.
    * `company` (string, opcional): Nome da empresa.
    * `company_size` (string, opcional): Tamanho da empresa.
    * `country` (string, opcional): País/Região.
    * `hs_country_region_code` (string, opcional): Código do País/Região.
    * `date_of_birth` (string, opcional): Data de nascimento.
    * `degree` (string, opcional): Grau de instrução.
    * `hs_email_customer_quarantined_reason` (string, opcional): Motivo da quarentena de e-mail.
    * `hs_role` (string, opcional): Cargo. Deve ser um dos valores predefinidos.
    * `hs_seniority` (string, opcional): Senioridade. Deve ser um dos valores predefinidos.
    * `hs_sub_role` (string, opcional): Sub papel. Deve ser um dos valores predefinidos.
    * `hs_employment_change_detected_date` (string, opcional): Data da detecção de mudança de emprego.
    * `hs_enriched_email_bounce_detected` (boolean, opcional): Bounce de e-mail enriquecido detectado.
    * `hs_facebookid` (string, opcional): Facebook ID.
    * `hs_facebook_click_id` (string, opcional): ID de clique no Facebook.
    * `fax` (string, opcional): Fax.
    * `field_of_study` (string, opcional): Área de estudo.
    * `followercount` (number, opcional): Número de seguidores.
    * `gender` (string, opcional): Gênero.
    * `hs_google_click_id` (string, opcional): ID de clique no Google.
    * `graduation_date` (string, opcional): Data de graduação.
    * `owneremail` (string, opcional): E-mail do proprietário no HubSpot (legado).
    * `ownername` (string, opcional): Nome do proprietário no HubSpot (legado).
    * `industry` (string, opcional): Setor.
    * `hs_inferred_language_codes` (string, opcional): Códigos de idioma inferido. Deve ser um dos valores predefinidos.
    * `jobtitle` (string, opcional): Cargo.
    * `hs_job_change_detected_date` (string, opcional): Data de detecção de mudança de emprego.
    * `job_function` (string, opcional): Função.
    * `hs_journey_stage` (string, opcional): Estágio da jornada. Deve ser um dos valores predefinidos.
    * `kloutscoregeneral` (number, opcional): Klout Score.
    * `hs_last_metered_enrichment_timestamp` (string, opcional): Último registro de enriquecimento medido.
    * `hs_latest_source` (string, opcional): Fonte de tráfego mais recente.
    * `hs_latest_source_timestamp` (string, opcional): Data da fonte mais recente.
    * `hs_legal_basis` (string, opcional): Base legal para o processamento dos dados do contato.
    * `linkedinbio` (string, opcional): Bio do LinkedIn.
    * `linkedinconnections` (number, opcional): Conexões no LinkedIn.
    * `hs_linkedin_url` (string, opcional): URL do LinkedIn.
    * `hs_linkedinid` (string, opcional): Linkedin ID.
    * `hs_live_enrichment_deadline` (string, opcional): Prazo para enriquecimento ao vivo.
    * `marital_status` (string, opcional): Estado civil.
    * `hs_content_membership_email` (string, opcional): E-mail de membro.
    * `hs_content_membership_notes` (string, opcional): Notas de associação.
    * `message` (string, opcional): Mensagem.
    * `military_status` (string, opcional): Status militar.
    * `mobilephone` (string, opcional): Celular.
    * `numemployees` (string, opcional): Número de funcionários.
    * `hs_analytics_source` (string, opcional): Fonte original do tráfego.
    * `photo` (string, opcional): Foto.
    * `hs_pinned_engagement_id` (number, opcional): ID de engajamento fixado.
    * `zip` (string, opcional): CEP.
    * `hs_language` (string, opcional): Idioma preferencial. Deve ser um dos valores predefinidos.
    * `associatedcompanyid` (number, opcional): ID da empresa associada primária.
    * `hs_email_optout_survey_reason` (string, opcional): Motivo da recusa de e-mail.
    * `relationship_status` (string, opcional): Status de relacionamento.
    * `hs_returning_to_office_detected_date` (string, opcional): Data de retorno ao escritório detectada.
    * `salutation` (string, opcional): Saudação.
    * `school` (string, opcional): Escola.
    * `seniority` (string, opcional): Senioridade.
    * `hs_feedback_show_nps_web_survey` (boolean, opcional): Mostrar pesquisa NPS na web.
    * `start_date` (string, opcional): Data de início.
    * `state` (string, opcional): Estado/Região.
    * `hs_state_code` (string, opcional): Código do Estado/Região.
    * `hs_content_membership_status` (string, opcional): Status.
    * `address` (string, opcional): Endereço.
    * `tax_exempt` (string, opcional): Isento de impostos.
    * `hs_timezone` (string, opcional): Fuso horário. Deve ser um dos valores predefinidos.
    * `twitterbio` (string, opcional): Bio do Twitter.
    * `hs_twitterid` (string, opcional): Twitter ID.
    * `twitterprofilephoto` (string, opcional): Foto de perfil do Twitter.
    * `twitterhandle` (string, opcional): Usuário do Twitter.
    * `vat_number` (string, opcional): Número VAT.
    * `ch_verified` (string, opcional): Verificado para pagamentos ACH/eCheck.
    * `website` (string, opcional): URL do site.
    * `hs_whatsapp_phone_number` (string, opcional): Número do WhatsApp.
    * `work_email` (string, opcional): E-mail corporativo.
    * `hs_googleplusid` (string, opcional): googleplus ID.
  </Accordion>

  <Accordion title="hubspot/create_deal">
    **Descrição:** Crie um novo registro de negócio (deal) no HubSpot.

    **Parâmetros:**

    * `dealname` (string, obrigatório): Nome do negócio.
    * `amount` (number, opcional): Valor do negócio.
    * `dealstage` (string, opcional): Estágio no pipeline.
    * `pipeline` (string, opcional): Pipeline ao qual o negócio pertence.
    * `closedate` (string, opcional): Data prevista de fechamento do negócio.
    * `hubspot_owner_id` (string, opcional): Responsável pelo negócio.
    * `dealtype` (string, opcional): Tipo do negócio. Valores disponíveis: `newbusiness`, `existingbusiness`.
    * `description` (string, opcional): Descrição do negócio.
    * `hs_priority` (string, opcional): Prioridade do negócio. Valores disponíveis: `low`, `medium`, `high`.
  </Accordion>

  <Accordion title="hubspot/create_record_engagements">
    **Descrição:** Crie um novo engajamento (ex: nota, e-mail, ligação, reunião, tarefa) no HubSpot.

    **Parâmetros:**

    * `engagementType` (string, obrigatório): Tipo de engajamento. Valores disponíveis: `NOTE`, `EMAIL`, `CALL`, `MEETING`, `TASK`.
    * `hubspot_owner_id` (string, opcional): Usuário responsável pela atividade.
    * `hs_timestamp` (string, opcional): Data e hora da atividade.
    * `hs_note_body` (string, opcional): Corpo da nota. (Utilizado para `NOTE`)
    * `hs_task_subject` (string, opcional): Título da tarefa. (Utilizado para `TASK`)
    * `hs_task_body` (string, opcional): Notas da tarefa. (Utilizado para `TASK`)
    * `hs_task_status` (string, opcional): Status da tarefa. (Utilizado para `TASK`)
    * `hs_meeting_title` (string, opcional): Título da reunião. (Utilizado para `MEETING`)
    * `hs_meeting_body` (string, opcional): Descrição da reunião. (Utilizado para `MEETING`)
    * `hs_meeting_start_time` (string, opcional): Horário de início da reunião. (Utilizado para `MEETING`)
    * `hs_meeting_end_time` (string, opcional): Horário de término da reunião. (Utilizado para `MEETING`)
  </Accordion>

  <Accordion title="hubspot/update_company">
    **Descrição:** Atualize um registro de empresa existente no HubSpot.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID da empresa a ser atualizada.
    * `name` (string, opcional): Nome da empresa.
    * `domain` (string, opcional): Nome do domínio da empresa.
    * `industry` (string, opcional): Setor.
    * `phone` (string, opcional): Telefone.
    * `city` (string, opcional): Cidade.
    * `state` (string, opcional): Estado/Região.
    * `zip` (string, opcional): CEP.
    * `numberofemployees` (number, opcional): Número de funcionários.
    * `annualrevenue` (number, opcional): Receita anual.
    * `description` (string, opcional): Descrição.
  </Accordion>

  <Accordion title="hubspot/create_record_any">
    **Descrição:** Crie um registro para um tipo de objeto especificado no HubSpot.

    **Parâmetros:**

    * `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * Parâmetros adicionais dependem do esquema do objeto personalizado.
  </Accordion>

  <Accordion title="hubspot/update_contact">
    **Descrição:** Atualize um registro de contato existente no HubSpot.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do contato a ser atualizado.
    * `firstname` (string, opcional): Nome.
    * `lastname` (string, opcional): Sobrenome.
    * `email` (string, opcional): E-mail.
    * `phone` (string, opcional): Telefone.
    * `company` (string, opcional): Nome da empresa.
    * `jobtitle` (string, opcional): Cargo.
    * `lifecyclestage` (string, opcional): Estágio no ciclo de vida.
  </Accordion>

  <Accordion title="hubspot/update_deal">
    **Descrição:** Atualize um registro de negócio existente no HubSpot.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do negócio a ser atualizado.
    * `dealname` (string, opcional): Nome do negócio.
    * `amount` (number, opcional): Valor do negócio.
    * `dealstage` (string, opcional): Estágio do pipeline.
    * `pipeline` (string, opcional): Pipeline ao qual o negócio pertence.
    * `closedate` (string, opcional): Data prevista de fechamento.
    * `dealtype` (string, opcional): Tipo de negócio.
  </Accordion>

  <Accordion title="hubspot/update_record_engagements">
    **Descrição:** Atualize um engajamento existente no HubSpot.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do engajamento a ser atualizado.
    * `hs_note_body` (string, opcional): Corpo da nota.
    * `hs_task_subject` (string, opcional): Título da tarefa.
    * `hs_task_body` (string, opcional): Notas da tarefa.
    * `hs_task_status` (string, opcional): Status da tarefa.
  </Accordion>

  <Accordion title="hubspot/update_record_any">
    **Descrição:** Atualize um registro para um tipo de objeto especificado no HubSpot.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro a ser atualizado.
    * `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * Parâmetros adicionais dependem do esquema do objeto personalizado.
  </Accordion>

  <Accordion title="hubspot/list_companies">
    **Descrição:** Obtenha uma lista de registros de empresas do HubSpot.

    **Parâmetros:**

    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/list_contacts">
    **Descrição:** Obtenha uma lista de registros de contatos do HubSpot.

    **Parâmetros:**

    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/list_deals">
    **Descrição:** Obtenha uma lista de registros de negócios do HubSpot.

    **Parâmetros:**

    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/get_records_engagements">
    **Descrição:** Obtenha uma lista de registros de engajamentos do HubSpot.

    **Parâmetros:**

    * `objectName` (string, obrigatório): O tipo de engajamento a ser buscado (ex.: "notes").
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/get_records_any">
    **Descrição:** Obtenha uma lista de registros de qualquer tipo de objeto no HubSpot.

    **Parâmetros:**

    * `recordType` (string, obrigatório): O ID do tipo de objeto personalizado.
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/get_company">
    **Descrição:** Obtenha um registro de empresa pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID da empresa a ser consultada.
  </Accordion>

  <Accordion title="hubspot/get_contact">
    **Descrição:** Obtenha um registro de contato pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do contato a ser consultado.
  </Accordion>

  <Accordion title="hubspot/get_deal">
    **Descrição:** Obtenha um registro de negócio pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do negócio a ser consultado.
  </Accordion>

  <Accordion title="hubspot/get_record_by_id_engagements">
    **Descrição:** Obtenha um registro de engajamento pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do engajamento a ser consultado.
  </Accordion>

  <Accordion title="hubspot/get_record_by_id_any">
    **Descrição:** Obtenha um registro de qualquer tipo de objeto especificado pelo seu ID.

    **Parâmetros:**

    * `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * `recordId` (string, obrigatório): ID do registro a ser consultado.
  </Accordion>

  <Accordion title="hubspot/search_companies">
    **Descrição:** Pesquise registros de empresas no HubSpot utilizando uma fórmula de filtro.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro em forma normal disjuntiva (OU de E).
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/search_contacts">
    **Descrição:** Pesquise registros de contatos no HubSpot utilizando uma fórmula de filtro.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro em forma normal disjuntiva (OU de E).
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/search_deals">
    **Descrição:** Pesquise registros de negócios no HubSpot utilizando uma fórmula de filtro.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro em forma normal disjuntiva (OU de E).
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/search_records_engagements">
    **Descrição:** Pesquise registros de engajamento no HubSpot utilizando uma fórmula de filtro.

    **Parâmetros:**

    * `engagementFilterFormula` (object, opcional): Filtro para engajamentos.
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/search_records_any">
    **Descrição:** Pesquise registros de qualquer tipo de objeto no HubSpot.

    **Parâmetros:**

    * `recordType` (string, obrigatório): O ID do tipo de objeto para pesquisa.
    * `filterFormula` (string, opcional): Fórmula de filtro a aplicar.
    * `paginationParameters` (object, opcional): Use `pageCursor` para buscar páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/delete_record_companies">
    **Descrição:** Exclua um registro de empresa pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID da empresa a ser excluída.
  </Accordion>

  <Accordion title="hubspot/delete_record_contacts">
    **Descrição:** Exclua um registro de contato pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do contato a ser excluído.
  </Accordion>

  <Accordion title="hubspot/delete_record_deals">
    **Descrição:** Exclua um registro de negócio pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do negócio a ser excluído.
  </Accordion>

  <Accordion title="hubspot/delete_record_engagements">
    **Descrição:** Exclua um registro de engajamento pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do engajamento a ser excluído.
  </Accordion>

  <Accordion title="hubspot/delete_record_any">
    **Descrição:** Exclua um registro de qualquer tipo de objeto especificado pelo seu ID.

    **Parâmetros:**

    * `recordType` (string, obrigatório): ID do tipo de objeto personalizado.
    * `recordId` (string, obrigatório): ID do registro a ser excluído.
  </Accordion>

  <Accordion title="hubspot/get_contacts_by_list_id">
    **Descrição:** Obtenha contatos de uma lista específica pelo seu ID.

    **Parâmetros:**

    * `listId` (string, obrigatório): ID da lista da qual obter os contatos.
    * `paginationParameters` (object, opcional): Use `pageCursor` para páginas subsequentes.
  </Accordion>

  <Accordion title="hubspot/describe_action_schema">
    **Descrição:** Obtenha o esquema esperado para um dado tipo de objeto e operação.

    **Parâmetros:**

    * `recordType` (string, obrigatório): ID do tipo de objeto (ex.: 'companies').
    * `operation` (string, obrigatório): Tipo de operação (ex.: 'CREATE\_RECORD').
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica de Agente HubSpot
```

---

## `BedrockKBRetrieverTool`

**URL:** llms-txt#`bedrockkbretrievertool`

**Contents:**
- Instalação
- Requisitos
- Uso

A `BedrockKBRetrieverTool` permite que agentes CrewAI recuperem informações das Bases de Conhecimento do Amazon Bedrock usando consultas em linguagem natural.

* Credenciais AWS configuradas (via variáveis de ambiente ou AWS CLI)
* Pacotes `boto3` e `python-dotenv`
* Acesso à Base de Conhecimento do Amazon Bedrock

Veja como utilizar a ferramenta com um agente CrewAI:

```python {2, 4-17} theme={null}
from crewai import Agent, Task, Crew
from crewai_tools.aws.bedrock.knowledge_base.retriever_tool import BedrockKBRetrieverTool

**Examples:**

Example 1 (unknown):
```unknown
## Requisitos

* Credenciais AWS configuradas (via variáveis de ambiente ou AWS CLI)
* Pacotes `boto3` e `python-dotenv`
* Acesso à Base de Conhecimento do Amazon Bedrock

## Uso

Veja como utilizar a ferramenta com um agente CrewAI:
```

---

## 2. SSE Server:

**URL:** llms-txt#2.-sse-server:

server_params = {
    "url": "http://localhost:8000/sse",
    "transport": "sse"
}

---

## para que o agente possa pesquisar dentro do conteúdo desse arquivo de texto

**URL:** llms-txt#para-que-o-agente-possa-pesquisar-dentro-do-conteúdo-desse-arquivo-de-texto

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = TXTSearchTool(txt='path/to/text/file.txt')
python Code theme={null}
from chromadb.config import Settings

tool = TXTSearchTool(
    config={
        # Obrigatório: provedor de embeddings + configuração
        "embedding_model": {
            "provider": "openai",  # ou google-generativeai, cohere, ollama, ...
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",  # opcional se variável de ambiente estiver definida
                # Exemplos por provedor:
                # Google → model: "models/embedding-001", task_type: "retrieval_document"
            },
        },

# Obrigatório: configuração do banco vetorial
        "vectordb": {
            "provider": "chromadb",  # ou "qdrant"
            "config": {
                # Configurações do Chroma (persistência opcional)
                # "settings": Settings(
                #     persist_directory="/content/chroma",
                #     allow_reset=True,
                #     is_persistent=True,
                # ),

# Exemplo de parâmetros de vetor do Qdrant:
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),

# Observação: o nome da coleção é controlado pela ferramenta (padrão: "rag_tool_collection").
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `txt` (str): **Opcional**. O caminho para o arquivo de texto que você deseja pesquisar.
  Este argumento só é necessário se a ferramenta não foi inicializada com um arquivo de texto específico;
  caso contrário, a pesquisa será realizada no arquivo de texto fornecido inicialmente.

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza o OpenAI tanto para embeddings quanto para sumarização.
Para personalizar o modelo, você pode usar um dicionário de configuração como o exemplo a seguir:
```

---

## Defina um agente com o BraveSearchTool

**URL:** llms-txt#defina-um-agente-com-o-bravesearchtool

**Contents:**
- Conclusão

@agent
def researcher(self) -> Agent:
    return Agent(
        config=self.agents_config["researcher"],
        allow_delegation=False,
        tools=[brave_search_tool]
    )
```

Ao integrar o `BraveSearchTool` em projetos Python, os usuários ganham a capacidade de realizar buscas em tempo real e relevantes na internet diretamente de suas aplicações. A ferramenta oferece uma interface simples para a poderosa Brave Search API, facilitando a recuperação e o processamento programático dos resultados de pesquisa. Seguindo as orientações de configuração e uso fornecidas, a incorporação desta ferramenta em projetos é simplificada e direta.

---

## Ferramenta de Extração Scrapegraph

**URL:** llms-txt#ferramenta-de-extração-scrapegraph

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/scrapegraphscrapetool

A `ScrapegraphScrapeTool` utiliza a API SmartScraper da Scrapegraph AI para extrair conteúdo de sites de forma inteligente.

---

## 외부 자동화

**URL:** llms-txt#외부-자동화

analysis_automation = InvokeCrewAIAutomationTool(
    crew_api_url="https://analysis-crew.acme.crewai.com",
    crew_bearer_token="YOUR_BEARER_TOKEN",
    crew_name="Analysis Automation",
    crew_description="프로덕션 분석 파이프라인을 실행",
)

---

## NL2SQL Tool

**URL:** llms-txt#nl2sql-tool

**Contents:**
- Visão Geral
- Requisitos
- Instalação
- Uso

Source: https://docs.crewai.com/pt-BR/tools/database-data/nl2sqltool

O `NL2SQLTool` foi projetado para converter linguagem natural em consultas SQL.

Esta ferramenta é utilizada para converter linguagem natural em consultas SQL. Quando passada para o agente, ela irá gerar as consultas e, em seguida, utilizá-las para interagir com o banco de dados.

Isso possibilita múltiplos fluxos de trabalho, como por exemplo ter um Agente acessando o banco de dados para buscar informações com base em um objetivo e, então, usar essas informações para gerar uma resposta, relatório ou qualquer outro tipo de saída. Além disso, permite que o Agente atualize o banco de dados de acordo com seu objetivo.

**Atenção**: Certifique-se de que o Agente tenha acesso a um Read-Replica ou que seja permitido que o Agente execute consultas de inserção/atualização no banco de dados.

* SqlAlchemy
* Qualquer biblioteca compatível com o banco de dados (ex.: psycopg2, mysql-connector-python)

Instale o pacote crewai\_tools

Para utilizar o NL2SQLTool, você precisa passar a URI do banco de dados para a ferramenta. O formato da URI deve ser `dialect+driver://username:password@host:port/database`.

```python Code theme={null}
from crewai_tools import NL2SQLTool

**Examples:**

Example 1 (unknown):
```unknown
## Uso

Para utilizar o NL2SQLTool, você precisa passar a URI do banco de dados para a ferramenta. O formato da URI deve ser `dialect+driver://username:password@host:port/database`.
```

---

## Cria uma tarefa para o agente

**URL:** llms-txt#cria-uma-tarefa-para-o-agente

scrape_task = Task(
    description="""
    Extract the following information from the news website at {website_url}:
    
    1. The headlines of all featured articles (CSS selector: '.headline')
    2. The publication dates of these articles (CSS selector: '.pub-date')
    3. The author names where available (CSS selector: '.author')
    
    Compile this information into a structured format with each article's details grouped together.
    """,
    expected_output="A structured list of articles with their headlines, publication dates, and authors.",
    agent=web_scraper_agent,
)

---

## `EXASearchTool`

**URL:** llms-txt#`exasearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

O EXASearchTool foi projetado para realizar uma busca semântica para uma consulta especificada a partir do conteúdo de um texto em toda a internet.
Ele utiliza a API da [exa.ai](https://exa.ai/) para buscar e exibir os resultados de pesquisa mais relevantes com base na consulta fornecida pelo usuário.

Para incorporar esta ferramenta em seu projeto, siga as instruções de instalação abaixo:

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca com uma consulta determinada:

```python Code theme={null}
from crewai_tools import EXASearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca com uma consulta determinada:
```

---

## Define the Pydantic model for the blog

**URL:** llms-txt#define-the-pydantic-model-for-the-blog

class Blog(BaseModel):
    title: str
    content: str

---

## 에이전트가 알고 있거나 경로를 학습한 파일을 읽기 위해 도구를 초기화합니다.

**URL:** llms-txt#에이전트가-알고-있거나-경로를-학습한-파일을-읽기-위해-도구를-초기화합니다.

file_read_tool = FileReadTool()

---

## Inicialize a ferramenta para buscas semânticas em um repositório GitHub específico, permitindo que o agente pesquise em qualquer repositório caso tome conhecimento durante a execução

**URL:** llms-txt#inicialize-a-ferramenta-para-buscas-semânticas-em-um-repositório-github-específico,-permitindo-que-o-agente-pesquise-em-qualquer-repositório-caso-tome-conhecimento-durante-a-execução

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = GithubSearchTool(
	gh_token='your_github_personal_access_token',
	content_types=['code', 'issue'] # Opções: code, repo, pr, issue
)
python Code theme={null}
tool = GithubSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # ou google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # ou openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `github_repo` : A URL do repositório GitHub onde a busca será realizada. Este é um campo obrigatório e especifica o repositório alvo para sua pesquisa.
* `gh_token` : Seu Personal Access Token (PAT) do GitHub necessário para autenticação. Você pode criar um nas configurações da sua conta GitHub em Developer Settings > Personal Access Tokens.
* `content_types` : Especifica os tipos de conteúdo a serem incluídos na busca. É necessário fornecer uma lista dos tipos de conteúdo das seguintes opções: `code` para pesquisar dentro do código,
  `repo` para pesquisar nas informações gerais do repositório, `pr` para pesquisar em pull requests, e `issue` para pesquisar nas issues.
  Este campo é obrigatório e permite adaptar a busca para tipos específicos de conteúdo dentro do repositório GitHub.

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza o OpenAI tanto para embeddings quanto para sumarização. Para personalizar o modelo, você pode usar um dicionário de configuração como no exemplo:
```

---

## 일반 텍스트용 마크다운 미포함 스크레이프

**URL:** llms-txt#일반-텍스트용-마크다운-미포함-스크레이프

**Contents:**
- 사용 사례
- 오류 처리
- 보안 고려사항

plain_result = tool.run(
    url="https://docs.crewai.com",
    include_markdown=False
)

print("마크다운 형식의 콘텐츠:")
print(markdown_result)

print("\n일반 텍스트 콘텐츠:")
print(plain_result)
```

`SerperScrapeWebsiteTool`은 특히 다음과 같은 경우에 유용합니다:

* **콘텐츠 분석**: 연구 목적을 위해 웹사이트 콘텐츠를 추출하고 분석할 때
* **데이터 수집**: 웹 페이지에서 구조화된 정보를 수집할 때
* **문서 처리**: 웹 기반 문서를 읽기 쉬운 형식으로 변환할 때
* **경쟁사 분석**: 시장 조사를 위해 경쟁사 웹사이트를 스크래핑할 때
* **콘텐츠 마이그레이션**: 기존 웹사이트의 콘텐츠를 마이그레이션 목적으로 추출할 때

이 도구는 다음에 대한 포괄적인 오류 처리를 포함합니다:

* **네트워크 문제**: 연결 시간 초과 및 네트워크 오류를 원활하게 처리
* **API 오류**: API 관련 문제에 대한 자세한 오류 메시지 제공
* **잘못된 URL**: 잘못된 형식의 URL 문제를 검증 및 보고
* **인증**: 누락되었거나 잘못된 API 키에 대해 명확한 오류 메시지 제공

* `SERPER_API_KEY`는 항상 환경 변수에 저장하고, 소스 코드에 하드코딩하지 마세요.
* Serper API에서 부과하는 속도 제한을 유의하세요.
* 콘텐츠를 스크래핑할 때 robots.txt와 웹사이트 서비스 약관을 준수하세요.
* 대규모 스크래핑 작업 시 요청 간에 지연을 구현하는 것을 고려하세요.

---

## JSON RAG Search

**URL:** llms-txt#json-rag-search

Source: https://docs.crewai.com/en/tools/file-document/jsonsearchtool

The `JSONSearchTool` is designed to search JSON files and return the most relevant results.

---

## Code Interpreter

**URL:** llms-txt#code-interpreter

Source: https://docs.crewai.com/en/tools/ai-ml/codeinterpretertool

The `CodeInterpreterTool` is a powerful tool designed for executing Python 3 code within a secure, isolated environment.

---

## Inicializa a ferramenta com parâmetros predefinidos

**URL:** llms-txt#inicializa-a-ferramenta-com-parâmetros-predefinidos

selenium_tool = SeleniumScrapingTool(
    website_url='https://example.com',
    css_element='.main-content',
    wait_time=5
)

---

## 다중 MCP 소스를 가진 에이전트 생성

**URL:** llms-txt#다중-mcp-소스를-가진-에이전트-생성

multi_source_agent = Agent(
    role="다중 소스 연구 분석가",
    goal="다중 데이터 소스를 사용한 종합적인 연구 수행",
    backstory="""웹 검색, 날씨 데이터, 금융 정보,
    학술 연구 도구에 접근할 수 있는 전문가 연구원""",
    mcps=[
        # 외부 MCP 서버
        "https://mcp.exa.ai/mcp?api_key=your_exa_key&profile=research",
        "https://weather.api.com/mcp#get_current_conditions",

# CrewAI AMP 마켓플레이스
        "crewai-amp:financial-insights",
        "crewai-amp:academic-research#pubmed_search",
        "crewai-amp:market-intelligence#competitor_analysis"
    ]
)

---

## Task to send project updates

**URL:** llms-txt#task-to-send-project-updates

update_task = Task(
    description="Send a project status update to the #general channel with current progress",
    agent=slack_agent,
    expected_output="Project update message sent successfully to team channel"
)

---

## Stdio Transport

**URL:** llms-txt#stdio-transport

**Contents:**
- Overview
- Key Concepts
- Connecting via Stdio
  - 1. Fully Managed Connection (Recommended)

Source: https://docs.crewai.com/en/mcp/stdio

Learn how to connect CrewAI to local MCP servers using the Stdio (Standard Input/Output) transport mechanism.

The Stdio (Standard Input/Output) transport is designed for connecting `MCPServerAdapter` to local MCP servers that communicate over their standard input and output streams. This is typically used when the MCP server is a script or executable running on the same machine as your CrewAI application.

* **Local Execution**: Stdio transport manages a locally running process for the MCP server.
* **`StdioServerParameters`**: This class from the `mcp` library is used to configure the command, arguments, and environment variables for launching the Stdio server.

## Connecting via Stdio

You can connect to an Stdio-based MCP server using two main approaches for managing the connection lifecycle:

### 1. Fully Managed Connection (Recommended)

Using a Python context manager (`with` statement) is the recommended approach. It automatically handles starting the MCP server process and stopping it when the context is exited.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters
import os

---

## Ideal para tarefas de precisão

**URL:** llms-txt#ideal-para-tarefas-de-precisão

**Contents:**
  - Abordagens Alternativas para Grandes Volumes de Dados

precision_agent = Agent(
    role="Code Security Auditor",
    goal="Identify security vulnerabilities in code",
    backstory="Security expert requiring complete code context",
    respect_context_window=False,  # Prefere falhar do que análise incompleta
    max_retry_limit=1,  # Falha rápida em caso de problemas de contexto
    verbose=True
)
python Code theme={null}
from crewai_tools import RagTool

**Examples:**

Example 1 (unknown):
```unknown
### Abordagens Alternativas para Grandes Volumes de Dados

Ao lidar com conjuntos de dados muito grandes, considere as seguintes estratégias:

#### 1. Use Ferramentas RAG
```

---

## Langfuse 통합

**URL:** llms-txt#langfuse-통합

Source: https://docs.crewai.com/ko/observability/langfuse

OpenLit을 사용하여 OpenTelemetry를 통해 CrewAI와 Langfuse를 통합하는 방법을 알아보세요

---

## Add content from a file

**URL:** llms-txt#add-content-from-a-file

rag_tool.add(data_type="file", path="path/to/your/document.pdf")

---

## ... importe events ...

**URL:** llms-txt#...-importe-events-...

class MyCustomListener(BaseEventListener):
    # ... implementação ...

---

## Integração com Arize Phoenix

**URL:** llms-txt#integração-com-arize-phoenix

**Contents:**
- Primeiros Passos
  - Passo 1: Instale as Dependências
  - Passo 2: Configure as Variáveis de Ambiente

Este guia demonstra como integrar o **Arize Phoenix** ao **CrewAI** usando o OpenTelemetry através do [OpenInference](https://github.com/openinference/openinference) SDK. Ao final deste guia, você será capaz de rastrear seus agentes CrewAI e depurá-los com facilidade.

> **O que é o Arize Phoenix?** O [Arize Phoenix](https://phoenix.arize.com) é uma plataforma de observabilidade de LLM que oferece rastreamento e avaliação para aplicações de IA.

[![Assista a um vídeo demonstrando a nossa integração com o Phoenix](https://storage.googleapis.com/arize-assets/fixtures/setup_crewai.png)](https://www.youtube.com/watch?v=Yc5q3l6F7Ww)

Vamos percorrer um exemplo simples de uso do CrewAI e integração com o Arize Phoenix via OpenTelemetry utilizando o OpenInference.

Você também pode acessar este guia no [Google Colab](https://colab.research.google.com/github/Arize-ai/phoenix/blob/main/tutorials/tracing/crewai_tracing_tutorial.ipynb).

### Passo 1: Instale as Dependências

### Passo 2: Configure as Variáveis de Ambiente

Configure as chaves de API do Phoenix Cloud e ajuste o OpenTelemetry para enviar rastros ao Phoenix. O Phoenix Cloud é uma versão hospedada do Arize Phoenix, mas não é obrigatório para utilizar esta integração.

Você pode obter uma chave de API gratuita do Serper [aqui](https://serper.dev/).

```python  theme={null}
import os
from getpass import getpass

**Examples:**

Example 1 (unknown):
```unknown
### Passo 2: Configure as Variáveis de Ambiente

Configure as chaves de API do Phoenix Cloud e ajuste o OpenTelemetry para enviar rastros ao Phoenix. O Phoenix Cloud é uma versão hospedada do Arize Phoenix, mas não é obrigatório para utilizar esta integração.

Você pode obter uma chave de API gratuita do Serper [aqui](https://serper.dev/).
```

---

## 디렉터리 읽기

**URL:** llms-txt#디렉터리-읽기

Source: https://docs.crewai.com/ko/tools/file-document/directoryreadtool

DirectoryReadTool은 디렉터리의 내용을 포괄적으로 나열할 수 있도록 설계된 강력한 유틸리티입니다.

---

## ✅ Descrições específicas e acionáveis

**URL:** llms-txt#✅-descrições-específicas-e-acionáveis

Task(
    description="""Research competitors in the AI chatbot space.
    Focus on: pricing models, key features, target markets.
    Provide data in a structured format.""",
    ...
)

---

## 작업 정의

**URL:** llms-txt#작업-정의

research = Task(
    description='Research the latest trends in the AI industry and provide a summary.',
    expected_output='A summary of the top 3 trending developments in the AI industry with a unique perspective on their significance.',
    agent=researcher
)

write = Task(
    description='Write an engaging blog post about the AI industry, based on the research analyst's summary. Draw inspiration from the latest blog posts in the directory.',
    expected_output='A 4-paragraph blog post formatted in markdown with engaging, informative, and accessible content, avoiding complex jargon.',
    agent=writer,
    output_file='blog-posts/new_post.md'  # 최종 블로그 글이 여기에 저장됩니다
)

---

## Integração Langfuse

**URL:** llms-txt#integração-langfuse

Source: https://docs.crewai.com/pt-BR/observability/langfuse

Saiba como integrar o Langfuse ao CrewAI via OpenTelemetry usando OpenLit

---

## 텔레메트리

**URL:** llms-txt#텔레메트리

**Contents:**
- 텔레메트리
  - 예시:

Source: https://docs.crewai.com/ko/telemetry

CrewAI에서 수집되는 텔레메트리 데이터와 이 데이터가 라이브러리의 향상에 어떻게 기여하는지 이해합니다.

<Note>
  기본적으로, 저희는 GDPR 및 기타 개인정보 보호 규정하에서 개인정보로 간주되는 어떠한 데이터도 수집하지 않습니다.
  도구 이름과 에이전트 역할만을 수집하므로, 도구 이름이나 에이전트 역할에 개인정보를 포함하지 않도록 주의하시기 바랍니다.
  개인정보가 수집되지 않으므로 데이터 거주지에 대해 걱정할 필요가 없습니다.
  `share_crew`가 활성화되면, 사용자가 포함한 경우 개인정보를 포함할 수 있는 추가 데이터가 수집될 수 있습니다.
  사용자는 이 기능을 활성화할 때 개인정보 보호 규정 준수를 위해 주의를 기울여야 합니다.
</Note>

CrewAI는 익명 텔레메트리를 활용하여 사용 통계를 수집하며, 주요 목적은 라이브러리의 향상에 있습니다.
저희의 초점은 사용자들이 가장 많이 사용하는 기능, 통합, 도구를 개선하고 개발하는 데 있습니다.

기본적으로 프롬프트, 작업 설명, 에이전트의 배경 이야기나 목표, 도구 사용, API 호출, 응답, 에이전트가 처리하는 데이터, 또는 시크릿과 환경 변수 등과 관련된 **개인 데이터는 절대 수집하지 않습니다**.
`share_crew` 기능이 활성화되면, 보다 심층적인 통찰을 제공하기 위해 작업 설명, 에이전트의 배경 이야기나 목표, 기타 특정 속성 등 상세한 데이터가 수집됩니다.
이 확대된 데이터 수집에는 사용자가 crew나 작업에 개인정보를 포함한 경우, 개인정보가 포함될 수 있습니다.
사용자는 `share_crew`를 활성화하기 전에 crew와 작업의 내용을 신중하게 검토해야 합니다.
사용자는 환경 변수 `CREWAI_DISABLE_TELEMETRY`를 `true`로 설정하거나, `OTEL_SDK_DISABLED`를 `true`로 설정하여 텔레메트리를 비활성화할 수 있습니다(후자의 경우 전체 OpenTelemetry 계측이 전역에서 비활성화된다는 점에 유의하십시오).

```python  theme={null}

---

## Opção 2: Acessando diretamente do modelo Pydantic

**URL:** llms-txt#opção-2:-acessando-diretamente-do-modelo-pydantic

print("Acessando propriedades - Opção 2")
title = result.pydantic.title
content = result.pydantic.content
print("Título:", title)
print("Conteúdo:", content)

---

## File Read

**URL:** llms-txt#file-read

**Contents:**
- Overview
- Installation
- Usage Example

Source: https://docs.crewai.com/en/tools/file-document/filereadtool

The `FileReadTool` is designed to read files from the local file system.

<Note>
  We are still working on improving tools, so there might be unexpected behavior or changes in the future.
</Note>

The FileReadTool conceptually represents a suite of functionalities within the crewai\_tools package aimed at facilitating file reading and content retrieval.
This suite includes tools for processing batch text files, reading runtime configuration files, and importing data for analytics.
It supports a variety of text-based file formats such as `.txt`, `.csv`, `.json`, and more. Depending on the file type, the suite offers specialized functionality,
such as converting JSON content into a Python dictionary for ease of use.

To utilize the functionalities previously attributed to the FileReadTool, install the crewai\_tools package:

To get started with the FileReadTool:

```python Code theme={null}
from crewai_tools import FileReadTool

**Examples:**

Example 1 (unknown):
```unknown
## Usage Example

To get started with the FileReadTool:
```

---

## Crie um agente com capacidades do Microsoft SharePoint

**URL:** llms-txt#crie-um-agente-com-capacidades-do-microsoft-sharepoint

sharepoint_agent = Agent(
    role="Gerenciador SharePoint",
    goal="Gerenciar sites, listas e documentos do SharePoint de forma eficiente",
    backstory="Um assistente IA especializado em administração do Microsoft SharePoint e gerenciamento de conteúdo.",
    apps=['microsoft_sharepoint']  # Todas as ações do SharePoint estarão disponíveis
)

---

## Assuming the tool's execution and result population occurs within the system

**URL:** llms-txt#assuming-the-tool's-execution-and-result-population-occurs-within-the-system

**Contents:**
- Fluxo de Trabalho em Ação

task_result = coding_agent.execute_task(task)
```

## Fluxo de Trabalho em Ação

<Steps>
  <Step title="Execução da Tarefa">
    O agent executa a tarefa utilizando a ferramenta fornecida.
  </Step>

<Step title="Saída da Ferramenta">
    A ferramenta gera a saída, que é capturada como resultado da tarefa.
  </Step>

<Step title="Interação do Agent">
    O agent pode refletir e aprender com a ferramenta, mas a saída não é modificada.
  </Step>

<Step title="Retorno do Resultado">
    A saída da ferramenta é retornada como resultado da tarefa sem quaisquer modificações.
  </Step>
</Steps>

---

## Se QdrantConfig tem um filtro pré-definido para categoria="pesquisa"

**URL:** llms-txt#se-qdrantconfig-tem-um-filtro-pré-definido-para-categoria="pesquisa"

---

## código não traduzido

**URL:** llms-txt#código-não-traduzido

**Contents:**
- Boas Práticas para Gerenciamento de Estado
  - 1. Mantenha o Estado Focado

**Examples:**

Example 1 (unknown):
```unknown
## Boas Práticas para Gerenciamento de Estado

### 1. Mantenha o Estado Focado

Projete seu estado para conter somente o necessário:
```

---

## FAQs

**URL:** llms-txt#faqs

Source: https://docs.crewai.com/pt-BR/enterprise/resources/frequently-asked-questions

Perguntas frequentes sobre CrewAI AMP

<AccordionGroup>
  <Accordion title="Como a execução de tarefas é tratada no processo hierárquico?">
    No processo hierárquico, um agente gerente é criado automaticamente e coordena o fluxo de trabalho, delegando tarefas e validando resultados para uma execução eficiente e simplificada. O agente gerente utiliza ferramentas para facilitar a delegação e execução de tarefas por agentes sob sua orientação. O LLM do gerente é fundamental para o processo hierárquico e deve ser configurado corretamente para funcionar adequadamente.
  </Accordion>

<Accordion title="Onde posso encontrar a documentação mais recente da CrewAI?">
    A documentação mais atualizada da CrewAI está disponível em nosso site oficial de documentação: [https://docs.crewai.com/](https://docs.crewai.com/)
    <Card href="https://docs.crewai.com/" icon="books">CrewAI Docs</Card>
  </Accordion>

<Accordion title="Quais as principais diferenças entre os Processos Hierárquico e Sequencial na CrewAI?">
    #### Processo Hierárquico:

* As tarefas são delegadas e executadas com base em uma cadeia de comando estruturada
    * Um modelo de linguagem do gerente (`manager_llm`) deve ser especificado para o agente gerente
    * O agente gerente supervisiona a execução de tarefas, planejamento, delegação e validação
    * As tarefas não são pré-atribuídas; o gerente aloca tarefas para os agentes com base em suas capacidades

#### Processo Sequencial:

* As tarefas são executadas uma após a outra, garantindo uma progressão ordenada
    * O resultado de uma tarefa serve como contexto para a próxima
    * A execução das tarefas segue a ordem predefinida na lista de tarefas

#### Qual Processo é Melhor para Projetos Complexos?

O processo hierárquico é mais adequado para projetos complexos porque permite:

* **Alocação e delegação dinâmica de tarefas**: O agente gerente pode atribuir tarefas de acordo com as capacidades dos agentes
    * **Validação e supervisão estruturadas**: O agente gerente revisa os resultados das tarefas e garante a conclusão
    * **Gestão de tarefas complexas**: Controle preciso da disponibilidade de ferramentas por agente
  </Accordion>

<Accordion title="Quais são os benefícios do uso de memória no framework CrewAI?">
    * **Aprendizado adaptativo**: As crews tornam-se mais eficientes ao longo do tempo, adaptando-se a novas informações e aprimorando sua abordagem às tarefas
    * **Personalização aprimorada**: A memória permite que os agentes recordem preferências do usuário e interações anteriores, possibilitando experiências personalizadas
    * **Resolução aprimorada de problemas**: O acesso a um repositório rico em memória auxilia os agentes a tomarem decisões mais informadas, baseando-se em aprendizados anteriores e insights contextuais
  </Accordion>

<Accordion title="Qual é o propósito de definir um limite máximo de RPM para um agente?">
    Definir um limite máximo de RPM para um agente evita que ele faça solicitações excessivas a serviços externos, o que pode ajudar a evitar limites de taxa e melhorar o desempenho.
  </Accordion>

<Accordion title="Qual o papel da entrada humana na execução de tarefas dentro de uma crew da CrewAI?">
    A entrada humana permite que os agentes solicitem informações adicionais ou esclarecimentos quando necessário. Este recurso é fundamental em processos de tomada de decisão complexos ou quando os agentes precisam de mais detalhes para concluir uma tarefa com eficácia.

Para integrar a entrada humana na execução do agente, defina a flag `human_input` na definição da tarefa. Quando habilitada, o agente solicitará a entrada do usuário antes de entregar sua resposta final. Essa entrada pode fornecer contexto extra, esclarecer ambiguidades ou validar a saída do agente.

Para orientações detalhadas de implementação, veja nosso [guia Human-in-the-Loop](/pt-BR/how-to/human-in-the-loop).
  </Accordion>

<Accordion title="Quais opções avançadas de customização estão disponíveis para aprimorar e personalizar o comportamento e as capacidades dos agentes na CrewAI?">
    A CrewAI oferece diversas opções avançadas de customização:

* **Customização de Modelo de Linguagem**: Os agentes podem ser personalizados com modelos de linguagem específicos (`llm`) e modelos de linguagem para chamadas de função (`function_calling_llm`)
    * **Configurações de Desempenho e Debug**: Ajuste o desempenho do agente e monitore suas operações
    * **Modo Verbose**: Habilita registros detalhados das ações do agente, útil para depuração e otimização
    * **Limite de RPM**: Define o número máximo de solicitações por minuto (`max_rpm`)
    * **Máximo de Iterações**: O atributo `max_iter` permite definir o número máximo de iterações que um agente pode executar para uma única tarefa
    * **Delegação e Autonomia**: Controle a capacidade do agente de delegar ou fazer perguntas com o atributo `allow_delegation` (padrão: True)
    * **Integração de Entrada Humana**: Os agentes podem solicitar informações adicionais ou esclarecimentos quando necessário
  </Accordion>

<Accordion title="Em quais cenários a entrada humana é particularmente útil na execução de agentes?">
    A entrada humana é especialmente útil quando:

* **Os agentes precisam de informações adicionais ou esclarecimentos**: Quando se deparam com ambiguidade ou dados incompletos
    * **Os agentes precisam tomar decisões complexas ou sensíveis**: A entrada humana pode auxiliar em decisões éticas ou de nuances
    * **Supervisão e validação da saída do agente**: A entrada humana pode ajudar a validar resultados e prevenir erros
    * **Personalização do comportamento do agente**: Entradas humanas podem fornecer feedback para aprimorar respostas dos agentes ao longo do tempo
    * **Identificação e resolução de erros ou limitações**: A entrada humana auxilia a suprir lacunas de capacidade dos agentes
  </Accordion>

<Accordion title="Quais são os diferentes tipos de memória disponíveis na crewAI?">
    Os diferentes tipos de memória disponíveis na CrewAI são:

* **Memória de curto prazo**: Armazenamento temporário para contexto imediato
    * **Memória de longo prazo**: Armazenamento persistente para padrões aprendidos e informações
    * **Memória de entidade**: Armazenamento focado em entidades específicas e seus atributos
    * **Memória contextual**: Memória que mantém o contexto ao longo das interações

Saiba mais sobre os diferentes tipos de memória:
    <Card href="https://docs.crewai.com/concepts/memory" icon="brain">CrewAI Memory</Card>
  </Accordion>

<Accordion title="Como faço para usar Output Pydantic em uma Tarefa?">
    Para usar Output Pydantic em uma tarefa, você precisa definir a saída esperada da tarefa como um modelo Pydantic. Veja um exemplo rápido:

<Steps>
      <Step title="Defina um modelo Pydantic">
        
      </Step>

<Step title="Crie uma tarefa com Output Pydantic">
        
      </Step>

<Step title="Defina o atributo output_pydantic no seu agente">
        
      </Step>
    </Steps>

Aqui está um tutorial de como obter saídas estruturadas de forma consistente dos seus agentes:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/dNpKQk5uxHw" title="Saídas estruturadas no CrewAI" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />
  </Accordion>

<Accordion title="Como posso criar ferramentas personalizadas para meus agentes CrewAI?">
    Você pode criar ferramentas personalizadas herdando da classe `BaseTool` fornecida pela CrewAI ou usando o decorador de ferramenta. Herdar envolve definir uma nova classe que herda de `BaseTool`, especificando o nome, a descrição e o método `_run` para a lógica operacional. O decorador de ferramenta permite criar um objeto `Tool` diretamente com os atributos necessários e uma lógica funcional.

<Card href="https://docs.crewai.com/how-to/create-custom-tools" icon="code">CrewAI Tools Guide</Card>
  </Accordion>

<Accordion title="Como controlar o número máximo de solicitações por minuto que toda a crew pode realizar?">
    O atributo `max_rpm` define o número máximo de solicitações por minuto que a crew pode realizar para evitar limites de taxa, e irá sobrescrever as definições de `max_rpm` dos agentes individuais se você defini-lo.
  </Accordion>
</AccordionGroup>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

      <Step title="Crie uma tarefa com Output Pydantic">
```

Example 2 (unknown):
```unknown
</Step>

      <Step title="Defina o atributo output_pydantic no seu agente">
```

---

## 먼저 Ollama를 로컬에 설치하고 실행한 다음, 임베딩 모델을 pull 합니다:

**URL:** llms-txt#먼저-ollama를-로컬에-설치하고-실행한-다음,-임베딩-모델을-pull-합니다:

---

## Initialize the tool to search within any text file's content

**URL:** llms-txt#initialize-the-tool-to-search-within-any-text-file's-content

---

## Create an agent

**URL:** llms-txt#create-an-agent

researcher = Agent(
    role="AI Technology Researcher",
    goal="Research the latest AI developments",
    tools=[SerperDevTool()],
    verbose=True
)

---

## Scrapegraph 스크레이프 도구

**URL:** llms-txt#scrapegraph-스크레이프-도구

Source: https://docs.crewai.com/ko/tools/web-scraping/scrapegraphscrapetool

ScrapegraphScrapeTool은 Scrapegraph AI의 SmartScraper API를 활용하여 웹사이트에서 콘텐츠를 지능적으로 추출합니다.

---

## Task to list files and create a folder

**URL:** llms-txt#task-to-list-files-and-create-a-folder

organize_files_task = Task(
    description="List all files in my OneDrive root directory and create a new folder called 'Project Documents'.",
    agent=onedrive_agent,
    expected_output="List of files displayed and new folder 'Project Documents' created."
)

---

## LlamaIndex 도구

**URL:** llms-txt#llamaindex-도구

Source: https://docs.crewai.com/ko/tools/ai-ml/llamaindextool

LlamaIndexTool은 LlamaIndex 도구와 쿼리 엔진의 래퍼입니다.

---

## Example server_params (choose one based on your server type):

**URL:** llms-txt#example-server_params-(choose-one-based-on-your-server-type):

---

## Sua chave OpenAI

**URL:** llms-txt#sua-chave-openai

os.environ["OPENAI_API_KEY"] = "sk-proj-..."
python  theme={null}
from langfuse import get_client
 
langfuse = get_client()

**Examples:**

Example 1 (unknown):
```unknown
Com as variáveis de ambiente configuradas, agora podemos inicializar o cliente Langfuse. A função get\_client() inicializa o cliente Langfuse usando as credenciais fornecidas nas variáveis de ambiente.
```

---

## Guardrail with tool response context

**URL:** llms-txt#guardrail-with-tool-response-context

**Contents:**
- 작동 원리
  - 검증 프로세스
  - 검증 논리
- 가드레일 결과

weather_guardrail = HallucinationGuardrail(
    context="Current weather information for the requested location",
    llm=LLM(model="gpt-4o-mini"),
    tool_response="Weather API returned: Temperature 22°C, Humidity 65%, Clear skies"
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 작동 원리

### 검증 프로세스

1. **컨텍스트 분석**: 가드레일은 작업 결과를 제공된 참조 컨텍스트와 비교합니다.
2. **정확성 점수 부여**: 내부 평가자를 사용하여 정확성 점수(0-10)를 부여합니다.
3. **판단 결정**: 콘텐츠가 정확한지 또는 환각이 포함되어 있는지 결정합니다.
4. **임계값 확인**: 사용자 지정 임계값이 설정된 경우 해당 점수와 비교하여 검증합니다.
5. **피드백 생성**: 검증에 실패할 때 상세한 사유를 제공합니다.

### 검증 논리

* **기본 모드**: 판정 기반 검증(FAITHFUL vs HALLUCINATED)을 사용함
* **임계값 모드**: 신뢰성 점수가 지정된 임계값에 도달하거나 이를 초과해야 함
* **오류 처리**: 평가 오류를 우아하게 처리하고 유익한 피드백을 제공함

## 가드레일 결과

가드레일은 검증 상태를 나타내는 구조화된 결과를 반환합니다:
```

---

## After kickoff - knowledge initialized

**URL:** llms-txt#after-kickoff---knowledge-initialized

print(f"After kickoff - Agent knowledge: {agent.knowledge}")
print(f"Agent knowledge collection: {agent.knowledge.storage.collection_name}")
print(f"Number of sources: {len(agent.knowledge.sources)}")
python  theme={null}
import os
from crewai.utilities.paths import db_storage_path

**Examples:**

Example 1 (unknown):
```unknown
#### Verificar Localizações de Armazenamento de Knowledge
```

---

## Verifique disponibilidade do modelo

**URL:** llms-txt#verifique-disponibilidade-do-modelo

from crewai.rag.embeddings.configurator import EmbeddingConfigurator

configurator = EmbeddingConfigurator()
try:
    embedder = configurator.configure_embedder({
        "provider": "ollama",
        "config": {"model": "mxbai-embed-large"}
    })
    print("Embedder configured successfully")
except Exception as e:
    print(f"Configuration error: {e}")
python  theme={null}
import os

**Examples:**

Example 1 (unknown):
```unknown
**Problemas com chave de API:**
```

---

## `DirectoryReadTool`

**URL:** llms-txt#`directoryreadtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, então pode haver comportamentos inesperados ou alterações no futuro.
</Note>

O DirectoryReadTool é uma poderosa utilidade projetada para fornecer uma listagem abrangente do conteúdo de diretórios.
Ele pode navegar recursivamente pelo diretório especificado, oferecendo aos usuários uma enumeração detalhada de todos os arquivos, incluindo aqueles que estão dentro de subdiretórios.
Essa ferramenta é fundamental para tarefas que exigem um inventário completo das estruturas de diretórios ou para validar a organização de arquivos em diretórios.

Para utilizar o DirectoryReadTool em seu projeto, instale o pacote `crewai_tools`. Se este pacote ainda não faz parte do seu ambiente, você pode instalá-lo usando o pip com o comando abaixo:

Esse comando instala a versão mais recente do pacote `crewai_tools`, permitindo o acesso ao DirectoryReadTool, entre outras utilidades.

Empregar o DirectoryReadTool é simples. O snippet de código a seguir demonstra como configurá-lo e usar a ferramenta para listar o conteúdo de um diretório especificado:

```python Code theme={null}
from crewai_tools import DirectoryReadTool

**Examples:**

Example 1 (unknown):
```unknown
Esse comando instala a versão mais recente do pacote `crewai_tools`, permitindo o acesso ao DirectoryReadTool, entre outras utilidades.

## Exemplo

Empregar o DirectoryReadTool é simples. O snippet de código a seguir demonstra como configurá-lo e usar a ferramenta para listar o conteúdo de um diretório especificado:
```

---

## Crie sua tarefa com a proteção

**URL:** llms-txt#crie-sua-tarefa-com-a-proteção

**Contents:**
- Configuração Avançada
  - Validação com Limiar Personalizado

minha_tarefa = Task(
    description="Escreva um resumo sobre as capacidades da IA",
    expected_output="Um resumo factual baseado no contexto fornecido",
    agent=meu_agente,
    guardrail=protecao  # Adiciona a proteção para validar a saída
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Configuração Avançada

### Validação com Limiar Personalizado

Para validação mais rigorosa, é possível definir um limiar de fidelidade personalizado (escala de 0-10):
```

---

## Shopify 연동

**URL:** llms-txt#shopify-연동

**Contents:**
- 개요
- 사전 요구 사항
- Shopify 통합 설정
  - 1. Shopify 스토어 연결
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 도구
  - **고객 관리**
  - **주문 관리**
  - **제품 관리 (REST API)**

Source: https://docs.crewai.com/ko/enterprise/integrations/shopify

CrewAI를 위한 Shopify 연동을 통한 전자상거래 및 온라인 스토어 관리.

에이전트가 Shopify를 통해 전자상거래 운영을 관리할 수 있게 하세요. 고객, 주문, 제품, 재고 및 스토어 분석을 처리하여 AI 기반 자동화를 통해 온라인 비즈니스를 간소화할 수 있습니다.

Shopify 연동을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 관리자 권한이 있는 Shopify 스토어
* [통합 페이지](https://app.crewai.com/integrations)를 통해 Shopify 스토어 연결

### 1. Shopify 스토어 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동합니다.
2. 인증 통합 섹션에서 **Shopify**를 찾습니다.
3. **연결**을 클릭하고 OAuth 과정을 완료합니다.
4. 스토어 및 제품 관리에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="shopify/get_customers">
    **설명:** Shopify 스토어에서 고객 목록을 조회합니다.

* `customerIds` (string, 선택): 필터링할 고객 ID의 쉼표로 구분된 목록 (예: "207119551, 207119552")
    * `createdAtMin` (string, 선택): 이 날짜 이후에 생성된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `createdAtMax` (string, 선택): 이 날짜 이전에 생성된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMin` (string, 선택): 이 날짜 이후에 업데이트된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMax` (string, 선택): 이 날짜 이전에 업데이트된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `limit` (string, 선택): 반환할 최대 고객 수 (기본값 250)
  </Accordion>

<Accordion title="shopify/search_customers">
    **설명:** 고급 필터링 기준을 사용하여 고객을 검색합니다.

* `filterFormula` (object, 선택): 필드별 연산자가 포함된 불리언 합정규형의 고급 필터
    * `limit` (string, 선택): 반환할 최대 고객 수 (기본값 250)
  </Accordion>

<Accordion title="shopify/create_customer">
    **설명:** Shopify 스토어에 새로운 고객을 생성합니다.

* `firstName` (string, 필수): 고객의 이름
    * `lastName` (string, 필수): 고객의 성
    * `email` (string, 필수): 고객의 이메일 주소
    * `company` (string, 선택): 회사명
    * `streetAddressLine1` (string, 선택): 거리 주소
    * `streetAddressLine2` (string, 선택): 거리 주소 2
    * `city` (string, 선택): 도시
    * `state` (string, 선택): 주 또는 도 코드
    * `country` (string, 선택): 국가
    * `zipCode` (string, 선택): 우편번호
    * `phone` (string, 선택): 전화번호
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 태그 목록
    * `note` (string, 선택): 고객 메모
    * `sendEmailInvite` (boolean, 선택): 이메일 초대장 전송 여부
    * `metafields` (object, 선택): 추가 메타필드(JSON 형식)
  </Accordion>

<Accordion title="shopify/update_customer">
    **설명:** Shopify 스토어에 기존 고객을 업데이트합니다.

* `customerId` (string, 필수): 업데이트할 고객의 ID
    * `firstName` (string, 선택): 고객의 이름
    * `lastName` (string, 선택): 고객의 성
    * `email` (string, 선택): 고객의 이메일 주소
    * `company` (string, 선택): 회사명
    * `streetAddressLine1` (string, 선택): 거리 주소
    * `streetAddressLine2` (string, 선택): 거리 주소 2
    * `city` (string, 선택): 도시
    * `state` (string, 선택): 주 또는 도 코드
    * `country` (string, 선택): 국가
    * `zipCode` (string, 선택): 우편번호
    * `phone` (string, 선택): 전화번호
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 태그 목록
    * `note` (string, 선택): 고객 메모
    * `sendEmailInvite` (boolean, 선택): 이메일 초대장 전송 여부
    * `metafields` (object, 선택): 추가 메타필드(JSON 형식)
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="shopify/get_orders">
    **설명:** Shopify 스토어에서 주문 목록을 조회합니다.

* `orderIds` (string, optional): 필터링할 주문 ID의 콤마로 구분된 목록 (예: "450789469, 450789470")
    * `createdAtMin` (string, optional): 이 날짜 이후에 생성된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `createdAtMax` (string, optional): 이 날짜 이전에 생성된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMin` (string, optional): 이 날짜 이후에 업데이트된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMax` (string, optional): 이 날짜 이전에 업데이트된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `limit` (string, optional): 반환할 주문의 최대 개수 (기본값: 250)
  </Accordion>

<Accordion title="shopify/create_order">
    **설명:** Shopify 스토어에 새 주문을 생성합니다.

* `email` (string, required): 고객 이메일 주소
    * `lineItems` (object, required): title, price, quantity, variant\_id가 포함된 JSON 형식의 주문 아이템
    * `sendReceipt` (boolean, optional): 주문 영수증을 발송할지 여부
    * `fulfillmentStatus` (string, optional): 주문 이행 상태 - 옵션: fulfilled, null, partial, restocked
    * `financialStatus` (string, optional): 결제 상태 - 옵션: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, optional): 인벤토리 동작 - 옵션: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, optional): 주문 메모
  </Accordion>

<Accordion title="shopify/update_order">
    **설명:** Shopify 스토어에서 기존 주문을 업데이트합니다.

* `orderId` (string, required): 업데이트할 주문의 ID
    * `email` (string, optional): 고객 이메일 주소
    * `lineItems` (object, optional): JSON 형식의 업데이트된 주문 아이템
    * `sendReceipt` (boolean, optional): 주문 영수증을 발송할지 여부
    * `fulfillmentStatus` (string, optional): 주문 이행 상태 - 옵션: fulfilled, null, partial, restocked
    * `financialStatus` (string, optional): 결제 상태 - 옵션: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, optional): 인벤토리 동작 - 옵션: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, optional): 주문 메모
  </Accordion>

<Accordion title="shopify/get_abandoned_carts">
    **설명:** Shopify 스토어에서 방치된 장바구니를 조회합니다.

* `createdWithInLast` (string, optional): 지정된 기간 내에 생성된 체크아웃 결과만 제한
    * `createdAfterId` (string, optional): 지정된 ID 이후 결과로 제한
    * `status` (string, optional): 주어진 상태의 체크아웃만 표시 - 옵션: open, closed (기본값: open)
    * `createdAtMin` (string, optional): 이 날짜 이후에 생성된 장바구니만 반환 (ISO 또는 Unix 타임스탬프)
    * `createdAtMax` (string, optional): 이 날짜 이전에 생성된 장바구니만 반환 (ISO 또는 Unix 타임스탬프)
    * `limit` (string, optional): 반환할 장바구니의 최대 개수 (기본값: 250)
  </Accordion>
</AccordionGroup>

### **제품 관리 (REST API)**

<AccordionGroup>
  <Accordion title="shopify/get_products">
    **설명:** REST API를 사용하여 Shopify 스토어에서 제품 목록을 조회합니다.

* `productIds` (string, optional): 필터링할 제품 ID의 콤마(,)로 구분된 목록 (예: "632910392, 632910393")
    * `title` (string, optional): 제품 제목으로 필터링
    * `productType` (string, optional): 제품 유형으로 필터링
    * `vendor` (string, optional): 공급업체로 필터링
    * `status` (string, optional): 상태별 필터링 - 옵션: active, archived, draft
    * `createdAtMin` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이후에 생성된 제품만 반환
    * `createdAtMax` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이전에 생성된 제품만 반환
    * `updatedAtMin` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이후에 수정된 제품만 반환
    * `updatedAtMax` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이전에 수정된 제품만 반환
    * `limit` (string, optional): 반환할 최대 제품 수 (기본값: 250)
  </Accordion>

<Accordion title="shopify/create_product">
    **설명:** REST API를 사용하여 Shopify 스토어에 새로운 제품을 생성합니다.

* `title` (string, required): 제품 제목
    * `productType` (string, required): 제품 유형/카테고리
    * `vendor` (string, required): 제품 공급업체
    * `productDescription` (string, optional): 제품 설명 (일반 텍스트 또는 HTML 가능)
    * `tags` (string, optional): 배열 또는 콤마(,)로 구분된 태그 목록
    * `price` (string, optional): 제품 가격
    * `inventoryPolicy` (string, optional): 재고 정책 - 옵션: deny, continue
    * `imageUrl` (string, optional): 제품 이미지 URL
    * `isPublished` (boolean, optional): 제품 공개 여부
    * `publishToPointToSale` (boolean, optional): 포인트 오브 세일(Point of Sale)에 공개 여부
  </Accordion>

<Accordion title="shopify/update_product">
    **설명:** REST API를 사용하여 Shopify 스토어의 기존 제품을 업데이트합니다.

* `productId` (string, required): 업데이트할 제품 ID
    * `title` (string, optional): 제품 제목
    * `productType` (string, optional): 제품 유형/카테고리
    * `vendor` (string, optional): 제품 공급업체
    * `productDescription` (string, optional): 제품 설명 (일반 텍스트 또는 HTML 가능)
    * `tags` (string, optional): 배열 또는 콤마(,)로 구분된 태그 목록
    * `price` (string, optional): 제품 가격
    * `inventoryPolicy` (string, optional): 재고 정책 - 옵션: deny, continue
    * `imageUrl` (string, optional): 제품 이미지 URL
    * `isPublished` (boolean, optional): 제품 공개 여부
    * `publishToPointToSale` (boolean, optional): 포인트 오브 세일(Point of Sale)에 공개 여부
  </Accordion>
</AccordionGroup>

### **제품 관리 (GraphQL)**

<AccordionGroup>
  <Accordion title="shopify/get_products_graphql">
    **설명:** 고급 GraphQL 필터링 기능을 사용하여 제품을 조회합니다.

* `productFilterFormula` (object, 선택): id, title, vendor, status, handle, tag, created\_at, updated\_at, published\_at와 같은 필드를 지원하는 불리언 정규합형(DNF) 기반의 고급 필터
  </Accordion>

<Accordion title="shopify/create_product_graphql">
    **설명:** 미디어 지원이 강화된 GraphQL API를 사용하여 새 제품을 생성합니다.

* `title` (string, 필수): 제품 제목
    * `productType` (string, 필수): 제품 유형/카테고리
    * `vendor` (string, 필수): 제품 공급업체
    * `productDescription` (string, 선택): 제품 설명 (일반 텍스트 또는 HTML 허용)
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 리스트 형태의 제품 태그
    * `media` (object, 선택): 대체 텍스트, 콘텐츠 유형 및 소스 URL을 가진 미디어 객체
    * `additionalFields` (object, 선택): status, requiresSellingPlan, giftCard와 같은 추가 제품 필드
  </Accordion>

<Accordion title="shopify/update_product_graphql">
    **설명:** 미디어 지원이 강화된 GraphQL API를 사용하여 기존 제품을 업데이트합니다.

* `productId` (string, 필수): 업데이트할 제품의 GraphQL ID (예: "gid://shopify/Product/913144112")
    * `title` (string, 선택): 제품 제목
    * `productType` (string, 선택): 제품 유형/카테고리
    * `vendor` (string, 선택): 제품 공급업체
    * `productDescription` (string, 선택): 제품 설명 (일반 텍스트 또는 HTML 허용)
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 리스트 형태의 제품 태그
    * `media` (object, 선택): 대체 텍스트, 콘텐츠 유형 및 소스 URL을 포함한 업데이트된 미디어 객체
    * `additionalFields` (object, 선택): status, requiresSellingPlan, giftCard와 같은 추가 제품 필드
  </Accordion>
</AccordionGroup>

### 기본 Shopify 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 도구

### **고객 관리**

<AccordionGroup>
  <Accordion title="shopify/get_customers">
    **설명:** Shopify 스토어에서 고객 목록을 조회합니다.

    **파라미터:**

    * `customerIds` (string, 선택): 필터링할 고객 ID의 쉼표로 구분된 목록 (예: "207119551, 207119552")
    * `createdAtMin` (string, 선택): 이 날짜 이후에 생성된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `createdAtMax` (string, 선택): 이 날짜 이전에 생성된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMin` (string, 선택): 이 날짜 이후에 업데이트된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMax` (string, 선택): 이 날짜 이전에 업데이트된 고객만 반환 (ISO 또는 Unix 타임스탬프)
    * `limit` (string, 선택): 반환할 최대 고객 수 (기본값 250)
  </Accordion>

  <Accordion title="shopify/search_customers">
    **설명:** 고급 필터링 기준을 사용하여 고객을 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 필드별 연산자가 포함된 불리언 합정규형의 고급 필터
    * `limit` (string, 선택): 반환할 최대 고객 수 (기본값 250)
  </Accordion>

  <Accordion title="shopify/create_customer">
    **설명:** Shopify 스토어에 새로운 고객을 생성합니다.

    **파라미터:**

    * `firstName` (string, 필수): 고객의 이름
    * `lastName` (string, 필수): 고객의 성
    * `email` (string, 필수): 고객의 이메일 주소
    * `company` (string, 선택): 회사명
    * `streetAddressLine1` (string, 선택): 거리 주소
    * `streetAddressLine2` (string, 선택): 거리 주소 2
    * `city` (string, 선택): 도시
    * `state` (string, 선택): 주 또는 도 코드
    * `country` (string, 선택): 국가
    * `zipCode` (string, 선택): 우편번호
    * `phone` (string, 선택): 전화번호
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 태그 목록
    * `note` (string, 선택): 고객 메모
    * `sendEmailInvite` (boolean, 선택): 이메일 초대장 전송 여부
    * `metafields` (object, 선택): 추가 메타필드(JSON 형식)
  </Accordion>

  <Accordion title="shopify/update_customer">
    **설명:** Shopify 스토어에 기존 고객을 업데이트합니다.

    **파라미터:**

    * `customerId` (string, 필수): 업데이트할 고객의 ID
    * `firstName` (string, 선택): 고객의 이름
    * `lastName` (string, 선택): 고객의 성
    * `email` (string, 선택): 고객의 이메일 주소
    * `company` (string, 선택): 회사명
    * `streetAddressLine1` (string, 선택): 거리 주소
    * `streetAddressLine2` (string, 선택): 거리 주소 2
    * `city` (string, 선택): 도시
    * `state` (string, 선택): 주 또는 도 코드
    * `country` (string, 선택): 국가
    * `zipCode` (string, 선택): 우편번호
    * `phone` (string, 선택): 전화번호
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 태그 목록
    * `note` (string, 선택): 고객 메모
    * `sendEmailInvite` (boolean, 선택): 이메일 초대장 전송 여부
    * `metafields` (object, 선택): 추가 메타필드(JSON 형식)
  </Accordion>
</AccordionGroup>

### **주문 관리**

<AccordionGroup>
  <Accordion title="shopify/get_orders">
    **설명:** Shopify 스토어에서 주문 목록을 조회합니다.

    **파라미터:**

    * `orderIds` (string, optional): 필터링할 주문 ID의 콤마로 구분된 목록 (예: "450789469, 450789470")
    * `createdAtMin` (string, optional): 이 날짜 이후에 생성된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `createdAtMax` (string, optional): 이 날짜 이전에 생성된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMin` (string, optional): 이 날짜 이후에 업데이트된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `updatedAtMax` (string, optional): 이 날짜 이전에 업데이트된 주문만 반환 (ISO 또는 Unix 타임스탬프)
    * `limit` (string, optional): 반환할 주문의 최대 개수 (기본값: 250)
  </Accordion>

  <Accordion title="shopify/create_order">
    **설명:** Shopify 스토어에 새 주문을 생성합니다.

    **파라미터:**

    * `email` (string, required): 고객 이메일 주소
    * `lineItems` (object, required): title, price, quantity, variant\_id가 포함된 JSON 형식의 주문 아이템
    * `sendReceipt` (boolean, optional): 주문 영수증을 발송할지 여부
    * `fulfillmentStatus` (string, optional): 주문 이행 상태 - 옵션: fulfilled, null, partial, restocked
    * `financialStatus` (string, optional): 결제 상태 - 옵션: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, optional): 인벤토리 동작 - 옵션: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, optional): 주문 메모
  </Accordion>

  <Accordion title="shopify/update_order">
    **설명:** Shopify 스토어에서 기존 주문을 업데이트합니다.

    **파라미터:**

    * `orderId` (string, required): 업데이트할 주문의 ID
    * `email` (string, optional): 고객 이메일 주소
    * `lineItems` (object, optional): JSON 형식의 업데이트된 주문 아이템
    * `sendReceipt` (boolean, optional): 주문 영수증을 발송할지 여부
    * `fulfillmentStatus` (string, optional): 주문 이행 상태 - 옵션: fulfilled, null, partial, restocked
    * `financialStatus` (string, optional): 결제 상태 - 옵션: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, optional): 인벤토리 동작 - 옵션: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, optional): 주문 메모
  </Accordion>

  <Accordion title="shopify/get_abandoned_carts">
    **설명:** Shopify 스토어에서 방치된 장바구니를 조회합니다.

    **파라미터:**

    * `createdWithInLast` (string, optional): 지정된 기간 내에 생성된 체크아웃 결과만 제한
    * `createdAfterId` (string, optional): 지정된 ID 이후 결과로 제한
    * `status` (string, optional): 주어진 상태의 체크아웃만 표시 - 옵션: open, closed (기본값: open)
    * `createdAtMin` (string, optional): 이 날짜 이후에 생성된 장바구니만 반환 (ISO 또는 Unix 타임스탬프)
    * `createdAtMax` (string, optional): 이 날짜 이전에 생성된 장바구니만 반환 (ISO 또는 Unix 타임스탬프)
    * `limit` (string, optional): 반환할 장바구니의 최대 개수 (기본값: 250)
  </Accordion>
</AccordionGroup>

### **제품 관리 (REST API)**

<AccordionGroup>
  <Accordion title="shopify/get_products">
    **설명:** REST API를 사용하여 Shopify 스토어에서 제품 목록을 조회합니다.

    **파라미터:**

    * `productIds` (string, optional): 필터링할 제품 ID의 콤마(,)로 구분된 목록 (예: "632910392, 632910393")
    * `title` (string, optional): 제품 제목으로 필터링
    * `productType` (string, optional): 제품 유형으로 필터링
    * `vendor` (string, optional): 공급업체로 필터링
    * `status` (string, optional): 상태별 필터링 - 옵션: active, archived, draft
    * `createdAtMin` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이후에 생성된 제품만 반환
    * `createdAtMax` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이전에 생성된 제품만 반환
    * `updatedAtMin` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이후에 수정된 제품만 반환
    * `updatedAtMax` (string, optional): 해당 날짜(ISO 혹은 Unix 타임스탬프) 이전에 수정된 제품만 반환
    * `limit` (string, optional): 반환할 최대 제품 수 (기본값: 250)
  </Accordion>

  <Accordion title="shopify/create_product">
    **설명:** REST API를 사용하여 Shopify 스토어에 새로운 제품을 생성합니다.

    **파라미터:**

    * `title` (string, required): 제품 제목
    * `productType` (string, required): 제품 유형/카테고리
    * `vendor` (string, required): 제품 공급업체
    * `productDescription` (string, optional): 제품 설명 (일반 텍스트 또는 HTML 가능)
    * `tags` (string, optional): 배열 또는 콤마(,)로 구분된 태그 목록
    * `price` (string, optional): 제품 가격
    * `inventoryPolicy` (string, optional): 재고 정책 - 옵션: deny, continue
    * `imageUrl` (string, optional): 제품 이미지 URL
    * `isPublished` (boolean, optional): 제품 공개 여부
    * `publishToPointToSale` (boolean, optional): 포인트 오브 세일(Point of Sale)에 공개 여부
  </Accordion>

  <Accordion title="shopify/update_product">
    **설명:** REST API를 사용하여 Shopify 스토어의 기존 제품을 업데이트합니다.

    **파라미터:**

    * `productId` (string, required): 업데이트할 제품 ID
    * `title` (string, optional): 제품 제목
    * `productType` (string, optional): 제품 유형/카테고리
    * `vendor` (string, optional): 제품 공급업체
    * `productDescription` (string, optional): 제품 설명 (일반 텍스트 또는 HTML 가능)
    * `tags` (string, optional): 배열 또는 콤마(,)로 구분된 태그 목록
    * `price` (string, optional): 제품 가격
    * `inventoryPolicy` (string, optional): 재고 정책 - 옵션: deny, continue
    * `imageUrl` (string, optional): 제품 이미지 URL
    * `isPublished` (boolean, optional): 제품 공개 여부
    * `publishToPointToSale` (boolean, optional): 포인트 오브 세일(Point of Sale)에 공개 여부
  </Accordion>
</AccordionGroup>

### **제품 관리 (GraphQL)**

<AccordionGroup>
  <Accordion title="shopify/get_products_graphql">
    **설명:** 고급 GraphQL 필터링 기능을 사용하여 제품을 조회합니다.

    **파라미터:**

    * `productFilterFormula` (object, 선택): id, title, vendor, status, handle, tag, created\_at, updated\_at, published\_at와 같은 필드를 지원하는 불리언 정규합형(DNF) 기반의 고급 필터
  </Accordion>

  <Accordion title="shopify/create_product_graphql">
    **설명:** 미디어 지원이 강화된 GraphQL API를 사용하여 새 제품을 생성합니다.

    **파라미터:**

    * `title` (string, 필수): 제품 제목
    * `productType` (string, 필수): 제품 유형/카테고리
    * `vendor` (string, 필수): 제품 공급업체
    * `productDescription` (string, 선택): 제품 설명 (일반 텍스트 또는 HTML 허용)
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 리스트 형태의 제품 태그
    * `media` (object, 선택): 대체 텍스트, 콘텐츠 유형 및 소스 URL을 가진 미디어 객체
    * `additionalFields` (object, 선택): status, requiresSellingPlan, giftCard와 같은 추가 제품 필드
  </Accordion>

  <Accordion title="shopify/update_product_graphql">
    **설명:** 미디어 지원이 강화된 GraphQL API를 사용하여 기존 제품을 업데이트합니다.

    **파라미터:**

    * `productId` (string, 필수): 업데이트할 제품의 GraphQL ID (예: "gid://shopify/Product/913144112")
    * `title` (string, 선택): 제품 제목
    * `productType` (string, 선택): 제품 유형/카테고리
    * `vendor` (string, 선택): 제품 공급업체
    * `productDescription` (string, 선택): 제품 설명 (일반 텍스트 또는 HTML 허용)
    * `tags` (string, 선택): 배열 또는 쉼표로 구분된 리스트 형태의 제품 태그
    * `media` (object, 선택): 대체 텍스트, 콘텐츠 유형 및 소스 URL을 포함한 업데이트된 미디어 객체
    * `additionalFields` (object, 선택): status, requiresSellingPlan, giftCard와 같은 추가 제품 필드
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 Shopify 에이전트 설정
```

---

## Crie um agente focado em pesquisar contatos

**URL:** llms-txt#crie-um-agente-focado-em-pesquisar-contatos

search_agent = Agent(
    role="Pesquisador de Contatos",
    goal="Encontrar e recuperar informações de contato",
    backstory="Um assistente IA habilidoso em pesquisar e listar contatos.",
    apps=['google_contacts/search_contacts', 'google_contacts/get_contacts']
)

---

## Example usage (uncomment and adapt once server_params is set):

**URL:** llms-txt#example-usage-(uncomment-and-adapt-once-server_params-is-set):

**Contents:**
- Filtering Tools
  - Accessing a specific tool using dictionary-style indexing.
  - Pass a list of tool names to the `MCPServerAdapter` constructor.
- Using with CrewBase
  - Connection Timeout Configuration
  - Filtering Tools
- Explore MCP Integrations
- Staying Safe with MCP
  - Limitations

with MCPServerAdapter(server_params, connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

my_agent = Agent(
        role="MCP Tool User",
        goal="Utilize tools from an MCP server.",
        backstory="I can connect to MCP servers and use their tools.",
        tools=mcp_tools, # Pass the loaded tools to your agent
        reasoning=True,
        verbose=True
    )
    # ... rest of your crew setup ...
python  theme={null}
with MCPServerAdapter(server_params, connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

my_agent = Agent(
        role="MCP Tool User",
        goal="Utilize tools from an MCP server.",
        backstory="I can connect to MCP servers and use their tools.",
        tools=[mcp_tools["tool_name"]], # Pass the loaded tools to your agent
        reasoning=True,
        verbose=True
    )
    # ... rest of your crew setup ...
python  theme={null}
with MCPServerAdapter(server_params, "tool_name", connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

my_agent = Agent(
        role="MCP Tool User",
        goal="Utilize tools from an MCP server.",
        backstory="I can connect to MCP servers and use their tools.",
        tools=mcp_tools, # Pass the loaded tools to your agent
        reasoning=True,
        verbose=True
    )
    # ... rest of your crew setup ...
python  theme={null}
@CrewBase
class CrewWithMCP:
  # ... define your agents and tasks config file ...

mcp_server_params = [
    # Streamable HTTP Server
    {
        "url": "http://localhost:8001/mcp",
        "transport": "streamable-http"
    },
    # SSE Server
    {
        "url": "http://localhost:8000/sse",
        "transport": "sse"
    },
    # StdIO Server
    StdioServerParameters(
        command="python3",
        args=["servers/your_stdio_server.py"],
        env={"UV_PYTHON": "3.12", **os.environ},
    )
  ]

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools()) # get all available tools

# ... rest of your crew setup ...
python  theme={null}
@CrewBase
class CrewWithMCP:
  mcp_server_params = [...]
  mcp_connect_timeout = 60  # 60 seconds timeout for all MCP connections

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools())
python  theme={null}
@CrewBase
class CrewWithDefaultTimeout:
  mcp_server_params = [...]
  # No mcp_connect_timeout specified - uses default 30 seconds

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools())
python  theme={null}
@agent
def another_agent(self):
    return Agent(
      config=self.agents_config["your_agent"],
      tools=self.get_mcp_tools("tool_1", "tool_2") # get specific tools
    )
python  theme={null}
@CrewBase
class CrewWithCustomTimeout:
  mcp_server_params = [...]
  mcp_connect_timeout = 90  # 90 seconds timeout for all MCP connections

@agent
  def filtered_agent(self):
      return Agent(
        config=self.agents_config["your_agent"],
        tools=self.get_mcp_tools("tool_1", "tool_2") # specific tools with custom timeout
      )
```

## Explore MCP Integrations

<CardGroup cols={2}>
  <Card title="Simple DSL Integration" icon="code" href="/en/mcp/dsl-integration" color="#3B82F6">
    **Recommended**: Use the simple `mcps=[]` field syntax for effortless MCP integration.
  </Card>

<Card title="Stdio Transport" icon="server" href="/en/mcp/stdio" color="#10B981">
    Connect to local MCP servers via standard input/output. Ideal for scripts and local executables.
  </Card>

<Card title="SSE Transport" icon="wifi" href="/en/mcp/sse" color="#F59E0B">
    Integrate with remote MCP servers using Server-Sent Events for real-time data streaming.
  </Card>

<Card title="Streamable HTTP Transport" icon="globe" href="/en/mcp/streamable-http" color="#8B5CF6">
    Utilize flexible Streamable HTTP for robust communication with remote MCP servers.
  </Card>

<Card title="Connecting to Multiple Servers" icon="layer-group" href="/en/mcp/multiple-servers" color="#EF4444">
    Aggregate tools from several MCP servers simultaneously using a single adapter.
  </Card>

<Card title="Security Considerations" icon="lock" href="/en/mcp/security" color="#DC2626">
    Review important security best practices for MCP integration to keep your agents safe.
  </Card>
</CardGroup>

Checkout this repository for full demos and examples of MCP integration with CrewAI! 👇

<Card title="GitHub Repository" icon="github" href="https://github.com/tonykipkemboi/crewai-mcp-demo" target="_blank">
  CrewAI MCP Demo
</Card>

## Staying Safe with MCP

<Warning>
  Always ensure that you trust an MCP Server before using it.
</Warning>

#### Security Warning: DNS Rebinding Attacks

SSE transports can be vulnerable to DNS rebinding attacks if not properly secured.
To prevent this:

1. **Always validate Origin headers** on incoming SSE connections to ensure they come from expected sources
2. **Avoid binding servers to all network interfaces** (0.0.0.0) when running locally - bind only to localhost (127.0.0.1) instead
3. **Implement proper authentication** for all SSE connections

Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.

For more details, see the [Anthropic's MCP Transport Security docs](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations).

* **Supported Primitives**: Currently, `MCPServerAdapter` primarily supports adapting MCP `tools`.
  Other MCP primitives like `prompts` or `resources` are not directly integrated as CrewAI components through this adapter at this time.
* **Output Handling**: The adapter typically processes the primary text output from an MCP tool (e.g., `.content[0].text`). Complex or multi-modal outputs might require custom handling if not fitting this pattern.

**Examples:**

Example 1 (unknown):
```unknown
This general pattern shows how to integrate tools. For specific examples tailored to each transport, refer to the detailed guides below.

## Filtering Tools

There are two ways to filter tools:

1. Accessing a specific tool using dictionary-style indexing.
2. Pass a list of tool names to the `MCPServerAdapter` constructor.

### Accessing a specific tool using dictionary-style indexing.
```

Example 2 (unknown):
```unknown
### Pass a list of tool names to the `MCPServerAdapter` constructor.
```

Example 3 (unknown):
```unknown
## Using with CrewBase

To use MCPServer tools within a CrewBase class, use the `get_mcp_tools` method. Server configurations should be provided via the `mcp_server_params` attribute. You can pass either a single configuration or a list of multiple server configurations.
```

Example 4 (unknown):
```unknown
<Tip>
  When a crew class is decorated with `@CrewBase`, the adapter lifecycle is managed for you:

  * The first call to `get_mcp_tools()` lazily creates a shared `MCPServerAdapter` that is reused by every agent in the crew.
  * The adapter automatically shuts down after `.kickoff()` completes thanks to an implicit after-kickoff hook injected by `@CrewBase`, so no manual cleanup is required.
  * If `mcp_server_params` is not defined, `get_mcp_tools()` simply returns an empty list, allowing the same code paths to run with or without MCP configured.

  This makes it safe to call `get_mcp_tools()` from multiple agent methods or selectively enable MCP per environment.
</Tip>

### Connection Timeout Configuration

You can configure the connection timeout for MCP servers by setting the `mcp_connect_timeout` class attribute. If no timeout is specified, it defaults to 30 seconds.
```

---

## QdrantConfig로 도구 초기화

**URL:** llms-txt#qdrantconfig로-도구-초기화

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_qdrant_url",
        qdrant_api_key="your_qdrant_api_key",
        collection_name="your_collection"
    )
)

---

## MLflow Overview

**URL:** llms-txt#mlflow-overview

**Contents:**
  - Features
- Setup Instructions

[MLflow](https://mlflow.org/) is an open-source platform to assist machine learning practitioners and teams in handling the complexities of the machine learning process.

It provides a tracing feature that enhances LLM observability in your Generative AI applications by capturing detailed information about the execution of your application’s services.
Tracing provides a way to record the inputs, outputs, and metadata associated with each intermediate step of a request, enabling you to easily pinpoint the source of bugs and unexpected behaviors.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow-tracing.gif?s=be88ff36aec776c005102164d804322a" alt="Overview of MLflow crewAI tracing usage" data-og-width="1144" width="1144" data-og-height="720" height="720" data-path="images/mlflow-tracing.gif" data-optimize="true" data-opv="3" />

* **Tracing Dashboard**: Monitor activities of your crewAI agents with detailed dashboards that include inputs, outputs and metadata of spans.
* **Automated Tracing**: A fully automated integration with crewAI, which can be enabled by running `mlflow.crewai.autolog()`.
* **Manual Trace Instrumentation with minor efforts**: Customize trace instrumentation through MLflow's high-level fluent APIs such as decorators, function wrappers and context managers.
* **OpenTelemetry Compatibility**: MLflow Tracing supports exporting traces to an OpenTelemetry Collector, which can then be used to export traces to various backends such as Jaeger, Zipkin, and AWS X-Ray.
* **Package and Deploy Agents**: Package and deploy your crewAI agents to an inference server with a variety of deployment targets.
* **Securely Host LLMs**: Host multiple LLM from various providers in one unified endpoint through MFflow gateway.
* **Evaluation**: Evaluate your crewAI agents with a wide range of metrics using a convenient API `mlflow.evaluate()`.

## Setup Instructions

<Steps>
  <Step title="Install MLflow package">
    
  </Step>

<Step title="Start MFflow tracking server">
    
  </Step>

<Step title="Initialize MLflow in Your Application">
    Add the following two lines to your application code:

Example Usage for tracing CrewAI Agents:

Refer to [MLflow Tracing Documentation](https://mlflow.org/docs/latest/llms/tracing/index.html) for more configurations and use cases.
  </Step>

<Step title="Visualize Activities of Agents">
    Now traces for your crewAI agents are captured by MLflow.
    Let's visit MLflow tracking server to view the traces and get insights into your Agents.

Open `127.0.0.1:5000` on your browser to visit MLflow tracking server.

<Frame caption="MLflow Tracing Dashboard">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=0685aeb79319ad21ff842053ce5303c9" alt="MLflow tracing example with crewai" data-og-width="3024" width="3024" data-og-height="1712" height="1712" data-path="images/mlflow1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f45f73922d8ea58f0e72c16c0e22d977 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5025f431d9c88bb7a094ab032aeaa753 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=385879dd49ee957a4c25c5f94a9766e1 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c779a19494038367ecb7f1caefe1014c 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ff45740a0aaab934952c2928edbdcbc6 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=af14478b932df5a9f9261514f38d5e14 2500w" />
    </Frame>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Start MFflow tracking server">
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Initialize MLflow in Your Application">
    Add the following two lines to your application code:
```

Example 3 (unknown):
```unknown
Example Usage for tracing CrewAI Agents:
```

---

## Create a task for the agent

**URL:** llms-txt#create-a-task-for-the-agent

scrape_task = Task(
    description="Extract the main content from example.com in markdown format.",
    expected_output="The main content of example.com in markdown format.",
    agent=web_scraper_agent,
)

---

## Integração com o Notion

**URL:** llms-txt#integração-com-o-notion

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o Notion
  - 1. Conecte sua Conta Notion
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Notion

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/notion

Gerenciamento de páginas e bancos de dados com integração do Notion para o CrewAI.

Permita que seus agentes gerenciem páginas, bancos de dados e conteúdos através do Notion. Crie e atualize páginas, gerencie blocos de conteúdo, organize bases de conhecimento e otimize seus fluxos de documentação com automação alimentada por IA.

Antes de usar a integração com o Notion, certifique-se de que você tem:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Notion com permissões adequadas no workspace
* Sua conta Notion conectada através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com o Notion

### 1. Conecte sua Conta Notion

1. Acesse [Integrações do CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Procure por **Notion** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo de OAuth
4. Conceda as permissões necessárias para gerenciamento de páginas e bancos de dados
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="notion/create_page">
    **Descrição:** Cria uma página no Notion.

* `parent` (object, obrigatório): Parent - A página ou banco de dados pai onde a nova página será inserida, representado como um objeto JSON com uma chave page\_id ou database\_id.
      
    * `properties` (object, obrigatório): Properties - Os valores das propriedades da página. Se o pai for um banco de dados, o schema deve corresponder às propriedades do banco de dados.
      
    * `icon` (object, obrigatório): Icon - O ícone da página.
      
    * `children` (object, opcional): Children - Blocos de conteúdo a serem adicionados à página.
      
    * `cover` (object, opcional): Cover - A imagem de capa da página.
      
  </Accordion>

<Accordion title="notion/update_page">
    **Descrição:** Atualiza uma página no Notion.

* `pageId` (string, obrigatório): Page ID - Especifique o ID da Página a ser atualizada. (exemplo: "59833787-2cf9-4fdf-8782-e53db20768a5").
    * `icon` (object, obrigatório): Icon - O ícone da página.
      
    * `archived` (boolean, opcional): Archived - Indica se a página está arquivada (excluída). Defina como true para arquivar a página. Defina como false para restaurar.
    * `properties` (object, opcional): Properties - Os valores das propriedades a serem atualizados na página.
      
    * `cover` (object, opcional): Cover - A imagem de capa da página.
      
  </Accordion>

<Accordion title="notion/get_page_by_id">
    **Descrição:** Busca uma página pelo ID no Notion.

* `pageId` (string, obrigatório): Page ID - Especifique o ID da Página a ser buscada. (exemplo: "59833787-2cf9-4fdf-8782-e53db20768a5").
  </Accordion>

<Accordion title="notion/archive_page">
    **Descrição:** Arquiva uma página no Notion.

* `pageId` (string, obrigatório): Page ID - Especifique o ID da Página a ser arquivada. (exemplo: "59833787-2cf9-4fdf-8782-e53db20768a5").
  </Accordion>

<Accordion title="notion/search_pages">
    **Descrição:** Pesquisa páginas no Notion utilizando filtros.

* `searchByTitleFilterSearch` (object, opcional): Um filtro na forma normal disjuntiva - OU de grupos E de condições simples.
      
      Campos disponíveis: `query`, `filter.value`, `direction`, `page_size`
  </Accordion>

<Accordion title="notion/get_page_content">
    **Descrição:** Obtém o conteúdo (blocos) de uma página no Notion.

* `blockId` (string, obrigatório): Page ID - Especifique o ID de um Bloco ou Página para receber todos os seus blocos filhos na ordem correta. (exemplo: "59833787-2cf9-4fdf-8782-e53db20768a5").
  </Accordion>

<Accordion title="notion/update_block">
    **Descrição:** Atualiza um bloco no Notion.

* `blockId` (string, obrigatório): Block ID - Especifique o ID do Bloco a ser atualizado. (exemplo: "9bc30ad4-9373-46a5-84ab-0a7845ee52e6").
    * `archived` (boolean, opcional): Archived - Defina como true para arquivar (excluir) um bloco. Defina como false para restaurar um bloco.
    * `paragraph` (object, opcional): Conteúdo do parágrafo.
      
    * `image` (object, opcional): Bloco de imagem.
      
    * `bookmark` (object, opcional): Bloco de bookmark.
      
    * `code` (object, opcional): Bloco de código.
      
    * `pdf` (object, opcional): Bloco de PDF.
      
    * `table` (object, opcional): Bloco de Tabela.
      
    * `tableOfContent` (object, opcional): Bloco de Sumário.
      
    * `additionalFields` (object, opcional): Blocos adicionais.
      
  </Accordion>

<Accordion title="notion/get_block_by_id">
    **Descrição:** Busca um bloco pelo ID no Notion.

* `blockId` (string, obrigatório): Block ID - Especifique o ID do Bloco a ser buscado. (exemplo: "9bc30ad4-9373-46a5-84ab-0a7845ee52e6").
  </Accordion>

<Accordion title="notion/delete_block">
    **Descrição:** Exclui um bloco no Notion.

* `blockId` (string, obrigatório): Block ID - Especifique o ID do Bloco a ser excluído. (exemplo: "9bc30ad4-9373-46a5-84ab-0a7845ee52e6").
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Notion

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="notion/create_page">
    **Descrição:** Cria uma página no Notion.

    **Parâmetros:**

    * `parent` (object, obrigatório): Parent - A página ou banco de dados pai onde a nova página será inserida, representado como um objeto JSON com uma chave page\_id ou database\_id.
```

Example 4 (unknown):
```unknown
* `properties` (object, obrigatório): Properties - Os valores das propriedades da página. Se o pai for um banco de dados, o schema deve corresponder às propriedades do banco de dados.
```

---

## Integração com Weave

**URL:** llms-txt#integração-com-weave

Source: https://docs.crewai.com/pt-BR/observability/weave

Saiba como usar o Weights & Biases (W&B) Weave para rastrear, experimentar, avaliar e melhorar suas aplicações CrewAI.

---

## Connect to any LLM

**URL:** llms-txt#connect-to-any-llm

**Contents:**
- Connect CrewAI to LLMs
- Supported Providers
- Changing the LLM
- Configuration Options
- Connecting to OpenAI-Compatible LLMs
- Using Local Models with Ollama
- Changing the Base API URL
- Conclusion

Source: https://docs.crewai.com/en/learn/llm-connections

Comprehensive guide on integrating CrewAI with various Large Language Models (LLMs) using LiteLLM, including supported providers and configuration options.

## Connect CrewAI to LLMs

CrewAI uses LiteLLM to connect to a wide variety of Language Models (LLMs). This integration provides extensive versatility, allowing you to use models from numerous providers with a simple, unified interface.

<Note>
  By default, CrewAI uses the `gpt-4o-mini` model. This is determined by the `OPENAI_MODEL_NAME` environment variable, which defaults to "gpt-4o-mini" if not set.
  You can easily configure your agents to use a different model or provider as described in this guide.
</Note>

## Supported Providers

LiteLLM supports a wide range of providers, including but not limited to:

* OpenAI
* Anthropic
* Google (Vertex AI, Gemini)
* Azure OpenAI
* AWS (Bedrock, SageMaker)
* Cohere
* VoyageAI
* Hugging Face
* Ollama
* Mistral AI
* Replicate
* Together AI
* AI21
* Cloudflare Workers AI
* DeepInfra
* Groq
* SambaNova
* Nebius AI Studio
* [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1)
* And many more!

For a complete and up-to-date list of supported providers, please refer to the [LiteLLM Providers documentation](https://docs.litellm.ai/docs/providers).

To use a different LLM with your CrewAI agents, you have several options:

<Tabs>
  <Tab title="Using a String Identifier">
    Pass the model name as a string when initializing the agent:

<CodeGroup>
      
    </CodeGroup>
  </Tab>

<Tab title="Using the LLM Class">
    For more detailed configuration, use the LLM class:

<CodeGroup>
      
    </CodeGroup>
  </Tab>
</Tabs>

## Configuration Options

When configuring an LLM for your agent, you have access to a wide range of parameters:

| Parameter              |        Type        | Description                                                      |
| :--------------------- | :----------------: | :--------------------------------------------------------------- |
| **model**              |        `str`       | The name of the model to use (e.g., "gpt-4", "claude-2")         |
| **temperature**        |       `float`      | Controls randomness in output (0.0 to 1.0)                       |
| **max\_tokens**        |        `int`       | Maximum number of tokens to generate                             |
| **top\_p**             |       `float`      | Controls diversity of output (0.0 to 1.0)                        |
| **frequency\_penalty** |       `float`      | Penalizes new tokens based on their frequency in the text so far |
| **presence\_penalty**  |       `float`      | Penalizes new tokens based on their presence in the text so far  |
| **stop**               | `str`, `List[str]` | Sequence(s) to stop generation                                   |
| **base\_url**          |        `str`       | The base URL for the API endpoint                                |
| **api\_key**           |        `str`       | Your API key for authentication                                  |

For a complete list of parameters and their descriptions, refer to the LLM class documentation.

## Connecting to OpenAI-Compatible LLMs

You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:

<Tabs>
  <Tab title="Using Environment Variables">
    <CodeGroup>

</CodeGroup>
  </Tab>

<Tab title="Using LLM Class Attributes">
    <CodeGroup>

</CodeGroup>
  </Tab>
</Tabs>

## Using Local Models with Ollama

For local models like those provided by Ollama:

<Steps>
  <Step title="Download and install Ollama">
    [Click here to download and install Ollama](https://ollama.com/download)
  </Step>

<Step title="Pull the desired model">
    For example, run `ollama pull llama3.2` to download the model.
  </Step>

<Step title="Configure your agent">
    <CodeGroup>
      
    </CodeGroup>
  </Step>
</Steps>

## Changing the Base API URL

You can change the base API URL for any LLM provider by setting the `base_url` parameter:

This is particularly useful when working with OpenAI-compatible APIs or when you need to specify a different endpoint for your chosen provider.

By leveraging LiteLLM, CrewAI offers seamless integration with a vast array of LLMs. This flexibility allows you to choose the most suitable model for your specific needs, whether you prioritize performance, cost-efficiency, or local deployment. Remember to consult the [LiteLLM documentation](https://docs.litellm.ai/docs/) for the most up-to-date information on supported models and configuration options.

**Examples:**

Example 1 (unknown):
```unknown
</CodeGroup>
  </Tab>

  <Tab title="Using the LLM Class">
    For more detailed configuration, use the LLM class:

    <CodeGroup>
```

Example 2 (unknown):
```unknown
</CodeGroup>
  </Tab>
</Tabs>

## Configuration Options

When configuring an LLM for your agent, you have access to a wide range of parameters:

| Parameter              |        Type        | Description                                                      |
| :--------------------- | :----------------: | :--------------------------------------------------------------- |
| **model**              |        `str`       | The name of the model to use (e.g., "gpt-4", "claude-2")         |
| **temperature**        |       `float`      | Controls randomness in output (0.0 to 1.0)                       |
| **max\_tokens**        |        `int`       | Maximum number of tokens to generate                             |
| **top\_p**             |       `float`      | Controls diversity of output (0.0 to 1.0)                        |
| **frequency\_penalty** |       `float`      | Penalizes new tokens based on their frequency in the text so far |
| **presence\_penalty**  |       `float`      | Penalizes new tokens based on their presence in the text so far  |
| **stop**               | `str`, `List[str]` | Sequence(s) to stop generation                                   |
| **base\_url**          |        `str`       | The base URL for the API endpoint                                |
| **api\_key**           |        `str`       | Your API key for authentication                                  |

For a complete list of parameters and their descriptions, refer to the LLM class documentation.

## Connecting to OpenAI-Compatible LLMs

You can connect to OpenAI-compatible LLMs using either environment variables or by setting specific attributes on the LLM class:

<Tabs>
  <Tab title="Using Environment Variables">
    <CodeGroup>
```

Example 3 (unknown):
```unknown

```

Example 4 (unknown):
```unknown
</CodeGroup>
  </Tab>

  <Tab title="Using LLM Class Attributes">
    <CodeGroup>
```

---

## Opção 2: Imprimindo o objeto Blog inteiro

**URL:** llms-txt#opção-2:-imprimindo-o-objeto-blog-inteiro

**Contents:**
- Integrando Ferramentas com Tarefas
- Criando uma Tarefa com Ferramentas

print("Acessando propriedades - Opção 2")
print("Blog:", result)
python Code theme={null}
import os
os.environ["OPENAI_API_KEY"] = "Sua Chave"
os.environ["SERPER_API_KEY"] = "Sua Chave" # Chave serper.dev

from crewai import Agent, Task, Crew
from crewai_tools import SerperDevTool

research_agent = Agent(
  role='Researcher',
  goal='Encontrar e resumir as últimas notícias de IA',
  backstory="""Você é um pesquisador em uma grande empresa.
  Sua responsabilidade é analisar dados e fornecer insights
  para o negócio.""",
  verbose=True
)

**Examples:**

Example 1 (unknown):
```unknown
Neste exemplo:

* Um modelo Pydantic Blog é definido com os campos title e content, usado para especificar a estrutura do JSON de saída.
* A tarefa task1 utiliza a propriedade output\_json para indicar que espera uma saída JSON que segue o modelo Blog.
* Após executar o crew, você pode acessar a saída estruturada em JSON conforme demonstrado.

#### Explicação sobre o acesso à saída

1. Acessando propriedades via indexação de dicionário: Você pode acessar os campos diretamente usando result\["nome\_do\_campo"]. Isso é possível pois a classe CrewOutput implementa o método **getitem**, permitindo tratar a saída como um dicionário. Nesse caso, estamos acessando title e content do resultado.
2. Imprimindo o objeto Blog inteiro: Ao imprimir result, você obterá a representação em string do objeto CrewOutput. Como o método **str** é implementado para retornar a saída em JSON, isso exibirá toda a saída como uma string formatada representando o objeto Blog.

***

Utilizando `output_pydantic` ou `output_json`, você garante que suas tarefas produzam saídas em um formato estruturado e consistente, facilitando o processamento e uso dos dados na sua aplicação ou entre múltiplas tarefas.

## Integrando Ferramentas com Tarefas

Utilize ferramentas do [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) e [LangChain Tools](https://python.langchain.com/docs/integrations/tools) para ampliar o desempenho das tarefas e aprimorar a interação dos agentes.

## Criando uma Tarefa com Ferramentas
```

---

## Agent-specific knowledge

**URL:** llms-txt#agent-specific-knowledge

specialist_knowledge = StringKnowledgeSource(
    content="Technical specifications only the specialist needs"
)

specialist = Agent(
    role="Especialista Técnico",
    goal="Fornecer expertise técnica",
    backstory="Especialista em domínios técnicos especializados",
    knowledge_sources=[specialist_knowledge]  # Conhecimento específico do agente
)

generalist = Agent(
    role="General Assistant",
    goal="Provide general assistance",
    backstory="General helper"
    # No agent-specific knowledge
)

crew = Crew(
    agents=[specialist, generalist],
    tasks=[...],
    knowledge_sources=[crew_knowledge]  # Crew-wide knowledge
)

---

## Create an agent by loading it from a repository

**URL:** llms-txt#create-an-agent-by-loading-it-from-a-repository

---

## Tarefa para criar hierarquia de issues

**URL:** llms-txt#tarefa-para-criar-hierarquia-de-issues

**Contents:**
  - Fluxo de Trabalho de Desenvolvimento Automatizado

hierarchy_task = Task(
    description="""
    1. Pesquise por issues de recursos grandes que precisam ser divididos
    2. Para cada issue complexa, crie sub-issues para diferentes componentes
    3. Atualize as issues principais com descrições adequadas e links para sub-issues
    4. Atribua sub-issues aos membros apropriados da equipe com base na especialidade
    """,
    agent=task_organizer,
    expected_output="Issues complexas divididas em sub-tarefas gerenciáveis com atribuições corretas"
)

crew = Crew(
    agents=[task_organizer],
    tasks=[hierarchy_task]
)

crew.kickoff()
python  theme={null}
from crewai import Agent, Task, Crew

workflow_automator = Agent(
    role="Workflow Automator",
    goal="Automatizar processos de fluxo de trabalho de desenvolvimento no Linear",
    backstory="Um assistente de IA que automatiza tarefas repetitivas de fluxo de trabalho de desenvolvimento.",
    apps=['linear']
)

**Examples:**

Example 1 (unknown):
```unknown
### Fluxo de Trabalho de Desenvolvimento Automatizado
```

---

## Force Tool Output as Result

**URL:** llms-txt#force-tool-output-as-result

**Contents:**
- Introduction
- Forcing Tool Output as Result

Source: https://docs.crewai.com/en/learn/force-tool-output-as-result

Learn how to force tool output as the result in an Agent's task in CrewAI.

In CrewAI, you can force the output of a tool as the result of an agent's task.
This feature is useful when you want to ensure that the tool output is captured and returned as the task result, avoiding any agent modification during the task execution.

## Forcing Tool Output as Result

To force the tool output as the result of an agent's task, you need to set the `result_as_answer` parameter to `True` when adding a tool to the agent.
This parameter ensures that the tool output is captured and returned as the task result, without any modifications by the agent.

Here's an example of how to force the tool output as the result of an agent's task:

```python Code theme={null}
from crewai.agent import Agent
from my_tool import MyCustomTool

---

## Crie um arquivo `.env` na raiz do seu projeto:

**URL:** llms-txt#crie-um-arquivo-`.env`-na-raiz-do-seu-projeto:

---

## Busca RAG no MySQL

**URL:** llms-txt#busca-rag-no-mysql

**Contents:**
- Visão Geral
- Instalação
- Exemplo

Source: https://docs.crewai.com/pt-BR/tools/database-data/mysqltool

O `MySQLSearchTool` foi projetado para buscar em bancos de dados MySQL e retornar os resultados mais relevantes.

Esta ferramenta foi desenvolvida para facilitar buscas semânticas em tabelas de bancos de dados MySQL. Utilizando a tecnologia RAG (Retrieve and Generate),
o MySQLSearchTool oferece aos usuários um meio eficiente de consultar o conteúdo de tabelas do banco de dados, especificamente adaptado para bancos MySQL.
Ela simplifica o processo de encontrar dados relevantes por meio de consultas de busca semântica, tornando-se um recurso valioso para quem precisa
realizar consultas avançadas em grandes conjuntos de dados dentro de um banco de dados MySQL.

Para instalar o pacote `crewai_tools` e utilizar o MySQLSearchTool, execute o seguinte comando no seu terminal:

Abaixo está um exemplo demonstrando como usar o MySQLSearchTool para realizar uma busca semântica em uma tabela de um banco de dados MySQL:

```python Code theme={null}
from crewai_tools import MySQLSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Abaixo está um exemplo demonstrando como usar o MySQLSearchTool para realizar uma busca semântica em uma tabela de um banco de dados MySQL:
```

---

## Slack 트리거

**URL:** llms-txt#slack-트리거

**Contents:**
- 사전 요구 사항
- 설정 단계
- 팁

Source: https://docs.crewai.com/ko/enterprise/guides/slack-trigger

슬래시 명령어를 사용해 Slack에서 CrewAI crew를 직접 트리거합니다

이 가이드는 CrewAI 트리거를 사용하여 Slack에서 직접 crew를 시작하는 방법을 설명합니다.

* CrewAI Slack 트리거가 설치되어 있고 Slack 워크스페이스에 연결되어 있음
* CrewAI에서 하나 이상의 crew가 구성되어 있음

<Steps>
  <Step title="CrewAI Slack 트리거가 설정되어 있는지 확인">
    CrewAI 대시보드에서 **트리거** 섹션으로 이동합니다.

<Frame>
      <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6d976bf9516d737af0b7ea3a77aa2b2a" alt="CrewAI Slack Integration" data-og-width="1962" width="1962" data-og-height="1052" height="1052" data-path="images/enterprise/slack-integration.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8ce8a2090ccca8027450db4f447f65cd 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=72063bc9e37d7ca4f495cb4dcac4fd04 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=bfb09bbf40fa85cff58485d75d6d2e55 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=30e1149f8bbe585c443d9b57c33d3888 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c6b943586531c6fab7eab1b9c2f61092 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/slack-integration.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=106a0fe6ed7e2f3a69b5bde02f21d860 2500w" />
    </Frame>

Slack이 나열되어 있고 연결되어 있는지 확인합니다.
  </Step>

<Step title="Slack 채널을 엽니다">
    * crew를 시작하려는 채널로 이동합니다.
    * 슬래시 명령어 "**/kickoff**"를 입력하여 crew 시작 프로세스를 시작합니다.
    * 입력하는 동안 "**Kickoff crew**"가 나타나야 합니다:
      <Frame>
        <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=cf16579e88e59903af9ac3f2ef374555" alt="Kickoff crew" data-og-width="601" width="601" data-og-height="157" height="157" data-path="images/enterprise/kickoff-slack-crew.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f43ffa15817823e76313f33c889f5708 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=bd173c20d88c0bf4466f1af1098bb285 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=00d64ee5b69f4c9497f32dd18335f53e 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6a38124f5f963b15b1cc0d6acaa1996f 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=94c6909651b61ec2b4de17687d1ce95a 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=47df98421d2a98e3fbc19015d2cb48ee 2500w" />
      </Frame>
    * Enter를 누르거나 "**Kickoff crew**" 옵션을 선택합니다. "**Kickoff an AI Crew**"라는 제목의 대화상자가 나타납니다.
  </Step>

<Step title="시작할 crew를 선택합니다">
    * "**Select of the crews online:**"라는 드롭다운 메뉴에서 시작할 crew를 선택합니다.
    * 아래 예시에서는 "**prep-for-meeting**"이 선택되어 있습니다:
      <Frame>
        <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7c92f688fcd7f1f0251cd90670014e34" alt="Kickoff crew dropdown" data-og-width="631" width="631" data-og-height="333" height="333" data-path="images/enterprise/kickoff-slack-crew-dropdown.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7efe2a1a20f23311e914b0fdedf7532a 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2bb784762404d9d7713743e8da6f0057 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=5aa472c131ee27c39c925b555f6d451d 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=18b84066d96edbacc103e57e99be592e 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=208d754df14ea8bcd287990df3d6bd55 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-dropdown.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=98efd80f079ee57494997f45e03455ed 2500w" />
      </Frame>
    * crew에 입력값이 필요한 경우 "**Add Inputs**" 버튼을 클릭하여 입력값을 제공합니다.
      <Note>
        위 예시에서 "**Add Inputs**" 버튼이 보이지만 아직 클릭되지 않았습니다.
      </Note>
  </Step>

<Step title="Kickoff을 클릭하고 crew가 완료될 때까지 기다립니다">
    * crew를 선택하고 필요한 입력값을 추가했다면, "**Kickoff**"를 클릭하여 crew를 시작합니다.
      <Frame>
        <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e5bebbf61fb92832dc1ebef0a77d5654" alt="Kickoff crew" data-og-width="628" width="628" data-og-height="771" height="771" data-path="images/enterprise/kickoff-slack-crew-kickoff.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3c04a8e5c5f45211135c3b31423b3baf 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a6d444a78f6991956f03eb92c8e83de0 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=789ad738a8dd10a4e9ad83de0be5faf3 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a1fec0a13f00082ab70c7c12744d2954 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2d7e271cf05848aaebdd7445923f6daf 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-kickoff.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=912bf7b4abb0d51b46ddf3f9d02230c2 2500w" />
      </Frame>
    * crew가 실행을 시작하면 Slack 채널에서 결과를 확인할 수 있습니다.
      <Frame>
        <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a3d451c03c3ff7ebf64eb9bb1b41c18c" alt="Kickoff crew results" data-og-width="653" width="653" data-og-height="678" height="678" data-path="images/enterprise/kickoff-slack-crew-results.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=fcaf9677647222c1a7c716ed197c9c60 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=bf3ff58196c634ebbaa545ad815593ba 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=34fd1fcef59569b7503b47587e29b31b 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ceeb582a0ea6ce7c4ce86080c5f09506 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7b1bac2cd281b5770f3ad33d13fc3e22 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-slack-crew-results.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1bef274ced3f62e923578f882cc36fc8 2500w" />
      </Frame>
  </Step>
</Steps>

* Slack 워크스페이스에서 `/kickoff` 명령어를 사용할 수 있는 필요한 권한이 있는지 확인하세요.
* 드롭다운에서 원하는 crew가 보이지 않는 경우, CrewAI에서 해당 crew가 올바르게 구성되어 있고 온라인 상태인지 확인하세요.

---

## Microsoft OneDrive 기능을 가진 에이전트 생성

**URL:** llms-txt#microsoft-onedrive-기능을-가진-에이전트-생성

onedrive_agent = Agent(
    role="파일 관리자",
    goal="OneDrive에서 파일과 폴더를 효율적으로 관리",
    backstory="Microsoft OneDrive 파일 작업 및 구성 전문 AI 어시스턴트.",
    apps=['microsoft_onedrive']  # 모든 OneDrive 작업을 사용할 수 있습니다
)

---

## Streamable HTTP Transport

**URL:** llms-txt#streamable-http-transport

**Contents:**
- Overview
- Key Concepts
- Connecting via Streamable HTTP
  - 1. Fully Managed Connection (Recommended)
  - 2. Manual Connection Lifecycle
- Security Considerations

Source: https://docs.crewai.com/en/mcp/streamable-http

Learn how to connect CrewAI to remote MCP servers using the flexible Streamable HTTP transport.

Streamable HTTP transport provides a flexible way to connect to remote MCP servers. It's often built upon HTTP and can support various communication patterns, including request-response and streaming, sometimes utilizing Server-Sent Events (SSE) for server-to-client streams within a broader HTTP interaction.

* **Remote Servers**: Designed for MCP servers hosted remotely.
* **Flexibility**: Can support more complex interaction patterns than plain SSE, potentially including bi-directional communication if the server implements it.
* **`MCPServerAdapter` Configuration**: You'll need to provide the server's base URL for MCP communication and specify `"streamable-http"` as the transport type.

## Connecting via Streamable HTTP

You have two primary methods for managing the connection lifecycle with a Streamable HTTP MCP server:

### 1. Fully Managed Connection (Recommended)

The recommended approach is to use a Python context manager (`with` statement), which handles the connection's setup and teardown automatically.

**Note:** Replace `"http://localhost:8001/mcp"` with the actual URL of your Streamable HTTP MCP server.

### 2. Manual Connection Lifecycle

For scenarios requiring more explicit control, you can manage the `MCPServerAdapter` connection manually.

<Info>
  It is **critical** to call `mcp_server_adapter.stop()` when you are done to close the connection and free up resources. A `try...finally` block is the safest way to ensure this.
</Info>

## Security Considerations

When using Streamable HTTP transport, general web security best practices are paramount:

* **Use HTTPS**: Always prefer HTTPS (HTTP Secure) for your MCP server URLs to encrypt data in transit.
* **Authentication**: Implement robust authentication mechanisms if your MCP server exposes sensitive tools or data.
* **Input Validation**: Ensure your MCP server validates all incoming requests and parameters.

For a comprehensive guide on securing your MCP integrations, please refer to our [Security Considerations](./security.mdx) page and the official [MCP Transport Security documentation](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations).

**Examples:**

Example 1 (unknown):
```unknown
**Note:** Replace `"http://localhost:8001/mcp"` with the actual URL of your Streamable HTTP MCP server.

### 2. Manual Connection Lifecycle

For scenarios requiring more explicit control, you can manage the `MCPServerAdapter` connection manually.

<Info>
  It is **critical** to call `mcp_server_adapter.stop()` when you are done to close the connection and free up resources. A `try...finally` block is the safest way to ensure this.
</Info>
```

---

## Configuração do Azure OpenAI

**URL:** llms-txt#configuração-do-azure-openai

**Contents:**
- Processo de Configuração
- Verificação
- Solução de Problemas

Source: https://docs.crewai.com/pt-BR/enterprise/guides/azure-openai-setup

Configure o Azure OpenAI com o Crew Studio para conexões empresariais de LLM

Este guia orienta você na conexão do Azure OpenAI com o Crew Studio para operações de IA empresarial sem interrupções.

## Processo de Configuração

<Steps>
  <Step title="Acesse o Azure OpenAI Studio">
    1. No Azure, vá para `Serviços de IA do Azure > selecione sua implantação > abra o Azure OpenAI Studio`.
    2. No menu à esquerda, clique em `Implantações`. Se não houver nenhuma, crie uma implantação com o modelo desejado.
    3. Uma vez criada, selecione sua implantação e localize o `Target URI` e a `Key` no lado direito da página. Mantenha esta página aberta, pois você precisará dessas informações.
       <Frame>
         <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a7136eae05529c674ddbda6e8f58eee8" alt="Azure OpenAI Studio" data-og-width="670" width="670" data-og-height="502" height="502" data-path="images/enterprise/azure-openai-studio.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=79abbdeb76fa4f38ef6614438651744c 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c60da2c7f702a15162111d45996d97ff 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=46d5ab75f601b9a14c53c93e51aa57b4 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=67e2c20ec9785d24bf69279102f564a7 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=342a5e6abe1f0a4b1dadf7865ac4cf27 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/azure-openai-studio.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=44d5e6cf8120262a1637a4e24858dfcb 2500w" />
       </Frame>
  </Step>

<Step title="Configure a Conexão Enterprise do CrewAI">
    4. Em outra aba, abra `CrewAI AMP > LLM Connections`. Dê um nome à sua LLM Connection, selecione Azure como provedor e escolha o mesmo modelo que você selecionou no Azure.
    5. Na mesma página, adicione as variáveis de ambiente do passo 3:
       * Uma chamada `AZURE_DEPLOYMENT_TARGET_URL` (usando o Target URI). A URL deve ser parecida com: [https://your-deployment.openai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-08-01-preview](https://your-deployment.openai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-08-01-preview)
       * Outra chamada `AZURE_API_KEY` (usando a Key).
    6. Clique em `Add Connection` para salvar sua LLM Connection.
  </Step>

<Step title="Defina Configurações Padrão">
    7. Em `CrewAI AMP > Settings > Defaults > Crew Studio LLM Settings`, defina a nova LLM Connection e o modelo como padrão.
  </Step>

<Step title="Configure o Acesso à Rede">
    8. Certifique-se das configurações de acesso à rede:
       * No Azure, vá para `Azure OpenAI > selecione sua implantação`.
       * Navegue até `Resource Management > Networking`.
       * Certifique-se de que a opção `Allow access from all networks` está habilitada. Se essa configuração estiver restrita, o CrewAI pode ser impedido de acessar seu endpoint do Azure OpenAI.
  </Step>
</Steps>

Tudo pronto! O Crew Studio agora utilizará sua conexão Azure OpenAI. Teste a conexão criando um crew ou task simples para garantir que tudo está funcionando corretamente.

## Solução de Problemas

Se você encontrar problemas:

* Verifique se o formato do Target URI corresponde ao padrão esperado
* Confira se a API key está correta e com as permissões adequadas
* Certifique-se de que o acesso à rede está configurado para permitir conexões do CrewAI
* Confirme se o modelo da implantação corresponde ao que você configurou no CrewAI

---

## `OxylabsAmazonProductScraperTool`

**URL:** llms-txt#`oxylabsamazonproductscrapertool`

**Contents:**
  - Exemplo

```python  theme={null}
from crewai_tools import OxylabsAmazonProductScraperTool

---

## Create an agent with all available parameters

**URL:** llms-txt#create-an-agent-with-all-available-parameters

**Contents:**
  - Parameter Details
- Agent Tools

agent = Agent(
    role="Senior Data Scientist",
    goal="Analyze and interpret complex datasets to provide actionable insights",
    backstory="With over 10 years of experience in data science and machine learning, "
              "you excel at finding patterns in complex datasets.",
    llm="gpt-4",  # Default: OPENAI_MODEL_NAME or "gpt-4"
    function_calling_llm=None,  # Optional: Separate LLM for tool calling
    verbose=False,  # Default: False
    allow_delegation=False,  # Default: False
    max_iter=20,  # Default: 20 iterations
    max_rpm=None,  # Optional: Rate limit for API calls
    max_execution_time=None,  # Optional: Maximum execution time in seconds
    max_retry_limit=2,  # Default: 2 retries on error
    allow_code_execution=False,  # Default: False
    code_execution_mode="safe",  # Default: "safe" (options: "safe", "unsafe")
    respect_context_window=True,  # Default: True
    use_system_prompt=True,  # Default: True
    multimodal=False,  # Default: False
    inject_date=False,  # Default: False
    date_format="%Y-%m-%d",  # Default: ISO format
    reasoning=False,  # Default: False
    max_reasoning_attempts=None,  # Default: None
    tools=[SerperDevTool()],  # Optional: List of tools
    knowledge_sources=None,  # Optional: List of knowledge sources
    embedder=None,  # Optional: Custom embedder configuration
    system_template=None,  # Optional: Custom system prompt template
    prompt_template=None,  # Optional: Custom prompt template
    response_template=None,  # Optional: Custom response template
    step_callback=None,  # Optional: Callback function for monitoring
)
python Code theme={null}
research_agent = Agent(
    role="Research Analyst",
    goal="Find and summarize information about specific topics",
    backstory="You are an experienced researcher with attention to detail",
    tools=[SerperDevTool()],
    verbose=True  # Enable logging for debugging
)
python Code theme={null}
dev_agent = Agent(
    role="Senior Python Developer",
    goal="Write and debug Python code",
    backstory="Expert Python developer with 10 years of experience",
    allow_code_execution=True,
    code_execution_mode="safe",  # Uses Docker for safety
    max_execution_time=300,  # 5-minute timeout
    max_retry_limit=3  # More retries for complex code tasks
)
python Code theme={null}
analysis_agent = Agent(
    role="Data Analyst",
    goal="Perform deep analysis of large datasets",
    backstory="Specialized in big data analysis and pattern recognition",
    memory=True,
    respect_context_window=True,
    max_rpm=10,  # Limit API calls
    function_calling_llm="gpt-4o-mini"  # Cheaper model for tool calls
)
python Code theme={null}
custom_agent = Agent(
    role="Customer Service Representative",
    goal="Assist customers with their inquiries",
    backstory="Experienced in customer support with a focus on satisfaction",
    system_template="""<|start_header_id|>system<|end_header_id|>
                        {{ .System }}<|eot_id|>""",
    prompt_template="""<|start_header_id|>user<|end_header_id|>
                        {{ .Prompt }}<|eot_id|>""",
    response_template="""<|start_header_id|>assistant<|end_header_id|>
                        {{ .Response }}<|eot_id|>""",
)
python Code theme={null}
strategic_agent = Agent(
    role="Market Analyst",
    goal="Track market movements with precise date references and strategic planning",
    backstory="Expert in time-sensitive financial analysis and strategic reporting",
    inject_date=True,  # Automatically inject current date into tasks
    date_format="%B %d, %Y",  # Format as "May 21, 2025"
    reasoning=True,  # Enable strategic planning
    max_reasoning_attempts=2,  # Limit planning iterations
    verbose=True
)
python Code theme={null}
reasoning_agent = Agent(
    role="Strategic Planner",
    goal="Analyze complex problems and create detailed execution plans",
    backstory="Expert strategic planner who methodically breaks down complex challenges",
    reasoning=True,  # Enable reasoning and planning
    max_reasoning_attempts=3,  # Limit reasoning attempts
    max_iter=30,  # Allow more iterations for complex planning
    verbose=True
)
python Code theme={null}
multimodal_agent = Agent(
    role="Visual Content Analyst",
    goal="Analyze and process both text and visual content",
    backstory="Specialized in multimodal analysis combining text and image understanding",
    multimodal=True,  # Enable multimodal capabilities
    verbose=True
)
python Code theme={null}
from crewai import Agent
from crewai_tools import SerperDevTool, WikipediaTools

**Examples:**

Example 1 (unknown):
```unknown
Let's break down some key parameter combinations for common use cases:

#### Basic Research Agent
```

Example 2 (unknown):
```unknown
#### Code Development Agent
```

Example 3 (unknown):
```unknown
#### Long-Running Analysis Agent
```

Example 4 (unknown):
```unknown
#### Custom Template Agent
```

---

## Os resultados serão filtrados onde categoria == "tecnologia"

**URL:** llms-txt#os-resultados-serão-filtrados-onde-categoria-==-"tecnologia"

**Contents:**
  - Filtros Pré-definidos com QdrantConfig

python  theme={null}
from qdrant_client.http import models as qmodels
from crewai_tools import QdrantVectorSearchTool, QdrantConfig

**Examples:**

Example 1 (unknown):
```unknown
### Filtros Pré-definidos com QdrantConfig

Para filtragens complexas, use instâncias de Filter do Qdrant na sua configuração:
```

---

## 사용자 추적이 설정된 LLM 구성

**URL:** llms-txt#사용자-추적이-설정된-llm-구성

portkey_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
        metadata={
            "_user": "user_123",  # 사용자 분석을 위한 특별 _user 필드
            "user_tier": "premium",
            "user_company": "Acme Corp",
            "session_id": "abc-123"
        }
    )
)

---

## Inicializando a partir das ferramentas do LlamaHub

**URL:** llms-txt#inicializando-a-partir-das-ferramentas-do-llamahub

**Contents:**
  - A partir de um mecanismo de consulta do LlamaIndex

wolfram_spec = WolframAlphaToolSpec(app_id="your_app_id")
wolfram_tools = wolfram_spec.to_tool_list()
tools = [LlamaIndexTool.from_tool(t) for t in wolfram_tools]
python Code theme={null}
from crewai_tools import LlamaIndexTool
from llama_index.core import VectorStoreIndex
from llama_index.core.readers import SimpleDirectoryReader

**Examples:**

Example 1 (unknown):
```unknown
### A partir de um mecanismo de consulta do LlamaIndex
```

---

## Tavily 검색 도구

**URL:** llms-txt#tavily-검색-도구

**Contents:**
- 설치
- 환경 변수
- 예제 사용법

Source: https://docs.crewai.com/ko/tools/search-research/tavilysearchtool

Tavily Search API를 사용하여 종합적인 웹 검색 수행

`TavilySearchTool`은 Tavily Search API에 대한 인터페이스를 제공하여 CrewAI 에이전트가 포괄적인 웹 검색을 수행할 수 있도록 합니다. 이 도구는 검색 깊이, 주제, 시간 범위, 포함/제외 도메인, 그리고 결과에 직접 답변, 원시 콘텐츠, 이미지 포함 여부 등을 지정할 수 있게 해줍니다.

`TavilySearchTool`을 사용하려면 `tavily-python` 라이브러리를 설치해야 합니다:

Tavily API 키가 환경 변수로 설정되어 있는지 확인하세요:

[https://app.tavily.com/에서](https://app.tavily.com/에서) API 키를 발급받으세요(회원가입 후 키를 생성하면 됩니다).

다음은 CrewAI agent 내에서 `TavilySearchTool`을 초기화하고 사용하는 방법입니다:

```python  theme={null}
import os
from crewai import Agent, Task, Crew
from crewai_tools import TavilySearchTool

**Examples:**

Example 1 (unknown):
```unknown
## 환경 변수

Tavily API 키가 환경 변수로 설정되어 있는지 확인하세요:
```

Example 2 (unknown):
```unknown
[https://app.tavily.com/에서](https://app.tavily.com/에서) API 키를 발급받으세요(회원가입 후 키를 생성하면 됩니다).

## 예제 사용법

다음은 CrewAI agent 내에서 `TavilySearchTool`을 초기화하고 사용하는 방법입니다:
```

---

## Snippet: Quels sont les sports présents aux Jeux Olympiques de Paris 2024 ? · Athlétisme · Aviron · Badminton · Basketball · Basketball 3x3 · Boxe · Breaking · Canoë ...

**URL:** llms-txt#snippet:-quels-sont-les-sports-présents-aux-jeux-olympiques-de-paris-2024-?-·-athlétisme-·-aviron-·-badminton-·-basketball-·-basketball-3x3-·-boxe-·-breaking-·-canoë-...

---

## Option 1: Accessing Properties Using Dictionary-Style Indexing

**URL:** llms-txt#option-1:-accessing-properties-using-dictionary-style-indexing

print("Accessing Properties - Option 1")
title = result["title"]
content = result["content"]
print("Title:", title)
print("Content:", content)

---

## Criação do agente é rápida - nenhuma conexão MCP feita ainda

**URL:** llms-txt#criação-do-agente-é-rápida---nenhuma-conexão-mcp-feita-ainda

agente = Agent(
    role="Agente Sob Demanda",
    goal="Usar ferramentas eficientemente",
    backstory="Agente eficiente que conecta apenas quando necessário",
    mcps=["https://api.example.com/mcp"]
)

---

## 사전 설정 필터로 도구 초기화

**URL:** llms-txt#사전-설정-필터로-도구-초기화

**Contents:**
  - 필터 결합

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_url",
        qdrant_api_key="your_key",
        collection_name="your_collection",
        filter=preset_filter  # 모든 검색에 적용되는 사전 설정 필터
    )
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 필터 결합

도구는 `QdrantConfig`의 사전 설정 필터와 `filter_by` 및 `filter_value`의 동적 필터를 자동으로 결합합니다:
```

---

## Now all knowledge will be stored in your project directory

**URL:** llms-txt#now-all-knowledge-will-be-stored-in-your-project-directory

**Contents:**
  - Comportamento Padrão do Provedor de Embedding

python  theme={null}
from crewai import Agent, Crew, LLM
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

**Examples:**

Example 1 (unknown):
```unknown
### Comportamento Padrão do Provedor de Embedding

<Info>
  **Provedor de Embedding Padrão**: O CrewAI usa por padrão embeddings da OpenAI (`text-embedding-3-small`) para armazenamento de knowledge, mesmo quando usa diferentes provedores de LLM. Você pode facilmente personalizar isso para corresponder à sua configuração.
</Info>

#### Entendendo o Comportamento Padrão
```

---

## }

**URL:** llms-txt#}

**Contents:**
- Parâmetros
  - Parâmetros de Inicialização
  - Parâmetros de Execução
- Opções de Configuração Scrapfly
- Uso

scrape_task = Task(
    description="Extract the main content from the product page at https://web-scraping.dev/products using advanced scraping options including JavaScript rendering and proxy settings.",
    expected_output="A detailed summary of the products with all available information.",
    agent=web_scraper_agent,
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros

A `ScrapflyScrapeWebsiteTool` aceita os seguintes parâmetros:

### Parâmetros de Inicialização

* **api\_key**: Obrigatório. Sua chave de API da Scrapfly.

### Parâmetros de Execução

* **url**: Obrigatório. A URL do site a ser raspado.
* **scrape\_format**: Opcional. O formato em que o conteúdo da página será extraído. As opções são "raw" (HTML), "markdown" ou "text". O padrão é "markdown".
* **scrape\_config**: Opcional. Um dicionário contendo opções adicionais de configuração de raspagem da Scrapfly.
* **ignore\_scrape\_failures**: Opcional. Determina se as falhas de raspagem devem ser ignoradas. Se definido como `True`, a ferramenta irá retornar `None` ao invés de lançar uma exceção caso ocorra uma falha na raspagem.

## Opções de Configuração Scrapfly

O parâmetro `scrape_config` permite personalizar o comportamento da raspagem com as seguintes opções:

* **asp**: Ativa o bypass de proteção anti-scraping.
* **render\_js**: Ativa a renderização de JavaScript com um navegador headless na nuvem.
* **proxy\_pool**: Seleciona um pool de proxies (por exemplo, "public\_residential\_pool", "datacenter").
* **country**: Seleciona a localização do proxy (por exemplo, "us", "uk").
* **auto\_scroll**: Rola automaticamente a página para carregar conteúdo lazy-loaded.
* **js**: Executa código JavaScript personalizado via o navegador headless.

Para uma lista completa de opções de configuração, consulte a [documentação da API Scrapfly](https://scrapfly.io/docs/scrape-api/getting-started).

## Uso

Ao usar a `ScrapflyScrapeWebsiteTool` com um agente, o agente deverá fornecer a URL do site a ser raspado e pode opcionalmente especificar o formato e opções adicionais de configuração:
```

---

## Microsoft Excel 통합

**URL:** llms-txt#microsoft-excel-통합

**Contents:**
- 개요
- 전제 조건
- Microsoft Excel 통합 설정
  - 1. Microsoft 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Microsoft Excel 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/microsoft_excel

CrewAI를 위한 Microsoft Excel 통합으로 통합 문서 및 데이터 관리.

에이전트가 OneDrive 또는 SharePoint에서 Excel 통합 문서, 워크시트, 테이블 및 차트를 생성하고 관리할 수 있도록 합니다. AI 기반 자동화로 데이터 범위를 조작하고, 시각화를 생성하고, 테이블을 관리하며, 스프레드시트 워크플로를 간소화합니다.

Microsoft Excel 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Excel 및 OneDrive/SharePoint 액세스 권한이 있는 Microsoft 365 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Microsoft 계정 연결

## Microsoft Excel 통합 설정

### 1. Microsoft 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Microsoft Excel** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 파일 및 Excel 통합 문서 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="microsoft_excel/create_workbook">
    **설명:** OneDrive 또는 SharePoint에 새 Excel 통합 문서를 만듭니다.

* `file_path` (string, 필수): 통합 문서를 만들 경로 (예: 'MyWorkbook.xlsx')
    * `worksheets` (array, 선택사항): 만들 초기 워크시트들. 각 항목은 `name` (string, 워크시트 이름)이 있는 객체.
  </Accordion>

<Accordion title="microsoft_excel/get_workbooks">
    **설명:** OneDrive 또는 SharePoint에서 모든 Excel 통합 문서를 가져옵니다.

* `select` (string, 선택사항): 반환할 특정 속성 선택.
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬.
  </Accordion>

<Accordion title="microsoft_excel/get_worksheets">
    **설명:** Excel 통합 문서의 모든 워크시트를 가져옵니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `select` (string, 선택사항): 반환할 특정 속성 선택 (예: 'id,name,position').
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬.
  </Accordion>

<Accordion title="microsoft_excel/create_worksheet">
    **설명:** Excel 통합 문서에 새 워크시트를 만듭니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `name` (string, 필수): 새 워크시트의 이름.
  </Accordion>

<Accordion title="microsoft_excel/get_range_data">
    **설명:** Excel 워크시트의 특정 범위에서 데이터를 가져옵니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `range` (string, 필수): 범위 주소 (예: 'A1:C10').
  </Accordion>

<Accordion title="microsoft_excel/update_range_data">
    **설명:** Excel 워크시트의 특정 범위에서 데이터를 업데이트합니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `range` (string, 필수): 범위 주소 (예: 'A1:C10').
    * `values` (array, 필수): 범위에 설정할 값들의 2D 배열. 각 내부 배열은 행을 나타내며, 요소는 string, number 또는 integer일 수 있음.
  </Accordion>

<Accordion title="microsoft_excel/add_table">
    **설명:** Excel 워크시트에 테이블을 만듭니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `range` (string, 필수): 테이블의 범위 (예: 'A1:D10').
    * `has_headers` (boolean, 선택사항): 첫 번째 행이 헤더를 포함하는지 여부. 기본값: true.
  </Accordion>

<Accordion title="microsoft_excel/get_tables">
    **설명:** Excel 워크시트의 모든 테이블을 가져옵니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
  </Accordion>

<Accordion title="microsoft_excel/add_table_row">
    **설명:** Excel 테이블에 새 행을 추가합니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `table_name` (string, 필수): 테이블의 이름.
    * `values` (array, 필수): 새 행의 값들 배열. 요소는 string, number 또는 integer일 수 있음.
  </Accordion>

<Accordion title="microsoft_excel/create_chart">
    **설명:** Excel 워크시트에 차트를 만듭니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `chart_type` (string, 필수): 차트 유형 (예: 'ColumnClustered', 'Line', 'Pie').
    * `source_data` (string, 필수): 차트의 데이터 범위 (예: 'A1:B10').
    * `series_by` (string, 선택사항): 데이터 해석 방법 ('Auto', 'Columns' 또는 'Rows'). 기본값: 'Auto'.
  </Accordion>

<Accordion title="microsoft_excel/get_cell">
    **설명:** Excel 워크시트의 단일 셀 값을 가져옵니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `row` (integer, 필수): 행 번호 (0 기반).
    * `column` (integer, 필수): 열 번호 (0 기반).
  </Accordion>

<Accordion title="microsoft_excel/get_used_range">
    **설명:** Excel 워크시트의 사용된 범위를 가져옵니다 (모든 데이터를 포함).

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
  </Accordion>

<Accordion title="microsoft_excel/list_charts">
    **설명:** Excel 워크시트의 모든 차트를 가져옵니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
  </Accordion>

<Accordion title="microsoft_excel/delete_worksheet">
    **설명:** Excel 통합 문서에서 워크시트를 삭제합니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 삭제할 워크시트의 이름.
  </Accordion>

<Accordion title="microsoft_excel/delete_table">
    **설명:** Excel 워크시트에서 테이블을 삭제합니다.

* `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `table_name` (string, 필수): 삭제할 테이블의 이름.
  </Accordion>

<Accordion title="microsoft_excel/list_names">
    **설명:** Excel 통합 문서의 모든 명명된 범위를 가져옵니다.

* `file_id` (string, 필수): Excel 파일의 ID.
  </Accordion>
</AccordionGroup>

### 기본 Microsoft Excel 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="microsoft_excel/create_workbook">
    **설명:** OneDrive 또는 SharePoint에 새 Excel 통합 문서를 만듭니다.

    **매개변수:**

    * `file_path` (string, 필수): 통합 문서를 만들 경로 (예: 'MyWorkbook.xlsx')
    * `worksheets` (array, 선택사항): 만들 초기 워크시트들. 각 항목은 `name` (string, 워크시트 이름)이 있는 객체.
  </Accordion>

  <Accordion title="microsoft_excel/get_workbooks">
    **설명:** OneDrive 또는 SharePoint에서 모든 Excel 통합 문서를 가져옵니다.

    **매개변수:**

    * `select` (string, 선택사항): 반환할 특정 속성 선택.
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬.
  </Accordion>

  <Accordion title="microsoft_excel/get_worksheets">
    **설명:** Excel 통합 문서의 모든 워크시트를 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `select` (string, 선택사항): 반환할 특정 속성 선택 (예: 'id,name,position').
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬.
  </Accordion>

  <Accordion title="microsoft_excel/create_worksheet">
    **설명:** Excel 통합 문서에 새 워크시트를 만듭니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `name` (string, 필수): 새 워크시트의 이름.
  </Accordion>

  <Accordion title="microsoft_excel/get_range_data">
    **설명:** Excel 워크시트의 특정 범위에서 데이터를 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `range` (string, 필수): 범위 주소 (예: 'A1:C10').
  </Accordion>

  <Accordion title="microsoft_excel/update_range_data">
    **설명:** Excel 워크시트의 특정 범위에서 데이터를 업데이트합니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `range` (string, 필수): 범위 주소 (예: 'A1:C10').
    * `values` (array, 필수): 범위에 설정할 값들의 2D 배열. 각 내부 배열은 행을 나타내며, 요소는 string, number 또는 integer일 수 있음.
  </Accordion>

  <Accordion title="microsoft_excel/add_table">
    **설명:** Excel 워크시트에 테이블을 만듭니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `range` (string, 필수): 테이블의 범위 (예: 'A1:D10').
    * `has_headers` (boolean, 선택사항): 첫 번째 행이 헤더를 포함하는지 여부. 기본값: true.
  </Accordion>

  <Accordion title="microsoft_excel/get_tables">
    **설명:** Excel 워크시트의 모든 테이블을 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
  </Accordion>

  <Accordion title="microsoft_excel/add_table_row">
    **설명:** Excel 테이블에 새 행을 추가합니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `table_name` (string, 필수): 테이블의 이름.
    * `values` (array, 필수): 새 행의 값들 배열. 요소는 string, number 또는 integer일 수 있음.
  </Accordion>

  <Accordion title="microsoft_excel/create_chart">
    **설명:** Excel 워크시트에 차트를 만듭니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `chart_type` (string, 필수): 차트 유형 (예: 'ColumnClustered', 'Line', 'Pie').
    * `source_data` (string, 필수): 차트의 데이터 범위 (예: 'A1:B10').
    * `series_by` (string, 선택사항): 데이터 해석 방법 ('Auto', 'Columns' 또는 'Rows'). 기본값: 'Auto'.
  </Accordion>

  <Accordion title="microsoft_excel/get_cell">
    **설명:** Excel 워크시트의 단일 셀 값을 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `row` (integer, 필수): 행 번호 (0 기반).
    * `column` (integer, 필수): 열 번호 (0 기반).
  </Accordion>

  <Accordion title="microsoft_excel/get_used_range">
    **설명:** Excel 워크시트의 사용된 범위를 가져옵니다 (모든 데이터를 포함).

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
  </Accordion>

  <Accordion title="microsoft_excel/list_charts">
    **설명:** Excel 워크시트의 모든 차트를 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
  </Accordion>

  <Accordion title="microsoft_excel/delete_worksheet">
    **설명:** Excel 통합 문서에서 워크시트를 삭제합니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 삭제할 워크시트의 이름.
  </Accordion>

  <Accordion title="microsoft_excel/delete_table">
    **설명:** Excel 워크시트에서 테이블을 삭제합니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
    * `worksheet_name` (string, 필수): 워크시트의 이름.
    * `table_name` (string, 필수): 삭제할 테이블의 이름.
  </Accordion>

  <Accordion title="microsoft_excel/list_names">
    **설명:** Excel 통합 문서의 모든 명명된 범위를 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): Excel 파일의 ID.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Microsoft Excel 에이전트 설정
```

---

## 트레이스

**URL:** llms-txt#트레이스

**Contents:**
- 개요
- Traces란 무엇인가요?
- 트레이스(Traces) 접근하기
- 트레이스 인터페이스 이해하기
  - 1. 실행 요약
  - 2. Tasks & Agents
  - 3. 최종 결과
  - 4. 실행 타임라인
  - 5. 상세 작업 보기
- 디버깅을 위한 트레이스 사용

Source: https://docs.crewai.com/ko/enterprise/features/traces

Traces를 사용하여 내 크루 모니터링하기

Trace는 crew 실행에 대한 포괄적인 가시성을 제공하여 성능 모니터링, 문제 디버깅, AI agent workflow 최적화에 도움을 줍니다.

CrewAI AMP의 Traces는 crew의 작동 과정을 처음 입력에서 최종 출력까지 모든 측면에서 포착하는 상세 실행 기록입니다. Traces에는 다음 내용이 기록됩니다:

* Agent의 생각 및 추론
* 작업 실행 세부 정보
* 도구 사용 및 출력
* 토큰 소모 메트릭
* 실행 시간
* 비용 추정치

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9c02d5b7306bf7adaeadd77a018f8fea" alt="Traces Overview" data-og-width="2244" width="2244" data-og-height="1422" height="1422" data-path="images/enterprise/traces-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e66e7c56a8848b69266563ea8cddfc4e 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f590b3901aaa5994042c79426d78bd6c 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=0ecb9dcb307e8f130f53393bd3abc12d 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=5fc6fcfc51c4e8f4ce16d237228043d6 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=253eaed4ec34a35798dad42e9a388859 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ec818e09bc20b3f72b1bcf1970804d13 2500w" />
</Frame>

<Steps>
  <Step title="트레이스 탭으로 이동">
    CrewAI AMP 대시보드에 들어가면, **트레이스**를 클릭하여 모든 실행 기록을 볼 수 있습니다.
  </Step>

<Step title="실행 선택하기">
    모든 crew 실행 목록이 날짜별로 정렬되어 표시됩니다. 상세 트레이스를 보려면 원하는 실행을 클릭하세요.
  </Step>
</Steps>

트레이스 인터페이스는 여러 섹션으로 나뉘어 있으며, 각 섹션은 crew의 실행에 대한 다양한 인사이트를 제공합니다.

상단 섹션에서는 실행에 대한 고수준 메트릭을 표시합니다:

* **총 토큰**: 모든 작업에서 소모된 토큰 수
* **프롬프트 토큰**: LLM에 프롬프트로 사용된 토큰
* **컴플리션 토큰**: LLM 응답에서 생성된 토큰
* **요청 수**: 수행된 API 호출 수
* **실행 시간**: crew 런의 전체 소요 시간
* **예상 비용**: 토큰 사용량을 기반으로 한 대략적인 비용

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a6a26eda2add26a6f649b1727bf90d8d" alt="Execution Summary" data-og-width="2576" width="2576" data-og-height="916" height="916" data-path="images/enterprise/trace-summary.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=52f47a0c5d9f2dc1d0c93d1c2446cb10 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=584cdc9fded1e3875799da73e60cdebd 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2e4f500438545badfa9b3bb3704786ce 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c3e0987a95638f9512ba6c64a5927eda 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=d80e2d9de9db7449368151ccaac8106b 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=39ccb1a6b12aecd0f6863f2783b1bfc6 2500w" />
</Frame>

### 2. Tasks & Agents

이 섹션에서는 crew 실행에 포함된 모든 task와 agent를 보여줍니다:

* task 이름 및 agent 할당
* 각 task에 사용된 agent 및 LLM
* 상태 (완료/실패)
* task의 개별 실행 시간

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f0358b4a17e78532500b4a14964bc30c" alt="Task List" data-og-width="1778" width="1778" data-og-height="594" height="594" data-path="images/enterprise/trace-tasks.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a775268b18c71e0ffa497c9a4e1ad179 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3dadaad60870c3841f859857d5d6f53d 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a0a1d24573dd32cb9d5a3f089536c547 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2ccc370f5e0b6b38521a5ed39e02b062 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=4d717a70fd61ce713f7d5d91ccf867fe 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2c577a5f8e1acea3942de29c5ca49343 2500w" />
</Frame>

모든 작업이 완료된 후 crew가 생성한 최종 결과를 표시합니다.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=5ca9ef8e4071ee570c3e0c8f93ff4253" alt="최종 결과" data-og-width="2212" width="2212" data-og-height="1572" height="1572" data-path="images/enterprise/final-output.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ab97b6b386304f03fe21c6ba2393c683 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3839e312b2a9caa45f3f4b72345ea87b 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b032c2c57ffcd5fb558c43915d385f9a 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=63390d70d70f1a2265a224e8c20d0204 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=abc4a7b81c51049ca606130a0dd543f7 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9fc40fc5f8ad52996aba482d62348f0f 2500w" />
</Frame>

각 작업이 시작되고 종료된 시점을 시각적으로 표현하여 병목 현상이나 병렬 실행 패턴을 파악하는 데 도움이 됩니다.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c860975d3e15e3a6988bedc7d1bf6ba4" alt="실행 타임라인" data-og-width="2210" width="2210" data-og-height="1406" height="1406" data-path="images/enterprise/trace-timeline.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b74d67bda34ce88ea23c30c580dfb2fc 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=99c6688c1d290548cc480232bb13b0e0 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=4876c794ddde894e1e2cf15f1926efcb 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c44f7eec8f0998e488bc951eee8961ea 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c25e4827f5a83172483c38f40e6685de 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b3b2f72954e565f7177b5175d89dfe79 2500w" />
</Frame>

타임라인이나 작업 목록에서 특정 작업을 클릭하면 다음을 볼 수 있습니다:

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=74f5e92354196325edca8d62c29363c7" alt="상세 작업 보기" data-og-width="2036" width="2036" data-og-height="1572" height="1572" data-path="images/enterprise/trace-detailed-task.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=d260407501639bcd1a45da51762f488e 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e577e06eb7658f045e56f2e40e03cf94 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=fcafbac3507eb800e08153352016bf14 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9b2b0decb758802aaa2d8b0b2bd39e6f 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=66a9362f6d8f2edd5a2dad353700e440 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=faadd7f3c9e9176060e21c2987c3d8c9 2500w" />
</Frame>

* **작업 키**: 작업의 고유 식별자
* **작업 ID**: 시스템 내의 기술적 식별자
* **상태**: 현재 상태 (완료/진행 중/실패)
* **에이전트**: 해당 작업을 수행한 에이전트
* **LLM**: 이 작업에 사용된 언어 모델
* **시작/종료 시간**: 작업이 시작되고 완료된 시간
* **실행 시간**: 이 특정 작업의 소요 시간
* **작업 설명**: 에이전트에게 지시된 작업 내용
* **예상 출력**: 요청된 출력 형식
* **입력**: 이전 작업에서 이 작업에 제공된 입력값
* **출력**: 에이전트가 실제로 생성한 결과

트레이스는 crew 문제 해결에 매우 유용합니다:

<Steps>
  <Step title="실패 지점 식별">
    crew 실행이 예상한 결과를 내지 못할 때, 트레이스를 확인하여 어디에서 문제가 발생했는지 찾으세요. 다음을 확인하세요:

* 실패한 작업
    * 에이전트의 예상 밖 결정
    * 도구 사용 오류
    * 잘못 해석된 지침

<Frame>
            <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c892a75b7a22a57949a2641a0fe45bfa" alt="Failure Points" data-og-width="820" width="820" data-og-height="924" height="924" data-path="images/enterprise/failure.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ecbcbd312dd467cb5cc1dae4a443c56d 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c0452a9db1f339e63686941a533d8946 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ded3f2fff055c8d16bcad99ad537da46 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f871feb85f88ba397a259ee8392aef3e 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2acf042b2e6b185f1fbc41100751e03f 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1e9fc9104e6b55b586a9b13e120de908 2500w" />
    </Frame>
  </Step>

<Step title="성능 최적화">
    실행 메트릭을 사용하여 성능 병목 현상을 파악하세요:

* 예상보다 오래 걸린 작업
    * 과도한 토큰 사용
    * 중복된 도구 작업
    * 불필요한 API 호출
  </Step>

<Step title="비용 효율성 향상">
    토큰 사용량 및 비용 추정치를 분석해 crew의 효율성을 최적화하세요:

* 더 간단한 작업에는 더 작은 모델을 사용 고려
    * 프롬프트를 더 간결하게 다듬기
    * 자주 액세스하는 정보 캐싱
    * 중복 작업을 최소화하도록 작업 구조화하기
  </Step>
</Steps>

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  트레이스 분석이나 기타 CrewAI 엔터프라이즈 기능에 대한 지원이 필요하시면 저희 지원팀에 문의하세요.
</Card>

---

## 여러 MCP 서버에 연결하기

**URL:** llms-txt#여러-mcp-서버에-연결하기

**Contents:**
- 개요
- 구성

Source: https://docs.crewai.com/ko/mcp/multiple-servers

CrewAI에서 MCPServerAdapter를 사용하여 여러 MCP 서버에 동시에 연결하고 해당 도구를 집계하는 방법을 알아봅니다.

`crewai-tools`의 `MCPServerAdapter`는 여러 MCP 서버에 동시에 연결할 수 있게 해줍니다. 이는 에이전트가 서로 다른 서비스나 환경에 분산된 도구에 접근해야 할 때 유용합니다. 어댑터는 지정된 모든 서버에서 도구를 집계하여 CrewAI 에이전트가 사용할 수 있게 합니다.

여러 서버에 연결하려면 서버 파라미터 딕셔너리의 리스트를 `MCPServerAdapter`에 제공합니다. 리스트에 있는 각 딕셔너리는 하나의 MCP 서버에 대한 파라미터를 정의해야 합니다.

각 서버에 대해 지원되는 transport 타입은 `stdio`, `sse`, 그리고 `streamable-http`입니다.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters # Needed for Stdio example

---

## Criar Ferramentas Personalizadas

**URL:** llms-txt#criar-ferramentas-personalizadas

**Contents:**
- Criando e Utilizando Ferramentas no CrewAI
  - Subclassificando `BaseTool`
  - Usando o Decorador `tool`
  - Definindo uma Função de Cache para a Ferramenta

Source: https://docs.crewai.com/pt-BR/learn/create-custom-tools

Guia abrangente sobre como criar, utilizar e gerenciar ferramentas personalizadas dentro do framework CrewAI, incluindo novas funcionalidades e tratamento de erros.

## Criando e Utilizando Ferramentas no CrewAI

Este guia traz instruções detalhadas sobre como criar ferramentas personalizadas para o framework CrewAI e como gerenciar e utilizar essas ferramentas de forma eficiente,
incorporando funcionalidades recentes, como delegação de ferramentas, tratamento de erros e chamada dinâmica de ferramentas. Destaca também a importância de ferramentas de colaboração,
permitindo que agentes executem uma ampla gama de ações.

### Subclassificando `BaseTool`

Para criar uma ferramenta personalizada, herde de `BaseTool` e defina os atributos necessários, incluindo o `args_schema` para validação de entrada e o método `_run`.

### Usando o Decorador `tool`

Como alternativa, você pode utilizar o decorador de ferramenta `@tool`. Esta abordagem permite definir os atributos e as funcionalidades da ferramenta diretamente em uma função,
oferecendo uma maneira concisa e eficiente de criar ferramentas especializadas de acordo com suas necessidades.

### Definindo uma Função de Cache para a Ferramenta

Para otimizar o desempenho da ferramenta com cache, defina estratégias de cache personalizadas utilizando o atributo `cache_function`.

Seguindo essas orientações e incorporando novas funcionalidades e ferramentas de colaboração nos seus processos de criação e gerenciamento de ferramentas,
você pode aproveitar ao máximo as capacidades do framework CrewAI, aprimorando tanto a experiência de desenvolvimento quanto a eficiência dos seus agentes de IA.

**Examples:**

Example 1 (unknown):
```unknown
### Usando o Decorador `tool`

Como alternativa, você pode utilizar o decorador de ferramenta `@tool`. Esta abordagem permite definir os atributos e as funcionalidades da ferramenta diretamente em uma função,
oferecendo uma maneira concisa e eficiente de criar ferramentas especializadas de acordo com suas necessidades.
```

Example 2 (unknown):
```unknown
### Definindo uma Função de Cache para a Ferramenta

Para otimizar o desempenho da ferramenta com cache, defina estratégias de cache personalizadas utilizando o atributo `cache_function`.
```

---

## DALL-E를 활용한 이미지 생성

**URL:** llms-txt#dall-e를-활용한-이미지-생성

**Contents:**
- 사전 요구 사항
- DALL-E 도구 설정하기
- DALL-E 도구 사용하기
  - 예시 에이전트 구성
  - 예상 결과
- 모범 사례
- 문제 해결

Source: https://docs.crewai.com/ko/learn/dalle-image-generation

CrewAI 프로젝트에서 AI 기반 이미지 생성을 위해 DALL-E를 활용하는 방법을 알아보세요

CrewAI는 OpenAI의 DALL-E와의 통합을 지원하여, AI 에이전트가 작업의 일환으로 이미지를 생성할 수 있습니다. 이 가이드에서는 CrewAI 프로젝트에서 DALL-E 도구를 설정하고 사용하는 방법을 단계별로 안내합니다.

* crewAI가 설치되어 있음 (최신 버전)
* DALL-E에 접근 가능한 OpenAI API 키

<Steps>
  <Step title="DALL-E 도구 임포트하기">
    
  </Step>

<Step title="DALL-E 도구를 에이전트 구성에 추가하기">
    
  </Step>
</Steps>

DALL-E 도구를 에이전트에 추가하면 텍스트 프롬프트를 기반으로 이미지를 생성할 수 있습니다. 도구는 생성된 이미지의 URL을 반환하며, 이 URL은 에이전트의 출력에 사용하거나 다른 에이전트에게 전달하여 추가 처리를 할 수 있습니다.

DALL-E 도구를 사용하는 agent는 이미지를 생성하고 응답에 URL을 제공할 수 있습니다. 그런 다음 이미지를 다운로드할 수 있습니다.

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=7b6378a1ee0aad5d3941193c6802312c" alt="DALL-E Image" data-og-width="670" width="670" data-og-height="670" height="670" data-path="images/enterprise/dall-e-image.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=95b3ae8ec53f789746846831fa981b32 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f880f86fa3b648a257ac74fcc7838dce 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c98e8fd36d462d3806c398c1f074efb2 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=68af7edd51913d04723c0fbae774ea1d 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=07c15be8399f83239d49e28f6667a28d 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/dall-e-image.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=619edc0ffc57a1eddd3cd7f9715b6b0a 2500w" />
</Frame>

1. **이미지 생성 프롬프트를 구체적으로 작성하세요**. 그래야 최상의 결과를 얻을 수 있습니다.
2. **생성 시간을 고려하세요** - 이미지 생성에는 시간이 걸릴 수 있으므로 작업 계획에 이를 반영하세요.
3. **사용 정책을 준수하세요** - 이미지를 생성할 때 항상 OpenAI의 사용 정책을 준수해야 합니다.

1. **API 접근 확인** - OpenAI API 키가 DALL-E에 접근 권한이 있는지 확인하세요.
2. **버전 호환성** - 최신 버전의 crewAI와 crewai-tools를 사용하고 있는지 확인하세요.
3. **도구 구성** - DALL-E 도구가 agent의 도구 목록에 올바르게 추가되어 있는지 확인하세요.

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="DALL-E 도구를 에이전트 구성에 추가하기">
```

Example 2 (unknown):
```unknown
</Step>
</Steps>

## DALL-E 도구 사용하기

DALL-E 도구를 에이전트에 추가하면 텍스트 프롬프트를 기반으로 이미지를 생성할 수 있습니다. 도구는 생성된 이미지의 URL을 반환하며, 이 URL은 에이전트의 출력에 사용하거나 다른 에이전트에게 전달하여 추가 처리를 할 수 있습니다.

### 예시 에이전트 구성
```

---

## URL이 알려졌거나 실행 중에 발견된 경우

**URL:** llms-txt#url이-알려졌거나-실행-중에-발견된-경우

---

## `OxylabsUniversalScraperTool`

**URL:** llms-txt#`oxylabsuniversalscrapertool`

**Contents:**
  - Exemplo

```python  theme={null}
from crewai_tools import OxylabsUniversalScraperTool

---

## Obtenha apenas ferramentas Jira específicas

**URL:** llms-txt#obtenha-apenas-ferramentas-jira-específicas

actions_list=["jira/create_issue", "jira/update_issue", "jira/search_by_jql"]
)

issue_coordinator = Agent(
    role="Issue Coordinator",
    goal="Criar e gerenciar issues Jira de forma eficiente",
    backstory="Um assistente de IA focado na criação e gestão de issues.",
    apps=['jira']
)

---

## Tarefa para criar um novo contato

**URL:** llms-txt#tarefa-para-criar-um-novo-contato

create_contact_task = Task(
    description="Criar um novo contato chamado 'João Silva' com email 'joao.silva@exemplo.com' e telefone '11-98765-4321'",
    agent=contacts_agent,
    expected_output="Novo contato criado com sucesso"
)

---

## Crie agente com LLM guardrailed

**URL:** llms-txt#crie-agente-com-llm-guardrailed

**Contents:**
  - 5. Rastreamento de Usuário com Metadados

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=portkey_llm
)
python  theme={null}
from crewai import Agent, LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
Os guardrails do Portkey podem:

* Detectar e redigir PII tanto em entradas quanto em saídas
* Filtrar conteúdo prejudicial ou inapropriado
* Validar formatos de resposta contra schemas
* Verificar alucinações comparando com ground truth
* Aplicar lógica e regras de negócio personalizadas

<Card title="Saiba Mais Sobre Guardrails" icon="shield-check" href="https://portkey.ai/docs/product/guardrails">
  Explore os recursos de guardrails do Portkey para aumentar a segurança dos agentes
</Card>

### 5. Rastreamento de Usuário com Metadados

Rastreie usuários individuais através dos seus agentes CrewAI utilizando o sistema de metadados do Portkey.

**O que é Metadata no Portkey?**

Metadados permitem associar dados personalizados a cada requisição, possibilitando filtragem, segmentação e analytics. O campo especial `_user` é projetado especificamente para rastreamento de usuário.
```

---

## Crie um agente com capacidades para Google Sheets

**URL:** llms-txt#crie-um-agente-com-capacidades-para-google-sheets

sheets_agent = Agent(
    role="Data Manager",
    goal="Gerenciar dados de planilha e rastrear informações de maneira eficiente",
    backstory="Um assistente de IA especializado em gestão de dados e operações em planilhas.",
    apps=['google_sheets']
)

---

## ✅ Solution: Provide better context and specific roles

**URL:** llms-txt#✅-solution:-provide-better-context-and-specific-roles

**Contents:**
  - 문제: 위임 루프

Task(
    description="""Write a technical blog post about machine learning.
    
    Context: Target audience is software developers with basic ML knowledge.
    Length: 1200 words
    Include: code examples, practical applications, best practices
    
    If you need specific technical details, delegate research to the researcher.""",
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 문제: 위임 루프

**증상:** 에이전트들이 무한히 서로에게 위임함
```

---

## Busca RAG em CSV

**URL:** llms-txt#busca-rag-em-csv

Source: https://docs.crewai.com/pt-BR/tools/file-document/csvsearchtool

O `CSVSearchTool` é uma poderosa ferramenta RAG (Geração com Recuperação Aprimorada) projetada para buscas semânticas no conteúdo de arquivos CSV.

---

## Add a PDF file

**URL:** llms-txt#add-a-pdf-file

rag_tool.add(data_type="file", path="path/to/your/document.pdf")

---

## RAG 도구

**URL:** llms-txt#rag-도구

Source: https://docs.crewai.com/ko/tools/ai-ml/ragtool

RagTool은 Retrieval-Augmented Generation을 사용하여 질문에 답변하는 동적 지식 기반 도구입니다.

---

## Raspar Site

**URL:** llms-txt#raspar-site

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/scrapewebsitetool

O `ScrapeWebsiteTool` foi desenvolvido para extrair e ler o conteúdo de um site especificado.

---

## Writer Agent

**URL:** llms-txt#writer-agent

role: "Technical Content Writer"
goal: "Transform research into engaging, clear content that educates and informs"
backstory: "You are an experienced writer who excels at explaining complex concepts..."

---

## Basic usage - will use task's expected_output as context

**URL:** llms-txt#basic-usage---will-use-task's-expected_output-as-context

guardrail = HallucinationGuardrail(
    llm=LLM(model="gpt-4o-mini")
)

---

## 에이전트가 사용할 수 있도록 도구를 초기화하는 예제

**URL:** llms-txt#에이전트가-사용할-수-있도록-도구를-초기화하는-예제

---

## Isso minimiza o overhead de conexão e melhora a performance de inicialização

**URL:** llms-txt#isso-minimiza-o-overhead-de-conexão-e-melhora-a-performance-de-inicialização

**Contents:**
- Melhores Práticas
  - 1. Use Ferramentas Específicas Quando Possível

**Examples:**

Example 1 (unknown):
```unknown
## Melhores Práticas

### 1. Use Ferramentas Específicas Quando Possível
```

---

## `PDFSearchTool`

**URL:** llms-txt#`pdfsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, então pode haver comportamentos inesperados ou mudanças futuras.
</Note>

O PDFSearchTool é uma ferramenta RAG projetada para buscas semânticas dentro do conteúdo de PDFs. Ela permite inserir uma consulta de busca e um documento PDF, aproveitando técnicas avançadas de busca para encontrar conteúdos relevantes de forma eficiente.
Essa capacidade a torna especialmente útil para extrair informações específicas de arquivos PDF grandes rapidamente.

Para começar a usar o PDFSearchTool, primeiro, garanta que o pacote crewai\_tools está instalado com o seguinte comando:

Veja como utilizar o PDFSearchTool para buscar dentro de um documento PDF:

```python Code theme={null}
from crewai_tools import PDFSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Veja como utilizar o PDFSearchTool para buscar dentro de um documento PDF:
```

---

## Corrija permissões

**URL:** llms-txt#corrija-permissões

chmod -R 755 ~/.local/share/CrewAI/
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Erros "Database is locked":**
```

---

## Avaliação Patronus AI

**URL:** llms-txt#avaliação-patronus-ai

**Contents:**
- Visão Geral
- Principais Funcionalidades
- Ferramentas de Avaliação
- Instalação
- Passos para Começar
- Exemplos
  - Utilizando PatronusEvalTool

[Patronus AI](https://patronus.ai) oferece capacidades abrangentes de avaliação e monitoramento para agentes CrewAI, permitindo avaliar as saídas dos modelos, comportamentos dos agentes e o desempenho geral do sistema. Essa integração possibilita implementar fluxos de avaliação contínuos que ajudam a manter a qualidade e confiabilidade em ambientes de produção.

## Principais Funcionalidades

* **Avaliação Automatizada**: Avaliação em tempo real das saídas e comportamentos dos agentes
* **Critérios Personalizados**: Defina critérios de avaliação específicos para seus casos de uso
* **Monitoramento de Desempenho**: Acompanhe métricas de desempenho dos agentes ao longo do tempo
* **Garantia de Qualidade**: Assegure consistência na qualidade das saídas em diferentes cenários
* **Segurança & Conformidade**: Monitore possíveis problemas e violações de políticas

## Ferramentas de Avaliação

A Patronus disponibiliza três principais ferramentas de avaliação para diferentes casos de uso:

1. **PatronusEvalTool**: Permite que os agentes selecionem o avaliador e os critérios mais apropriados para a tarefa de avaliação.
2. **PatronusPredefinedCriteriaEvalTool**: Utiliza avaliador e critérios predefinidos, especificados pelo usuário.
3. **PatronusLocalEvaluatorTool**: Utiliza avaliadores customizados definidos pelo usuário.

Para utilizar essas ferramentas, é necessário instalar o pacote Patronus:

Você também precisará configurar sua chave de API da Patronus como uma variável de ambiente:

## Passos para Começar

Para utilizar as ferramentas de avaliação da Patronus de forma eficaz, siga estes passos:

1. **Instale o Patronus**: Instale o pacote Patronus usando o comando acima.
2. **Configure a Chave de API**: Defina sua chave de API da Patronus como uma variável de ambiente.
3. **Escolha a Ferramenta Certa**: Selecione a ferramenta de avaliação Patronus mais adequada às suas necessidades.
4. **Configure a Ferramenta**: Configure a ferramenta com os parâmetros necessários.

### Utilizando PatronusEvalTool

O exemplo a seguir demonstra como usar o `PatronusEvalTool`, que permite aos agentes selecionar o avaliador e critérios mais apropriados:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import PatronusEvalTool

**Examples:**

Example 1 (unknown):
```unknown
Você também precisará configurar sua chave de API da Patronus como uma variável de ambiente:
```

Example 2 (unknown):
```unknown
## Passos para Começar

Para utilizar as ferramentas de avaliação da Patronus de forma eficaz, siga estes passos:

1. **Instale o Patronus**: Instale o pacote Patronus usando o comando acima.
2. **Configure a Chave de API**: Defina sua chave de API da Patronus como uma variável de ambiente.
3. **Escolha a Ferramenta Certa**: Selecione a ferramenta de avaliação Patronus mais adequada às suas necessidades.
4. **Configure a Ferramenta**: Configure a ferramenta com os parâmetros necessários.

## Exemplos

### Utilizando PatronusEvalTool

O exemplo a seguir demonstra como usar o `PatronusEvalTool`, que permite aos agentes selecionar o avaliador e critérios mais apropriados:
```

---

## SSE 트랜스포트

**URL:** llms-txt#sse-트랜스포트

**Contents:**
- 개요
- 주요 개념
- SSE를 통한 연결
  - 1. 완전 관리형 연결(권장)

Source: https://docs.crewai.com/ko/mcp/sse

서버 전송 이벤트(SSE)를 사용하여 CrewAI를 원격 MCP 서버에 연결하여 실시간 통신을 구현하는 방법을 알아보세요.

Server-Sent Events(SSE)는 웹 서버가 하나의 장기 실행 HTTP 연결을 통해 클라이언트에 업데이트를 전송할 수 있는 표준 방식을 제공합니다. MCP의 맥락에서 SSE는 원격 서버가 데이터(예: tool 응답)를 실시간으로 CrewAI 애플리케이션에 스트리밍하는 데 사용됩니다.

* **원격 서버**: SSE는 원격에 호스팅된 MCP 서버에 적합합니다.
* **단방향 스트림**: 일반적으로 SSE는 서버에서 클라이언트로의 단방향 통신 채널입니다.
* **`MCPServerAdapter` 구성**: SSE의 경우, 서버의 URL을 제공하고 전송 유형을 지정해야 합니다.

SSE 기반 MCP 서버에 연결하려면 연결 수명 주기를 관리하는 두 가지 주요 접근 방식을 사용할 수 있습니다.

Python 컨텍스트 매니저(`with` 문)를 사용하는 것이 권장되는 접근 방식입니다. 이 방법은 SSE MCP 서버에 대한 연결의 생성과 종료를 자동으로 처리합니다.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter

server_params = {
    "url": "http://localhost:8000/sse", # Replace with your actual SSE server URL
    "transport": "sse" 
}

---

## 도구 생성

**URL:** llms-txt#도구-생성

search_tool = SerperDevTool()
wiki_tool = WikipediaTools()

---

## Define the task

**URL:** llms-txt#define-the-task

research_task = Task(
    description="Research the latest AI advancements...",
    expected_output="",
    agent=researcher
)

---

## ❌ Vague descriptions that don't guide collaboration

**URL:** llms-txt#❌-vague-descriptions-that-don't-guide-collaboration

**Contents:**
- Troubleshooting Collaboration
  - Issue: Agents Not Collaborating

Task(description="Do some research about chatbots", ...)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Troubleshooting Collaboration

### Issue: Agents Not Collaborating

**Symptoms:** Agents work in isolation, no delegation occurs
```

---

## Crie agentes e tarefas normalmente

**URL:** llms-txt#crie-agentes-e-tarefas-normalmente

researcher = Agent(
    role="Research Specialist",
    goal="Find information on quantum computing",
    backstory="You are a quantum physics expert",
    verbose=True
)

research_task = Task(
    description="Research quantum computing applications",
    expected_output="A summary of practical applications",
    agent=researcher
)

---

## Behind the scenes, this might be rewritten as:

**URL:** llms-txt#behind-the-scenes,-this-might-be-rewritten-as:

**Contents:**
  - Eventos de Knowledge

rewritten_query = "What movies did John watch last week?"
python  theme={null}
from crewai.events import (
    KnowledgeRetrievalStartedEvent,
    KnowledgeRetrievalCompletedEvent,
    BaseEventListener,
)

class KnowledgeMonitorListener(BaseEventListener):
    def setup_listeners(self, crewai_event_bus):
        @crewai_event_bus.on(KnowledgeRetrievalStartedEvent)
        def on_knowledge_retrieval_started(source, event):
            print(f"Agent '{event.agent.role}' started retrieving knowledge")

@crewai_event_bus.on(KnowledgeRetrievalCompletedEvent)
        def on_knowledge_retrieval_completed(source, event):
            print(f"Agent '{event.agent.role}' completed knowledge retrieval")
            print(f"Query: {event.query}")
            print(f"Retrieved {len(event.retrieved_knowledge)} knowledge chunks")

**Examples:**

Example 1 (unknown):
```unknown
A consulta reescrita é mais focada na necessidade de informação principal e remove instruções irrelevantes sobre formatação de saída.

<Tip>
  Este mecanismo é totalmente automático e não requer configuração dos usuários. O LLM do agente é usado para realizar a reescrita da consulta, então usar um LLM mais capaz pode melhorar a qualidade das consultas reescritas.
</Tip>

### Eventos de Knowledge

O CrewAI emite eventos durante o processo de recuperação de knowledge que você pode escutar usando o sistema de eventos. Esses eventos permitem que você monitore, depure e analise como o knowledge está sendo recuperado e usado pelos seus agentes.

#### Eventos de Knowledge Disponíveis

* **KnowledgeRetrievalStartedEvent**: Emitido quando um agente começa a recuperar knowledge das fontes
* **KnowledgeRetrievalCompletedEvent**: Emitido quando a recuperação de knowledge é concluída, incluindo a consulta usada e o conteúdo recuperado
* **KnowledgeQueryStartedEvent**: Emitido quando uma consulta às fontes de knowledge começa
* **KnowledgeQueryCompletedEvent**: Emitido quando uma consulta é concluída com sucesso
* **KnowledgeQueryFailedEvent**: Emitido quando uma consulta às fontes de knowledge falha
* **KnowledgeSearchQueryFailedEvent**: Emitido quando uma consulta de pesquisa falha

#### Exemplo: Monitorando Recuperação de Knowledge
```

---

## Spider Scraper

**URL:** llms-txt#spider-scraper

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/spidertool

O `SpiderTool` foi projetado para extrair e ler o conteúdo de um site especificado usando o Spider.

---

## ...

**URL:** llms-txt#...

**Contents:**
- Utilizando Ambos os Hooks
- Conclusão

Na função `registrar_resultados`, os resultados da execução da crew são simplesmente impressos. Você pode estender isso para realizar operações mais complexas, como enviar notificações ou integrar com outros serviços.

## Utilizando Ambos os Hooks

Ambos os hooks podem ser usados juntos para oferecer um processo completo de preparação e finalização na execução da sua crew. Eles são particularmente úteis para manter uma arquitetura de código limpa, separando responsabilidades e melhorando a modularidade das suas implementações com CrewAI.

Os hooks antes e depois do kickoff em CrewAI oferecem formas poderosas de interagir com o ciclo de vida da execução de uma crew. Ao entender e utilizar esses hooks, você pode aumentar significativamente a robustez e flexibilidade dos seus agentes de IA.

---

## Create a task for the agent to extract specific content

**URL:** llms-txt#create-a-task-for-the-agent-to-extract-specific-content

extract_task = Task(
    description="Extract the main heading and summary from example.com",
    expected_output="The main heading and summary from the website",
    agent=web_scraper_agent,
)

---

## Datadog 통합

**URL:** llms-txt#datadog-통합

Source: https://docs.crewai.com/ko/observability/datadog

Datadog을 CrewAI와 통합하여 LLM Observability 트레이스들을 Datadog에 제출하는 방법을 알아보세요.

---

## Obter suas credenciais do Braintrust

**URL:** llms-txt#obter-suas-credenciais-do-braintrust

BRAINTRUST_API_KEY = getpass("🔑 Digite sua Chave de API do Braintrust: ")

---

## Create a LlamaIndex FunctionTool

**URL:** llms-txt#create-a-llamaindex-functiontool

og_tool = FunctionTool.from_defaults(
    search_data,
    name="DataSearchTool",
    description="Search for information in the data"
)

---

## Define custom input schema

**URL:** llms-txt#define-custom-input-schema

custom_inputs = {
    "year": Field(..., description="Year to retrieve the report for (integer)"),
    "region": Field(default="global", description="Geographic region for analysis"),
    "format": Field(default="summary", description="Report format (summary, detailed, raw)")
}

---

## `WebsiteSearchTool`

**URL:** llms-txt#`websitesearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo de Uso

<Note>
  O WebsiteSearchTool está atualmente em fase experimental. Estamos trabalhando ativamente para incorporar esta ferramenta em nosso conjunto de ofertas e atualizaremos a documentação conforme necessário.
</Note>

O WebsiteSearchTool foi concebido como um conceito para realizar buscas semânticas dentro do conteúdo de sites.
Ele visa aproveitar modelos avançados de aprendizado de máquina, como a Geração Aumentada por Recuperação (RAG), para navegar e extrair informações de URLs especificadas de forma eficiente.
Esta ferramenta pretende oferecer flexibilidade, permitindo que usuários realizem buscas em qualquer site ou foquem em sites específicos de seu interesse.
Por favor, note que os detalhes da implementação atual do WebsiteSearchTool estão em desenvolvimento, e as funcionalidades aqui descritas podem ainda não estar acessíveis.

Para preparar seu ambiente para quando o WebsiteSearchTool estiver disponível, você pode instalar o pacote fundamental com:

Este comando instala as dependências necessárias para garantir que, assim que a ferramenta estiver totalmente integrada, os usuários possam começar a usá-la imediatamente.

Abaixo estão exemplos de como o WebsiteSearchTool poderá ser utilizado em diferentes cenários. Por favor, observe que esses exemplos são ilustrativos e representam funcionalidades planejadas:

```python Code theme={null}
from crewai_tools import WebsiteSearchTool

**Examples:**

Example 1 (unknown):
```unknown
Este comando instala as dependências necessárias para garantir que, assim que a ferramenta estiver totalmente integrada, os usuários possam começar a usá-la imediatamente.

## Exemplo de Uso

Abaixo estão exemplos de como o WebsiteSearchTool poderá ser utilizado em diferentes cenários. Por favor, observe que esses exemplos são ilustrativos e representam funcionalidades planejadas:
```

---

## You can also see how the task description gets formatted

**URL:** llms-txt#you-can-also-see-how-the-task-description-gets-formatted

**Contents:**
  - Overriding Default Instructions

print("\n=== TASK CONTEXT ===")
print(f"Task Description: {task.description}")
print(f"Expected Output: {task.expected_output}")
python  theme={null}
from crewai import Agent

**Examples:**

Example 1 (unknown):
```unknown
### Overriding Default Instructions

You have several options to gain full control over the prompts:

#### Option 1: Custom Templates (Recommended)
```

---

## Modelo de raciocínio para planejamento estratégico

**URL:** llms-txt#modelo-de-raciocínio-para-planejamento-estratégico

manager_llm = LLM(model="gemini-2.5-flash-preview-05-20", temperature=0.1)

---

## 새로운 상태를 생성하는 것을 고려하세요:

**URL:** llms-txt#새로운-상태를-생성하는-것을-고려하세요:

**Contents:**
- 플로우 상태 디버깅
  - 상태 변경 로깅
  - 상태 시각화
- 결론
- 다음 단계

from pydantic import BaseModel
from typing import List

class ItemState(BaseModel):
    items: List[str] = []

class ImmutableFlow(Flow[ItemState]):
    @start()
    def add_item(self):
        # 추가된 항목과 함께 새로운 리스트 생성
        self.state.items = [*self.state.items, "new item"]
        return "Item added"
python  theme={null}
import logging
logging.basicConfig(level=logging.INFO)

class LoggingFlow(Flow):
    def log_state(self, step_name):
        logging.info(f"State after {step_name}: {self.state}")

@start()
    def initialize(self):
        self.state["counter"] = 0
        self.log_state("initialize")
        return "Initialized"

@listen(initialize)
    def increment(self, _):
        self.state["counter"] += 1
        self.log_state("increment")
        return f"Incremented to {self.state['counter']}"
python  theme={null}
def visualize_state(self):
    """Create a simple visualization of the current state"""
    import json
    from rich.console import Console
    from rich.panel import Panel

if hasattr(self.state, "model_dump"):
        # Pydantic v2
        state_dict = self.state.model_dump()
    elif hasattr(self.state, "dict"):
        # Pydantic v1
        state_dict = self.state.dict()
    else:
        # Unstructured state
        state_dict = dict(self.state)

# Remove id for cleaner output
    if "id" in state_dict:
        state_dict.pop("id")

state_json = json.dumps(state_dict, indent=2, default=str)
    console.print(Panel(state_json, title="Current Flow State"))
```

CrewAI Flows에서 상태 관리를 마스터하면 컨텍스트를 유지하고, 복잡한 결정을 내리며, 일관된 결과를 제공하는 정교하고 견고한 AI 애플리케이션을 구축할 수 있는 힘을 얻게 됩니다.

비구조화 상태든 구조화 상태든 적절한 상태 관리 방식을 구현하면 유지 관리가 용이하고, 확장 가능하며, 실제 문제를 효과적으로 해결할 수 있는 플로우를 만들 수 있습니다.

더 복잡한 플로우를 개발할수록 좋은 상태 관리는 유연성과 구조성 사이의 올바른 균형을 찾는 것임을 기억하세요. 이를 통해 코드가 강력하면서도 이해하기 쉬워집니다.

<Check>
  이제 CrewAI Flows에서 상태 관리의 개념과 실습을 마스터하셨습니다! 이 지식을 통해 컨텍스트를 효과적으로 유지하고, 단계 간 데이터를 공유하며, 정교한 애플리케이션 로직을 구현하는 견고한 AI 워크플로우를 만들 수 있습니다.
</Check>

* flow에서 구조화된 state와 비구조화된 state를 모두 실험해 보세요
* 장기 실행 워크플로를 위해 state 영속성을 구현해 보세요
* [첫 crew 만들기](/ko/guides/crews/first-crew)를 탐색하여 crew와 flow가 어떻게 함께 작동하는지 확인해 보세요
* 더 고급 기능을 원한다면 [Flow 참고 문서](/ko/concepts/flows)를 확인해 보세요

**Examples:**

Example 1 (unknown):
```unknown
## 플로우 상태 디버깅

### 상태 변경 로깅

개발할 때 상태 변화를 추적하기 위해 로깅을 추가하세요:
```

Example 2 (unknown):
```unknown
### 상태 시각화

디버깅을 위해 상태를 시각화하는 메서드를 추가할 수 있습니다:
```

---

## `AIMindTool`

**URL:** llms-txt#`aimindtool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

O `AIMindTool` é um wrapper em torno do [AI-Minds](https://mindsdb.com/minds) fornecido pela [MindsDB](https://mindsdb.com/). Ele permite que você consulte fontes de dados em linguagem natural, bastando configurar os parâmetros de conexão. Essa ferramenta é útil quando você precisa de respostas para perguntas utilizando dados armazenados em diversas fontes, incluindo PostgreSQL, MySQL, MariaDB, ClickHouse, Snowflake e Google BigQuery.

Minds são sistemas de IA que funcionam de forma similar aos grandes modelos de linguagem (LLMs), mas vão além ao responder qualquer pergunta sobre qualquer dado. Isso é realizado por meio de:

* Seleção dos dados mais relevantes para a resposta utilizando busca paramétrica
* Compreensão do significado e fornecimento de respostas dentro do contexto correto através de busca semântica
* Entrega de respostas precisas ao analisar dados e utilizar modelos de machine learning (ML)

Para incorporar esta ferramenta ao seu projeto, é necessário instalar o Minds SDK:

## Passos para Começar

Para utilizar o `AIMindTool` de maneira eficaz, siga estes passos:

1. **Instalação de Pacotes**: Verifique se os pacotes `crewai[tools]` e `minds-sdk` estão instalados no seu ambiente Python.
2. **Obtenção da Chave de API**: Cadastre-se para uma conta Minds [aqui](https://mdb.ai/register) e obtenha uma chave de API.
3. **Configuração do Ambiente**: Armazene sua chave de API obtida em uma variável de ambiente chamada `MINDS_API_KEY` para facilitar seu uso pela ferramenta.

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma consulta:

```python Code theme={null}
from crewai_tools import AIMindTool

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para utilizar o `AIMindTool` de maneira eficaz, siga estes passos:

1. **Instalação de Pacotes**: Verifique se os pacotes `crewai[tools]` e `minds-sdk` estão instalados no seu ambiente Python.
2. **Obtenção da Chave de API**: Cadastre-se para uma conta Minds [aqui](https://mdb.ai/register) e obtenha uma chave de API.
3. **Configuração do Ambiente**: Armazene sua chave de API obtida em uma variável de ambiente chamada `MINDS_API_KEY` para facilitar seu uso pela ferramenta.

## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma consulta:
```

---

## Create an agent with reasoning enabled

**URL:** llms-txt#create-an-agent-with-reasoning-enabled

agent = Agent(
    role="Analista de Dados",
    goal="Analisar dados e fornecer insights",
    reasoning=True,
    max_reasoning_attempts=3
)

---

## Exemplo de tarefa para extrair conteúdo de um site

**URL:** llms-txt#exemplo-de-tarefa-para-extrair-conteúdo-de-um-site

scrape_task = Task(
    description="Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.",
    expected_output="The main content from example.com's homepage.",
    agent=web_scraper_agent,
)

---

## SingleStore Search Tool

**URL:** llms-txt#singlestore-search-tool

Source: https://docs.crewai.com/pt-BR/tools/database-data/singlestoresearchtool

The `SingleStoreSearchTool` safely executes SELECT/SHOW queries on SingleStore with pooling.

---

## `LinkupSearchTool`

**URL:** llms-txt#`linkupsearchtool`

**Contents:**
- Descrição
- Instalação
- Passos para começar
- Exemplo

O `LinkupSearchTool` fornece a capacidade de consultar a API do Linkup para obter informações contextuais e recuperar resultados estruturados. Esta ferramenta é ideal para enriquecer fluxos de trabalho com informações atualizadas e confiáveis do Linkup, permitindo que agentes acessem dados relevantes durante a execução de suas tarefas.

Para utilizar esta ferramenta, é necessário instalar o Linkup SDK:

## Passos para começar

Para usar efetivamente o `LinkupSearchTool`, siga estes passos:

1. **Chave de API**: Obtenha uma chave de API do Linkup.
2. **Configuração do Ambiente**: Configure seu ambiente com a chave de API.
3. **Instalar SDK**: Instale o Linkup SDK usando o comando acima.

O exemplo a seguir demonstra como inicializar a ferramenta e usá-la em um agente:

```python Code theme={null}
from crewai_tools import LinkupSearchTool
from crewai import Agent
import os

**Examples:**

Example 1 (unknown):
```unknown
## Passos para começar

Para usar efetivamente o `LinkupSearchTool`, siga estes passos:

1. **Chave de API**: Obtenha uma chave de API do Linkup.
2. **Configuração do Ambiente**: Configure seu ambiente com a chave de API.
3. **Instalar SDK**: Instale o Linkup SDK usando o comando acima.

## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e usá-la em um agente:
```

---

## Optionally export them if you need to access them elsewhere

**URL:** llms-txt#optionally-export-them-if-you-need-to-access-them-elsewhere

__all__ = ['my_custom_listener', 'another_listener']
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
4. Import your listeners package in your Crew or Flow file:
```

---

## Google Serper 검색

**URL:** llms-txt#google-serper-검색

Source: https://docs.crewai.com/ko/tools/search-research/serperdevtool

SerperDevTool은(는) 인터넷을 검색하여 가장 관련성 높은 결과를 반환하도록 설계되었습니다.

---

## Get your Phoenix Cloud credentials

**URL:** llms-txt#get-your-phoenix-cloud-credentials

PHOENIX_API_KEY = getpass("🔑 Enter your Phoenix Cloud API Key: ")

---

## Google Docs 통합

**URL:** llms-txt#google-docs-통합

**Contents:**
- 개요
- 전제 조건
- Google Docs 통합 설정
  - 1. Google 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Google Docs 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/google_docs

CrewAI를 위한 Google Docs 통합으로 문서 생성 및 편집.

에이전트가 텍스트 조작 및 서식을 사용하여 Google Docs 문서를 생성, 편집 및 관리할 수 있도록 합니다. AI 기반 자동화로 문서 생성을 자동화하고, 텍스트를 삽입 및 교체하고, 콘텐츠 범위를 관리하며, 문서 워크플로를 간소화합니다.

Google Docs 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Google Docs 액세스 권한이 있는 Google 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Google 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Google Docs** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 문서 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="google_docs/create_document">
    **설명:** 새 Google 문서를 만듭니다.

* `title` (string, 선택사항): 새 문서의 제목.
  </Accordion>

<Accordion title="google_docs/get_document">
    **설명:** Google 문서의 내용과 메타데이터를 가져옵니다.

* `documentId` (string, 필수): 검색할 문서의 ID.
    * `includeTabsContent` (boolean, 선택사항): 탭 내용을 포함할지 여부. 기본값: false
    * `suggestionsViewMode` (string, 선택사항): 문서에 적용할 제안 보기 모드. 옵션: DEFAULT\_FOR\_CURRENT\_ACCESS, PREVIEW\_SUGGESTIONS\_ACCEPTED, PREVIEW\_WITHOUT\_SUGGESTIONS. 기본값: DEFAULT\_FOR\_CURRENT\_ACCESS
  </Accordion>

<Accordion title="google_docs/batch_update">
    **설명:** Google 문서에 하나 이상의 업데이트를 적용합니다.

* `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `requests` (array, 필수): 문서에 적용할 업데이트 목록. 각 항목은 요청을 나타내는 객체.
    * `writeControl` (object, 선택사항): 쓰기 요청이 실행되는 방식을 제어합니다. `requiredRevisionId` (string)와 `targetRevisionId` (string)를 포함.
  </Accordion>

<Accordion title="google_docs/insert_text">
    **설명:** Google 문서의 특정 위치에 텍스트를 삽입합니다.

* `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `text` (string, 필수): 삽입할 텍스트.
    * `index` (integer, 선택사항): 텍스트를 삽입할 0 기반 인덱스. 기본값: 1
  </Accordion>

<Accordion title="google_docs/replace_text">
    **설명:** Google 문서에서 텍스트의 모든 인스턴스를 교체합니다.

* `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `containsText` (string, 필수): 찾아서 교체할 텍스트.
    * `replaceText` (string, 필수): 교체할 텍스트.
    * `matchCase` (boolean, 선택사항): 검색이 대소문자를 구분할지 여부. 기본값: false
  </Accordion>

<Accordion title="google_docs/delete_content_range">
    **설명:** Google 문서의 특정 범위에서 내용을 삭제합니다.

* `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `startIndex` (integer, 필수): 삭제할 범위의 시작 인덱스.
    * `endIndex` (integer, 필수): 삭제할 범위의 끝 인덱스.
  </Accordion>

<Accordion title="google_docs/insert_page_break">
    **설명:** Google 문서의 특정 위치에 페이지 나누기를 삽입합니다.

* `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `index` (integer, 선택사항): 페이지 나누기를 삽입할 0 기반 인덱스. 기본값: 1
  </Accordion>

<Accordion title="google_docs/create_named_range">
    **설명:** Google 문서에 명명된 범위를 만듭니다.

* `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `name` (string, 필수): 명명된 범위의 이름.
    * `startIndex` (integer, 필수): 범위의 시작 인덱스.
    * `endIndex` (integer, 필수): 범위의 끝 인덱스.
  </Accordion>
</AccordionGroup>

### 기본 Google Docs 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="google_docs/create_document">
    **설명:** 새 Google 문서를 만듭니다.

    **매개변수:**

    * `title` (string, 선택사항): 새 문서의 제목.
  </Accordion>

  <Accordion title="google_docs/get_document">
    **설명:** Google 문서의 내용과 메타데이터를 가져옵니다.

    **매개변수:**

    * `documentId` (string, 필수): 검색할 문서의 ID.
    * `includeTabsContent` (boolean, 선택사항): 탭 내용을 포함할지 여부. 기본값: false
    * `suggestionsViewMode` (string, 선택사항): 문서에 적용할 제안 보기 모드. 옵션: DEFAULT\_FOR\_CURRENT\_ACCESS, PREVIEW\_SUGGESTIONS\_ACCEPTED, PREVIEW\_WITHOUT\_SUGGESTIONS. 기본값: DEFAULT\_FOR\_CURRENT\_ACCESS
  </Accordion>

  <Accordion title="google_docs/batch_update">
    **설명:** Google 문서에 하나 이상의 업데이트를 적용합니다.

    **매개변수:**

    * `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `requests` (array, 필수): 문서에 적용할 업데이트 목록. 각 항목은 요청을 나타내는 객체.
    * `writeControl` (object, 선택사항): 쓰기 요청이 실행되는 방식을 제어합니다. `requiredRevisionId` (string)와 `targetRevisionId` (string)를 포함.
  </Accordion>

  <Accordion title="google_docs/insert_text">
    **설명:** Google 문서의 특정 위치에 텍스트를 삽입합니다.

    **매개변수:**

    * `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `text` (string, 필수): 삽입할 텍스트.
    * `index` (integer, 선택사항): 텍스트를 삽입할 0 기반 인덱스. 기본값: 1
  </Accordion>

  <Accordion title="google_docs/replace_text">
    **설명:** Google 문서에서 텍스트의 모든 인스턴스를 교체합니다.

    **매개변수:**

    * `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `containsText` (string, 필수): 찾아서 교체할 텍스트.
    * `replaceText` (string, 필수): 교체할 텍스트.
    * `matchCase` (boolean, 선택사항): 검색이 대소문자를 구분할지 여부. 기본값: false
  </Accordion>

  <Accordion title="google_docs/delete_content_range">
    **설명:** Google 문서의 특정 범위에서 내용을 삭제합니다.

    **매개변수:**

    * `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `startIndex` (integer, 필수): 삭제할 범위의 시작 인덱스.
    * `endIndex` (integer, 필수): 삭제할 범위의 끝 인덱스.
  </Accordion>

  <Accordion title="google_docs/insert_page_break">
    **설명:** Google 문서의 특정 위치에 페이지 나누기를 삽입합니다.

    **매개변수:**

    * `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `index` (integer, 선택사항): 페이지 나누기를 삽입할 0 기반 인덱스. 기본값: 1
  </Accordion>

  <Accordion title="google_docs/create_named_range">
    **설명:** Google 문서에 명명된 범위를 만듭니다.

    **매개변수:**

    * `documentId` (string, 필수): 업데이트할 문서의 ID.
    * `name` (string, 필수): 명명된 범위의 이름.
    * `startIndex` (integer, 필수): 범위의 시작 인덱스.
    * `endIndex` (integer, 필수): 범위의 끝 인덱스.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Google Docs 에이전트 설정
```

---

## Accessing the task output

**URL:** llms-txt#accessing-the-task-output

**Contents:**
- 마크다운 출력 포매팅
  - 마크다운(Markdown) 포매팅 사용하기

task_output = task.output

print(f"Task Description: {task_output.description}")
print(f"Task Summary: {task_output.summary}")
print(f"Raw Output: {task_output.raw}")
if task_output.json_dict:
    print(f"JSON Output: {json.dumps(task_output.json_dict, indent=2)}")
if task_output.pydantic:
    print(f"Pydantic Output: {task_output.pydantic}")
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 마크다운 출력 포매팅

`markdown` 매개변수는 작업 출력에 대해 자동 마크다운 포매팅을 활성화합니다. 이 값을 `True`로 설정하면, 작업은 에이전트에게 최종 답변을 올바른 마크다운 문법으로 포매팅하도록 지시합니다.

### 마크다운(Markdown) 포매팅 사용하기
```

---

## Example task to search for information in a specific video

**URL:** llms-txt#example-task-to-search-for-information-in-a-specific-video

research_task = Task(
    description="Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}",
    expected_output="A summary of the key machine learning frameworks mentioned in the video.",
    agent=video_researcher,
)

---

## Defina seu próprio template de sistema sem instruções padrão

**URL:** llms-txt#defina-seu-próprio-template-de-sistema-sem-instruções-padrão

**Contents:**
  - Depuração com Ferramentas de Observabilidade
  - Boas Práticas para Produção
- Melhores Práticas para Gerenciar Arquivos de Prompt
- O Jeito Mais Simples de Personalizar Prompts
  - Exemplo: Customização Básica de Prompt

custom_system_template = """You are {role}. {backstory}
Your goal is: {goal}

Respond naturally and conversationally. Focus on providing helpful, accurate information."""

custom_prompt_template = """Task: {input}

Please complete this task thoughtfully."""

agent = Agent(
    role="Research Assistant",
    goal="Help users find accurate information",
    backstory="You are a helpful research assistant.",
    system_template=custom_system_template,
    prompt_template=custom_prompt_template,
    use_system_prompt=True  # Use mensagens separadas system/user
)
json  theme={null}
{
  "slices": {
    "no_tools": "\nProvide your best answer in a natural, conversational way.",
    "tools": "\nYou have access to these tools: {tools}\n\nUse them when helpful, but respond naturally.",
    "formatted_task_instructions": "Format your response as: {output_format}"
  }
}
python  theme={null}
crew = Crew(
    agents=[agent],
    tasks=[task],
    prompt_file="custom_prompts.json",
    verbose=True
)
python  theme={null}
agent = Agent(
    role="Analyst",
    goal="Analyze data",
    backstory="Expert analyst",
    use_system_prompt=False  # Desativa separação de mensagens system prompt
)
json  theme={null}
{
  "slices": {
    "format": "When responding, follow this structure:\n\nTHOUGHTS: Your step-by-step thinking\nACTION: Any tool you're using\nRESULT: Your final answer or conclusion"
  }
}
python  theme={null}
from crewai import Agent, Crew, Task, Process

**Examples:**

Example 1 (unknown):
```unknown
#### Opção 2: Arquivo de Prompt Personalizado

Crie um arquivo `custom_prompts.json` para sobrescrever slices específicas de prompt:
```

Example 2 (unknown):
```unknown
Em seguida, utilize no seu crew:
```

Example 3 (unknown):
```unknown
#### Opção 3: Desativar Prompts de Sistema para Modelos o1
```

Example 4 (unknown):
```unknown
### Depuração com Ferramentas de Observabilidade

Para garantir transparência em produção, integre com plataformas de observabilidade para monitorar todos os prompts e interações com LLM. Isso permite que você veja exatamente quais prompts (incluindo instruções padrão) estão sendo enviados para os seus LLMs.

Veja nossa [documentação sobre Observabilidade](/pt-BR/observability/overview) para guias detalhados de integração com diversas plataformas como Langfuse, MLflow, Weights & Biases e soluções de logging customizadas.

### Boas Práticas para Produção

1. **Sempre inspecione prompts gerados** antes de implantar em produção
2. **Use templates customizados** quando precisar de controle total sobre o conteúdo do prompt
3. **Integre ferramentas de observabilidade** para monitoramento contínuo de prompts (veja [docs de Observabilidade](/pt-BR/observability/overview))
4. **Teste com diferentes LLMs** já que instruções padrão podem se comportar de maneira diferente em cada modelo
5. **Documente suas customizações de prompt** para transparência da equipe

<Tip>
  As instruções padrão existem para garantir comportamento consistente nos agentes, mas podem interferir com requisitos de domínio específicos. Use as opções de customização acima para manter controle total sobre o comportamento do seu agente em sistemas de produção.
</Tip>

## Melhores Práticas para Gerenciar Arquivos de Prompt

Ao realizar personalização de prompts em baixo nível, siga estas diretrizes para manter tudo organizado e fácil de manter:

1. **Mantenha arquivos separados** – Armazene seus prompts personalizados em arquivos JSON dedicados fora do código principal.
2. **Controle de versão** – Acompanhe as alterações no seu repositório, garantindo documentação clara das mudanças nos prompts ao longo do tempo.
3. **Organize por modelo ou idioma** – Utilize nomes como `prompts_llama.json` ou `prompts_es.json` para identificar rapidamente configurações especializadas.
4. **Documente as alterações** – Adicione comentários ou mantenha um README detalhando o propósito e o escopo das customizações.
5. **Minimize alterações** – Sobrescreva apenas os slices específicos que realmente precisam de ajuste, mantendo a funcionalidade padrão para o restante.

## O Jeito Mais Simples de Personalizar Prompts

Uma abordagem direta é criar um arquivo JSON para os prompts que deseja sobrescrever e então indicar este arquivo no seu Crew:

1. Crie um arquivo JSON com os slices de prompt atualizados.
2. Referencie este arquivo no parâmetro `prompt_file` do seu Crew.

O CrewAI então mescla suas customizações com os padrões, assim você não precisa redefinir todos os prompts. Veja como:

### Exemplo: Customização Básica de Prompt

Crie um arquivo `custom_prompts.json` com os prompts que deseja modificar. Certifique-se de listar todos os prompts de nível superior que ele deve conter, não apenas suas alterações:
```

---

## Fingerprinting

**URL:** llms-txt#fingerprinting

**Contents:**
- Overview
- How Fingerprints Work
- Basic Usage
  - Accessing Fingerprints

Source: https://docs.crewai.com/en/guides/advanced/fingerprinting

Learn how to use CrewAI's fingerprinting system to uniquely identify and track components throughout their lifecycle.

Fingerprints in CrewAI provide a way to uniquely identify and track components throughout their lifecycle. Each `Agent`, `Crew`, and `Task` automatically receives a unique fingerprint when created, which cannot be manually overridden.

These fingerprints can be used for:

* Auditing and tracking component usage
* Ensuring component identity integrity
* Attaching metadata to components
* Creating a traceable chain of operations

## How Fingerprints Work

A fingerprint is an instance of the `Fingerprint` class from the `crewai.security` module. Each fingerprint contains:

* A UUID string: A unique identifier for the component that is automatically generated and cannot be manually set
* A creation timestamp: When the fingerprint was generated, automatically set and cannot be manually modified
* Metadata: A dictionary of additional information that can be customized

Fingerprints are automatically generated and assigned when a component is created. Each component exposes its fingerprint through a read-only property.

### Accessing Fingerprints

```python  theme={null}
from crewai import Agent, Crew, Task

---

## LangGraph Agent Adapter

**URL:** llms-txt#langgraph-agent-adapter

reporter_agent = LangGraphAgentAdapter(
    role="Reporter",
    goal="Report the results of the tasks.",
    backstory="You are a reporter who reports the results of the other tasks",
    llm=ChatOpenAI(model="gpt-4o"),
    allow_delegation=True,
    verbose=True,
)

class Code(BaseModel):
    code: str

task = Task(
    description="Give an answer to the coding question: {task}",
    expected_output="A thorough answer to the coding question: {task}",
    agent=code_helper_agent,
    output_json=Code,
)
task2 = Task(
    description="Find links to resources that can help with coding tasks. Use the serper tool to find resources that can help.",
    expected_output="A list of links to resources that can help with coding tasks",
    agent=link_finder_agent,
)

class Report(BaseModel):
    code: str
    links: List[str]

task3 = Task(
    description="Report the results of the tasks.",
    expected_output="A report of the results of the tasks. this is the code produced and then the links to the resources that can help with the coding task.",
    agent=reporter_agent,
    output_json=Report,
)

---

## Initialize the tool with a specific YouTube video URL

**URL:** llms-txt#initialize-the-tool-with-a-specific-youtube-video-url

youtube_search_tool = YoutubeVideoSearchTool(
    youtube_video_url='https://youtube.com/watch?v=example'
)

---

## Create a task

**URL:** llms-txt#create-a-task

task = Task(
    description="Analise os dados de vendas fornecidos e identifique as principais tendências.",
    expected_output="Um relatório destacando as 3 principais tendências de vendas.",
    agent=agent
)

---

## Define o modelo Pydantic para o blog

**URL:** llms-txt#define-o-modelo-pydantic-para-o-blog

class Blog(BaseModel):
    title: str
    content: str

---

## Task to create a new issue

**URL:** llms-txt#task-to-create-a-new-issue

create_issue_task = Task(
    description="Create a bug report issue for the login functionality in the main repository",
    agent=github_agent,
    expected_output="Issue created successfully with issue number"
)

---

## Braintrust 자격 증명 가져오기

**URL:** llms-txt#braintrust-자격-증명-가져오기

BRAINTRUST_API_KEY = getpass("🔑 Braintrust API 키를 입력하세요: ")

---

## Traga seu próprio agente

**URL:** llms-txt#traga-seu-próprio-agente

**Contents:**
- Guia de Adaptação para trazer seus próprios agentes (Agentes Langgraph, Agentes OpenAI, etc...)
- BaseAgentAdapter
- Criando seu próprio Adaptador
- Implementação de BaseToolAdapter
- BaseConverter
- Adapters prontos para uso
- Iniciando uma crew com agentes adaptados:

Source: https://docs.crewai.com/pt-BR/learn/bring-your-own-agent

Aprenda como trazer seus próprios agentes que funcionam dentro de uma Crew.

Interoperabilidade é um conceito fundamental no CrewAI. Este guia mostrará como trazer seus próprios agentes para funcionar dentro de uma Crew.

## Guia de Adaptação para trazer seus próprios agentes (Agentes Langgraph, Agentes OpenAI, etc...)

Requeremos 3 adaptadores para tornar qualquer agente de diferentes frameworks compatível com uma crew.

1. BaseAgentAdapter
2. BaseToolAdapter
3. BaseConverter

Esta classe abstrata define a interface comum e a funcionalidade que todos
os adaptadores de agente devem implementar. Ela estende BaseAgent para manter compatibilidade
com o framework CrewAI, ao mesmo tempo em que adiciona requisitos específicos do adaptador.

Métodos obrigatórios:

1. `def configure_tools`
2. `def configure_structured_output`

## Criando seu próprio Adaptador

Para integrar um agente de um framework diferente (por exemplo, LangGraph, Autogen, OpenAI Assistants) ao CrewAI, você precisa criar um adaptador customizado herdando de `BaseAgentAdapter`. Esse adaptador atua como uma camada de compatibilidade, traduzindo entre as interfaces do CrewAI e os requisitos específicos do seu agente externo.

Veja como implementar seu adaptador customizado:

1. **Herdar de `BaseAgentAdapter`**:

2. **Implementar `__init__`**:
   O construtor deve chamar o construtor da classe pai `super().__init__(**kwargs)` e executar qualquer inicialização específica do seu agente externo. Você pode usar o dicionário opcional `agent_config` passado durante a inicialização do `Agent` do CrewAI para configurar seu adaptador e o agente subjacente.

3. **Implementar `configure_tools`**:
   Este método abstrato é crucial. Ele recebe uma lista de instâncias de `BaseTool` do CrewAI. Sua implementação deve converter ou adaptar essas ferramentas para o formato esperado pelo seu framework de agente externo. Isso pode envolver encapsulamento, extração de atributos específicos ou registro delas na instância do agente externo.

4. **Implementar `configure_structured_output`**:
   Esse método é chamado quando o `Agent` do CrewAI é configurado com requisitos de saída estruturada (por exemplo, `output_json` ou `output_pydantic`). Seu adaptador precisa garantir que o agente externo esteja configurado para cumprir esses requisitos. Isso pode envolver definir parâmetros específicos no agente externo ou garantir que seu modelo subjacente suporte o formato solicitado. Se o agente externo não suportar saída estruturada de forma compatível com as expectativas do CrewAI, talvez seja necessário lidar com a conversão ou lançar um erro apropriado.

Implementando esses métodos, seu `MyCustomAgentAdapter` permitirá que sua implementação personalizada de agente funcione corretamente dentro de uma crew do CrewAI, interagindo com tarefas e ferramentas de forma transparente. Lembre-se de substituir os comentários e prints de exemplo pela sua lógica real de adaptação específica do framework externo que está integrando.

## Implementação de BaseToolAdapter

A classe `BaseToolAdapter` é responsável por converter os objetos nativos `BaseTool` do CrewAI em um formato que o seu framework de agente externo possa entender e utilizar. Diferentes frameworks de agentes (como LangGraph, OpenAI Assistants, etc.) possuem suas próprias formas de definir e tratar ferramentas, e o `BaseToolAdapter` age como tradutor.

Veja como implementar seu adaptador de ferramentas personalizado:

1. **Herdar de `BaseToolAdapter`**:

2. **Implementar `configure_tools`**:
   Este é o método abstrato principal que você deve implementar. Ele recebe uma lista de instâncias de `BaseTool` fornecidas ao agente. Sua tarefa é iterar por essa lista, adaptar cada `BaseTool` para o formato esperado pelo seu framework externo e armazenar as ferramentas convertidas na lista `self.converted_tools` (inicializada no construtor da classe base).

3. **Utilizando o Adaptador**:
   Normalmente, você instanciaria seu `MyCustomToolAdapter` dentro do método `configure_tools` do seu `MyCustomAgentAdapter` e o usaria para processar as ferramentas antes de configurar o agente externo.

Ao criar um `BaseToolAdapter`, você desacopla a lógica de conversão de ferramenta da adaptação de agente, tornando a integração mais limpa e modular. Lembre-se de substituir os exemplos de placeholder pela lógica de conversão real exigida pelo seu framework externo específico.

O `BaseConverterAdapter` desempenha um papel crucial quando uma `Task` do CrewAI exige que um agente retorne sua saída final em um formato estruturado específico, como JSON ou um modelo Pydantic. Ele faz a ponte entre os requisitos de saída estruturada do CrewAI e as capacidades do seu agente externo.

Suas responsabilidades principais são:

1. **Configurar o Agente para Saída Estruturada:** Com base nos requisitos da `Task` (`output_json` ou `output_pydantic`), ele instrui o `BaseAgentAdapter` associado (e indiretamente, o agente externo) sobre qual formato é esperado.
2. **Apriorar o Prompt do Sistema:** Ele modifica o prompt do sistema do agente para incluir instruções claras sobre *como* gerar a saída na estrutura exigida.
3. **Pós-processamento do Resultado:** Pega a saída bruta do agente e tenta fazer parsing, validar e formatar conforme a estrutura requerida, retornando por fim uma representação em string (por exemplo, uma string JSON).

Veja como implementar seu adaptador de conversão customizado:

1. **Herdar de `BaseConverterAdapter`**:

2. **Implementar `__init__`**:
   O construtor deve aceitar a instância correspondente de `agent_adapter` com a qual irá trabalhar.

3. **Implementar `configure_structured_output`**:
   Esse método recebe o objeto `Task` do CrewAI. Você precisa checar os atributos `output_json` e `output_pydantic` da task para determinar a estrutura de saída exigida. Armazene essa informação (por exemplo, em `_output_type` e `_output_schema`) e, potencialmente, chame métodos de configuração no seu `self.agent_adapter` se o agente externo necessitar de um ajuste específico para saída estruturada (algo que pode já ter sido parcialmente feito no `configure_structured_output` do adaptador de agente).

4. **Implementar `enhance_system_prompt`**:
   Este método recebe o prompt base do sistema do agente e deve anexar instruções adaptadas para o `_output_type` e `_output_schema` atualmente configurados. O objetivo é guiar o LLM que alimenta o agente a produzir saída no formato correto.

json\n{schema_str}\njson\n{schema_str}\n`

*Nota: O prompt pode precisar de ajustes conforme o agente/LLM usado.*

5. **Implementar `post_process_result`**:
   Esse método recebe a saída em string bruta do agente. Se uma saída estruturada foi solicitada (`json` ou `pydantic`), você deve tentar convertê-la para o formato esperado. Trate erros de parsing caso ocorram (por exemplo, registre-os, tente corrigir, ou lance uma exceção). O método **deve sempre retornar uma string**, mesmo se o formato intermediário seja um dicionário ou objeto Pydantic (por exemplo, serializando novamente para JSON).

Implementando esses métodos, seu `MyCustomConverterAdapter` assegurará que as solicitações de saída estruturada das tarefas do CrewAI sejam corretamente tratadas pelo seu agente externo integrado, aumentando a confiabilidade e a usabilidade do seu agente customizado dentro do framework CrewAI.

## Adapters prontos para uso

Fornecemos adapters prontos para uso para os seguintes frameworks:

1. LangGraph
2. Agentes OpenAI

## Iniciando uma crew com agentes adaptados:

```python  theme={null}
import json
import os
from typing import List

from crewai_tools import SerperDevTool
from src.crewai import Agent, Crew, Task
from langchain_openai import ChatOpenAI
from pydantic import BaseModel

from crewai.agents.agent_adapters.langgraph.langgraph_adapter import (
    LangGraphAgentAdapter,
)
from crewai.agents.agent_adapters.openai_agents.openai_adapter import OpenAIAgentAdapter

**Examples:**

Example 1 (unknown):
```unknown
2. **Implementar `__init__`**:
   O construtor deve chamar o construtor da classe pai `super().__init__(**kwargs)` e executar qualquer inicialização específica do seu agente externo. Você pode usar o dicionário opcional `agent_config` passado durante a inicialização do `Agent` do CrewAI para configurar seu adaptador e o agente subjacente.
```

Example 2 (unknown):
```unknown
3. **Implementar `configure_tools`**:
   Este método abstrato é crucial. Ele recebe uma lista de instâncias de `BaseTool` do CrewAI. Sua implementação deve converter ou adaptar essas ferramentas para o formato esperado pelo seu framework de agente externo. Isso pode envolver encapsulamento, extração de atributos específicos ou registro delas na instância do agente externo.
```

Example 3 (unknown):
```unknown
4. **Implementar `configure_structured_output`**:
   Esse método é chamado quando o `Agent` do CrewAI é configurado com requisitos de saída estruturada (por exemplo, `output_json` ou `output_pydantic`). Seu adaptador precisa garantir que o agente externo esteja configurado para cumprir esses requisitos. Isso pode envolver definir parâmetros específicos no agente externo ou garantir que seu modelo subjacente suporte o formato solicitado. Se o agente externo não suportar saída estruturada de forma compatível com as expectativas do CrewAI, talvez seja necessário lidar com a conversão ou lançar um erro apropriado.
```

Example 4 (unknown):
```unknown
Implementando esses métodos, seu `MyCustomAgentAdapter` permitirá que sua implementação personalizada de agente funcione corretamente dentro de uma crew do CrewAI, interagindo com tarefas e ferramentas de forma transparente. Lembre-se de substituir os comentários e prints de exemplo pela sua lógica real de adaptação específica do framework externo que está integrando.

## Implementação de BaseToolAdapter

A classe `BaseToolAdapter` é responsável por converter os objetos nativos `BaseTool` do CrewAI em um formato que o seu framework de agente externo possa entender e utilizar. Diferentes frameworks de agentes (como LangGraph, OpenAI Assistants, etc.) possuem suas próprias formas de definir e tratar ferramentas, e o `BaseToolAdapter` age como tradutor.

Veja como implementar seu adaptador de ferramentas personalizado:

1. **Herdar de `BaseToolAdapter`**:
```

---

## Busca RAG em PDF

**URL:** llms-txt#busca-rag-em-pdf

Source: https://docs.crewai.com/pt-BR/tools/file-document/pdfsearchtool

O `PDFSearchTool` é projetado para pesquisar arquivos PDF e retornar os resultados mais relevantes.

---

## Ferramentas MCP agora estão automaticamente disponíveis para seu agente!

**URL:** llms-txt#ferramentas-mcp-agora-estão-automaticamente-disponíveis-para-seu-agente!

**Contents:**
  - 🔧 **Avançado: MCPServerAdapter** (Para Cenários Complexos)
- Tutorial em Vídeo
- Instalação
- Conceitos Chave & Primeiros Passos
- Configuração de Conexão

shell  theme={null}
uv pip install 'crewai-tools[mcp]'
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 🔧 **Avançado: MCPServerAdapter** (Para Cenários Complexos)

Para casos de uso avançados que requerem gerenciamento manual de conexão, a biblioteca `crewai-tools` fornece a classe `MCPServerAdapter`.

Atualmente, suportamos os seguintes mecanismos de transporte:

* **HTTPS**: para servidores remotos (comunicação segura via HTTPS)
* **Server-Sent Events (SSE)**: para servidores remotos (transmissão de dados unidirecional em tempo real do servidor para o cliente via HTTP)
* **Streamable HTTP**: para servidores remotos (comunicação flexível e potencialmente bidirecional via HTTP, geralmente utilizando SSE para streams do servidor para o cliente)

## Tutorial em Vídeo

Assista a este tutorial em vídeo para um guia abrangente sobre a integração do MCP com o CrewAI:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/TpQ45lAZh48" title="CrewAI MCP Integration Guide" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

## Instalação

Antes de começar a usar MCP com `crewai-tools`, é necessário instalar a dependência extra `mcp` do `crewai-tools` com o seguinte comando:
```

Example 2 (unknown):
```unknown
## Conceitos Chave & Primeiros Passos

A classe `MCPServerAdapter` da `crewai-tools` é a principal forma de conectar-se a um servidor MCP e disponibilizar suas ferramentas aos seus agentes CrewAI. Ela suporta diferentes mecanismos de transporte e simplifica o gerenciamento de conexões.

O uso de um gerenciador de contexto Python (`with`) é a **abordagem recomendada** para o `MCPServerAdapter`. Ele lida automaticamente com a abertura e o fechamento da conexão com o servidor MCP.

## Configuração de Conexão

O `MCPServerAdapter` suporta várias opções de configuração para personalizar o comportamento da conexão:

* **`connect_timeout`** (opcional): Tempo máximo em segundos para aguardar o estabelecimento de uma conexão com o servidor MCP. O padrão é 30 segundos se não especificado. Isso é particularmente útil para servidores remotos que podem ter tempos de resposta variáveis.
```

---

## S3 Reader Tool

**URL:** llms-txt#s3-reader-tool

Source: https://docs.crewai.com/pt-BR/tools/cloud-storage/s3readertool

O `S3ReaderTool` permite que agentes CrewAI leiam arquivos de buckets Amazon S3.

---

## 사용 가능한 모든 트리거 보기

**URL:** llms-txt#사용-가능한-모든-트리거-보기

---

## 에이전트 생성은 빠름 - 아직 MCP 연결을 만들지 않음

**URL:** llms-txt#에이전트-생성은-빠름---아직-mcp-연결을-만들지-않음

agent = Agent(
    role="온디맨드 에이전트",
    goal="도구를 효율적으로 사용",
    backstory="필요할 때만 연결하는 효율적인 에이전트",
    mcps=["https://api.example.com/mcp"]
)

---

## Server with authentication

**URL:** llms-txt#server-with-authentication

"https://mcp.exa.ai/mcp?api_key=your_key&profile=your_profile"

---

## Google Serper Search

**URL:** llms-txt#google-serper-search

Source: https://docs.crewai.com/en/tools/search-research/serperdevtool

The `SerperDevTool` is designed to search the internet and return the most relevant results.

---

## Uso básico - utiliza o expected_output da tarefa como contexto

**URL:** llms-txt#uso-básico---utiliza-o-expected_output-da-tarefa-como-contexto

protecao = HallucinationGuardrail(
    llm=LLM(model="gpt-4o-mini")
)

---

## Get keys for your project from the project settings page: https://cloud.langfuse.com

**URL:** llms-txt#get-keys-for-your-project-from-the-project-settings-page:-https://cloud.langfuse.com

os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..."
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # 🇪🇺 EU region

---

## 웹사이트 스크랩

**URL:** llms-txt#웹사이트-스크랩

Source: https://docs.crewai.com/ko/tools/web-scraping/scrapewebsitetool

ScrapeWebsiteTool은 지정된 웹사이트의 내용을 추출하고 읽도록 설계되었습니다.

---

## Create a test knowledge source

**URL:** llms-txt#create-a-test-knowledge-source

test_source = StringKnowledgeSource(
    content="Test knowledge content for debugging",
    chunk_size=100,  # Small chunks for testing
    chunk_overlap=20
)

---

## ClickUp 연동

**URL:** llms-txt#clickup-연동

**Contents:**
- 개요
- 사전 준비사항
- ClickUp 통합 설정
  - 1. ClickUp 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 동작
- 사용 예시
  - 기본 ClickUp 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/clickup

CrewAI를 위한 ClickUp 연동을 통한 작업 및 생산성 관리.

에이전트가 ClickUp을 통해 작업, 프로젝트 및 생산성 워크플로우를 관리할 수 있도록 지원하세요. 작업을 생성 및 업데이트하고, 프로젝트를 구성하며, 팀 할당을 관리하고, AI 기반 자동화를 통해 생산성 관리를 간소화할 수 있습니다.

ClickUp 통합을 사용하기 전에 다음을 준비해야 합니다:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 ClickUp 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 ClickUp 계정 연결

### 1. ClickUp 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **ClickUp**을 찾습니다.
3. **Connect**를 클릭하고 OAuth 과정을 완료합니다.
4. 작업 및 프로젝트 관리에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="clickup/search_tasks">
    **설명:** 고급 필터를 사용하여 ClickUp에서 작업을 검색합니다.

* `taskFilterFormula` (object, 선택): 이항 표준형(DNF)의 필터 - 단일 조건의 AND 그룹들의 OR.
      
      사용 가능한 필드: `space_ids%5B%5D`, `project_ids%5B%5D`, `list_ids%5B%5D`, `statuses%5B%5D`, `include_closed`, `assignees%5B%5D`, `tags%5B%5D`, `due_date_gt`, `due_date_lt`, `date_created_gt`, `date_created_lt`, `date_updated_gt`, `date_updated_lt`
  </Accordion>

<Accordion title="clickup/get_task_in_list">
    **설명:** ClickUp의 특정 목록에서 작업을 가져옵니다.

* `listId` (string, 필수): 목록 - 작업을 가져올 목록을 선택합니다. 사용자가 ClickUp 목록을 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `taskFilterFormula` (string, 선택): 지정된 필터와 일치하는 작업을 검색합니다. 예: name=task1.
  </Accordion>

<Accordion title="clickup/create_task">
    **설명:** ClickUp에 작업을 생성합니다.

* `listId` (string, 필수): 목록 - 이 작업을 생성할 목록을 선택합니다. 사용자가 ClickUp 목록을 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `name` (string, 필수): 이름 - 작업 이름.
    * `description` (string, 선택): 설명 - 작업 설명.
    * `status` (string, 선택): 상태 - 이 작업에 대한 상태를 선택합니다. 사용자가 ClickUp 상태를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `assignees` (string, 선택): 담당자 - 이 작업에 할당할 멤버(또는 멤버 ID 배열)를 선택합니다. 사용자가 ClickUp 멤버를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `dueDate` (string, 선택): 마감일 - 이 작업의 마감일을 지정합니다.
    * `additionalFields` (string, 선택): 추가 필드 - 이 작업에 포함할 추가 필드를 JSON으로 지정합니다.
  </Accordion>

<Accordion title="clickup/update_task">
    **설명:** ClickUp의 작업을 업데이트합니다.

* `taskId` (string, 필수): 작업 ID - 업데이트할 작업의 ID입니다.
    * `listId` (string, 필수): 목록 - 이 작업을 생성할 목록을 선택합니다. 사용자가 ClickUp 목록을 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `name` (string, 선택): 이름 - 작업 이름.
    * `description` (string, 선택): 설명 - 작업 설명.
    * `status` (string, 선택): 상태 - 이 작업에 대한 상태를 선택합니다. 사용자가 ClickUp 상태를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `assignees` (string, 선택): 담당자 - 이 작업에 할당할 멤버(또는 멤버 ID 배열)를 선택합니다. 사용자가 ClickUp 멤버를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `dueDate` (string, 선택): 마감일 - 이 작업의 마감일을 지정합니다.
    * `additionalFields` (string, 선택): 추가 필드 - 이 작업에 포함할 추가 필드를 JSON으로 지정합니다.
  </Accordion>

<Accordion title="clickup/delete_task">
    **설명:** ClickUp에서 작업을 삭제합니다.

* `taskId` (string, 필수): 작업 ID - 삭제할 작업의 ID입니다.
  </Accordion>

<Accordion title="clickup/get_list">
    **설명:** ClickUp에서 목록 정보를 가져옵니다.

* `spaceId` (string, 필수): 스페이스 ID - 목록이 포함된 스페이스의 ID입니다.
  </Accordion>

<Accordion title="clickup/get_custom_fields_in_list">
    **설명:** ClickUp에서 목록의 사용자 정의 필드를 가져옵니다.

* `listId` (string, 필수): 목록 ID - 사용자 정의 필드를 가져올 목록의 ID입니다.
  </Accordion>

<Accordion title="clickup/get_all_fields_in_list">
    **설명:** ClickUp에서 목록의 모든 필드를 가져옵니다.

* `listId` (string, 필수): 목록 ID - 모든 필드를 가져올 목록의 ID입니다.
  </Accordion>

<Accordion title="clickup/get_space">
    **설명:** ClickUp에서 스페이스 정보를 가져옵니다.

* `spaceId` (string, 선택): 스페이스 ID - 조회할 스페이스의 ID입니다.
  </Accordion>

<Accordion title="clickup/get_folders">
    **설명:** ClickUp에서 폴더를 가져옵니다.

* `spaceId` (string, 필수): 스페이스 ID - 폴더가 포함된 스페이스의 ID입니다.
  </Accordion>

<Accordion title="clickup/get_member">
    **설명:** ClickUp에서 멤버 정보를 가져옵니다.

**파라미터:** 필요 없음.
  </Accordion>
</AccordionGroup>

### 기본 ClickUp 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 동작

<AccordionGroup>
  <Accordion title="clickup/search_tasks">
    **설명:** 고급 필터를 사용하여 ClickUp에서 작업을 검색합니다.

    **파라미터:**

    * `taskFilterFormula` (object, 선택): 이항 표준형(DNF)의 필터 - 단일 조건의 AND 그룹들의 OR.
```

Example 4 (unknown):
```unknown
사용 가능한 필드: `space_ids%5B%5D`, `project_ids%5B%5D`, `list_ids%5B%5D`, `statuses%5B%5D`, `include_closed`, `assignees%5B%5D`, `tags%5B%5D`, `due_date_gt`, `due_date_lt`, `date_created_gt`, `date_created_lt`, `date_updated_gt`, `date_updated_lt`
  </Accordion>

  <Accordion title="clickup/get_task_in_list">
    **설명:** ClickUp의 특정 목록에서 작업을 가져옵니다.

    **파라미터:**

    * `listId` (string, 필수): 목록 - 작업을 가져올 목록을 선택합니다. 사용자가 ClickUp 목록을 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `taskFilterFormula` (string, 선택): 지정된 필터와 일치하는 작업을 검색합니다. 예: name=task1.
  </Accordion>

  <Accordion title="clickup/create_task">
    **설명:** ClickUp에 작업을 생성합니다.

    **파라미터:**

    * `listId` (string, 필수): 목록 - 이 작업을 생성할 목록을 선택합니다. 사용자가 ClickUp 목록을 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `name` (string, 필수): 이름 - 작업 이름.
    * `description` (string, 선택): 설명 - 작업 설명.
    * `status` (string, 선택): 상태 - 이 작업에 대한 상태를 선택합니다. 사용자가 ClickUp 상태를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `assignees` (string, 선택): 담당자 - 이 작업에 할당할 멤버(또는 멤버 ID 배열)를 선택합니다. 사용자가 ClickUp 멤버를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `dueDate` (string, 선택): 마감일 - 이 작업의 마감일을 지정합니다.
    * `additionalFields` (string, 선택): 추가 필드 - 이 작업에 포함할 추가 필드를 JSON으로 지정합니다.
  </Accordion>

  <Accordion title="clickup/update_task">
    **설명:** ClickUp의 작업을 업데이트합니다.

    **파라미터:**

    * `taskId` (string, 필수): 작업 ID - 업데이트할 작업의 ID입니다.
    * `listId` (string, 필수): 목록 - 이 작업을 생성할 목록을 선택합니다. 사용자가 ClickUp 목록을 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `name` (string, 선택): 이름 - 작업 이름.
    * `description` (string, 선택): 설명 - 작업 설명.
    * `status` (string, 선택): 상태 - 이 작업에 대한 상태를 선택합니다. 사용자가 ClickUp 상태를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `assignees` (string, 선택): 담당자 - 이 작업에 할당할 멤버(또는 멤버 ID 배열)를 선택합니다. 사용자가 ClickUp 멤버를 선택할 수 있도록 Connect Portal 사용자 설정을 사용하세요.
    * `dueDate` (string, 선택): 마감일 - 이 작업의 마감일을 지정합니다.
    * `additionalFields` (string, 선택): 추가 필드 - 이 작업에 포함할 추가 필드를 JSON으로 지정합니다.
  </Accordion>

  <Accordion title="clickup/delete_task">
    **설명:** ClickUp에서 작업을 삭제합니다.

    **파라미터:**

    * `taskId` (string, 필수): 작업 ID - 삭제할 작업의 ID입니다.
  </Accordion>

  <Accordion title="clickup/get_list">
    **설명:** ClickUp에서 목록 정보를 가져옵니다.

    **파라미터:**

    * `spaceId` (string, 필수): 스페이스 ID - 목록이 포함된 스페이스의 ID입니다.
  </Accordion>

  <Accordion title="clickup/get_custom_fields_in_list">
    **설명:** ClickUp에서 목록의 사용자 정의 필드를 가져옵니다.

    **파라미터:**

    * `listId` (string, 필수): 목록 ID - 사용자 정의 필드를 가져올 목록의 ID입니다.
  </Accordion>

  <Accordion title="clickup/get_all_fields_in_list">
    **설명:** ClickUp에서 목록의 모든 필드를 가져옵니다.

    **파라미터:**

    * `listId` (string, 필수): 목록 ID - 모든 필드를 가져올 목록의 ID입니다.
  </Accordion>

  <Accordion title="clickup/get_space">
    **설명:** ClickUp에서 스페이스 정보를 가져옵니다.

    **파라미터:**

    * `spaceId` (string, 선택): 스페이스 ID - 조회할 스페이스의 ID입니다.
  </Accordion>

  <Accordion title="clickup/get_folders">
    **설명:** ClickUp에서 폴더를 가져옵니다.

    **파라미터:**

    * `spaceId` (string, 필수): 스페이스 ID - 폴더가 포함된 스페이스의 ID입니다.
  </Accordion>

  <Accordion title="clickup/get_member">
    **설명:** ClickUp에서 멤버 정보를 가져옵니다.

    **파라미터:** 필요 없음.
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 ClickUp 에이전트 설정
```

---

## Store sensitive data in environment variables

**URL:** llms-txt#store-sensitive-data-in-environment-variables

**Contents:**
  - 스토리지 보안

crew = Crew(
    memory=True,
    embedder={
        "provider": "openai",
        "config": {
            "api_key": os.getenv("OPENAI_API_KEY"),
            "model": "text-embedding-3-small"
        }
    }
)
python  theme={null}
import os
from crewai import Crew
from crewai.memory import LongTermMemory
from crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage

**Examples:**

Example 1 (unknown):
```unknown
### 스토리지 보안
```

---

## Example of using kickoff_for_each

**URL:** llms-txt#example-of-using-kickoff_for_each

inputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]
results = my_crew.kickoff_for_each(inputs=inputs_array)
for result in results:
    print(result)

---

## Define a tarefa com output_json configurado para o modelo Blog

**URL:** llms-txt#define-a-tarefa-com-output_json-configurado-para-o-modelo-blog

task1 = Task(
    description="""Crie um título e conteúdo para blog sobre um tópico. Certifique-se de que o conteúdo tenha menos de 200 palavras.""",
    expected_output="Um objeto JSON com os campos 'title' e 'content'.",
    agent=blog_agent,
    output_json=Blog,
)

---

## Veja os logs da implantação

**URL:** llms-txt#veja-os-logs-da-implantação

---

## Processo Hierárquico

**URL:** llms-txt#processo-hierárquico

**Contents:**
- Introdução
- Visão Geral do Processo Hierárquico
  - Principais Características
- Implementando o Processo Hierárquico

Source: https://docs.crewai.com/pt-BR/learn/hierarchical-process

Um guia abrangente para compreender e aplicar o processo hierárquico em seus projetos CrewAI, atualizado para refletir as práticas de codificação e funcionalidades mais recentes.

O processo hierárquico no CrewAI introduz uma abordagem estruturada para a gestão de tarefas, simulando hierarquias organizacionais tradicionais para uma delegação e execução eficiente de tarefas.
Esse fluxo de trabalho sistemático melhora os resultados do projeto ao garantir que as tarefas sejam tratadas com máxima eficiência e precisão.

<Tip>
  O processo hierárquico foi projetado para alavancar modelos avançados como o GPT-4, otimizando o uso de tokens enquanto lida com tarefas complexas de forma mais eficiente.
</Tip>

## Visão Geral do Processo Hierárquico

Por padrão, as tarefas no CrewAI são gerenciadas por meio de um processo sequencial. No entanto, adotar uma abordagem hierárquica permite uma hierarquia clara na gestão de tarefas,
onde um agente 'gerente' coordena o fluxo de trabalho, delega tarefas e valida os resultados para uma execução eficaz e simplificada. Esse agente gerente pode agora ser
criado automaticamente pelo CrewAI ou explicitamente definido pelo usuário.

### Principais Características

* **Delegação de Tarefas**: Um agente gerente distribui tarefas entre os membros da crew com base em seus papéis e capacidades.
* **Validação de Resultados**: O gerente avalia os resultados para garantir que atendam aos padrões exigidos.
* **Fluxo de Trabalho Eficiente**: Emula estruturas corporativas, oferecendo uma abordagem organizada para a gestão de tarefas.
* **Manipulação de System Prompt**: Opcionalmente, especifique se o sistema deve usar prompts predefinidos.
* **Controle de Stop Words**: Opcionalmente, especifique se stop words devem ser usadas, oferecendo suporte a diversos modelos, incluindo os modelos o1.
* **Respeito à Context Window**: Priorização de contexto relevante ativando o respeito à context window, que agora é o comportamento padrão.
* **Controle de Delegação**: A delegação agora está desativada por padrão para dar controle explícito ao usuário.
* **Máximo de Requisições por Minuto**: Opção configurável para definir o número máximo de requisições por minuto.
* **Máximo de Iterações**: Limitação do número máximo de iterações até a obtenção de uma resposta final.

## Implementando o Processo Hierárquico

Para utilizar o processo hierárquico, é essencial definir explicitamente o atributo de processo como `Process.hierarchical`, já que o comportamento padrão é `Process.sequential`.
Defina uma crew com um gerente designado e estabeleça uma cadeia de comando clara.

<Tip>
  Atribua ferramentas no nível do agente para facilitar a delegação e execução de tarefas pelos agentes designados sob a orientação do gerente.
  Ferramentas também podem ser especificadas no nível da tarefa, para um controle preciso sobre a disponibilidade de ferramentas durante a execução das tarefas.
</Tip>

<Tip>
  Configurar o parâmetro `manager_llm` é fundamental para o processo hierárquico.
  O sistema exige a configuração de um LLM do gerente para funcionar corretamente, garantindo tomadas de decisão personalizadas.
</Tip>

```python Code theme={null}
from crewai import Crew, Process, Agent

---

## Qdrant Vector Search Tool

**URL:** llms-txt#qdrant-vector-search-tool

**Contents:**
- Visão Geral
- Instalação
- Uso Básico

Source: https://docs.crewai.com/pt-BR/tools/database-data/qdrantvectorsearchtool

Capacidades de busca semântica para agentes CrewAI usando o banco de dados vetorial Qdrant

A ferramenta Qdrant Vector Search permite adicionar capacidades de busca semântica aos seus agentes CrewAI utilizando o [Qdrant](https://qdrant.tech/), um mecanismo de busca por similaridade vetorial. Com essa ferramenta, seus agentes podem pesquisar em documentos armazenados em uma coleção Qdrant usando similaridade semântica.

Instale os pacotes necessários:

Veja um exemplo mínimo de como utilizar a ferramenta:

```python  theme={null}
from crewai import Agent
from crewai_tools import QdrantVectorSearchTool, QdrantConfig

**Examples:**

Example 1 (unknown):
```unknown
## Uso Básico

Veja um exemplo mínimo de como utilizar a ferramenta:
```

---

## EXA 검색 웹 로더

**URL:** llms-txt#exa-검색-웹-로더

Source: https://docs.crewai.com/ko/tools/search-research/exasearchtool

EXASearchTool은 인터넷 전반에 걸쳐 텍스트의 내용에서 지정된 쿼리에 대한 시맨틱 검색을 수행하도록 설계되었습니다.

---

## O agente usará ferramentas de servidores funcionais e registrará avisos para os que falharem

**URL:** llms-txt#o-agente-usará-ferramentas-de-servidores-funcionais-e-registrará-avisos-para-os-que-falharem

**Contents:**
- Recursos de Performance
  - Cache Automático

**Examples:**

Example 1 (unknown):
```unknown
## Recursos de Performance

### Cache Automático

Esquemas de ferramentas são cacheados por 5 minutos para melhorar a performance:
```

---

## Exportação de Componentes React

**URL:** llms-txt#exportação-de-componentes-react

**Contents:**
- Exportando um Componente React
- Configurando seu Ambiente React
- Personalização
- Próximos Passos

Source: https://docs.crewai.com/pt-BR/enterprise/guides/react-component-export

Aprenda como exportar e integrar componentes React do CrewAI AMP em suas aplicações

Este guia explica como exportar crews do CrewAI AMP como componentes React e integrá-los às suas próprias aplicações.

## Exportando um Componente React

<Steps>
  <Step title="Exporte o Componente">
    Clique no menu de opções (três pontos à direita do seu crew implantado), selecione a opção de exportação e salve o arquivo localmente. Usaremos o arquivo `CrewLead.jsx` como exemplo.

<Frame>
      <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e0c72184b57eeae414674023197fca1b" alt="Exportar Componente React" data-og-width="493" width="493" data-og-height="359" height="359" data-path="images/enterprise/export-react-component.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8493fbf39305d5f66dea0f19af860363 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=77698a5cf65d840dc81de4bd72bb4db1 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=fe2f4ee4cf620354f6413726983a33fb 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c817314a4164f7c55ecd424ab5de61cf 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6d982c3772ec31c866bcdcabaa8a6b5e 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=0b9e48143a23435526cf924906aac876 2500w" />
    </Frame>
  </Step>
</Steps>

## Configurando seu Ambiente React

Para executar este componente React localmente, você precisará configurar um ambiente de desenvolvimento React e integrar este componente em um projeto React.

<Steps>
  <Step title="Instale o Node.js">
    * Baixe e instale o Node.js no site oficial: [https://nodejs.org/](https://nodejs.org/)
    * Escolha a versão LTS (Long Term Support) para maior estabilidade.
  </Step>

<Step title="Crie um novo projeto React">
    * Abra o Prompt de Comando ou PowerShell
    * Navegue até o diretório onde deseja criar seu projeto
    * Execute o seguinte comando para criar um novo projeto React:

* Entre no diretório do projeto:

<Step title="Instale as dependências necessárias">
    
  </Step>

<Step title="Crie o componente CrewLead">
    * Mova o arquivo baixado `CrewLead.jsx` para a pasta `src` do seu projeto.
  </Step>

<Step title="Modifique seu App.js para usar o componente CrewLead">
    * Abra o arquivo `src/App.js`
    * Substitua o conteúdo por algo semelhante a isso:

* Substitua `YOUR_API_BASE_URL` e `YOUR_BEARER_TOKEN` pelos valores reais da sua API.
  </Step>

<Step title="Inicie o servidor de desenvolvimento">
    * No diretório do seu projeto, execute:

* Isso iniciará o servidor de desenvolvimento, e seu navegador padrão será aberto automaticamente em [http://localhost:3000](http://localhost:3000), onde você verá sua aplicação React rodando.
  </Step>
</Steps>

Você pode então personalizar o `CrewLead.jsx` para adicionar cor, título etc.

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4673fd3ac9eedc1c83b777afb8cf09c9" alt="Personalizar Componente React" data-og-width="1119" width="1119" data-og-height="939" height="939" data-path="images/enterprise/customise-react-component.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=551606e5340b4eb48fa2ca617486ab17 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4861d2caa401af697527bbafe3cfdb8a 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=ce6d2304d336e487c9bfbd8e1fde5eaf 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1b2d7f443f10ff21f73e14ef42f91063 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=af6ddc00aa79e8b1606d74b587336a5d 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=997057d8f5ed2b15166ea3cec704a4f3 2500w" />
</Frame>

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=714c15d129b3db4bd96cdc55e80916dd" alt="Personalizar Componente React" data-og-width="1058" width="1058" data-og-height="427" height="427" data-path="images/enterprise/customise-react-component-2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=5c589ec079cd09f29551136ee607d0a5 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=059851daaaf939d0a5bb2aa1598940cf 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3bad7a6f0f18aff57419ded53c398f15 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6753c201e535c8fcebd1d949436003c7 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=352df6d7283212880ef271a8fb673098 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=725cfe8688b8135dd25290296d787dbf 2500w" />
</Frame>

* Personalize o estilo do componente para combinar com o design da sua aplicação
* Adicione props adicionais para configuração
* Integre com o gerenciamento de estado da sua aplicação
* Adicione tratamento de erros e estados de carregamento

**Examples:**

Example 1 (unknown):
```unknown
* Entre no diretório do projeto:
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Instale as dependências necessárias">
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="Crie o componente CrewLead">
    * Mova o arquivo baixado `CrewLead.jsx` para a pasta `src` do seu projeto.
  </Step>

  <Step title="Modifique seu App.js para usar o componente CrewLead">
    * Abra o arquivo `src/App.js`
    * Substitua o conteúdo por algo semelhante a isso:
```

Example 4 (unknown):
```unknown
* Substitua `YOUR_API_BASE_URL` e `YOUR_BEARER_TOKEN` pelos valores reais da sua API.
  </Step>

  <Step title="Inicie o servidor de desenvolvimento">
    * No diretório do seu projeto, execute:
```

---

## Add a web page

**URL:** llms-txt#add-a-web-page

rag_tool.add(data_type="web_page", url="https://example.com")

---

## Busca RAG em Diretório

**URL:** llms-txt#busca-rag-em-diretório

Source: https://docs.crewai.com/pt-BR/tools/file-document/directorysearchtool

O `DirectorySearchTool` é uma poderosa ferramenta RAG (Retrieval-Augmented Generation) desenvolvida para buscas semânticas no conteúdo de um diretório.

---

## Listar todas as organizações disponíveis

**URL:** llms-txt#listar-todas-as-organizações-disponíveis

<Note>
  Ao carregar agentes de repositórios, você deve estar autenticado e ter alternado para a organização correta. Se você receber erros, verifique seu status de autenticação e as configurações de organização usando os comandos do CLI acima.
</Note>

---

## Configurar o LLM com a TrueFoundry

**URL:** llms-txt#configurar-o-llm-com-a-truefoundry

llm = LLM(
    model="openai-main/gpt-4o",
    base_url="your_truefoundry_gateway_base_url", 
    api_key="your_truefoundry_api_key"
)

---

## Patronus AI 평가

**URL:** llms-txt#patronus-ai-평가

**Contents:**
- 개요
- 주요 기능
- 평가 도구
- 설치
- 시작 단계
- 예시
  - PatronusEvalTool 사용하기

[Patronus AI](https://patronus.ai)는 CrewAI 에이전트를 위한 종합적인 평가 및 모니터링 기능을 제공하여, 모델 출력, 에이전트 동작, 전체 시스템 성능을 평가할 수 있게 해줍니다. 이 통합을 통해 품질과 신뢰성을 유지하기 위한 지속적인 평가 워크플로우를 프로덕션 환경에 구현할 수 있습니다.

* **자동 평가**: 에이전트 출력 및 행동의 실시간 평가
* **맞춤 기준**: 사용 사례에 맞게 특정 평가 기준 정의
* **성능 모니터링**: 에이전트 성능 지표를 시간에 따라 추적
* **품질 보증**: 다양한 시나리오에서 일관된 출력 품질 보장
* **안전성 및 준수**: 잠재적인 문제 및 정책 위반 모니터링

Patronus는 다양한 사용 사례를 위한 세 가지 주요 평가 도구를 제공합니다:

1. **PatronusEvalTool**: 에이전트가 평가 작업에 가장 적합한 평가자와 기준을 선택할 수 있도록 합니다.
2. **PatronusPredefinedCriteriaEvalTool**: 사용자가 지정한 미리 정의된 평가자와 기준을 사용합니다.
3. **PatronusLocalEvaluatorTool**: 사용자가 정의한 커스텀 함수 평가자를 사용합니다.

이 도구들을 사용하려면 Patronus 패키지를 설치해야 합니다:

또한 Patronus API 키를 환경 변수로 설정해야 합니다:

Patronus 평가 도구를 효과적으로 사용하려면 다음 단계를 따르세요:

1. **Patronus 설치**: 위의 명령어를 사용하여 Patronus 패키지를 설치합니다.
2. **API 키 설정**: Patronus API 키를 환경 변수로 설정합니다.
3. **적합한 도구 선택**: 필요에 따라 적절한 Patronus 평가 도구를 선택합니다.
4. **도구 구성**: 필요한 파라미터로 도구를 구성합니다.

### PatronusEvalTool 사용하기

다음 예제는 에이전트가 가장 적합한 평가자와 평가 기준을 선택할 수 있도록 해주는 `PatronusEvalTool`의 사용 방법을 보여줍니다:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import PatronusEvalTool

**Examples:**

Example 1 (unknown):
```unknown
또한 Patronus API 키를 환경 변수로 설정해야 합니다:
```

Example 2 (unknown):
```unknown
## 시작 단계

Patronus 평가 도구를 효과적으로 사용하려면 다음 단계를 따르세요:

1. **Patronus 설치**: 위의 명령어를 사용하여 Patronus 패키지를 설치합니다.
2. **API 키 설정**: Patronus API 키를 환경 변수로 설정합니다.
3. **적합한 도구 선택**: 필요에 따라 적절한 Patronus 평가 도구를 선택합니다.
4. **도구 구성**: 필요한 파라미터로 도구를 구성합니다.

## 예시

### PatronusEvalTool 사용하기

다음 예제는 에이전트가 가장 적합한 평가자와 평가 기준을 선택할 수 있도록 해주는 `PatronusEvalTool`의 사용 방법을 보여줍니다:
```

---

## `MDXSearchTool`

**URL:** llms-txt#`mdxsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo de Uso

<Note>
  O MDXSearchTool está em desenvolvimento contínuo. Recursos podem ser adicionados ou removidos, e a funcionalidade pode mudar de forma imprevisível à medida que refinamos a ferramenta.
</Note>

A Ferramenta de Pesquisa MDX é um componente do pacote `crewai_tools` focado em facilitar a extração avançada de dados do markdown. Ela permite que usuários pesquisem e extraiam informações relevantes de arquivos MD utilizando buscas baseadas em consulta. Esta ferramenta é indispensável para análise de dados, gestão de informações e tarefas de pesquisa, agilizando o processo de encontrar informações específicas em grandes coleções de documentos.

Antes de utilizar a Ferramenta de Pesquisa MDX, certifique-se de que o pacote `crewai_tools` está instalado. Caso não esteja, você pode instalá-lo com o comando abaixo:

Para utilizar a Ferramenta de Pesquisa MDX, primeiro defina as variáveis de ambiente necessárias. Em seguida, integre a ferramenta ao seu projeto crewAI para começar sua pesquisa de mercado. Veja abaixo um exemplo básico de como fazer isso:

```python Code theme={null}
from crewai_tools import MDXSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo de Uso

Para utilizar a Ferramenta de Pesquisa MDX, primeiro defina as variáveis de ambiente necessárias. Em seguida, integre a ferramenta ao seu projeto crewAI para começar sua pesquisa de mercado. Veja abaixo um exemplo básico de como fazer isso:
```

---

## Box 통합

**URL:** llms-txt#box-통합

**Contents:**
- 개요
- 사전 준비 사항
- Box 통합 설정
  - 1. Box 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 액션
- 사용 예시
  - 기본 Box Agent 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/box

CrewAI용 Box 통합을 통한 파일 저장 및 문서 관리.

에이전트가 Box를 통해 파일, 폴더, 문서를 관리할 수 있도록 지원하세요. 파일을 업로드하고, 폴더 구조를 조직하며, 콘텐츠를 검색하고, AI 기반 자동화를 통해 팀의 문서 관리를 효율적으로 진행할 수 있습니다.

Box 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 Box 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Box 계정 연결

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **Box**를 찾습니다.
3. **Connect**를 클릭하고 OAuth 흐름을 완료합니다.
4. 파일 및 폴더 관리를 위한 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="box/save_file">
    **설명:** Box에서 URL로부터 파일을 저장합니다.

* `fileAttributes` (object, 필수): 속성 - 이름, 상위 폴더, 타임스탬프 등 파일 메타데이터.
      
    * `file` (string, 필수): 파일 URL - 파일 크기는 50MB 미만이어야 합니다. (예시: "[https://picsum.photos/200/300](https://picsum.photos/200/300)").
  </Accordion>

<Accordion title="box/save_file_from_object">
    **설명:** Box에 파일을 저장합니다.

* `file` (string, 필수): 파일 - 파일 데이터를 포함하는 파일 객체를 허용합니다. 파일 크기는 50MB 미만이어야 합니다.
    * `fileName` (string, 필수): 파일명 (예시: "qwerty.png").
    * `folder` (string, 선택): 폴더 - Connect Portal Workflow Settings를 사용하여 사용자가 파일의 폴더 목적지를 선택할 수 있도록 합니다. 비워두면 기본적으로 사용자의 루트 폴더에 저장됩니다.
  </Accordion>

<Accordion title="box/get_file_by_id">
    **설명:** Box에서 ID로 파일을 가져옵니다.

* `fileId` (string, 필수): 파일 ID - 파일을 나타내는 고유 식별자. (예시: "12345").
  </Accordion>

<Accordion title="box/list_files">
    **설명:** Box에서 파일 목록을 조회합니다.

* `folderId` (string, 필수): 폴더 ID - 폴더를 나타내는 고유 식별자. (예시: "0").
    * `filterFormula` (object, 선택): 쿼리 normal form (DNF)의 필터 - 단일 조건의 AND 그룹의 OR.
      
  </Accordion>

<Accordion title="box/create_folder">
    **설명:** Box에 폴더를 생성합니다.

* `folderName` (string, 필수): 이름 - 새 폴더의 이름. (예시: "New Folder").
    * `folderParent` (object, 필수): 상위 폴더 - 새 폴더가 생성될 상위 폴더.
      
  </Accordion>

<Accordion title="box/move_folder">
    **설명:** Box에서 폴더를 이동합니다.

* `folderId` (string, 필수): 폴더 ID - 폴더를 나타내는 고유 식별자. (예시: "0").
    * `folderName` (string, 필수): 이름 - 폴더의 이름. (예시: "New Folder").
    * `folderParent` (object, 필수): 상위 폴더 - 새 상위 폴더 목적지.
      
  </Accordion>

<Accordion title="box/get_folder_by_id">
    **설명:** Box에서 ID로 폴더를 가져옵니다.

* `folderId` (string, 필수): 폴더 ID - 폴더를 나타내는 고유 식별자. (예시: "0").
  </Accordion>

<Accordion title="box/search_folders">
    **설명:** Box에서 폴더를 검색합니다.

* `folderId` (string, 필수): 폴더 ID - 검색할 폴더.
    * `filterFormula` (object, 선택): 쿼리 normal form (DNF)의 필터 - 단일 조건의 AND 그룹의 OR.
      
  </Accordion>

<Accordion title="box/delete_folder">
    **설명:** Box에서 폴더를 삭제합니다.

* `folderId` (string, 필수): 폴더 ID - 폴더를 나타내는 고유 식별자. (예시: "0").
    * `recursive` (boolean, 선택): 재귀적 삭제 - 폴더가 비어 있지 않을 경우, 폴더와 그 모든 내용을 재귀적으로 삭제합니다.
  </Accordion>
</AccordionGroup>

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 액션

<AccordionGroup>
  <Accordion title="box/save_file">
    **설명:** Box에서 URL로부터 파일을 저장합니다.

    **파라미터:**

    * `fileAttributes` (object, 필수): 속성 - 이름, 상위 폴더, 타임스탬프 등 파일 메타데이터.
```

Example 4 (unknown):
```unknown
* `file` (string, 필수): 파일 URL - 파일 크기는 50MB 미만이어야 합니다. (예시: "[https://picsum.photos/200/300](https://picsum.photos/200/300)").
  </Accordion>

  <Accordion title="box/save_file_from_object">
    **설명:** Box에 파일을 저장합니다.

    **파라미터:**

    * `file` (string, 필수): 파일 - 파일 데이터를 포함하는 파일 객체를 허용합니다. 파일 크기는 50MB 미만이어야 합니다.
    * `fileName` (string, 필수): 파일명 (예시: "qwerty.png").
    * `folder` (string, 선택): 폴더 - Connect Portal Workflow Settings를 사용하여 사용자가 파일의 폴더 목적지를 선택할 수 있도록 합니다. 비워두면 기본적으로 사용자의 루트 폴더에 저장됩니다.
  </Accordion>

  <Accordion title="box/get_file_by_id">
    **설명:** Box에서 ID로 파일을 가져옵니다.

    **파라미터:**

    * `fileId` (string, 필수): 파일 ID - 파일을 나타내는 고유 식별자. (예시: "12345").
  </Accordion>

  <Accordion title="box/list_files">
    **설명:** Box에서 파일 목록을 조회합니다.

    **파라미터:**

    * `folderId` (string, 필수): 폴더 ID - 폴더를 나타내는 고유 식별자. (예시: "0").
    * `filterFormula` (object, 선택): 쿼리 normal form (DNF)의 필터 - 단일 조건의 AND 그룹의 OR.
```

---

## ChromaDB (default)

**URL:** llms-txt#chromadb-(default)

from crewai.rag.chromadb.config import ChromaDBConfig
set_rag_config(ChromaDBConfig())
chromadb_client = get_rag_client()

---

## Crie um agente focado em edição de texto

**URL:** llms-txt#crie-um-agente-focado-em-edição-de-texto

text_editor = Agent(
    role="Editor de Documentos",
    goal="Editar e atualizar conteúdo em documentos do Google Docs",
    backstory="Um assistente IA habilidoso em edição precisa de texto e gerenciamento de conteúdo.",
    apps=['google_docs/insert_text', 'google_docs/replace_text', 'google_docs/delete_content_range']
)

---

## Tarefa para criar um novo ticket de suporte

**URL:** llms-txt#tarefa-para-criar-um-novo-ticket-de-suporte

create_ticket_task = Task(
    description="Crie um ticket de suporte de alta prioridade para John Smith que não consegue acessar sua conta após redefinir a senha",
    agent=zendesk_agent,
    expected_output="Ticket de suporte criado com sucesso com o ID do ticket"
)

---

## Task 2

**URL:** llms-txt#task-2

analysis_task:
  description: "Analyze the identified trends to determine potential business impacts."
  expected_output: "A structured analysis with impact ratings (High/Medium/Low)."

---

## Generate and inspect the actual prompt

**URL:** llms-txt#generate-and-inspect-the-actual-prompt

generated_prompt = prompt_generator.task_execution()

---

## Criar uma tarefa

**URL:** llms-txt#criar-uma-tarefa

task = Task(
    description="Pesquise o tópico dado e forneça um resumo abrangente",
    agent=researcher,
    expected_output="Resumo de pesquisa detalhado com principais descobertas"
)

---

## Interpretador de Código

**URL:** llms-txt#interpretador-de-código

Source: https://docs.crewai.com/pt-BR/tools/ai-ml/codeinterpretertool

O `CodeInterpreterTool` é uma poderosa ferramenta projetada para executar código Python 3 em um ambiente seguro e isolado.

---

## Create an index

**URL:** llms-txt#create-an-index

index = VectorStoreIndex.from_documents(documents)

---

## Inicializa a ferramenta

**URL:** llms-txt#inicializa-a-ferramenta

selenium_tool = SeleniumScrapingTool()

---

## Servidor com caminho personalizado

**URL:** llms-txt#servidor-com-caminho-personalizado

**Contents:**
  - Seleção de Ferramentas Específicas

"https://services.company.com/api/v1/mcp"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Seleção de Ferramentas Específicas

Use a sintaxe `#` para selecionar ferramentas específicas de um servidor:
```

---

## ✅ Solução: Forneça melhor contexto e papéis específicos

**URL:** llms-txt#✅-solução:-forneça-melhor-contexto-e-papéis-específicos

**Contents:**
  - Problema: Loops de Delegação

Task(
    description="""Write a technical blog post about machine learning.
    
    Context: Target audience is software developers with basic ML knowledge.
    Length: 1200 words
    Include: code examples, practical applications, best practices
    
    If you need specific technical details, delegate research to the researcher.""",
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Problema: Loops de Delegação

**Sintomas:** Agentes delegam tarefas repetidamente uns para os outros indefinidamente
```

---

## "render_js": True,  # Enable JavaScript rendering with a cloud headless browser

**URL:** llms-txt#"render_js":-true,--#-enable-javascript-rendering-with-a-cloud-headless-browser

---

## Para buscar qualquer conteúdo de documentação de código

**URL:** llms-txt#para-buscar-qualquer-conteúdo-de-documentação-de-código

---

## Integração com a TrueFoundry

**URL:** llms-txt#integração-com-a-truefoundry

**Contents:**
- Como a TrueFoundry se integra ao CrewAI
  - Instalação e configuração
  - Exemplo completo do CrewAI

Source: https://docs.crewai.com/pt-BR/observability/truefoundry

A TrueFoundry fornece um [AI Gateway](https://www.truefoundry.com/ai-gateway) pronto para uso empresarial, que pode ser usado para governança e observabilidade em frameworks agentivos como o CrewAI. O AI Gateway da TrueFoundry funciona como uma interface unificada para acesso a LLMs, oferecendo:

* **Acesso unificado à API**: Conecte-se a 250+ LLMs (OpenAI, Claude, Gemini, Groq, Mistral) por meio de uma única API
* **Baixa latência**: Latência interna abaixo de 3 ms com roteamento inteligente e balanceamento de carga
* **Segurança corporativa**: Conformidade com SOC 2, HIPAA e GDPR, com RBAC e auditoria de logs
* **Gestão de cotas e custos**: Cotas baseadas em tokens, rate limiting e rastreamento abrangente de uso
* **Observabilidade**: Registro completo de requisições/respostas, métricas e traces com retenção personalizável

## Como a TrueFoundry se integra ao CrewAI

### Instalação e configuração

<Steps>
  <Step title="Instalar o CrewAI">
    
  </Step>

<Step title="Obter o token de acesso da TrueFoundry">
    1. Crie uma conta na [TrueFoundry](https://www.truefoundry.com/register)
    2. Siga os passos do [Início rápido](https://docs.truefoundry.com/gateway/quick-start)
  </Step>

<Step title="Configurar o CrewAI com a TrueFoundry">
        <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=746c0bd23a77535f35b0b2bcf3320bf5" alt="Configuração de código da TrueFoundry" data-og-width="2940" width="2940" data-og-height="1664" height="1664" data-path="images/new-code-snippet.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1d7f4e8883760766aa1ae1274fba2ffe 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4604432c1e1121d24c3fa6ad93bc0bd9 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=8dd95282de37aa70090ac61a00b6e1bb 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=920a67bee38e979c770d775195b60864 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4173b6e99ed12b00b54bf3f222589863 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=176dd84222c8c1a6f40af3e0adb88e37 2500w" />

### Exemplo completo do CrewAI

```python  theme={null}
from crewai import Agent, Task, Crew, LLM

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Obter o token de acesso da TrueFoundry">
    1. Crie uma conta na [TrueFoundry](https://www.truefoundry.com/register)
    2. Siga os passos do [Início rápido](https://docs.truefoundry.com/gateway/quick-start)
  </Step>

  <Step title="Configurar o CrewAI com a TrueFoundry">
        <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=746c0bd23a77535f35b0b2bcf3320bf5" alt="Configuração de código da TrueFoundry" data-og-width="2940" width="2940" data-og-height="1664" height="1664" data-path="images/new-code-snippet.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1d7f4e8883760766aa1ae1274fba2ffe 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4604432c1e1121d24c3fa6ad93bc0bd9 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=8dd95282de37aa70090ac61a00b6e1bb 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=920a67bee38e979c770d775195b60864 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4173b6e99ed12b00b54bf3f222589863 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=176dd84222c8c1a6f40af3e0adb88e37 2500w" />
```

Example 2 (unknown):
```unknown
</Step>
</Steps>

### Exemplo completo do CrewAI
```

---

## 특정 문서 사이트 내에서 검색을 집중적으로 수행하려면

**URL:** llms-txt#특정-문서-사이트-내에서-검색을-집중적으로-수행하려면

---

## Tarefa de workflow complexa

**URL:** llms-txt#tarefa-de-workflow-complexa

**Contents:**
- Solução de Problemas
  - Problemas Comuns
  - Obtendo Ajuda

workflow_task = Task(
    description="""
    1. Obter todos os dados de clientes da planilha principal de clientes
    2. Criar registros de resumo mensal para clientes ativos
    3. Atualizar o status de clientes com base na atividade nos últimos 30 dias
    4. Gerar um relatório mensal com métricas dos clientes
    5. Arquivar registros de clientes inativos em uma planilha separada
    """,
    agent=workflow_manager,
    expected_output="Workflow mensal de clientes concluído com atualizações de status e relatórios gerados"
)

crew = Crew(
    agents=[workflow_manager],
    tasks=[workflow_task]
)

## Solução de Problemas

**Erros de Permissão**

* Certifique-se de que sua conta Google tem acesso de edição às planilhas alvo
* Verifique se a conexão OAuth inclui os escopos necessários para a API do Google Sheets
* Confira se as planilhas estão compartilhadas com a conta autenticada

**Problemas de Estrutura da Planilha**

* Certifique-se de que as worksheets têm cabeçalhos de coluna antes de criar ou atualizar linhas
* Verifique se os nomes das colunas em `additionalFields` correspondem exatamente aos cabeçalhos
* Confirme que a worksheet especificada existe na planilha

**Problemas de Tipo e Formato de Dados**

* Garanta que os valores dos dados estejam no formato esperado para cada coluna
* Utilize formatos de data adequados nas colunas de data (recomenda-se ISO)
* Verifique se valores numéricos estão devidamente formatados para colunas numéricas

**Problemas com Fórmulas de Filtro**

* Certifique-se de que as fórmulas de filtro seguem a estrutura JSON correta para forma normal disjuntiva
* Use nomes de campos válidos, correspondendo exatamente aos cabeçalhos das colunas
* Teste filtros simples antes de criar consultas com múltiplas condições
* Verifique se os tipos de operadores correspondem aos tipos de dados das colunas

**Limites de Linhas e Performance**

* Fique atento aos limites de linhas ao usar `GOOGLE_SHEETS_GET_ROW`
* Considere paginação para grandes volumes de dados
* Use filtros específicos para reduzir a quantidade de dados processados

**Operações de Atualização**

* Certifique-se de que as condições de filtro identifiquem corretamente as linhas a serem atualizadas
* Teste condições de filtro com pequenos conjuntos de dados antes de grandes atualizações
* Verifique se todos os campos obrigatórios estão incluídos nas operações de atualização

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nosso time de suporte para auxílio na configuração ou solução de problemas da integração com o Google Sheets.
</Card>

---

## Initialize OpenAI client

**URL:** llms-txt#initialize-openai-client

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

---

## Arize Phoenix

**URL:** llms-txt#arize-phoenix

Source: https://docs.crewai.com/pt-BR/observability/arize-phoenix

Integração do Arize Phoenix para CrewAI com OpenTelemetry e OpenInference

---

## Esta abordagem é adequada quando o caminho JSON já é conhecido ou pode ser identificado dinamicamente.

**URL:** llms-txt#esta-abordagem-é-adequada-quando-o-caminho-json-já-é-conhecido-ou-pode-ser-identificado-dinamicamente.

tool = JSONSearchTool()

---

## Firecrawl Crawl Website

**URL:** llms-txt#firecrawl-crawl-website

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/firecrawlcrawlwebsitetool

O `FirecrawlCrawlWebsiteTool` foi projetado para rastrear e converter sites em markdown limpo ou dados estruturados.

---

## For dynamic directory specification at runtime

**URL:** llms-txt#for-dynamic-directory-specification-at-runtime

tool = DirectorySearchTool()

---

## Task to create a new customer

**URL:** llms-txt#task-to-create-a-new-customer

create_customer_task = Task(
    description="Create a new premium customer John Doe with email john.doe@example.com",
    agent=stripe_agent,
    expected_output="Customer created successfully with customer ID"
)

---

## Exa에서 검색 도구만 가져오기

**URL:** llms-txt#exa에서-검색-도구만-가져오기

**Contents:**
  - CrewAI AMP 마켓플레이스

"https://mcp.exa.ai/mcp?api_key=your_key#web_search_exa"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### CrewAI AMP 마켓플레이스

CrewAI AMP 마켓플레이스의 도구에 액세스하세요:
```

---

## Microsoft SharePoint 기능을 가진 에이전트 생성

**URL:** llms-txt#microsoft-sharepoint-기능을-가진-에이전트-생성

sharepoint_agent = Agent(
    role="SharePoint 관리자",
    goal="SharePoint 사이트, 목록 및 문서를 효율적으로 관리",
    backstory="Microsoft SharePoint 관리 및 콘텐츠 관리 전문 AI 어시스턴트.",
    apps=['microsoft_sharepoint']  # 모든 SharePoint 작업을 사용할 수 있습니다
)

---

## 특정 웹사이트의 콘텐츠로 검색을 제한하는 예제

**URL:** llms-txt#특정-웹사이트의-콘텐츠로-검색을-제한하는-예제

---

## LangDB 통합

**URL:** llms-txt#langdb-통합

Source: https://docs.crewai.com/ko/observability/langdb

LangDB AI Gateway로 CrewAI 워크플로우를 관리, 보안, 최적화하세요—350개 이상의 모델 액세스, 자동 라우팅, 비용 최적화, 완전한 가시성을 제공합니다.

---

## Tarefa para criar uma nova pasta de trabalho

**URL:** llms-txt#tarefa-para-criar-uma-nova-pasta-de-trabalho

create_workbook_task = Task(
    description="Criar uma nova pasta de trabalho do Excel chamada 'RelatorioMensal.xlsx' com uma planilha inicial chamada 'DadosVendas'.",
    agent=excel_agent,
    expected_output="Nova pasta de trabalho 'RelatorioMensal.xlsx' criada com planilha 'DadosVendas'."
)

---

## Repetir a partir de uma tarefa específica

**URL:** llms-txt#repetir-a-partir-de-uma-tarefa-específica

**Contents:**
- O que Mais é Possível: Além da sua Primeira Crew
  - Expandindo sua Crew
  - Adicionando Ferramentas e Capacidades
  - Criando Fluxos de Trabalho Mais Complexos
  - Aplicando em Diferentes Domínios
- Próximos Passos

crewai replay -t <task_id>
```

## O que Mais é Possível: Além da sua Primeira Crew

O que você construiu neste guia é só o começo. As habilidades e padrões aprendidos aqui podem ser aplicados para criar sistemas de IA cada vez mais sofisticados. Veja algumas maneiras de expandir sua crew de pesquisa básica:

### Expandindo sua Crew

Você pode adicionar mais agentes especializados à sua crew:

* Um **checador de fatos** para verificar as informações encontradas
* Um **visualizador de dados** para criar gráficos e tabelas
* Um **especialista de domínio** com conhecimento aprofundado em uma área específica
* Um **crítico** para identificar pontos fracos na análise

### Adicionando Ferramentas e Capacidades

Você pode potencializar seus agentes com ferramentas adicionais:

* Ferramentas de navegação web para pesquisa em tempo real
* Ferramentas para CSV ou bancos de dados para análise de dados
* Ferramentas de execução de código para processamento de dados
* Conexões de API com serviços externos

### Criando Fluxos de Trabalho Mais Complexos

Você pode implementar processos mais sofisticados:

* Processos hierárquicos em que agentes gestores delegam para agentes
* Processos iterativos com loops de feedback para refinamento
* Processos paralelos onde múltiplos agentes trabalham simultaneamente
* Processos dinâmicos que se adaptam a resultados intermediários

### Aplicando em Diferentes Domínios

Os mesmos padrões podem ser aplicados para criar crews para:

* **Criação de conteúdo:** Redatores, editores, checadores de fatos e designers trabalhando juntos
* **Atendimento ao cliente:** Agentes de triagem, especialistas e controle de qualidade atuando colaborativamente
* **Desenvolvimento de produto:** Pesquisadores, designers e planejadores trabalhando em conjunto
* **Análise de dados:** Coletores de dados, analistas e especialistas em visualização

Agora que você montou sua primeira crew, você pode:

1. Experimentar diferentes configurações e personalidades de agentes
2. Testar estruturas de tarefas e fluxos de trabalho mais complexos
3. Implementar ferramentas customizadas para dar novas capacidades aos agentes
4. Aplicar sua crew em outros temas ou domínios de problemas
5. Explorar [CrewAI Flows](/pt-BR/guides/flows/first-flow) para fluxos de trabalho avançados usando programação procedural

<Check>
  Parabéns! Você construiu com sucesso sua primeira crew com o CrewAI, capaz de pesquisar e analisar qualquer tema que desejar. Essa experiência fundamental lhe deu as habilidades para criar sistemas de IA cada vez mais sofisticados, aptos a encarar problemas complexos e de múltiplas etapas por meio da inteligência colaborativa.
</Check>

---

## Agent will need to provide the CSV path at runtime.

**URL:** llms-txt#agent-will-need-to-provide-the-csv-path-at-runtime.

**Contents:**
- 인자
- 커스텀 모델 및 임베딩

tool = CSVSearchTool()
python Code theme={null}
from chromadb.config import Settings

tool = CSVSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

다음 매개변수들은 `CSVSearchTool`의 동작을 사용자 정의하는 데 사용할 수 있습니다:

| 인자      | 타입       | 설명                                                                                     |
| :------ | :------- | :------------------------------------------------------------------------------------- |
| **csv** | `string` | *선택 사항*. 검색하려는 CSV 파일의 경로입니다. 이 인자는 도구가 특정 CSV 파일 없이 초기화된 경우 필수이며, 그렇지 않은 경우 선택 사항입니다. |

## 커스텀 모델 및 임베딩

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 사용자 지정하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다:
```

---

## Initialize the tool with a specific XML file path

**URL:** llms-txt#initialize-the-tool-with-a-specific-xml-file-path

**Contents:**
- 인자
- 커스텀 모델 및 임베딩

#for exclusive search within that document
tool = XMLSearchTool(xml='path/to/your/xmlfile.xml')
python Code theme={null}
from chromadb.config import Settings

tool = XMLSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

* `xml`: 검색하려는 XML 파일의 경로입니다.
  이 매개변수는 도구 초기화 시 선택적으로 제공할 수 있지만, 검색을 실행하기 위해서는 초기화 시 또는 `run` 메서드의 인자로 반드시 제공되어야 합니다.

## 커스텀 모델 및 임베딩

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 커스터마이징하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다.
```

---

## Portkey 통합

**URL:** llms-txt#portkey-통합

**Contents:**
- 소개
  - 설치 및 설정
- 프로덕션 기능
  - 1. 향상된 가시성
  - 2. 신뢰성 - Crew를 원활하게 운영하세요

Source: https://docs.crewai.com/ko/observability/portkey

CrewAI에서 Portkey를 사용하는 방법

<img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/main/Portkey-CrewAI.png" alt="Portkey CrewAI 헤더 이미지" width="70%" />

Portkey는 CrewAI에 프로덕션 적합성을 위한 기능을 추가하여 실험적인 agent crew를 다음과 같이 견고한 시스템으로 전환합니다.

* **모든 agent 단계, 도구 사용, 상호작용에 대한 완전한 관찰 가능성**
* **내장된 신뢰성**: 폴백, 재시도, 로드 밸런싱 기능 제공
* **AI 비용 관리**를 위한 비용 추적 및 최적화
* **단일 통합을 통한 200개 이상의 LLM 접근**
* **agent의 행동을 안전하고 규정 준수로 유지하는 가드레일**
* **일관된 agent 성능을 위한 버전 관리되는 prompt**

<Steps>
  <Step title="필요한 패키지 설치하기">
    
  </Step>

<Step title="API 키 생성" icon="lock">
    [Portkey 대시보드](https://app.portkey.ai/)에서 예산/속도 제한을 선택적으로 설정하여 Portkey API 키를 생성하세요. 이 키에는 신뢰성, 캐싱 등 여러 가지 구성을 추가로 적용할 수 있습니다. 자세한 내용은 추후 설명합니다.
  </Step>

<Step title="Portkey로 CrewAI 구성하기">
    통합은 매우 간단합니다. CrewAI 설정의 LLM 구성을 다음과 같이 업데이트하기만 하면 됩니다:

<Info>
      **Virtual Key란?** Portkey의 Virtual Key는 LLM 제공업체의 API 키(OpenAI, Anthropic 등)를 암호화된 금고에 안전하게 저장합니다. 이를 통해 키 교체 및 예산 관리를 더 쉽게 할 수 있습니다. [Virtual Key에 대해 자세히 알아보기](https://portkey.ai/docs/product/ai-gateway/virtual-keys).
    </Info>
  </Step>
</Steps>

Portkey는 CrewAI agent에 대한 종합적인 가시성을 제공하여 각 실행 중에 어떤 일이 일어나고 있는지 정확히 이해할 수 있게 도와줍니다.

<Tabs>
  <Tab title="Traces">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Product%2011.1.webp" />
    </Frame>

Traces는 crew의 실행을 계층적으로 보여주며, LLM 호출, 도구 호출, 상태 전환의 순서를 확인할 수 있습니다.

<Tab title="Logs">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Metadata.png" />
    </Frame>

Portkey는 LLM과의 모든 상호작용을 로그로 남깁니다. 여기에는 다음이 포함됩니다:

* 전체 요청 및 응답 페이로드
    * 지연 시간 및 토큰 사용량 지표
    * 비용 계산
    * 도구 호출 및 함수 실행

모든 로그는 메타데이터, trace ID, 모델 등으로 필터링할 수 있어 특정 crew 실행을 쉽게 디버깅할 수 있습니다.
  </Tab>

<Tab title="Metrics & Dashboards">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Dashboard.png" />
    </Frame>

Portkey는 사용자가 다음을 할 수 있도록 지원하는 내장 대시보드를 제공합니다:

* 모든 crew 실행에서 비용 및 토큰 사용량 추적
    * 지연 시간, 성공률과 같은 성능 지표 분석
    * agent workflow의 병목 지점 식별
    * 서로 다른 crew 구성 및 LLM 비교

사용자는 모든 지표를 사용자 정의 메타데이터별로 필터링 및 세분화하여 특정 crew 유형, 사용자 그룹 또는 사용 사례를 분석할 수 있습니다.
  </Tab>

<Tab title="Metadata Filtering">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" alt="Analytics with metadata filters" />
    </Frame>

CrewAI LLM 구성에 사용자 정의 메타데이터를 추가하여 강력한 필터링 및 세분화를 활성화할 수 있습니다:

이 메타데이터는 Portkey 대시보드에서 로그, trace, 지표를 필터링하는 데 사용될 수 있으며, 특정 crew 실행, 사용자 또는 환경을 분석할 수 있습니다.
  </Tab>
</Tabs>

### 2. 신뢰성 - Crew를 원활하게 운영하세요

프로덕션에서 crew를 운영할 때, API 속도 제한, 네트워크 이슈 또는 공급자 장애와 같이 문제가 발생할 수 있습니다. Portkey의 신뢰성 기능은 문제가 발생해도 에이전트가 원활하게 동작하도록 보장합니다.

Portkey Config를 사용하여 CrewAI 설정에서 페일오버를 간단하게 활성화할 수 있습니다:

```python  theme={null}
from crewai import LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="API 키 생성" icon="lock">
    [Portkey 대시보드](https://app.portkey.ai/)에서 예산/속도 제한을 선택적으로 설정하여 Portkey API 키를 생성하세요. 이 키에는 신뢰성, 캐싱 등 여러 가지 구성을 추가로 적용할 수 있습니다. 자세한 내용은 추후 설명합니다.
  </Step>

  <Step title="Portkey로 CrewAI 구성하기">
    통합은 매우 간단합니다. CrewAI 설정의 LLM 구성을 다음과 같이 업데이트하기만 하면 됩니다:
```

Example 2 (unknown):
```unknown
<Info>
      **Virtual Key란?** Portkey의 Virtual Key는 LLM 제공업체의 API 키(OpenAI, Anthropic 등)를 암호화된 금고에 안전하게 저장합니다. 이를 통해 키 교체 및 예산 관리를 더 쉽게 할 수 있습니다. [Virtual Key에 대해 자세히 알아보기](https://portkey.ai/docs/product/ai-gateway/virtual-keys).
    </Info>
  </Step>
</Steps>

## 프로덕션 기능

### 1. 향상된 가시성

Portkey는 CrewAI agent에 대한 종합적인 가시성을 제공하여 각 실행 중에 어떤 일이 일어나고 있는지 정확히 이해할 수 있게 도와줍니다.

<Tabs>
  <Tab title="Traces">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Product%2011.1.webp" />
    </Frame>

    Traces는 crew의 실행을 계층적으로 보여주며, LLM 호출, 도구 호출, 상태 전환의 순서를 확인할 수 있습니다.
```

Example 3 (unknown):
```unknown
</Tab>

  <Tab title="Logs">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Metadata.png" />
    </Frame>

    Portkey는 LLM과의 모든 상호작용을 로그로 남깁니다. 여기에는 다음이 포함됩니다:

    * 전체 요청 및 응답 페이로드
    * 지연 시간 및 토큰 사용량 지표
    * 비용 계산
    * 도구 호출 및 함수 실행

    모든 로그는 메타데이터, trace ID, 모델 등으로 필터링할 수 있어 특정 crew 실행을 쉽게 디버깅할 수 있습니다.
  </Tab>

  <Tab title="Metrics & Dashboards">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Dashboard.png" />
    </Frame>

    Portkey는 사용자가 다음을 할 수 있도록 지원하는 내장 대시보드를 제공합니다:

    * 모든 crew 실행에서 비용 및 토큰 사용량 추적
    * 지연 시간, 성공률과 같은 성능 지표 분석
    * agent workflow의 병목 지점 식별
    * 서로 다른 crew 구성 및 LLM 비교

    사용자는 모든 지표를 사용자 정의 메타데이터별로 필터링 및 세분화하여 특정 crew 유형, 사용자 그룹 또는 사용 사례를 분석할 수 있습니다.
  </Tab>

  <Tab title="Metadata Filtering">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" alt="Analytics with metadata filters" />
    </Frame>

    CrewAI LLM 구성에 사용자 정의 메타데이터를 추가하여 강력한 필터링 및 세분화를 활성화할 수 있습니다:
```

Example 4 (unknown):
```unknown
이 메타데이터는 Portkey 대시보드에서 로그, trace, 지표를 필터링하는 데 사용될 수 있으며, 특정 crew 실행, 사용자 또는 환경을 분석할 수 있습니다.
  </Tab>
</Tabs>

### 2. 신뢰성 - Crew를 원활하게 운영하세요

프로덕션에서 crew를 운영할 때, API 속도 제한, 네트워크 이슈 또는 공급자 장애와 같이 문제가 발생할 수 있습니다. Portkey의 신뢰성 기능은 문제가 발생해도 에이전트가 원활하게 동작하도록 보장합니다.

Portkey Config를 사용하여 CrewAI 설정에서 페일오버를 간단하게 활성화할 수 있습니다:
```

---

## 웹사이트 RAG 검색

**URL:** llms-txt#웹사이트-rag-검색

Source: https://docs.crewai.com/ko/tools/search-research/websitesearchtool

WebsiteSearchTool은(는) 웹사이트의 콘텐츠 내에서 RAG(Retrieval-Augmented Generation) 검색을 수행하도록 설계되었습니다.

---

## Define a structured output format

**URL:** llms-txt#define-a-structured-output-format

class MarketAnalysis(BaseModel):
    key_trends: List[str] = Field(description="List of identified market trends")
    market_size: str = Field(description="Estimated market size")
    competitors: List[str] = Field(description="Major competitors in the space")

---

## Create a multimodal agent for detailed analysis

**URL:** llms-txt#create-a-multimodal-agent-for-detailed-analysis

expert_analyst = Agent(
    role="Visual Quality Inspector",
    goal="Perform detailed quality analysis of product images",
    backstory="Senior quality control expert with expertise in visual inspection",
    multimodal=True  # AddImageTool is automatically included
)

---

## Conectando a Múltiplos Servidores MCP

**URL:** llms-txt#conectando-a-múltiplos-servidores-mcp

**Contents:**
- Visão Geral
- Configuração

Source: https://docs.crewai.com/pt-BR/mcp/multiple-servers

Saiba como usar o MCPServerAdapter no CrewAI para conectar-se simultaneamente a múltiplos servidores MCP e agregar suas ferramentas.

O `MCPServerAdapter` em `crewai-tools` permite que você conecte-se a vários servidores MCP simultaneamente. Isso é útil quando seus agentes precisam acessar ferramentas distribuídas entre diferentes serviços ou ambientes. O adaptador agrega as ferramentas de todos os servidores especificados, tornando-as disponíveis para seus agentes CrewAI.

Para conectar-se a múltiplos servidores, você fornece uma lista de dicionários de parâmetros de servidor para o `MCPServerAdapter`. Cada dicionário na lista deve definir os parâmetros para um servidor MCP.

Os tipos de transporte suportados para cada servidor na lista incluem `stdio`, `sse` e `streamable-http`.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters # Needed for Stdio example

---

## 웹훅 스트리밍

**URL:** llms-txt#웹훅-스트리밍

**Contents:**
- 개요
- 사용법
- Webhook 형식
- 지원되는 이벤트

Source: https://docs.crewai.com/ko/enterprise/features/webhook-streaming

웹훅 스트리밍을 사용하여 이벤트를 웹훅으로 스트리밍하기

Enterprise Event Streaming을 사용하면 CrewAI AMP에 배포된 crew 및 flow에 대한 실시간 웹훅 업데이트(예: 모델 호출, 도구 사용, flow 단계)를 받을 수 있습니다.

Kickoff API를 사용할 때, 요청에 `webhooks` 객체를 포함시키세요. 예를 들면 아래와 같습니다:

`realtime`이 `true`로 설정되면, 각 이벤트가 개별적으로 그리고 즉시 전달되지만 crew/flow 성능에 영향을 미칠 수 있습니다.

각 webhook은 이벤트 목록을 전송합니다:

`data` 객체의 구조는 이벤트 타입에 따라 다릅니다. 자세한 내용은 GitHub의 [이벤트 목록](https://github.com/crewAIInc/crewAI/tree/main/src/crewai/utilities/events)을 참조하세요.

요청이 HTTP를 통해 전송되므로, 이벤트의 순서가 보장되지 않습니다. 순서가 필요하다면 `timestamp` 필드를 사용하세요.

CrewAI는 Enterprise Event Streaming에서 시스템 이벤트와 사용자 지정 이벤트 둘 다를 지원합니다. 이러한 이벤트는 crew 및 flow 실행 중에 구성한 웹훅 엔드포인트로 전송됩니다.

* `crew_kickoff_started`
* `crew_step_started`
* `crew_step_completed`
* `crew_execution_completed`
* `llm_call_started`
* `llm_call_completed`
* `tool_usage_started`
* `tool_usage_completed`
* `crew_test_failed`
* *...그리고 기타 여러 가지*

이벤트 이름은 내부 이벤트 버스와 일치합니다. 전체 목록은 [GitHub 소스](https://github.com/crewAIInc/crewAI/tree/main/src/crewai/utilities/events)에서 확인할 수 있습니다.

사용자 지정 이벤트도 직접 발생시킬 수 있으며, 시스템 이벤트와 함께 웹훅 스트림을 통해 전달됩니다.

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  웹훅 통합 또는 문제 해결에 대한 지원이 필요하다면 저희 지원팀에 문의해 주세요.
</Card>

**Examples:**

Example 1 (unknown):
```unknown
`realtime`이 `true`로 설정되면, 각 이벤트가 개별적으로 그리고 즉시 전달되지만 crew/flow 성능에 영향을 미칠 수 있습니다.

## Webhook 형식

각 webhook은 이벤트 목록을 전송합니다:
```

---

## RAG Tool

**URL:** llms-txt#rag-tool

Source: https://docs.crewai.com/en/tools/ai-ml/ragtool

The `RagTool` is a dynamic knowledge base tool for answering questions using Retrieval-Augmented Generation.

---

## Configure LLM with TrueFoundry

**URL:** llms-txt#configure-llm-with-truefoundry

llm = LLM(
    model="openai-main/gpt-4o",
    base_url="your_truefoundry_gateway_base_url",
    api_key="your_truefoundry_api_key"
)

---

## Defina uma tarefa de exemplo

**URL:** llms-txt#defina-uma-tarefa-de-exemplo

engineering_task = Task(
    description="Review AI implementation files for potential improvements",
    expected_output="A summary of key findings and recommendations",
    agent=principal_engineer
)

---

## Salesforce 통합

**URL:** llms-txt#salesforce-통합

**Contents:**
- 개요
- 사전 준비 사항
- Salesforce 통합 설정
  - 1. Salesforce 계정 연결
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 도구
  - **레코드 관리**
  - **레코드 업데이트**
  - **레코드 조회**

Source: https://docs.crewai.com/ko/enterprise/integrations/salesforce

CrewAI를 위한 Salesforce 통합을 통한 CRM 및 영업 자동화.

에이전트가 Salesforce를 통해 고객 관계, 영업 프로세스 및 데이터를 관리할 수 있도록 합니다. 레코드를 생성 및 업데이트하고, 리드와 기회를 관리하며, SOQL 쿼리를 실행하고, AI 기반 자동화로 CRM 워크플로를 간소화하세요.

Salesforce 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 Salesforce 계정
* [통합 페이지](https://app.crewai.com/integrations)를 통해 Salesforce 계정 연결

### 1. Salesforce 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동합니다.
2. 인증 통합 섹션에서 **Salesforce**를 찾습니다.
3. **연결**을 클릭하고 OAuth 과정을 완료합니다.
4. CRM 및 영업 관리에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="salesforce/create_record_contact">
    **설명:** Salesforce에서 새로운 Contact 레코드를 생성합니다.

* `FirstName` (string, 선택): 이름
    * `LastName` (string, 필수): 성 - 이 필드는 필수입니다
    * `accountId` (string, 선택): Account ID - 이 Contact가 소속된 Account
    * `Email` (string, 선택): 이메일 주소
    * `Title` (string, 선택): 담당자의 직함(예: CEO 또는 Vice President 등)
    * `Description` (string, 선택): Contact에 대한 설명
    * `additionalFields` (object, 선택): 사용자 정의 Contact 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/create_record_lead">
    **설명:** Salesforce에서 새로운 Lead 레코드를 생성합니다.

* `FirstName` (string, 선택): 이름
    * `LastName` (string, 필수): 성 - 이 필드는 필수입니다
    * `Company` (string, 필수): 회사명 - 이 필드는 필수입니다
    * `Email` (string, 선택): 이메일 주소
    * `Phone` (string, 선택): 전화번호
    * `Website` (string, 선택): 웹사이트 URL
    * `Title` (string, 선택): 담당자의 직함(예: CEO 또는 Vice President 등)
    * `Status` (string, 선택): 리드 상태 - 리드 상태를 선택하려면 Connect Portal Workflow 설정을 사용하세요
    * `Description` (string, 선택): Lead에 대한 설명
    * `additionalFields` (object, 선택): 사용자 정의 Lead 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/create_record_opportunity">
    **설명:** Salesforce에서 새로운 Opportunity 레코드를 생성합니다.

* `Name` (string, 필수): Opportunity 이름 - 이 필드는 필수입니다
    * `StageName` (string, 선택): Opportunity 단계 - 단계를 선택하려면 Connect Portal Workflow 설정을 사용하세요
    * `CloseDate` (string, 선택): 마감일(YYYY-MM-DD 형식) - 기본값은 현재 날짜로부터 30일 이후
    * `AccountId` (string, 선택): 이 Opportunity가 소속된 Account
    * `Amount` (string, 선택): 예상 전체 판매 금액
    * `Description` (string, 선택): Opportunity에 대한 설명
    * `OwnerId` (string, 선택): 이 Opportunity를 담당하는 Salesforce 사용자
    * `NextStep` (string, 선택): Opportunity 마감을 위한 다음 작업의 설명
    * `additionalFields` (object, 선택): 사용자 정의 Opportunity 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/create_record_task">
    **설명:** Salesforce에서 새로운 Task 레코드를 생성합니다.

* `whatId` (string, 선택): 관련 ID - 이 Task가 관련된 Account 또는 Opportunity의 ID
    * `whoId` (string, 선택): 이름 ID - 이 Task가 관련된 Contact 또는 Lead의 ID
    * `subject` (string, 필수): 작업 제목
    * `activityDate` (string, 선택): 작업 날짜(YYYY-MM-DD 형식)
    * `description` (string, 선택): Task에 대한 설명
    * `taskSubtype` (string, 필수): Task 하위 유형 - 선택 항목: task, email, listEmail, call
    * `Status` (string, 선택): 상태 - 선택 항목: Not Started, In Progress, Completed
    * `ownerId` (string, 선택): 담당자 ID - 이 Task를 담당하는 Salesforce 사용자
    * `callDurationInSeconds` (string, 선택): 통화 시간(초)
    * `isReminderSet` (boolean, 선택): 알림 설정 여부
    * `reminderDateTime` (string, 선택): 알림 날짜/시간(ISO 형식)
    * `additionalFields` (object, 선택): 사용자 정의 Task 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/create_record_account">
    **설명:** Salesforce에서 새로운 Account 레코드를 생성합니다.

* `Name` (string, 필수): Account 이름 - 이 필드는 필수입니다
    * `OwnerId` (string, 선택): 이 Account를 담당하는 Salesforce 사용자
    * `Website` (string, 선택): 웹사이트 URL
    * `Phone` (string, 선택): 전화번호
    * `Description` (string, 선택): Account 설명
    * `additionalFields` (object, 선택): 사용자 정의 Account 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/create_record_any">
    **설명:** Salesforce에서 모든 오브젝트 유형의 레코드를 생성합니다.

**참고:** 이 기능은 사용자 정의 또는 알려지지 않은 오브젝트 유형의 레코드를 생성할 때 유연하게 사용할 수 있습니다.
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="salesforce/update_record_contact">
    **설명:** Salesforce에서 기존 연락처(Contact) 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `FirstName` (string, 선택): 이름
    * `LastName` (string, 선택): 성
    * `accountId` (string, 선택): 계정 ID - 연락처가 속한 계정
    * `Email` (string, 선택): 이메일 주소
    * `Title` (string, 선택): 연락처의 직함
    * `Description` (string, 선택): 연락처에 대한 설명
    * `additionalFields` (object, 선택): 커스텀 연락처 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/update_record_lead">
    **설명:** Salesforce에서 기존 리드(Lead) 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `FirstName` (string, 선택): 이름
    * `LastName` (string, 선택): 성
    * `Company` (string, 선택): 회사명
    * `Email` (string, 선택): 이메일 주소
    * `Phone` (string, 선택): 전화번호
    * `Website` (string, 선택): 웹사이트 URL
    * `Title` (string, 선택): 연락처의 직함
    * `Status` (string, 선택): 리드 상태
    * `Description` (string, 선택): 리드에 대한 설명
    * `additionalFields` (object, 선택): 커스텀 리드 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/update_record_opportunity">
    **설명:** Salesforce에서 기존 기회(Opportunity) 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `Name` (string, 선택): 기회명
    * `StageName` (string, 선택): 기회 단계
    * `CloseDate` (string, 선택): 마감 날짜 (YYYY-MM-DD 형식)
    * `AccountId` (string, 선택): 기회가 속한 계정
    * `Amount` (string, 선택): 예상 총 판매 금액
    * `Description` (string, 선택): 기회에 대한 설명
    * `OwnerId` (string, 선택): 이 기회를 담당하는 Salesforce 사용자
    * `NextStep` (string, 선택): 기회 마감을 위한 다음 작업의 설명
    * `additionalFields` (object, 선택): 커스텀 기회 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/update_record_task">
    **설명:** Salesforce에서 기존 작업(Task) 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `whatId` (string, 선택): 관련 ID - 이 작업이 연결된 계정 또는 기회의 ID
    * `whoId` (string, 선택): 이름 ID - 이 작업이 연결된 연락처 또는 리드의 ID
    * `subject` (string, 선택): 작업의 주제
    * `activityDate` (string, 선택): 활동 날짜 (YYYY-MM-DD 형식)
    * `description` (string, 선택): 작업에 대한 설명
    * `Status` (string, 선택): 상태 - 옵션: Not Started, In Progress, Completed
    * `ownerId` (string, 선택): 담당자 ID - 이 작업을 할당받은 Salesforce 사용자
    * `callDurationInSeconds` (string, 선택): 통화 시간(초)
    * `isReminderSet` (boolean, 선택): 알림 설정 여부
    * `reminderDateTime` (string, 선택): 알림 날짜/시간 (ISO 형식)
    * `additionalFields` (object, 선택): 커스텀 작업 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/update_record_account">
    **설명:** Salesforce에서 기존 계정(Account) 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `Name` (string, 선택): 계정 이름
    * `OwnerId` (string, 선택): 이 계정에 할당된 Salesforce 사용자
    * `Website` (string, 선택): 웹사이트 URL
    * `Phone` (string, 선택): 전화번호
    * `Description` (string, 선택): 계정 설명
    * `additionalFields` (object, 선택): 커스텀 계정 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

<Accordion title="salesforce/update_record_any">
    **설명:** Salesforce에서 어떤 객체 유형이든 레코드를 업데이트합니다.

**참고:** 이는 커스텀 또는 미확인 객체 유형의 레코드 업데이트를 위한 유연한 도구입니다.
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_id_contact">
    **설명:** ID로 Contact 레코드를 조회합니다.

* `recordId` (string, 필수): Contact의 레코드 ID
  </Accordion>

<Accordion title="salesforce/get_record_by_id_lead">
    **설명:** ID로 Lead 레코드를 조회합니다.

* `recordId` (string, 필수): Lead의 레코드 ID
  </Accordion>

<Accordion title="salesforce/get_record_by_id_opportunity">
    **설명:** ID로 Opportunity 레코드를 조회합니다.

* `recordId` (string, 필수): Opportunity의 레코드 ID
  </Accordion>

<Accordion title="salesforce/get_record_by_id_task">
    **설명:** ID로 Task 레코드를 조회합니다.

* `recordId` (string, 필수): Task의 레코드 ID
  </Accordion>

<Accordion title="salesforce/get_record_by_id_account">
    **설명:** ID로 Account 레코드를 조회합니다.

* `recordId` (string, 필수): Account의 레코드 ID
  </Accordion>

<Accordion title="salesforce/get_record_by_id_any">
    **설명:** ID로 임의 객체 유형의 레코드를 조회합니다.

* `recordType` (string, 필수): 레코드 유형 (예: "CustomObject\_\_c")
    * `recordId` (string, 필수): 레코드 ID
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="salesforce/search_records_contact">
    **설명:** 고급 필터링으로 연락처(Contact) 레코드를 검색합니다.

* `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형(Disjunctive Normal Form)의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/search_records_lead">
    **설명:** 고급 필터링으로 리드(Lead) 레코드를 검색합니다.

* `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/search_records_opportunity">
    **설명:** 고급 필터링으로 기회(Opportunity) 레코드를 검색합니다.

* `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/search_records_task">
    **설명:** 고급 필터링으로 작업(Task) 레코드를 검색합니다.

* `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/search_records_account">
    **설명:** 고급 필터링으로 계정(Account) 레코드를 검색합니다.

* `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/search_records_any">
    **설명:** 모든 오브젝트 유형의 레코드를 검색합니다.

* `recordType` (string, 필수): 검색할 레코드 유형
    * `filterFormula` (string, 선택): 필터 검색 조건
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_view_id_contact">
    **설명:** 특정 리스트 뷰에서 Contact 레코드를 가져옵니다.

* `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_lead">
    **설명:** 특정 리스트 뷰에서 Lead 레코드를 가져옵니다.

* `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_opportunity">
    **설명:** 특정 리스트 뷰에서 Opportunity 레코드를 가져옵니다.

* `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_task">
    **설명:** 특정 리스트 뷰에서 Task 레코드를 가져옵니다.

* `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_account">
    **설명:** 특정 리스트 뷰에서 Account 레코드를 가져옵니다.

* `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_any">
    **설명:** 특정 리스트 뷰에서 임의의 객체 유형의 레코드를 가져옵니다.

* `recordType` (string, 필수): 레코드 유형
    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="salesforce/create_custom_field_contact">
    **설명:** Contact 오브젝트에 대한 커스텀 필드를 배포합니다.

* `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

<Accordion title="salesforce/create_custom_field_lead">
    **설명:** Lead 오브젝트에 대한 커스텀 필드를 배포합니다.

* `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

<Accordion title="salesforce/create_custom_field_opportunity">
    **설명:** Opportunity 오브젝트에 대한 커스텀 필드를 배포합니다.

* `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

<Accordion title="salesforce/create_custom_field_task">
    **설명:** Task 오브젝트에 대한 커스텀 필드를 배포합니다.

* `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

<Accordion title="salesforce/create_custom_field_account">
    **설명:** Account 오브젝트에 대한 커스텀 필드를 배포합니다.

* `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

<Accordion title="salesforce/create_custom_field_any">
    **설명:** 모든 오브젝트 타입에 대한 커스텀 필드를 배포합니다.

**참고:** 커스텀 또는 미지의 오브젝트 타입에 커스텀 필드를 생성할 수 있는 유연한 도구입니다.
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="salesforce/write_soql_query">
    **설명:** Salesforce 데이터에 대해 커스텀 SOQL 쿼리를 실행합니다.

* `query` (string, 필수): SOQL 쿼리 (예: "SELECT Id, Name FROM Account WHERE Name = 'Example'")
  </Accordion>

<Accordion title="salesforce/create_custom_object">
    **설명:** Salesforce에 새로운 커스텀 오브젝트를 배포합니다.

* `label` (string, 필수): 탭, 페이지 레이아웃, 리포트에 사용되는 오브젝트 라벨
    * `pluralLabel` (string, 필수): 복수형 라벨 (예: "Accounts")
    * `description` (string, 선택): 커스텀 오브젝트에 대한 설명
    * `recordName` (string, 필수): 레이아웃과 검색에 표시되는 레코드 이름 (예: "Account Name")
  </Accordion>

<Accordion title="salesforce/describe_action_schema">
    **설명:** 특정 오브젝트 타입에 대한 작업의 예상 스키마를 가져옵니다.

* `recordType` (string, 필수): 설명할 레코드 타입
    * `operation` (string, 필수): 작업 타입 (예: "CREATE\_RECORD" 또는 "UPDATE\_RECORD")

**참고:** 커스텀 오브젝트 작업 시, 해당 스키마를 이해하기 위해 제일 먼저 이 기능을 사용하세요.
  </Accordion>
</AccordionGroup>

### 기본 Salesforce 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 도구

### **레코드 관리**

<AccordionGroup>
  <Accordion title="salesforce/create_record_contact">
    **설명:** Salesforce에서 새로운 Contact 레코드를 생성합니다.

    **파라미터:**

    * `FirstName` (string, 선택): 이름
    * `LastName` (string, 필수): 성 - 이 필드는 필수입니다
    * `accountId` (string, 선택): Account ID - 이 Contact가 소속된 Account
    * `Email` (string, 선택): 이메일 주소
    * `Title` (string, 선택): 담당자의 직함(예: CEO 또는 Vice President 등)
    * `Description` (string, 선택): Contact에 대한 설명
    * `additionalFields` (object, 선택): 사용자 정의 Contact 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/create_record_lead">
    **설명:** Salesforce에서 새로운 Lead 레코드를 생성합니다.

    **파라미터:**

    * `FirstName` (string, 선택): 이름
    * `LastName` (string, 필수): 성 - 이 필드는 필수입니다
    * `Company` (string, 필수): 회사명 - 이 필드는 필수입니다
    * `Email` (string, 선택): 이메일 주소
    * `Phone` (string, 선택): 전화번호
    * `Website` (string, 선택): 웹사이트 URL
    * `Title` (string, 선택): 담당자의 직함(예: CEO 또는 Vice President 등)
    * `Status` (string, 선택): 리드 상태 - 리드 상태를 선택하려면 Connect Portal Workflow 설정을 사용하세요
    * `Description` (string, 선택): Lead에 대한 설명
    * `additionalFields` (object, 선택): 사용자 정의 Lead 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/create_record_opportunity">
    **설명:** Salesforce에서 새로운 Opportunity 레코드를 생성합니다.

    **파라미터:**

    * `Name` (string, 필수): Opportunity 이름 - 이 필드는 필수입니다
    * `StageName` (string, 선택): Opportunity 단계 - 단계를 선택하려면 Connect Portal Workflow 설정을 사용하세요
    * `CloseDate` (string, 선택): 마감일(YYYY-MM-DD 형식) - 기본값은 현재 날짜로부터 30일 이후
    * `AccountId` (string, 선택): 이 Opportunity가 소속된 Account
    * `Amount` (string, 선택): 예상 전체 판매 금액
    * `Description` (string, 선택): Opportunity에 대한 설명
    * `OwnerId` (string, 선택): 이 Opportunity를 담당하는 Salesforce 사용자
    * `NextStep` (string, 선택): Opportunity 마감을 위한 다음 작업의 설명
    * `additionalFields` (object, 선택): 사용자 정의 Opportunity 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/create_record_task">
    **설명:** Salesforce에서 새로운 Task 레코드를 생성합니다.

    **파라미터:**

    * `whatId` (string, 선택): 관련 ID - 이 Task가 관련된 Account 또는 Opportunity의 ID
    * `whoId` (string, 선택): 이름 ID - 이 Task가 관련된 Contact 또는 Lead의 ID
    * `subject` (string, 필수): 작업 제목
    * `activityDate` (string, 선택): 작업 날짜(YYYY-MM-DD 형식)
    * `description` (string, 선택): Task에 대한 설명
    * `taskSubtype` (string, 필수): Task 하위 유형 - 선택 항목: task, email, listEmail, call
    * `Status` (string, 선택): 상태 - 선택 항목: Not Started, In Progress, Completed
    * `ownerId` (string, 선택): 담당자 ID - 이 Task를 담당하는 Salesforce 사용자
    * `callDurationInSeconds` (string, 선택): 통화 시간(초)
    * `isReminderSet` (boolean, 선택): 알림 설정 여부
    * `reminderDateTime` (string, 선택): 알림 날짜/시간(ISO 형식)
    * `additionalFields` (object, 선택): 사용자 정의 Task 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/create_record_account">
    **설명:** Salesforce에서 새로운 Account 레코드를 생성합니다.

    **파라미터:**

    * `Name` (string, 필수): Account 이름 - 이 필드는 필수입니다
    * `OwnerId` (string, 선택): 이 Account를 담당하는 Salesforce 사용자
    * `Website` (string, 선택): 웹사이트 URL
    * `Phone` (string, 선택): 전화번호
    * `Description` (string, 선택): Account 설명
    * `additionalFields` (object, 선택): 사용자 정의 Account 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/create_record_any">
    **설명:** Salesforce에서 모든 오브젝트 유형의 레코드를 생성합니다.

    **참고:** 이 기능은 사용자 정의 또는 알려지지 않은 오브젝트 유형의 레코드를 생성할 때 유연하게 사용할 수 있습니다.
  </Accordion>
</AccordionGroup>

### **레코드 업데이트**

<AccordionGroup>
  <Accordion title="salesforce/update_record_contact">
    **설명:** Salesforce에서 기존 연락처(Contact) 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `FirstName` (string, 선택): 이름
    * `LastName` (string, 선택): 성
    * `accountId` (string, 선택): 계정 ID - 연락처가 속한 계정
    * `Email` (string, 선택): 이메일 주소
    * `Title` (string, 선택): 연락처의 직함
    * `Description` (string, 선택): 연락처에 대한 설명
    * `additionalFields` (object, 선택): 커스텀 연락처 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/update_record_lead">
    **설명:** Salesforce에서 기존 리드(Lead) 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `FirstName` (string, 선택): 이름
    * `LastName` (string, 선택): 성
    * `Company` (string, 선택): 회사명
    * `Email` (string, 선택): 이메일 주소
    * `Phone` (string, 선택): 전화번호
    * `Website` (string, 선택): 웹사이트 URL
    * `Title` (string, 선택): 연락처의 직함
    * `Status` (string, 선택): 리드 상태
    * `Description` (string, 선택): 리드에 대한 설명
    * `additionalFields` (object, 선택): 커스텀 리드 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/update_record_opportunity">
    **설명:** Salesforce에서 기존 기회(Opportunity) 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `Name` (string, 선택): 기회명
    * `StageName` (string, 선택): 기회 단계
    * `CloseDate` (string, 선택): 마감 날짜 (YYYY-MM-DD 형식)
    * `AccountId` (string, 선택): 기회가 속한 계정
    * `Amount` (string, 선택): 예상 총 판매 금액
    * `Description` (string, 선택): 기회에 대한 설명
    * `OwnerId` (string, 선택): 이 기회를 담당하는 Salesforce 사용자
    * `NextStep` (string, 선택): 기회 마감을 위한 다음 작업의 설명
    * `additionalFields` (object, 선택): 커스텀 기회 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/update_record_task">
    **설명:** Salesforce에서 기존 작업(Task) 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `whatId` (string, 선택): 관련 ID - 이 작업이 연결된 계정 또는 기회의 ID
    * `whoId` (string, 선택): 이름 ID - 이 작업이 연결된 연락처 또는 리드의 ID
    * `subject` (string, 선택): 작업의 주제
    * `activityDate` (string, 선택): 활동 날짜 (YYYY-MM-DD 형식)
    * `description` (string, 선택): 작업에 대한 설명
    * `Status` (string, 선택): 상태 - 옵션: Not Started, In Progress, Completed
    * `ownerId` (string, 선택): 담당자 ID - 이 작업을 할당받은 Salesforce 사용자
    * `callDurationInSeconds` (string, 선택): 통화 시간(초)
    * `isReminderSet` (boolean, 선택): 알림 설정 여부
    * `reminderDateTime` (string, 선택): 알림 날짜/시간 (ISO 형식)
    * `additionalFields` (object, 선택): 커스텀 작업 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/update_record_account">
    **설명:** Salesforce에서 기존 계정(Account) 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 레코드의 ID
    * `Name` (string, 선택): 계정 이름
    * `OwnerId` (string, 선택): 이 계정에 할당된 Salesforce 사용자
    * `Website` (string, 선택): 웹사이트 URL
    * `Phone` (string, 선택): 전화번호
    * `Description` (string, 선택): 계정 설명
    * `additionalFields` (object, 선택): 커스텀 계정 필드를 위한 JSON 형식의 추가 필드
  </Accordion>

  <Accordion title="salesforce/update_record_any">
    **설명:** Salesforce에서 어떤 객체 유형이든 레코드를 업데이트합니다.

    **참고:** 이는 커스텀 또는 미확인 객체 유형의 레코드 업데이트를 위한 유연한 도구입니다.
  </Accordion>
</AccordionGroup>

### **레코드 조회**

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_id_contact">
    **설명:** ID로 Contact 레코드를 조회합니다.

    **파라미터:**

    * `recordId` (string, 필수): Contact의 레코드 ID
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_lead">
    **설명:** ID로 Lead 레코드를 조회합니다.

    **파라미터:**

    * `recordId` (string, 필수): Lead의 레코드 ID
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_opportunity">
    **설명:** ID로 Opportunity 레코드를 조회합니다.

    **파라미터:**

    * `recordId` (string, 필수): Opportunity의 레코드 ID
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_task">
    **설명:** ID로 Task 레코드를 조회합니다.

    **파라미터:**

    * `recordId` (string, 필수): Task의 레코드 ID
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_account">
    **설명:** ID로 Account 레코드를 조회합니다.

    **파라미터:**

    * `recordId` (string, 필수): Account의 레코드 ID
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_any">
    **설명:** ID로 임의 객체 유형의 레코드를 조회합니다.

    **파라미터:**

    * `recordType` (string, 필수): 레코드 유형 (예: "CustomObject\_\_c")
    * `recordId` (string, 필수): 레코드 ID
  </Accordion>
</AccordionGroup>

### **레코드 검색**

<AccordionGroup>
  <Accordion title="salesforce/search_records_contact">
    **설명:** 고급 필터링으로 연락처(Contact) 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형(Disjunctive Normal Form)의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/search_records_lead">
    **설명:** 고급 필터링으로 리드(Lead) 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/search_records_opportunity">
    **설명:** 고급 필터링으로 기회(Opportunity) 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/search_records_task">
    **설명:** 고급 필터링으로 작업(Task) 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/search_records_account">
    **설명:** 고급 필터링으로 계정(Account) 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 필드별 연산자가 지정된 분리적 정규형의 고급 필터
    * `sortBy` (string, 선택): 정렬 기준 필드 (예: "CreatedDate")
    * `sortDirection` (string, 선택): 정렬 방향 - 옵션: ASC, DESC
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/search_records_any">
    **설명:** 모든 오브젝트 유형의 레코드를 검색합니다.

    **파라미터:**

    * `recordType` (string, 필수): 검색할 레코드 유형
    * `filterFormula` (string, 선택): 필터 검색 조건
    * `includeAllFields` (boolean, 선택): 결과에 모든 필드를 포함
    * `paginationParameters` (object, 선택): pageCursor를 포함한 페이지네이션 설정
  </Accordion>
</AccordionGroup>

### **리스트 뷰 조회**

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_view_id_contact">
    **설명:** 특정 리스트 뷰에서 Contact 레코드를 가져옵니다.

    **파라미터:**

    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_lead">
    **설명:** 특정 리스트 뷰에서 Lead 레코드를 가져옵니다.

    **파라미터:**

    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_opportunity">
    **설명:** 특정 리스트 뷰에서 Opportunity 레코드를 가져옵니다.

    **파라미터:**

    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_task">
    **설명:** 특정 리스트 뷰에서 Task 레코드를 가져옵니다.

    **파라미터:**

    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_account">
    **설명:** 특정 리스트 뷰에서 Account 레코드를 가져옵니다.

    **파라미터:**

    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_any">
    **설명:** 특정 리스트 뷰에서 임의의 객체 유형의 레코드를 가져옵니다.

    **파라미터:**

    * `recordType` (string, 필수): 레코드 유형
    * `listViewId` (string, 필수): 리스트 뷰 ID
    * `paginationParameters` (object, 선택): pageCursor와 함께 사용하는 페이지네이션 설정
  </Accordion>
</AccordionGroup>

### **커스텀 필드**

<AccordionGroup>
  <Accordion title="salesforce/create_custom_field_contact">
    **설명:** Contact 오브젝트에 대한 커스텀 필드를 배포합니다.

    **파라미터:**

    * `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

  <Accordion title="salesforce/create_custom_field_lead">
    **설명:** Lead 오브젝트에 대한 커스텀 필드를 배포합니다.

    **파라미터:**

    * `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

  <Accordion title="salesforce/create_custom_field_opportunity">
    **설명:** Opportunity 오브젝트에 대한 커스텀 필드를 배포합니다.

    **파라미터:**

    * `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

  <Accordion title="salesforce/create_custom_field_task">
    **설명:** Task 오브젝트에 대한 커스텀 필드를 배포합니다.

    **파라미터:**

    * `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

  <Accordion title="salesforce/create_custom_field_account">
    **설명:** Account 오브젝트에 대한 커스텀 필드를 배포합니다.

    **파라미터:**

    * `label` (string, 필수): 표시 및 내부 참조를 위한 필드 라벨
    * `type` (string, 필수): 필드 유형 - 옵션: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, 선택): 체크박스 필드의 기본값
    * `length` (string, 필수): 숫자/텍스트 필드의 길이
    * `decimalPlace` (string, 필수): 숫자 필드의 소수 자릿수
    * `pickListValues` (string, 필수): 피클리스트 필드의 값(줄바꿈으로 구분)
    * `visibleLines` (string, 필수): 멀티셀렉트/텍스트 영역 필드의 표시 줄 수
    * `description` (string, 선택): 필드 설명
    * `helperText` (string, 선택): 마우스를 올렸을 때 표시되는 도움말 텍스트
    * `defaultFieldValue` (string, 선택): 필드의 기본값
  </Accordion>

  <Accordion title="salesforce/create_custom_field_any">
    **설명:** 모든 오브젝트 타입에 대한 커스텀 필드를 배포합니다.

    **참고:** 커스텀 또는 미지의 오브젝트 타입에 커스텀 필드를 생성할 수 있는 유연한 도구입니다.
  </Accordion>
</AccordionGroup>

### **고급 작업**

<AccordionGroup>
  <Accordion title="salesforce/write_soql_query">
    **설명:** Salesforce 데이터에 대해 커스텀 SOQL 쿼리를 실행합니다.

    **파라미터:**

    * `query` (string, 필수): SOQL 쿼리 (예: "SELECT Id, Name FROM Account WHERE Name = 'Example'")
  </Accordion>

  <Accordion title="salesforce/create_custom_object">
    **설명:** Salesforce에 새로운 커스텀 오브젝트를 배포합니다.

    **파라미터:**

    * `label` (string, 필수): 탭, 페이지 레이아웃, 리포트에 사용되는 오브젝트 라벨
    * `pluralLabel` (string, 필수): 복수형 라벨 (예: "Accounts")
    * `description` (string, 선택): 커스텀 오브젝트에 대한 설명
    * `recordName` (string, 필수): 레이아웃과 검색에 표시되는 레코드 이름 (예: "Account Name")
  </Accordion>

  <Accordion title="salesforce/describe_action_schema">
    **설명:** 특정 오브젝트 타입에 대한 작업의 예상 스키마를 가져옵니다.

    **파라미터:**

    * `recordType` (string, 필수): 설명할 레코드 타입
    * `operation` (string, 필수): 작업 타입 (예: "CREATE\_RECORD" 또는 "UPDATE\_RECORD")

    **참고:** 커스텀 오브젝트 작업 시, 해당 스키마를 이해하기 위해 제일 먼저 이 기능을 사용하세요.
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 Salesforce 에이전트 설정
```

---

## Create agent with guardrailed LLM

**URL:** llms-txt#create-agent-with-guardrailed-llm

**Contents:**
  - 5. 메타데이터로 사용자 추적

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=portkey_llm
)
python  theme={null}
from crewai import Agent, LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
Portkey의 가드레일은 다음을 수행할 수 있습니다:

* 입력 및 출력의 PII 감지 및 마스킹
* 유해하거나 부적절한 콘텐츠 필터링
* 응답 형식을 스키마에 따라 검증
* 근거 자료와 비교하여 환각 여부 확인
* 맞춤형 비즈니스 로직 및 규칙 적용

<Card title="가드레일에 대해 더 알아보기" icon="shield-check" href="https://portkey.ai/docs/product/guardrails">
  Portkey의 가드레일 기능을 탐색하여 agent의 안전성을 높여보세요
</Card>

### 5. 메타데이터로 사용자 추적

Portkey의 메타데이터 시스템을 사용하여 CrewAI 에이전트를 통해 개별 사용자를 추적할 수 있습니다.

**Portkey에서의 메타데이터란?**

메타데이터를 사용하면 각 요청에 사용자 지정 데이터를 연결할 수 있어 필터링, 세분화, 분석이 가능합니다. 특별한 `_user` 필드는 사용자 추적을 위해 특별히 설계되었습니다.
```

---

## Hyperbrowser 로드 도구

**URL:** llms-txt#hyperbrowser-로드-도구

Source: https://docs.crewai.com/ko/tools/web-scraping/hyperbrowserloadtool

HyperbrowserLoadTool은 Hyperbrowser를 사용하여 웹 스크래핑과 크롤링을 가능하게 합니다.

---

## Crie agente com LLM rastreado

**URL:** llms-txt#crie-agente-com-llm-rastreado

**Contents:**
  - 6. Cache para Crews Eficientes
  - 7. Interoperabilidade de Modelos

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=portkey_llm
)
python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

# Configure o LLM com caching simples
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
            config={
                "cache": {
                    "mode": "simple"
                }
            }
        )
    )

# Crie agente com LLM cacheado
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

# Configure o LLM com cache semântico
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
            config={
                "cache": {
                    "mode": "semantic"
                }
            }
        )
    )

# Crie agente com LLM com cache semântico
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
from crewai import Agent, LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
**Filtre Analytics por Usuário**

Com os metadados configurados, você pode filtrar analytics por usuário e analisar métricas de desempenho individualmente:

<Frame caption="Filtre analytics por usuário">
  <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" />
</Frame>

Isso permite:

* Rastreamento de custos e orçamento por usuário
* Analytics personalizados por usuário
* Métricas por equipe ou organização
* Monitoramento específico por ambiente (homologação x produção)

<Card title="Saiba Mais Sobre Metadata" icon="tags" href="https://portkey.ai/docs/product/observability/metadata">
  Veja como usar metadados personalizados para aprimorar seus analytics
</Card>

### 6. Cache para Crews Eficientes

Implemente caching para tornar seus agentes CrewAI mais eficientes e econômicos:

<Tabs>
  <Tab title="Caching Simples">
```

Example 2 (unknown):
```unknown
O caching simples realiza correspondências exatas de prompts de entrada, cacheando requisições idênticas para evitar execuções redundantes do modelo.
  </Tab>

  <Tab title="Cache Semântico">
```

Example 3 (unknown):
```unknown
O cache semântico considera a similaridade contextual entre solicitações de entrada, armazenando respostas para entradas semanticamente similares.
  </Tab>
</Tabs>

### 7. Interoperabilidade de Modelos

O CrewAI oferece suporte a múltiplos provedores de LLM, e o Portkey amplia essa capacidade fornecendo acesso a mais de 200 LLMs por meio de uma interface unificada. Você pode facilmente alternar entre diferentes modelos sem alterar a lógica central do seu agente:
```

---

## This minimizes connection overhead and improves startup performance

**URL:** llms-txt#this-minimizes-connection-overhead-and-improves-startup-performance

**Contents:**
- Integration with Existing Features
- Best Practices
  - 1. Use Specific Tools When Possible

python  theme={null}
from crewai.tools import BaseTool

class CustomTool(BaseTool):
    name: str = "custom_analysis"
    description: str = "Custom analysis tool"

def _run(self, **kwargs):
        return "Custom analysis result"

agent = Agent(
    role="Full-Featured Agent",
    goal="Use all available tool types",
    backstory="Agent with comprehensive tool access",

# All tool types work together
    tools=[CustomTool()],                          # Custom tools
    apps=["gmail", "slack"],                       # Platform integrations
    mcps=[                                         # MCP servers
        "https://mcp.exa.ai/mcp?api_key=key",
        "crewai-amp:research-tools"
    ],

verbose=True,
    max_iter=15
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Integration with Existing Features

MCP tools work seamlessly with other CrewAI features:
```

Example 2 (unknown):
```unknown
## Best Practices

### 1. Use Specific Tools When Possible
```

---

## [CÓDIGO NÃO TRADUZIDO, MANTER COMO ESTÁ]

**URL:** llms-txt#[código-não-traduzido,-manter-como-está]

**Contents:**
- Passo 6: Configure suas Variáveis de Ambiente

sh .env theme={null}
OPENAI_API_KEY=sua_chave_openai

**Examples:**

Example 1 (unknown):
```unknown
Vamos analisar o que está acontecendo neste flow:

1. Definimos modelos Pydantic para dados estruturados, garantindo segurança de tipos e representação clara dos dados.
2. Criamos uma classe de estado para manter dados entre os diferentes passos do flow.
3. Implementamos três etapas principais para o flow:
   * Obtenção da entrada do usuário com o decorator `@start()`
   * Criação do roteiro do guia com uma chamada direta à LLM
   * Processamento das seções com nosso crew de conteúdo
4. Usamos o decorator `@listen()` para estabelecer relações orientadas a eventos entre as etapas

Este é o poder dos flows – combinar diferentes tipos de processamento (interação com usuário, chamadas diretas a IA, tarefas colaborativas com crews) em um sistema orientado a eventos e coeso.

## Passo 6: Configure suas Variáveis de Ambiente

Crie um arquivo `.env` na raiz do projeto com suas chaves de API. Veja o [guia de configuração do LLM](/pt-BR/concepts/llms#setting-up-your-llm) para detalhes sobre como configurar o provedor.
```

---

## Initialize the tool with predefined parameters

**URL:** llms-txt#initialize-the-tool-with-predefined-parameters

**Contents:**
- Parâmetros
- Uso

scrape_tool = ScrapegraphScrapeTool(
    website_url="https://www.example.com",
    user_prompt="Extract all product prices and descriptions",
    api_key="your_api_key"
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros

A `ScrapegraphScrapeTool` aceita os seguintes parâmetros durante a inicialização:

* **api\_key**: Opcional. Sua chave de API do Scrapegraph. Se não for fornecida, será procurada a variável de ambiente `SCRAPEGRAPH_API_KEY`.
* **website\_url**: Opcional. A URL do site a ser extraído. Se fornecida na inicialização, o agente não precisa especificá-la ao usar a ferramenta.
* **user\_prompt**: Opcional. Instruções customizadas para extração de conteúdo. Se fornecida na inicialização, o agente não precisa especificá-la ao usar a ferramenta.
* **enable\_logging**: Opcional. Define se o registro (logging) na Scrapegraph deve ser ativado. O padrão é `False`.

## Uso

Ao usar a `ScrapegraphScrapeTool` com um agente, será necessário fornecer os seguintes parâmetros (a menos que tenham sido especificados durante a inicialização):

* **website\_url**: A URL do site a ser extraída.
* **user\_prompt**: Opcional. Instruções customizadas para extração de conteúdo. O padrão é "Extract the main content of the webpage".

A ferramenta retornará o conteúdo extraído com base no prompt fornecido.
```

---

## Neatlogs 통합

**URL:** llms-txt#neatlogs-통합

Source: https://docs.crewai.com/ko/observability/neatlogs

CrewAI agent 실행을 이해하고, 디버그하며, 공유하기

---

## Crie uma instância do seu listener

**URL:** llms-txt#crie-uma-instância-do-seu-listener

my_custom_listener = MyCustomListener()
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
3. Em `__init__.py`, importe as instâncias dos listeners para garantir seu carregamento:
```

---

## Maxim Integration

**URL:** llms-txt#maxim-integration

Source: https://docs.crewai.com/ko/observability/maxim

에이전트 모니터링, 평가 및 가시성 시작

---

## reasoning 오류를 캡처하기 위해 로깅을 설정합니다

**URL:** llms-txt#reasoning-오류를-캡처하기-위해-로깅을-설정합니다

logging.basicConfig(level=logging.INFO)

---

## Qdrant

**URL:** llms-txt#qdrant

from crewai.rag.qdrant.config import QdrantConfig
set_rag_config(QdrantConfig())
qdrant_client = get_rag_client()

---

## Example of guardrail result structure

**URL:** llms-txt#example-of-guardrail-result-structure

**Contents:**
  - 결과 속성
- 작업 시스템과의 통합
  - 자동 검증

{
    "valid": False,
    "feedback": "Content appears to be hallucinated (score: 4.2/10, verdict: HALLUCINATED). The output contains information not supported by the provided context."
}
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 결과 속성

* **valid**: 출력이 검증을 통과했는지 여부를 나타내는 불리언 값
* **feedback**: 검증 실패 시 상세 설명. 다음을 포함:
  * 신뢰도 점수
  * 판정 분류
  * 실패의 구체적인 이유

## 작업 시스템과의 통합

### 자동 검증

가드레일이 태스크에 추가되면, 태스크가 완료로 표시되기 전에 출력값이 자동으로 검증됩니다:
```

---

## Create a task that instructs the agent to handle errors

**URL:** llms-txt#create-a-task-that-instructs-the-agent-to-handle-errors

**Contents:**
- Detalhes de Implementação
- Conclusão

error_handling_task = Task(
    description="""
    Extract content from a potentially problematic website and make sure to handle any 
    scraping failures gracefully by setting ignore_scrape_failures to True.
    """,
    expected_output="Either the extracted content or a graceful error message",
    agent=web_scraper_agent,
)
python Code theme={null}
class ScrapflyScrapeWebsiteTool(BaseTool):
    name: str = "Scrapfly web scraping API tool"
    description: str = (
        "Scrape a webpage url using Scrapfly and return its content as markdown or text"
    )
    
    # Implementation details...
    
    def _run(
        self,
        url: str,
        scrape_format: str = "markdown",
        scrape_config: Optional[Dict[str, Any]] = None,
        ignore_scrape_failures: Optional[bool] = None,
    ):
        from scrapfly import ScrapeApiResponse, ScrapeConfig

scrape_config = scrape_config if scrape_config is not None else {}
        try:
            response: ScrapeApiResponse = self.scrapfly.scrape(
                ScrapeConfig(url, format=scrape_format, **scrape_config)
            )
            return response.scrape_result["content"]
        except Exception as e:
            if ignore_scrape_failures:
                logger.error(f"Error fetching data from {url}, exception: {e}")
                return None
            else:
                raise e
```

A `ScrapflyScrapeWebsiteTool` oferece uma forma poderosa de extrair conteúdo de sites usando as avançadas capacidades de web scraping da Scrapfly. Com recursos como suporte a navegador headless, proxies e bypass de anti-bot, ela consegue lidar com sites complexos e extrair conteúdo em diversos formatos. Esta ferramenta é especialmente útil em tarefas de extração de dados, monitoramento de conteúdo e pesquisa, onde a raspagem confiável de sites é necessária.

**Examples:**

Example 1 (unknown):
```unknown
## Detalhes de Implementação

A `ScrapflyScrapeWebsiteTool` utiliza o Scrapfly SDK para interagir com a API Scrapfly:
```

---

## Composio 도구

**URL:** llms-txt#composio-도구

Source: https://docs.crewai.com/ko/tools/automation/composiotool

Composio는 유연한 인증 관리가 가능한 AI 에이전트를 위한 250개 이상의 프로덕션 준비 도구를 제공합니다.

---

## Create an agent focused on messaging

**URL:** llms-txt#create-an-agent-focused-on-messaging

messenger = Agent(
    role="Teams Messenger",
    goal="Send and retrieve messages in Teams channels",
    backstory="An AI assistant skilled in team communication and message management.",
    apps=['microsoft_teams/send_message', 'microsoft_teams/get_messages']
)

---

## Search results: Title: Jeux Olympiques de Paris 2024 - Actualités, calendriers, résultats

**URL:** llms-txt#search-results:-title:-jeux-olympiques-de-paris-2024---actualités,-calendriers,-résultats

---

## Extrair texto do PDF

**URL:** llms-txt#extrair-texto-do-pdf

def extract_text_from_pdf(pdf_path):
    text = []
    with pdfplumber.open(pdf_path) as pdf:
        for page in pdf.pages:
            page_text = page.extract_text()
            if page_text:
                text.append(page_text.strip())
    return text

---

## Inicialize a ferramenta para buscar dentro do conteúdo de qualquer arquivo DOCX

**URL:** llms-txt#inicialize-a-ferramenta-para-buscar-dentro-do-conteúdo-de-qualquer-arquivo-docx

tool = DOCXSearchTool()

---

## General JSON content search

**URL:** llms-txt#general-json-content-search

---

## Create a task for image analysis

**URL:** llms-txt#create-a-task-for-image-analysis

task = Task(
    description="Analyze the product image at https://example.com/product.jpg and provide a detailed description",
    expected_output="A detailed description of the product image",
    agent=image_analyst
)

---

## If an error occurs during reasoning, it will be logged and execution will continue

**URL:** llms-txt#if-an-error-occurs-during-reasoning,-it-will-be-logged-and-execution-will-continue

**Contents:**
- Exemplo de Saída de reasoning

result = agent.execute_task(task)

Task: Analise os dados de vendas fornecidos e identifique as principais tendências.

Reasoning Plan:
I'll analyze the sales data to identify the top 3 trends.

1. Understanding of the task:
   I need to analyze sales data to identify key trends that would be valuable for business decision-making.

2. Key steps I'll take:
   - First, I'll examine the data structure to understand what fields are available
   - Then I'll perform exploratory data analysis to identify patterns
   - Next, I'll analyze sales by time periods to identify temporal trends
   - I'll also analyze sales by product categories and customer segments
   - Finally, I'll identify the top 3 most significant trends

3. Approach to challenges:
   - If the data has missing values, I'll decide whether to fill or filter them
   - If the data has outliers, I'll investigate whether they're valid data points or errors
   - If trends aren't immediately obvious, I'll apply statistical methods to uncover patterns

4. Use of available tools:
   - I'll use data analysis tools to explore and visualize the data
   - I'll use statistical tools to identify significant patterns
   - I'll use knowledge retrieval to access relevant information about sales analysis

5. Expected outcome:
   A concise report highlighting the top 3 sales trends with supporting evidence from the data.

READY: I am ready to execute the task.
```

Esse plano de reasoning ajuda o agente a organizar sua abordagem para a tarefa, considerar possíveis desafios e garantir que entregará o resultado esperado.

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo de Saída de reasoning

Veja um exemplo de como pode ser um plano de reasoning para uma tarefa de análise de dados:
```

---

## 1. Stdio Server:

**URL:** llms-txt#1.-stdio-server:

server_params=StdioServerParameters(
    command="python3",
    args=["servers/your_server.py"],
    env={"UV_PYTHON": "3.12", **os.environ},
)

---

## Default behavior - directories are created automatically

**URL:** llms-txt#default-behavior---directories-are-created-automatically

**Contents:**
  - Disabling Directory Creation

report_task = Task(
    description='Generate a comprehensive market analysis report',
    expected_output='A detailed market analysis with charts and insights',
    agent=analyst_agent,
    output_file='reports/2025/market_analysis.md',  # Creates 'reports/2025/' if it doesn't exist
    markdown=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Disabling Directory Creation

If you want to prevent automatic directory creation and ensure that the directory already exists, set `create_directory=False`:
```

---

## These servers will timeout gracefully if unresponsive

**URL:** llms-txt#these-servers-will-timeout-gracefully-if-unresponsive

**Contents:**
- Performance Features
  - Automatic Caching

mcps=[
    "https://slow-server.com/mcp",        # Will timeout after 10s if unresponsive
    "https://overloaded-api.com/mcp"      # Will timeout if discovery takes > 15s
]
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Performance Features

### Automatic Caching

Tool schemas are cached for 5 minutes to improve performance:
```

---

## Asana 연동

**URL:** llms-txt#asana-연동

**Contents:**
- 개요
- 사전 준비 사항
- 아사나(Asana) 연동 설정
  - 1. Asana 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 Asana 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/asana

CrewAI를 위한 Asana 연동으로 팀 작업 및 프로젝트 조정.

에이전트가 Asana를 통해 업무, 프로젝트, 팀 협업을 관리할 수 있도록 지원하세요. 작업 생성, 프로젝트 상태 업데이트, 담당 할당 관리, AI 기반 자동화를 통한 팀의 워크플로우 최적화를 손쉽게 할 수 있습니다.

Asana 연동을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 Asana 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Asana 계정 연결

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **Asana**를 찾습니다.
3. **Connect**를 클릭하고 OAuth 플로우를 완료합니다.
4. 작업 및 프로젝트 관리를 위한 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="asana/create_comment">
    **설명:** Asana에 댓글을 생성합니다.

* `task` (string, 필수): 작업 ID - 댓글이 추가될 작업의 ID입니다. 댓글 작성자는 현재 인증된 사용자입니다.
    * `text` (string, 필수): 텍스트 (예: "This is a comment.").
  </Accordion>

<Accordion title="asana/create_project">
    **설명:** Asana에 프로젝트를 생성합니다.

* `name` (string, 필수): 이름 (예: "Stuff to buy").
    * `workspace` (string, 필수): 워크스페이스 - Connect Portal Workflow 설정을 사용해 사용자가 프로젝트를 생성할 워크스페이스를 선택할 수 있도록 합니다. 공란인 경우 기본적으로 사용자의 첫 번째 워크스페이스가 선택됩니다.
    * `team` (string, 선택): 팀 - Connect Portal Workflow 설정을 사용해 사용자가 이 프로젝트를 공유할 팀을 선택할 수 있도록 합니다. 공란인 경우 기본적으로 사용자의 첫 번째 팀이 선택됩니다.
    * `notes` (string, 선택): 노트 (예: "These are things we need to purchase.").
  </Accordion>

<Accordion title="asana/get_projects">
    **설명:** Asana의 프로젝트 목록을 가져옵니다.

* `archived` (string, 선택): 보관됨 - 보관된 프로젝트를 보려면 "true", 활성 프로젝트만 보려면 "false", 보관됨과 활성 모두 보려면 "default"를 선택합니다.
      * 옵션: `default`, `true`, `false`
  </Accordion>

<Accordion title="asana/get_project_by_id">
    **설명:** Asana에서 ID로 프로젝트를 가져옵니다.

* `projectFilterId` (string, 필수): 프로젝트 ID.
  </Accordion>

<Accordion title="asana/create_task">
    **설명:** Asana에 작업을 생성합니다.

* `name` (string, 필수): 이름 (예: "Task Name").
    * `workspace` (string, 선택): 워크스페이스 - Connect Portal Workflow 설정을 사용해 사용자가 작업을 생성할 워크스페이스를 선택할 수 있도록 합니다. 공란인 경우 기본적으로 사용자의 첫 번째 워크스페이스가 선택됩니다.
    * `project` (string, 선택): 프로젝트 - Connect Portal Workflow 설정을 사용해 사용자가 이 작업을 생성할 프로젝트를 선택할 수 있도록 합니다.
    * `notes` (string, 선택): 노트.
    * `dueOnDate` (string, 선택): 마감일 - 이 작업이 완료되어야 하는 날짜입니다. Due At과 함께 사용할 수 없습니다. (예: "YYYY-MM-DD").
    * `dueAtDate` (string, 선택): 마감 시각 - 이 작업이 완료되어야 하는 날짜와 시간 (ISO 타임스탬프) 입니다. Due On과 함께 사용할 수 없습니다. (예: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, 선택): 담당자 - 이 작업이 할당될 Asana 사용자의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 담당자를 선택할 수 있도록 합니다.
    * `gid` (string, 선택): 외부 ID - 이 작업과 연결할 애플리케이션의 ID입니다. 이 ID를 사용하여 이후 작업 업데이트를 동기화할 수 있습니다.
  </Accordion>

<Accordion title="asana/update_task">
    **설명:** Asana의 작업을 업데이트합니다.

* `taskId` (string, 필수): 작업 ID - 업데이트할 작업의 ID입니다.
    * `completeStatus` (string, 선택): 완료 상태.
      * 옵션: `true`, `false`
    * `name` (string, 선택): 이름 (예: "Task Name").
    * `notes` (string, 선택): 노트.
    * `dueOnDate` (string, 선택): 마감일 - 이 작업이 완료되어야 하는 날짜입니다. Due At과 함께 사용할 수 없습니다. (예: "YYYY-MM-DD").
    * `dueAtDate` (string, 선택): 마감 시각 - 이 작업이 완료되어야 하는 날짜와 시간 (ISO 타임스탬프) 입니다. Due On과 함께 사용할 수 없습니다. (예: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, 선택): 담당자 - 이 작업이 할당될 Asana 사용자의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 담당자를 선택할 수 있도록 합니다.
    * `gid` (string, 선택): 외부 ID - 이 작업과 연결할 애플리케이션의 ID입니다. 이 ID를 사용하여 이후 작업 업데이트를 동기화할 수 있습니다.
  </Accordion>

<Accordion title="asana/get_tasks">
    **설명:** Asana의 작업 목록을 가져옵니다.

* `workspace` (string, 선택): 워크스페이스 - 작업을 필터링할 워크스페이스의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 워크스페이스를 선택할 수 있도록 합니다.
    * `project` (string, 선택): 프로젝트 - 작업을 필터링할 프로젝트의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 프로젝트를 선택할 수 있도록 합니다.
    * `assignee` (string, 선택): 담당자 - 작업을 필터링할 담당자의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 담당자를 선택할 수 있도록 합니다.
    * `completedSince` (string, 선택): 이후 완료됨 - 미완료이거나 해당 시간(ISO 또는 Unix 타임스탬프) 이후에 완료된 작업만 반환합니다. (예: "2014-04-25T16:15:47-04:00").
  </Accordion>

<Accordion title="asana/get_tasks_by_id">
    **설명:** Asana에서 ID로 작업 목록을 가져옵니다.

* `taskId` (string, 필수): 작업 ID.
  </Accordion>

<Accordion title="asana/get_task_by_external_id">
    **설명:** Asana에서 외부 ID로 작업을 가져옵니다.

* `gid` (string, 필수): 외부 ID - 이 작업이 애플리케이션과 연동(또는 동기화)된 ID입니다.
  </Accordion>

<Accordion title="asana/add_task_to_section">
    **설명:** Asana에서 섹션에 작업을 추가합니다.

* `sectionId` (string, 필수): 섹션 ID - 작업을 추가할 섹션의 ID입니다.
    * `taskId` (string, 필수): 작업 ID - 작업의 ID입니다. (예: "1204619611402340").
    * `beforeTaskId` (string, 선택): 이전 작업 ID - 이 작업이 삽입될 섹션 내의 작업 ID입니다. 이후 작업 ID와 함께 사용할 수 없습니다. (예: "1204619611402340").
    * `afterTaskId` (string, 선택): 이후 작업 ID - 이 작업이 삽입될 섹션 내의 작업 ID입니다. 이전 작업 ID와 함께 사용할 수 없습니다. (예: "1204619611402340").
  </Accordion>

<Accordion title="asana/get_teams">
    **설명:** Asana에서 팀 목록을 가져옵니다.

* `workspace` (string, 필수): 워크스페이스 - 인증된 사용자가 볼 수 있는 이 워크스페이스 내의 팀을 반환합니다.
  </Accordion>

<Accordion title="asana/get_workspaces">
    **설명:** Asana에서 워크스페이스 목록을 가져옵니다.

**매개변수:** 필요 없음.
  </Accordion>
</AccordionGroup>

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="asana/create_comment">
    **설명:** Asana에 댓글을 생성합니다.

    **매개변수:**

    * `task` (string, 필수): 작업 ID - 댓글이 추가될 작업의 ID입니다. 댓글 작성자는 현재 인증된 사용자입니다.
    * `text` (string, 필수): 텍스트 (예: "This is a comment.").
  </Accordion>

  <Accordion title="asana/create_project">
    **설명:** Asana에 프로젝트를 생성합니다.

    **매개변수:**

    * `name` (string, 필수): 이름 (예: "Stuff to buy").
    * `workspace` (string, 필수): 워크스페이스 - Connect Portal Workflow 설정을 사용해 사용자가 프로젝트를 생성할 워크스페이스를 선택할 수 있도록 합니다. 공란인 경우 기본적으로 사용자의 첫 번째 워크스페이스가 선택됩니다.
    * `team` (string, 선택): 팀 - Connect Portal Workflow 설정을 사용해 사용자가 이 프로젝트를 공유할 팀을 선택할 수 있도록 합니다. 공란인 경우 기본적으로 사용자의 첫 번째 팀이 선택됩니다.
    * `notes` (string, 선택): 노트 (예: "These are things we need to purchase.").
  </Accordion>

  <Accordion title="asana/get_projects">
    **설명:** Asana의 프로젝트 목록을 가져옵니다.

    **매개변수:**

    * `archived` (string, 선택): 보관됨 - 보관된 프로젝트를 보려면 "true", 활성 프로젝트만 보려면 "false", 보관됨과 활성 모두 보려면 "default"를 선택합니다.
      * 옵션: `default`, `true`, `false`
  </Accordion>

  <Accordion title="asana/get_project_by_id">
    **설명:** Asana에서 ID로 프로젝트를 가져옵니다.

    **매개변수:**

    * `projectFilterId` (string, 필수): 프로젝트 ID.
  </Accordion>

  <Accordion title="asana/create_task">
    **설명:** Asana에 작업을 생성합니다.

    **매개변수:**

    * `name` (string, 필수): 이름 (예: "Task Name").
    * `workspace` (string, 선택): 워크스페이스 - Connect Portal Workflow 설정을 사용해 사용자가 작업을 생성할 워크스페이스를 선택할 수 있도록 합니다. 공란인 경우 기본적으로 사용자의 첫 번째 워크스페이스가 선택됩니다.
    * `project` (string, 선택): 프로젝트 - Connect Portal Workflow 설정을 사용해 사용자가 이 작업을 생성할 프로젝트를 선택할 수 있도록 합니다.
    * `notes` (string, 선택): 노트.
    * `dueOnDate` (string, 선택): 마감일 - 이 작업이 완료되어야 하는 날짜입니다. Due At과 함께 사용할 수 없습니다. (예: "YYYY-MM-DD").
    * `dueAtDate` (string, 선택): 마감 시각 - 이 작업이 완료되어야 하는 날짜와 시간 (ISO 타임스탬프) 입니다. Due On과 함께 사용할 수 없습니다. (예: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, 선택): 담당자 - 이 작업이 할당될 Asana 사용자의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 담당자를 선택할 수 있도록 합니다.
    * `gid` (string, 선택): 외부 ID - 이 작업과 연결할 애플리케이션의 ID입니다. 이 ID를 사용하여 이후 작업 업데이트를 동기화할 수 있습니다.
  </Accordion>

  <Accordion title="asana/update_task">
    **설명:** Asana의 작업을 업데이트합니다.

    **매개변수:**

    * `taskId` (string, 필수): 작업 ID - 업데이트할 작업의 ID입니다.
    * `completeStatus` (string, 선택): 완료 상태.
      * 옵션: `true`, `false`
    * `name` (string, 선택): 이름 (예: "Task Name").
    * `notes` (string, 선택): 노트.
    * `dueOnDate` (string, 선택): 마감일 - 이 작업이 완료되어야 하는 날짜입니다. Due At과 함께 사용할 수 없습니다. (예: "YYYY-MM-DD").
    * `dueAtDate` (string, 선택): 마감 시각 - 이 작업이 완료되어야 하는 날짜와 시간 (ISO 타임스탬프) 입니다. Due On과 함께 사용할 수 없습니다. (예: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, 선택): 담당자 - 이 작업이 할당될 Asana 사용자의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 담당자를 선택할 수 있도록 합니다.
    * `gid` (string, 선택): 외부 ID - 이 작업과 연결할 애플리케이션의 ID입니다. 이 ID를 사용하여 이후 작업 업데이트를 동기화할 수 있습니다.
  </Accordion>

  <Accordion title="asana/get_tasks">
    **설명:** Asana의 작업 목록을 가져옵니다.

    **매개변수:**

    * `workspace` (string, 선택): 워크스페이스 - 작업을 필터링할 워크스페이스의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 워크스페이스를 선택할 수 있도록 합니다.
    * `project` (string, 선택): 프로젝트 - 작업을 필터링할 프로젝트의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 프로젝트를 선택할 수 있도록 합니다.
    * `assignee` (string, 선택): 담당자 - 작업을 필터링할 담당자의 ID입니다. Connect Portal Workflow 설정을 사용해 사용자가 담당자를 선택할 수 있도록 합니다.
    * `completedSince` (string, 선택): 이후 완료됨 - 미완료이거나 해당 시간(ISO 또는 Unix 타임스탬프) 이후에 완료된 작업만 반환합니다. (예: "2014-04-25T16:15:47-04:00").
  </Accordion>

  <Accordion title="asana/get_tasks_by_id">
    **설명:** Asana에서 ID로 작업 목록을 가져옵니다.

    **매개변수:**

    * `taskId` (string, 필수): 작업 ID.
  </Accordion>

  <Accordion title="asana/get_task_by_external_id">
    **설명:** Asana에서 외부 ID로 작업을 가져옵니다.

    **매개변수:**

    * `gid` (string, 필수): 외부 ID - 이 작업이 애플리케이션과 연동(또는 동기화)된 ID입니다.
  </Accordion>

  <Accordion title="asana/add_task_to_section">
    **설명:** Asana에서 섹션에 작업을 추가합니다.

    **매개변수:**

    * `sectionId` (string, 필수): 섹션 ID - 작업을 추가할 섹션의 ID입니다.
    * `taskId` (string, 필수): 작업 ID - 작업의 ID입니다. (예: "1204619611402340").
    * `beforeTaskId` (string, 선택): 이전 작업 ID - 이 작업이 삽입될 섹션 내의 작업 ID입니다. 이후 작업 ID와 함께 사용할 수 없습니다. (예: "1204619611402340").
    * `afterTaskId` (string, 선택): 이후 작업 ID - 이 작업이 삽입될 섹션 내의 작업 ID입니다. 이전 작업 ID와 함께 사용할 수 없습니다. (예: "1204619611402340").
  </Accordion>

  <Accordion title="asana/get_teams">
    **설명:** Asana에서 팀 목록을 가져옵니다.

    **매개변수:**

    * `workspace` (string, 필수): 워크스페이스 - 인증된 사용자가 볼 수 있는 이 워크스페이스 내의 팀을 반환합니다.
  </Accordion>

  <Accordion title="asana/get_workspaces">
    **설명:** Asana에서 워크스페이스 목록을 가져옵니다.

    **매개변수:** 필요 없음.
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 Asana 에이전트 설정
```

---

## YouTube 채널 RAG 검색

**URL:** llms-txt#youtube-채널-rag-검색

Source: https://docs.crewai.com/ko/tools/search-research/youtubechannelsearchtool

YoutubeChannelSearchTool은 YouTube 채널의 콘텐츠 내에서 RAG(검색 증강 생성) 검색을 수행하도록 설계되었습니다.

---

## Directory RAG Search

**URL:** llms-txt#directory-rag-search

Source: https://docs.crewai.com/en/tools/file-document/directorysearchtool

The `DirectorySearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a directory's content.

---

## `FirecrawlScrapeWebsiteTool`

**URL:** llms-txt#`firecrawlscrapewebsitetool`

**Contents:**
- Descrição
- Instalação
- Exemplo
- Argumentos

[Firecrawl](https://firecrawl.dev) é uma plataforma para rastrear e converter qualquer site em markdown limpo ou dados estruturados.

* Obtenha uma chave de API em [firecrawl.dev](https://firecrawl.dev) e defina-a nas variáveis de ambiente (`FIRECRAWL_API_KEY`).
* Instale o [Firecrawl SDK](https://github.com/mendableai/firecrawl) junto com o pacote `crewai[tools]`:

Utilize o FirecrawlScrapeWebsiteTool da seguinte forma para permitir que seu agente carregue sites:

* `api_key`: Opcional. Especifica a chave de API do Firecrawl. O padrão é a variável de ambiente `FIRECRAWL_API_KEY`.
* `url`: A URL a ser raspada.
* `page_options`: Opcional.
  * `onlyMainContent`: Opcional. Retorna apenas o conteúdo principal da página, excluindo cabeçalhos, navegações, rodapés, etc.
  * `includeHtml`: Opcional. Inclui o conteúdo HTML bruto da página. Irá gerar uma chave html na resposta.
* `extractor_options`: Opcional. Opções para extração baseada em LLM de informações estruturadas do conteúdo da página
  * `mode`: O modo de extração a ser utilizado, atualmente suporta 'llm-extraction'
  * `extractionPrompt`: Opcional. Um prompt descrevendo quais informações extrair da página
  * `extractionSchema`: Opcional. O esquema para os dados a serem extraídos
* `timeout`: Opcional. Timeout em milissegundos para a requisição

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Utilize o FirecrawlScrapeWebsiteTool da seguinte forma para permitir que seu agente carregue sites:
```

---

## Integração com Shopify

**URL:** llms-txt#integração-com-shopify

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Shopify
  - 1. Conecte sua Loja Shopify
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ferramentas Disponíveis
  - **Gerenciamento de Clientes**
  - **Gestão de Pedidos**
  - **Gestão de Produtos (REST API)**

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/shopify

Gestão de e-commerce e loja online com integração do Shopify para CrewAI.

Permita que seus agentes gerenciem operações de e-commerce através do Shopify. Gerencie clientes, pedidos, produtos, inventário e análises da loja para otimizar sua empresa online com automação alimentada por IA.

Antes de utilizar a integração com o Shopify, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com uma assinatura ativa
* Uma loja Shopify com permissões administrativas adequadas
* Sua loja Shopify conectada através da [página de Integrações](https://app.crewai.com/integrations)

## Configurando a Integração Shopify

### 1. Conecte sua Loja Shopify

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Shopify** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de loja e produtos
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

## Ferramentas Disponíveis

### **Gerenciamento de Clientes**

<AccordionGroup>
  <Accordion title="shopify/get_customers">
    **Descrição:** Recupera uma lista de clientes da sua loja Shopify.

* `customerIds` (string, opcional): Lista de IDs de clientes separada por vírgula para filtrar (exemplo: "207119551, 207119552")
    * `createdAtMin` (string, opcional): Retorna somente clientes criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente clientes criados antes desta data (ISO ou timestamp Unix)
    * `updatedAtMin` (string, opcional): Retorna somente clientes atualizados após esta data (ISO ou timestamp Unix)
    * `updatedAtMax` (string, opcional): Retorna somente clientes atualizados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de clientes a retornar (padrão 250)
  </Accordion>

<Accordion title="shopify/search_customers">
    **Descrição:** Pesquise por clientes usando critérios de filtragem avançados.

* `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `limit` (string, opcional): Número máximo de clientes a retornar (padrão 250)
  </Accordion>

<Accordion title="shopify/create_customer">
    **Descrição:** Crie um novo cliente em sua loja Shopify.

* `firstName` (string, obrigatório): Primeiro nome do cliente
    * `lastName` (string, obrigatório): Sobrenome do cliente
    * `email` (string, obrigatório): Endereço de e-mail do cliente
    * `company` (string, opcional): Nome da empresa
    * `streetAddressLine1` (string, opcional): Endereço
    * `streetAddressLine2` (string, opcional): Complemento do endereço
    * `city` (string, opcional): Cidade
    * `state` (string, opcional): Estado ou código da província
    * `country` (string, opcional): País
    * `zipCode` (string, opcional): CEP
    * `phone` (string, opcional): Telefone
    * `tags` (string, opcional): Tags como array ou lista separada por vírgula
    * `note` (string, opcional): Observação sobre o cliente
    * `sendEmailInvite` (boolean, opcional): Se deve enviar convite por e-mail
    * `metafields` (object, opcional): Metacampos adicionais em formato JSON
  </Accordion>

<Accordion title="shopify/update_customer">
    **Descrição:** Atualize um cliente existente em sua loja Shopify.

* `customerId` (string, obrigatório): O ID do cliente a ser atualizado
    * `firstName` (string, opcional): Primeiro nome do cliente
    * `lastName` (string, opcional): Sobrenome do cliente
    * `email` (string, opcional): Endereço de e-mail do cliente
    * `company` (string, opcional): Nome da empresa
    * `streetAddressLine1` (string, opcional): Endereço
    * `streetAddressLine2` (string, opcional): Complemento do endereço
    * `city` (string, opcional): Cidade
    * `state` (string, opcional): Estado ou código da província
    * `country` (string, opcional): País
    * `zipCode` (string, opcional): CEP
    * `phone` (string, opcional): Telefone
    * `tags` (string, opcional): Tags como array ou lista separada por vírgula
    * `note` (string, opcional): Observação sobre o cliente
    * `sendEmailInvite` (boolean, opcional): Se deve enviar convite por e-mail
    * `metafields` (object, opcional): Metacampos adicionais em formato JSON
  </Accordion>
</AccordionGroup>

### **Gestão de Pedidos**

<AccordionGroup>
  <Accordion title="shopify/get_orders">
    **Descrição:** Recupera uma lista de pedidos da sua loja Shopify.

* `orderIds` (string, opcional): Lista de IDs de pedidos separada por vírgula para filtrar (exemplo: "450789469, 450789470")
    * `createdAtMin` (string, opcional): Retorna somente pedidos criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente pedidos criados antes desta data (ISO ou timestamp Unix)
    * `updatedAtMin` (string, opcional): Retorna somente pedidos atualizados após esta data (ISO ou timestamp Unix)
    * `updatedAtMax` (string, opcional): Retorna somente pedidos atualizados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de pedidos a retornar (padrão 250)
  </Accordion>

<Accordion title="shopify/create_order">
    **Descrição:** Crie um novo pedido em sua loja Shopify.

* `email` (string, obrigatório): Endereço de e-mail do cliente
    * `lineItems` (object, obrigatório): Itens do pedido em formato JSON com título, preço, quantidade e variant\_id
    * `sendReceipt` (boolean, opcional): Se deve enviar recibo do pedido
    * `fulfillmentStatus` (string, opcional): Status de atendimento - Opções: fulfilled, null, partial, restocked
    * `financialStatus` (string, opcional): Status financeiro - Opções: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, opcional): Comportamento de inventário - Opções: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, opcional): Observação do pedido
  </Accordion>

<Accordion title="shopify/update_order">
    **Descrição:** Atualize um pedido existente em sua loja Shopify.

* `orderId` (string, obrigatório): O ID do pedido a ser atualizado
    * `email` (string, opcional): Endereço de e-mail do cliente
    * `lineItems` (object, opcional): Itens do pedido atualizados em formato JSON
    * `sendReceipt` (boolean, opcional): Se deve enviar recibo do pedido
    * `fulfillmentStatus` (string, opcional): Status de atendimento - Opções: fulfilled, null, partial, restocked
    * `financialStatus` (string, opcional): Status financeiro - Opções: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, opcional): Comportamento de inventário - Opções: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, opcional): Observação do pedido
  </Accordion>

<Accordion title="shopify/get_abandoned_carts">
    **Descrição:** Recupera carrinhos abandonados da sua loja Shopify.

* `createdWithInLast` (string, opcional): Restringe os resultados para checkouts criados dentro do período especificado
    * `createdAfterId` (string, opcional): Restringe os resultados após o ID especificado
    * `status` (string, opcional): Mostra checkouts com o status especificado - Opções: open, closed (padrão open)
    * `createdAtMin` (string, opcional): Retorna somente carrinhos criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente carrinhos criados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de carrinhos a retornar (padrão 250)
  </Accordion>
</AccordionGroup>

### **Gestão de Produtos (REST API)**

<AccordionGroup>
  <Accordion title="shopify/get_products">
    **Descrição:** Recupera uma lista de produtos da sua loja Shopify utilizando a REST API.

* `productIds` (string, opcional): Lista de IDs de produtos separada por vírgula para filtrar (exemplo: "632910392, 632910393")
    * `title` (string, opcional): Filtrar pelo título do produto
    * `productType` (string, opcional): Filtrar pelo tipo de produto
    * `vendor` (string, opcional): Filtrar por fornecedor
    * `status` (string, opcional): Filtrar por status - Opções: active, archived, draft
    * `createdAtMin` (string, opcional): Retorna somente produtos criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente produtos criados antes desta data (ISO ou timestamp Unix)
    * `updatedAtMin` (string, opcional): Retorna somente produtos atualizados após esta data (ISO ou timestamp Unix)
    * `updatedAtMax` (string, opcional): Retorna somente produtos atualizados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de produtos a retornar (padrão 250)
  </Accordion>

<Accordion title="shopify/create_product">
    **Descrição:** Crie um novo produto em sua loja Shopify utilizando a REST API.

* `title` (string, obrigatório): Título do produto
    * `productType` (string, obrigatório): Tipo/categoria do produto
    * `vendor` (string, obrigatório): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `price` (string, opcional): Preço do produto
    * `inventoryPolicy` (string, opcional): Política de estoque - Opções: deny, continue
    * `imageUrl` (string, opcional): URL da imagem do produto
    * `isPublished` (boolean, opcional): Se o produto está publicado
    * `publishToPointToSale` (boolean, opcional): Se deve publicar no ponto de venda
  </Accordion>

<Accordion title="shopify/update_product">
    **Descrição:** Atualize um produto existente em sua loja Shopify utilizando a REST API.

* `productId` (string, obrigatório): O ID do produto a ser atualizado
    * `title` (string, opcional): Título do produto
    * `productType` (string, opcional): Tipo/categoria do produto
    * `vendor` (string, opcional): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `price` (string, opcional): Preço do produto
    * `inventoryPolicy` (string, opcional): Política de estoque - Opções: deny, continue
    * `imageUrl` (string, opcional): URL da imagem do produto
    * `isPublished` (boolean, opcional): Se o produto está publicado
    * `publishToPointToSale` (boolean, opcional): Se deve publicar no ponto de venda
  </Accordion>
</AccordionGroup>

### **Gestão de Produtos (GraphQL)**

<AccordionGroup>
  <Accordion title="shopify/get_products_graphql">
    **Descrição:** Recupere produtos utilizando filtros avançados do GraphQL.

* `productFilterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com suporte a campos como id, title, vendor, status, handle, tag, created\_at, updated\_at, published\_at
  </Accordion>

<Accordion title="shopify/create_product_graphql">
    **Descrição:** Crie um novo produto utilizando a API GraphQL com suporte aprimorado a mídias.

* `title` (string, obrigatório): Título do produto
    * `productType` (string, obrigatório): Tipo/categoria do produto
    * `vendor` (string, obrigatório): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `media` (object, opcional): Objetos de mídia com texto alternativo, tipo de conteúdo e URL de origem
    * `additionalFields` (object, opcional): Campos adicionais do produto como status, requiresSellingPlan, giftCard
  </Accordion>

<Accordion title="shopify/update_product_graphql">
    **Descrição:** Atualize um produto existente utilizando a API GraphQL com suporte aprimorado a mídias.

* `productId` (string, obrigatório): O ID GraphQL do produto a ser atualizado (ex.: "gid://shopify/Product/913144112")
    * `title` (string, opcional): Título do produto
    * `productType` (string, opcional): Tipo/categoria do produto
    * `vendor` (string, opcional): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `media` (object, opcional): Objetos de mídia atualizados com texto alternativo, tipo de conteúdo e URL de origem
    * `additionalFields` (object, opcional): Campos adicionais do produto como status, requiresSellingPlan, giftCard
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Shopify

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ferramentas Disponíveis

### **Gerenciamento de Clientes**

<AccordionGroup>
  <Accordion title="shopify/get_customers">
    **Descrição:** Recupera uma lista de clientes da sua loja Shopify.

    **Parâmetros:**

    * `customerIds` (string, opcional): Lista de IDs de clientes separada por vírgula para filtrar (exemplo: "207119551, 207119552")
    * `createdAtMin` (string, opcional): Retorna somente clientes criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente clientes criados antes desta data (ISO ou timestamp Unix)
    * `updatedAtMin` (string, opcional): Retorna somente clientes atualizados após esta data (ISO ou timestamp Unix)
    * `updatedAtMax` (string, opcional): Retorna somente clientes atualizados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de clientes a retornar (padrão 250)
  </Accordion>

  <Accordion title="shopify/search_customers">
    **Descrição:** Pesquise por clientes usando critérios de filtragem avançados.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `limit` (string, opcional): Número máximo de clientes a retornar (padrão 250)
  </Accordion>

  <Accordion title="shopify/create_customer">
    **Descrição:** Crie um novo cliente em sua loja Shopify.

    **Parâmetros:**

    * `firstName` (string, obrigatório): Primeiro nome do cliente
    * `lastName` (string, obrigatório): Sobrenome do cliente
    * `email` (string, obrigatório): Endereço de e-mail do cliente
    * `company` (string, opcional): Nome da empresa
    * `streetAddressLine1` (string, opcional): Endereço
    * `streetAddressLine2` (string, opcional): Complemento do endereço
    * `city` (string, opcional): Cidade
    * `state` (string, opcional): Estado ou código da província
    * `country` (string, opcional): País
    * `zipCode` (string, opcional): CEP
    * `phone` (string, opcional): Telefone
    * `tags` (string, opcional): Tags como array ou lista separada por vírgula
    * `note` (string, opcional): Observação sobre o cliente
    * `sendEmailInvite` (boolean, opcional): Se deve enviar convite por e-mail
    * `metafields` (object, opcional): Metacampos adicionais em formato JSON
  </Accordion>

  <Accordion title="shopify/update_customer">
    **Descrição:** Atualize um cliente existente em sua loja Shopify.

    **Parâmetros:**

    * `customerId` (string, obrigatório): O ID do cliente a ser atualizado
    * `firstName` (string, opcional): Primeiro nome do cliente
    * `lastName` (string, opcional): Sobrenome do cliente
    * `email` (string, opcional): Endereço de e-mail do cliente
    * `company` (string, opcional): Nome da empresa
    * `streetAddressLine1` (string, opcional): Endereço
    * `streetAddressLine2` (string, opcional): Complemento do endereço
    * `city` (string, opcional): Cidade
    * `state` (string, opcional): Estado ou código da província
    * `country` (string, opcional): País
    * `zipCode` (string, opcional): CEP
    * `phone` (string, opcional): Telefone
    * `tags` (string, opcional): Tags como array ou lista separada por vírgula
    * `note` (string, opcional): Observação sobre o cliente
    * `sendEmailInvite` (boolean, opcional): Se deve enviar convite por e-mail
    * `metafields` (object, opcional): Metacampos adicionais em formato JSON
  </Accordion>
</AccordionGroup>

### **Gestão de Pedidos**

<AccordionGroup>
  <Accordion title="shopify/get_orders">
    **Descrição:** Recupera uma lista de pedidos da sua loja Shopify.

    **Parâmetros:**

    * `orderIds` (string, opcional): Lista de IDs de pedidos separada por vírgula para filtrar (exemplo: "450789469, 450789470")
    * `createdAtMin` (string, opcional): Retorna somente pedidos criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente pedidos criados antes desta data (ISO ou timestamp Unix)
    * `updatedAtMin` (string, opcional): Retorna somente pedidos atualizados após esta data (ISO ou timestamp Unix)
    * `updatedAtMax` (string, opcional): Retorna somente pedidos atualizados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de pedidos a retornar (padrão 250)
  </Accordion>

  <Accordion title="shopify/create_order">
    **Descrição:** Crie um novo pedido em sua loja Shopify.

    **Parâmetros:**

    * `email` (string, obrigatório): Endereço de e-mail do cliente
    * `lineItems` (object, obrigatório): Itens do pedido em formato JSON com título, preço, quantidade e variant\_id
    * `sendReceipt` (boolean, opcional): Se deve enviar recibo do pedido
    * `fulfillmentStatus` (string, opcional): Status de atendimento - Opções: fulfilled, null, partial, restocked
    * `financialStatus` (string, opcional): Status financeiro - Opções: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, opcional): Comportamento de inventário - Opções: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, opcional): Observação do pedido
  </Accordion>

  <Accordion title="shopify/update_order">
    **Descrição:** Atualize um pedido existente em sua loja Shopify.

    **Parâmetros:**

    * `orderId` (string, obrigatório): O ID do pedido a ser atualizado
    * `email` (string, opcional): Endereço de e-mail do cliente
    * `lineItems` (object, opcional): Itens do pedido atualizados em formato JSON
    * `sendReceipt` (boolean, opcional): Se deve enviar recibo do pedido
    * `fulfillmentStatus` (string, opcional): Status de atendimento - Opções: fulfilled, null, partial, restocked
    * `financialStatus` (string, opcional): Status financeiro - Opções: pending, authorized, partially\_paid, paid, partially\_refunded, refunded, voided
    * `inventoryBehaviour` (string, opcional): Comportamento de inventário - Opções: bypass, decrement\_ignoring\_policy, decrement\_obeying\_policy
    * `note` (string, opcional): Observação do pedido
  </Accordion>

  <Accordion title="shopify/get_abandoned_carts">
    **Descrição:** Recupera carrinhos abandonados da sua loja Shopify.

    **Parâmetros:**

    * `createdWithInLast` (string, opcional): Restringe os resultados para checkouts criados dentro do período especificado
    * `createdAfterId` (string, opcional): Restringe os resultados após o ID especificado
    * `status` (string, opcional): Mostra checkouts com o status especificado - Opções: open, closed (padrão open)
    * `createdAtMin` (string, opcional): Retorna somente carrinhos criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente carrinhos criados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de carrinhos a retornar (padrão 250)
  </Accordion>
</AccordionGroup>

### **Gestão de Produtos (REST API)**

<AccordionGroup>
  <Accordion title="shopify/get_products">
    **Descrição:** Recupera uma lista de produtos da sua loja Shopify utilizando a REST API.

    **Parâmetros:**

    * `productIds` (string, opcional): Lista de IDs de produtos separada por vírgula para filtrar (exemplo: "632910392, 632910393")
    * `title` (string, opcional): Filtrar pelo título do produto
    * `productType` (string, opcional): Filtrar pelo tipo de produto
    * `vendor` (string, opcional): Filtrar por fornecedor
    * `status` (string, opcional): Filtrar por status - Opções: active, archived, draft
    * `createdAtMin` (string, opcional): Retorna somente produtos criados após esta data (ISO ou timestamp Unix)
    * `createdAtMax` (string, opcional): Retorna somente produtos criados antes desta data (ISO ou timestamp Unix)
    * `updatedAtMin` (string, opcional): Retorna somente produtos atualizados após esta data (ISO ou timestamp Unix)
    * `updatedAtMax` (string, opcional): Retorna somente produtos atualizados antes desta data (ISO ou timestamp Unix)
    * `limit` (string, opcional): Número máximo de produtos a retornar (padrão 250)
  </Accordion>

  <Accordion title="shopify/create_product">
    **Descrição:** Crie um novo produto em sua loja Shopify utilizando a REST API.

    **Parâmetros:**

    * `title` (string, obrigatório): Título do produto
    * `productType` (string, obrigatório): Tipo/categoria do produto
    * `vendor` (string, obrigatório): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `price` (string, opcional): Preço do produto
    * `inventoryPolicy` (string, opcional): Política de estoque - Opções: deny, continue
    * `imageUrl` (string, opcional): URL da imagem do produto
    * `isPublished` (boolean, opcional): Se o produto está publicado
    * `publishToPointToSale` (boolean, opcional): Se deve publicar no ponto de venda
  </Accordion>

  <Accordion title="shopify/update_product">
    **Descrição:** Atualize um produto existente em sua loja Shopify utilizando a REST API.

    **Parâmetros:**

    * `productId` (string, obrigatório): O ID do produto a ser atualizado
    * `title` (string, opcional): Título do produto
    * `productType` (string, opcional): Tipo/categoria do produto
    * `vendor` (string, opcional): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `price` (string, opcional): Preço do produto
    * `inventoryPolicy` (string, opcional): Política de estoque - Opções: deny, continue
    * `imageUrl` (string, opcional): URL da imagem do produto
    * `isPublished` (boolean, opcional): Se o produto está publicado
    * `publishToPointToSale` (boolean, opcional): Se deve publicar no ponto de venda
  </Accordion>
</AccordionGroup>

### **Gestão de Produtos (GraphQL)**

<AccordionGroup>
  <Accordion title="shopify/get_products_graphql">
    **Descrição:** Recupere produtos utilizando filtros avançados do GraphQL.

    **Parâmetros:**

    * `productFilterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com suporte a campos como id, title, vendor, status, handle, tag, created\_at, updated\_at, published\_at
  </Accordion>

  <Accordion title="shopify/create_product_graphql">
    **Descrição:** Crie um novo produto utilizando a API GraphQL com suporte aprimorado a mídias.

    **Parâmetros:**

    * `title` (string, obrigatório): Título do produto
    * `productType` (string, obrigatório): Tipo/categoria do produto
    * `vendor` (string, obrigatório): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `media` (object, opcional): Objetos de mídia com texto alternativo, tipo de conteúdo e URL de origem
    * `additionalFields` (object, opcional): Campos adicionais do produto como status, requiresSellingPlan, giftCard
  </Accordion>

  <Accordion title="shopify/update_product_graphql">
    **Descrição:** Atualize um produto existente utilizando a API GraphQL com suporte aprimorado a mídias.

    **Parâmetros:**

    * `productId` (string, obrigatório): O ID GraphQL do produto a ser atualizado (ex.: "gid://shopify/Product/913144112")
    * `title` (string, opcional): Título do produto
    * `productType` (string, opcional): Tipo/categoria do produto
    * `vendor` (string, opcional): Fornecedor do produto
    * `productDescription` (string, opcional): Descrição do produto (aceita texto simples ou HTML)
    * `tags` (string, opcional): Tags do produto como array ou lista separada por vírgula
    * `media` (object, opcional): Objetos de mídia atualizados com texto alternativo, tipo de conteúdo e URL de origem
    * `additionalFields` (object, opcional): Campos adicionais do produto como status, requiresSellingPlan, giftCard
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Shopify
```

---

## Exemplo de tarefa para buscar informações em um canal específico

**URL:** llms-txt#exemplo-de-tarefa-para-buscar-informações-em-um-canal-específico

research_task = Task(
    description="Buscar informações sobre tutoriais de machine learning no canal do YouTube {youtube_channel_handle}",
    expected_output="Um resumo dos principais tutoriais de machine learning disponíveis no canal.",
    agent=channel_researcher,
)

---

## CLI commands

**URL:** llms-txt#cli-commands

---

## Opcionalmente exporte-os se precisar acessá-los em outros lugares

**URL:** llms-txt#opcionalmente-exporte-os-se-precisar-acessá-los-em-outros-lugares

__all__ = ['my_custom_listener', 'another_listener']
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
4. Importe seu pacote de listeners no arquivo do seu Crew ou Flow:
```

---

## Solução rápida: Habilite manipulação automática

**URL:** llms-txt#solução-rápida:-habilite-manipulação-automática

agent.respect_context_window = True

---

## Armazenar texto e embeddings no Qdrant

**URL:** llms-txt#armazenar-texto-e-embeddings-no-qdrant

def load_pdf_to_qdrant(pdf_path, qdrant, collection_name):
    # Extrair texto do PDF
    text_chunks = extract_text_from_pdf(pdf_path)

# Criar coleção no Qdrant
    if qdrant.collection_exists(collection_name):
        qdrant.delete_collection(collection_name)
    qdrant.create_collection(
        collection_name=collection_name,
        vectors_config=VectorParams(size=3072, distance=Distance.COSINE)
    )

# Armazenar embeddings
    points = []
    for chunk in text_chunks:
        embedding = get_openai_embedding(chunk)
        points.append(PointStruct(
            id=str(uuid.uuid4()),
            vector=embedding,
            payload={"text": chunk}
        ))
    qdrant.upsert(collection_name=collection_name, points=points)

---

## Obter apenas a ferramenta de busca do Exa

**URL:** llms-txt#obter-apenas-a-ferramenta-de-busca-do-exa

**Contents:**
  - Marketplace CrewAI AMP

"https://mcp.exa.ai/mcp?api_key=sua_chave#web_search_exa"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Marketplace CrewAI AMP

Acesse ferramentas do marketplace CrewAI AMP:
```

---

## HubSpot 연동

**URL:** llms-txt#hubspot-연동

**Contents:**
- 개요
- 사전 준비 사항
- HubSpot 통합 설정
  - 1. HubSpot 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 액션
- 사용 예시
  - 기본 HubSpot 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/hubspot

CrewAI로 HubSpot에서 회사 및 연락처를 관리하세요.

에이전트가 HubSpot 내에서 회사 및 연락처를 관리할 수 있도록 지원합니다. 새로운 레코드를 생성하고 AI 기반 자동화로 CRM 프로세스를 효율화하세요.

HubSpot 통합을 사용하기 전에 다음을 확인하세요.

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 권한이 있는 HubSpot 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 HubSpot 계정이 연결되어 있음

### 1. HubSpot 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **HubSpot**을 찾습니다.
3. **Connect**를 클릭하고 OAuth 플로우를 완료합니다.
4. 회사 및 연락처 관리를 위한 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="hubspot/create_company">
    **설명:** HubSpot에서 새로운 회사 레코드를 생성합니다.

* `name` (string, 필수): 회사명.
    * `domain` (string, 선택): 회사 도메인명.
    * `industry` (string, 선택): 산업군. HubSpot에서 미리 정의된 값 중 하나여야 합니다.
    * `phone` (string, 선택): 전화번호.
    * `hubspot_owner_id` (string, 선택): 회사 소유자 ID.
    * `type` (string, 선택): 회사 유형. 사용 가능한 값: `PROSPECT`, `PARTNER`, `RESELLER`, `VENDOR`, `OTHER`.
    * `city` (string, 선택): 도시.
    * `state` (string, 선택): 주/지역.
    * `zip` (string, 선택): 우편번호.
    * `numberofemployees` (number, 선택): 직원 수.
    * `annualrevenue` (number, 선택): 연간 매출.
    * `timezone` (string, 선택): 시간대.
    * `description` (string, 선택): 설명.
    * `linkedin_company_page` (string, 선택): LinkedIn 회사 페이지 URL.
    * `company_email` (string, 선택): 회사 이메일.
    * `first_name` (string, 선택): 회사 연락처의 이름.
    * `last_name` (string, 선택): 회사 연락처의 성.
    * `about_us` (string, 선택): 회사 소개.
    * `hs_csm_sentiment` (string, 선택): CSM 만족도. 사용 가능한 값: `at_risk`, `neutral`, `healthy`.
    * `closedate` (string, 선택): 마감일.
    * `hs_keywords` (string, 선택): 회사 키워드. 미리 정의된 값 중 하나여야 합니다.
    * `country` (string, 선택): 국가/지역.
    * `hs_country_code` (string, 선택): 국가/지역 코드.
    * `hs_employee_range` (string, 선택): 직원 범위.
    * `facebook_company_page` (string, 선택): Facebook 회사 페이지 URL.
    * `facebookfans` (number, 선택): Facebook 팬 수.
    * `hs_gps_coordinates` (string, 선택): GPS 좌표.
    * `hs_gps_error` (string, 선택): GPS 오류.
    * `googleplus_page` (string, 선택): Google Plus 페이지 URL.
    * `owneremail` (string, 선택): HubSpot 소유자 이메일.
    * `ownername` (string, 선택): HubSpot 소유자 이름.
    * `hs_ideal_customer_profile` (string, 선택): 이상적인 고객 프로필 티어. 사용 가능한 값: `tier_1`, `tier_2`, `tier_3`.
    * `hs_industry_group` (string, 선택): 산업 그룹.
    * `is_public` (boolean, 선택): 공개 여부.
    * `hs_last_metered_enrichment_timestamp` (string, 선택): 마지막 enrichment 타임스탬프.
    * `hs_lead_status` (string, 선택): 리드 상태. 사용 가능한 값: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `lifecyclestage` (string, 선택): 라이프사이클 단계. 사용 가능한 값: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `linkedinbio` (string, 선택): LinkedIn 바이오.
    * `hs_linkedin_handle` (string, 선택): LinkedIn 핸들.
    * `hs_live_enrichment_deadline` (string, 선택): 라이브 enrichment 기한.
    * `hs_logo_url` (string, 선택): 로고 URL.
    * `hs_analytics_source` (string, 선택): 원래 유입 경로.
    * `hs_pinned_engagement_id` (number, 선택): 고정된 참여 ID.
    * `hs_quick_context` (string, 선택): 간략한 컨텍스트.
    * `hs_revenue_range` (string, 선택): 매출 범위.
    * `hs_state_code` (string, 선택): 주/지역 코드.
    * `address` (string, 선택): 거리 주소.
    * `address2` (string, 선택): 거리 주소 2.
    * `hs_is_target_account` (boolean, 선택): 타깃 계정 여부.
    * `hs_target_account` (string, 선택): 타깃 계정 티어. 사용 가능한 값: `tier_1`, `tier_2`, `tier_3`.
    * `hs_target_account_recommendation_snooze_time` (string, 선택): 타깃 계정 추천 일시중지 시간.
    * `hs_target_account_recommendation_state` (string, 선택): 타깃 계정 추천 상태. 사용 가능한 값: `DISMISSED`, `NONE`, `SNOOZED`.
    * `total_money_raised` (string, 선택): 총 조달 금액.
    * `twitterbio` (string, 선택): 트위터 바이오.
    * `twitterfollowers` (number, 선택): 트위터 팔로워 수.
    * `twitterhandle` (string, 선택): 트위터 핸들.
    * `web_technologies` (string, 선택): 사용한 웹 기술. 미리 정의된 값 중 하나여야 합니다.
    * `website` (string, 선택): 웹사이트 URL.
    * `founded_year` (string, 선택): 설립 연도.
  </Accordion>

<Accordion title="hubspot/create_contact">
    **설명:** HubSpot에서 새로운 연락처 레코드를 생성합니다.

* `email` (string, 필수): 연락처 이메일 주소.
    * `firstname` (string, 선택): 이름.
    * `lastname` (string, 선택): 성.
    * `phone` (string, 선택): 전화번호.
    * `hubspot_owner_id` (string, 선택): 연락처 소유자.
    * `lifecyclestage` (string, 선택): 라이프사이클 단계. 사용 가능한 값: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `hs_lead_status` (string, 선택): 리드 상태. 사용 가능한 값: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `annualrevenue` (string, 선택): 연간 매출.
    * `hs_buying_role` (string, 선택): 구매 역할.
    * `cc_emails` (string, 선택): 참조(CC) 이메일.
    * `ch_customer_id` (string, 선택): Chargify 고객 ID.
    * `ch_customer_reference` (string, 선택): Chargify 고객 참조.
    * `chargify_sites` (string, 선택): Chargify 사이트(들).
    * `city` (string, 선택): 도시.
    * `hs_facebook_ad_clicked` (boolean, 선택): Facebook 광고 클릭 여부.
    * `hs_linkedin_ad_clicked` (string, 선택): LinkedIn 광고 클릭 여부.
    * `hs_clicked_linkedin_ad` (string, 선택): LinkedIn 광고 클릭 여부.
    * `closedate` (string, 선택): 마감일.
    * `company` (string, 선택): 회사명.
    * `company_size` (string, 선택): 회사 규모.
    * `country` (string, 선택): 국가/지역.
    * `hs_country_region_code` (string, 선택): 국가/지역 코드.
    * `date_of_birth` (string, 선택): 생년월일.
    * `degree` (string, 선택): 학위.
    * `hs_email_customer_quarantined_reason` (string, 선택): 이메일 주소 격리 사유.
    * `hs_role` (string, 선택): 고용 역할. 미리 정의된 값 중 하나여야 합니다.
    * `hs_seniority` (string, 선택): 고용 직급. 미리 정의된 값 중 하나여야 합니다.
    * `hs_sub_role` (string, 선택): 고용 하위 역할. 미리 정의된 값 중 하나여야 합니다.
    * `hs_employment_change_detected_date` (string, 선택): 고용 변경 감지 날짜.
    * `hs_enriched_email_bounce_detected` (boolean, 선택): 향상된 이메일 바운스 감지됨.
    * `hs_facebookid` (string, 선택): Facebook ID.
    * `hs_facebook_click_id` (string, 선택): Facebook 클릭 ID.
    * `fax` (string, 선택): 팩스번호.
    * `field_of_study` (string, 선택): 전공.
    * `followercount` (number, 선택): 팔로워 수.
    * `gender` (string, 선택): 성별.
    * `hs_google_click_id` (string, 선택): Google 광고 클릭 ID.
    * `graduation_date` (string, 선택): 졸업 날짜.
    * `owneremail` (string, 선택): HubSpot 소유자 이메일(레거시).
    * `ownername` (string, 선택): HubSpot 소유자 이름(레거시).
    * `industry` (string, 선택): 산업군.
    * `hs_inferred_language_codes` (string, 선택): 추정 언어 코드. 미리 정의된 값 중 하나여야 합니다.
    * `jobtitle` (string, 선택): 직책.
    * `hs_job_change_detected_date` (string, 선택): 직장 변경 감지 날짜.
    * `job_function` (string, 선택): 직무.
    * `hs_journey_stage` (string, 선택): 여정 단계. 미리 정의된 값 중 하나여야 합니다.
    * `kloutscoregeneral` (number, 선택): Klout 점수.
    * `hs_last_metered_enrichment_timestamp` (string, 선택): 마지막 enrichment 타임스탬프.
    * `hs_latest_source` (string, 선택): 최신 유입 경로.
    * `hs_latest_source_timestamp` (string, 선택): 최신 유입 경로 날짜.
    * `hs_legal_basis` (string, 선택): 연락처 데이터 처리를 위한 법적 근거.
    * `linkedinbio` (string, 선택): LinkedIn 바이오.
    * `linkedinconnections` (number, 선택): LinkedIn 연결 수.
    * `hs_linkedin_url` (string, 선택): LinkedIn URL.
    * `hs_linkedinid` (string, 선택): LinkedIn ID.
    * `hs_live_enrichment_deadline` (string, 선택): 라이브 enrichment 기한.
    * `marital_status` (string, 선택): 결혼 상태.
    * `hs_content_membership_email` (string, 선택): 멤버 이메일.
    * `hs_content_membership_notes` (string, 선택): 멤버십 노트.
    * `message` (string, 선택): 메시지.
    * `military_status` (string, 선택): 군복무 상태.
    * `mobilephone` (string, 선택): 휴대전화 번호.
    * `numemployees` (string, 선택): 직원 수.
    * `hs_analytics_source` (string, 선택): 원래 유입 경로.
    * `photo` (string, 선택): 사진.
    * `hs_pinned_engagement_id` (number, 선택): 고정된 참여 ID.
    * `zip` (string, 선택): 우편번호.
    * `hs_language` (string, 선택): 선호 언어. 미리 정의된 값 중 하나여야 합니다.
    * `associatedcompanyid` (number, 선택): 기본 연결된 회사 ID.
    * `hs_email_optout_survey_reason` (string, 선택): 이메일 수신 거부 사유.
    * `relationship_status` (string, 선택): 관계 상태.
    * `hs_returning_to_office_detected_date` (string, 선택): 사무실 복귀 감지 날짜.
    * `salutation` (string, 선택): 호칭.
    * `school` (string, 선택): 학교.
    * `seniority` (string, 선택): 직급.
    * `hs_feedback_show_nps_web_survey` (boolean, 선택): NPS 웹 설문조사를 표시할지 여부.
    * `start_date` (string, 선택): 시작일.
    * `state` (string, 선택): 주/지역.
    * `hs_state_code` (string, 선택): 주/지역 코드.
    * `hs_content_membership_status` (string, 선택): 상태.
    * `address` (string, 선택): 거리 주소.
    * `tax_exempt` (string, 선택): 세금 면제.
    * `hs_timezone` (string, 선택): 시간대. 미리 정의된 값 중 하나여야 합니다.
    * `twitterbio` (string, 선택): 트위터 바이오.
    * `hs_twitterid` (string, 선택): 트위터 ID.
    * `twitterprofilephoto` (string, 선택): 트위터 프로필 사진.
    * `twitterhandle` (string, 선택): 트위터 사용자명.
    * `vat_number` (string, 선택): 부가가치세 번호.
    * `ch_verified` (string, 선택): ACH/eCheck 결제 인증됨.
    * `website` (string, 선택): 웹사이트 URL.
    * `hs_whatsapp_phone_number` (string, 선택): WhatsApp 전화번호.
    * `work_email` (string, 선택): 업무용 이메일.
    * `hs_googleplusid` (string, 선택): googleplus ID.
  </Accordion>

<Accordion title="hubspot/create_deal">
    **설명:** HubSpot에서 새로운 거래(deal) 레코드를 생성합니다.

* `dealname` (string, 필수): 거래 이름.
    * `amount` (number, 선택): 거래 금액.
    * `dealstage` (string, 선택): 거래의 파이프라인 단계.
    * `pipeline` (string, 선택): 거래가 속한 파이프라인.
    * `closedate` (string, 선택): 예상 마감일.
    * `hubspot_owner_id` (string, 선택): 거래 소유자.
    * `dealtype` (string, 선택): 거래 유형. 사용 가능한 값: `newbusiness`, `existingbusiness`.
    * `description` (string, 선택): 거래 설명.
    * `hs_priority` (string, 선택): 거래 우선순위. 사용 가능한 값: `low`, `medium`, `high`.
  </Accordion>

<Accordion title="hubspot/create_record_engagements">
    **설명:** HubSpot에서 새로운 참여(예: 노트, 이메일, 통화, 미팅, 작업)를 생성합니다.

* `engagementType` (string, 필수): 참여 유형. 사용 가능한 값: `NOTE`, `EMAIL`, `CALL`, `MEETING`, `TASK`.
    * `hubspot_owner_id` (string, 선택): 이 활동이 할당된 사용자.
    * `hs_timestamp` (string, 선택): 활동 날짜 및 시간.
    * `hs_note_body` (string, 선택): 노트 본문. (`NOTE`에서 사용)
    * `hs_task_subject` (string, 선택): 작업 제목. (`TASK`에서 사용)
    * `hs_task_body` (string, 선택): 작업 노트. (`TASK`에서 사용)
    * `hs_task_status` (string, 선택): 작업 상태. (`TASK`에서 사용)
    * `hs_meeting_title` (string, 선택): 미팅 제목. (`MEETING`에서 사용)
    * `hs_meeting_body` (string, 선택): 미팅 설명. (`MEETING`에서 사용)
    * `hs_meeting_start_time` (string, 선택): 미팅 시작 시간. (`MEETING`에서 사용)
    * `hs_meeting_end_time` (string, 선택): 미팅 종료 시간. (`MEETING`에서 사용)
  </Accordion>

<Accordion title="hubspot/update_company">
    **설명:** HubSpot에서 기존 회사 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 회사의 ID.
    * `name` (string, 선택): 회사명.
    * `domain` (string, 선택): 회사 도메인명.
    * `industry` (string, 선택): 산업군.
    * `phone` (string, 선택): 전화번호.
    * `city` (string, 선택): 도시.
    * `state` (string, 선택): 주/지역.
    * `zip` (string, 선택): 우편번호.
    * `numberofemployees` (number, 선택): 직원 수.
    * `annualrevenue` (number, 선택): 연간 매출.
    * `description` (string, 선택): 설명.
  </Accordion>

<Accordion title="hubspot/create_record_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드를 생성합니다.

* `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * 추가 파라미터는 커스텀 오브젝트의 스키마에 따라 다릅니다.
  </Accordion>

<Accordion title="hubspot/update_contact">
    **설명:** HubSpot에서 기존 연락처 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 연락처의 ID.
    * `firstname` (string, 선택): 이름.
    * `lastname` (string, 선택): 성.
    * `email` (string, 선택): 이메일 주소.
    * `phone` (string, 선택): 전화번호.
    * `company` (string, 선택): 회사명.
    * `jobtitle` (string, 선택): 직책.
    * `lifecyclestage` (string, 선택): 라이프사이클 단계.
  </Accordion>

<Accordion title="hubspot/update_deal">
    **설명:** HubSpot에서 기존 거래 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 거래의 ID.
    * `dealname` (string, 선택): 거래 이름.
    * `amount` (number, 선택): 거래 금액.
    * `dealstage` (string, 선택): 거래의 파이프라인 단계.
    * `pipeline` (string, 선택): 거래가 속한 파이프라인.
    * `closedate` (string, 선택): 예상 마감일.
    * `dealtype` (string, 선택): 거래 유형.
  </Accordion>

<Accordion title="hubspot/update_record_engagements">
    **설명:** HubSpot에서 기존 참여(engagement)를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 참여의 ID.
    * `hs_note_body` (string, 선택): 노트 본문.
    * `hs_task_subject` (string, 선택): 작업 제목.
    * `hs_task_body` (string, 선택): 작업 노트.
    * `hs_task_status` (string, 선택): 작업 상태.
  </Accordion>

<Accordion title="hubspot/update_record_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드를 업데이트합니다.

* `recordId` (string, 필수): 업데이트할 레코드의 ID.
    * `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * 추가 파라미터는 커스텀 오브젝트의 스키마에 따라 다릅니다.
  </Accordion>

<Accordion title="hubspot/list_companies">
    **설명:** HubSpot에서 회사 레코드 목록을 가져옵니다.

* `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/list_contacts">
    **설명:** HubSpot에서 연락처 레코드 목록을 가져옵니다.

* `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/list_deals">
    **설명:** HubSpot에서 거래 레코드 목록을 가져옵니다.

* `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/get_records_engagements">
    **설명:** HubSpot에서 참여(engagement) 레코드 목록을 가져옵니다.

* `objectName` (string, 필수): 가져올 참여 유형(예: "notes").
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/get_records_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드 목록을 가져옵니다.

* `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/get_company">
    **설명:** ID로 단일 회사 레코드를 가져옵니다.

* `recordId` (string, 필수): 가져올 회사의 ID.
  </Accordion>

<Accordion title="hubspot/get_contact">
    **설명:** ID로 단일 연락처 레코드를 가져옵니다.

* `recordId` (string, 필수): 가져올 연락처의 ID.
  </Accordion>

<Accordion title="hubspot/get_deal">
    **설명:** ID로 단일 거래 레코드를 가져옵니다.

* `recordId` (string, 필수): 가져올 거래의 ID.
  </Accordion>

<Accordion title="hubspot/get_record_by_id_engagements">
    **설명:** ID로 단일 참여(engagement) 레코드를 가져옵니다.

* `recordId` (string, 필수): 가져올 참여의 ID.
  </Accordion>

<Accordion title="hubspot/get_record_by_id_any">
    **설명:** 지정된 오브젝트 타입의 단일 레코드를 ID로 가져옵니다.

* `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * `recordId` (string, 필수): 가져올 레코드의 ID.
  </Accordion>

<Accordion title="hubspot/search_companies">
    **설명:** 필터 수식을 사용해 HubSpot에서 회사 레코드를 검색합니다.

* `filterFormula` (object, 선택): 분리 정규형(OR of ANDs) 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/search_contacts">
    **설명:** 필터 수식을 사용해 HubSpot에서 연락처 레코드를 검색합니다.

* `filterFormula` (object, 선택): 분리 정규형(OR of ANDs) 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/search_deals">
    **설명:** 필터 수식을 사용해 HubSpot에서 거래 레코드를 검색합니다.

* `filterFormula` (object, 선택): 분리 정규형(OR of ANDs) 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/search_records_engagements">
    **설명:** 필터 수식을 사용해 HubSpot에서 참여(engagement) 레코드를 검색합니다.

* `engagementFilterFormula` (object, 선택): 참여 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/search_records_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드를 검색합니다.

* `recordType` (string, 필수): 검색할 오브젝트 타입 ID.
    * `filterFormula` (string, 선택): 적용할 필터 수식.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

<Accordion title="hubspot/delete_record_companies">
    **설명:** ID로 회사 레코드를 삭제합니다.

* `recordId` (string, 필수): 삭제할 회사의 ID.
  </Accordion>

<Accordion title="hubspot/delete_record_contacts">
    **설명:** ID로 연락처 레코드를 삭제합니다.

* `recordId` (string, 필수): 삭제할 연락처의 ID.
  </Accordion>

<Accordion title="hubspot/delete_record_deals">
    **설명:** ID로 거래 레코드를 삭제합니다.

* `recordId` (string, 필수): 삭제할 거래의 ID.
  </Accordion>

<Accordion title="hubspot/delete_record_engagements">
    **설명:** ID로 참여(engagement) 레코드를 삭제합니다.

* `recordId` (string, 필수): 삭제할 참여의 ID.
  </Accordion>

<Accordion title="hubspot/delete_record_any">
    **설명:** 지정된 오브젝트 타입의 레코드를 ID로 삭제합니다.

* `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * `recordId` (string, 필수): 삭제할 레코드의 ID.
  </Accordion>

<Accordion title="hubspot/get_contacts_by_list_id">
    **설명:** 지정된 리스트 ID로부터 연락처 목록을 가져옵니다.

* `listId` (string, 필수): 연락처를 가져올 리스트의 ID.
    * `paginationParameters` (object, 선택): 이후 페이지를 위해 `pageCursor` 사용.
  </Accordion>

<Accordion title="hubspot/describe_action_schema">
    **설명:** 특정 오브젝트 타입 및 작업에 대한 예상 스키마를 가져옵니다.

* `recordType` (string, 필수): 오브젝트 타입 ID(예: 'companies').
    * `operation` (string, 필수): 작업 유형(예: 'CREATE\_RECORD').
  </Accordion>
</AccordionGroup>

### 기본 HubSpot 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 액션

<AccordionGroup>
  <Accordion title="hubspot/create_company">
    **설명:** HubSpot에서 새로운 회사 레코드를 생성합니다.

    **파라미터:**

    * `name` (string, 필수): 회사명.
    * `domain` (string, 선택): 회사 도메인명.
    * `industry` (string, 선택): 산업군. HubSpot에서 미리 정의된 값 중 하나여야 합니다.
    * `phone` (string, 선택): 전화번호.
    * `hubspot_owner_id` (string, 선택): 회사 소유자 ID.
    * `type` (string, 선택): 회사 유형. 사용 가능한 값: `PROSPECT`, `PARTNER`, `RESELLER`, `VENDOR`, `OTHER`.
    * `city` (string, 선택): 도시.
    * `state` (string, 선택): 주/지역.
    * `zip` (string, 선택): 우편번호.
    * `numberofemployees` (number, 선택): 직원 수.
    * `annualrevenue` (number, 선택): 연간 매출.
    * `timezone` (string, 선택): 시간대.
    * `description` (string, 선택): 설명.
    * `linkedin_company_page` (string, 선택): LinkedIn 회사 페이지 URL.
    * `company_email` (string, 선택): 회사 이메일.
    * `first_name` (string, 선택): 회사 연락처의 이름.
    * `last_name` (string, 선택): 회사 연락처의 성.
    * `about_us` (string, 선택): 회사 소개.
    * `hs_csm_sentiment` (string, 선택): CSM 만족도. 사용 가능한 값: `at_risk`, `neutral`, `healthy`.
    * `closedate` (string, 선택): 마감일.
    * `hs_keywords` (string, 선택): 회사 키워드. 미리 정의된 값 중 하나여야 합니다.
    * `country` (string, 선택): 국가/지역.
    * `hs_country_code` (string, 선택): 국가/지역 코드.
    * `hs_employee_range` (string, 선택): 직원 범위.
    * `facebook_company_page` (string, 선택): Facebook 회사 페이지 URL.
    * `facebookfans` (number, 선택): Facebook 팬 수.
    * `hs_gps_coordinates` (string, 선택): GPS 좌표.
    * `hs_gps_error` (string, 선택): GPS 오류.
    * `googleplus_page` (string, 선택): Google Plus 페이지 URL.
    * `owneremail` (string, 선택): HubSpot 소유자 이메일.
    * `ownername` (string, 선택): HubSpot 소유자 이름.
    * `hs_ideal_customer_profile` (string, 선택): 이상적인 고객 프로필 티어. 사용 가능한 값: `tier_1`, `tier_2`, `tier_3`.
    * `hs_industry_group` (string, 선택): 산업 그룹.
    * `is_public` (boolean, 선택): 공개 여부.
    * `hs_last_metered_enrichment_timestamp` (string, 선택): 마지막 enrichment 타임스탬프.
    * `hs_lead_status` (string, 선택): 리드 상태. 사용 가능한 값: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `lifecyclestage` (string, 선택): 라이프사이클 단계. 사용 가능한 값: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `linkedinbio` (string, 선택): LinkedIn 바이오.
    * `hs_linkedin_handle` (string, 선택): LinkedIn 핸들.
    * `hs_live_enrichment_deadline` (string, 선택): 라이브 enrichment 기한.
    * `hs_logo_url` (string, 선택): 로고 URL.
    * `hs_analytics_source` (string, 선택): 원래 유입 경로.
    * `hs_pinned_engagement_id` (number, 선택): 고정된 참여 ID.
    * `hs_quick_context` (string, 선택): 간략한 컨텍스트.
    * `hs_revenue_range` (string, 선택): 매출 범위.
    * `hs_state_code` (string, 선택): 주/지역 코드.
    * `address` (string, 선택): 거리 주소.
    * `address2` (string, 선택): 거리 주소 2.
    * `hs_is_target_account` (boolean, 선택): 타깃 계정 여부.
    * `hs_target_account` (string, 선택): 타깃 계정 티어. 사용 가능한 값: `tier_1`, `tier_2`, `tier_3`.
    * `hs_target_account_recommendation_snooze_time` (string, 선택): 타깃 계정 추천 일시중지 시간.
    * `hs_target_account_recommendation_state` (string, 선택): 타깃 계정 추천 상태. 사용 가능한 값: `DISMISSED`, `NONE`, `SNOOZED`.
    * `total_money_raised` (string, 선택): 총 조달 금액.
    * `twitterbio` (string, 선택): 트위터 바이오.
    * `twitterfollowers` (number, 선택): 트위터 팔로워 수.
    * `twitterhandle` (string, 선택): 트위터 핸들.
    * `web_technologies` (string, 선택): 사용한 웹 기술. 미리 정의된 값 중 하나여야 합니다.
    * `website` (string, 선택): 웹사이트 URL.
    * `founded_year` (string, 선택): 설립 연도.
  </Accordion>

  <Accordion title="hubspot/create_contact">
    **설명:** HubSpot에서 새로운 연락처 레코드를 생성합니다.

    **파라미터:**

    * `email` (string, 필수): 연락처 이메일 주소.
    * `firstname` (string, 선택): 이름.
    * `lastname` (string, 선택): 성.
    * `phone` (string, 선택): 전화번호.
    * `hubspot_owner_id` (string, 선택): 연락처 소유자.
    * `lifecyclestage` (string, 선택): 라이프사이클 단계. 사용 가능한 값: `subscriber`, `lead`, `marketingqualifiedlead`, `salesqualifiedlead`, `opportunity`, `customer`, `evangelist`, `other`.
    * `hs_lead_status` (string, 선택): 리드 상태. 사용 가능한 값: `NEW`, `OPEN`, `IN_PROGRESS`, `OPEN_DEAL`, `UNQUALIFIED`, `ATTEMPTED_TO_CONTACT`, `CONNECTED`, `BAD_TIMING`.
    * `annualrevenue` (string, 선택): 연간 매출.
    * `hs_buying_role` (string, 선택): 구매 역할.
    * `cc_emails` (string, 선택): 참조(CC) 이메일.
    * `ch_customer_id` (string, 선택): Chargify 고객 ID.
    * `ch_customer_reference` (string, 선택): Chargify 고객 참조.
    * `chargify_sites` (string, 선택): Chargify 사이트(들).
    * `city` (string, 선택): 도시.
    * `hs_facebook_ad_clicked` (boolean, 선택): Facebook 광고 클릭 여부.
    * `hs_linkedin_ad_clicked` (string, 선택): LinkedIn 광고 클릭 여부.
    * `hs_clicked_linkedin_ad` (string, 선택): LinkedIn 광고 클릭 여부.
    * `closedate` (string, 선택): 마감일.
    * `company` (string, 선택): 회사명.
    * `company_size` (string, 선택): 회사 규모.
    * `country` (string, 선택): 국가/지역.
    * `hs_country_region_code` (string, 선택): 국가/지역 코드.
    * `date_of_birth` (string, 선택): 생년월일.
    * `degree` (string, 선택): 학위.
    * `hs_email_customer_quarantined_reason` (string, 선택): 이메일 주소 격리 사유.
    * `hs_role` (string, 선택): 고용 역할. 미리 정의된 값 중 하나여야 합니다.
    * `hs_seniority` (string, 선택): 고용 직급. 미리 정의된 값 중 하나여야 합니다.
    * `hs_sub_role` (string, 선택): 고용 하위 역할. 미리 정의된 값 중 하나여야 합니다.
    * `hs_employment_change_detected_date` (string, 선택): 고용 변경 감지 날짜.
    * `hs_enriched_email_bounce_detected` (boolean, 선택): 향상된 이메일 바운스 감지됨.
    * `hs_facebookid` (string, 선택): Facebook ID.
    * `hs_facebook_click_id` (string, 선택): Facebook 클릭 ID.
    * `fax` (string, 선택): 팩스번호.
    * `field_of_study` (string, 선택): 전공.
    * `followercount` (number, 선택): 팔로워 수.
    * `gender` (string, 선택): 성별.
    * `hs_google_click_id` (string, 선택): Google 광고 클릭 ID.
    * `graduation_date` (string, 선택): 졸업 날짜.
    * `owneremail` (string, 선택): HubSpot 소유자 이메일(레거시).
    * `ownername` (string, 선택): HubSpot 소유자 이름(레거시).
    * `industry` (string, 선택): 산업군.
    * `hs_inferred_language_codes` (string, 선택): 추정 언어 코드. 미리 정의된 값 중 하나여야 합니다.
    * `jobtitle` (string, 선택): 직책.
    * `hs_job_change_detected_date` (string, 선택): 직장 변경 감지 날짜.
    * `job_function` (string, 선택): 직무.
    * `hs_journey_stage` (string, 선택): 여정 단계. 미리 정의된 값 중 하나여야 합니다.
    * `kloutscoregeneral` (number, 선택): Klout 점수.
    * `hs_last_metered_enrichment_timestamp` (string, 선택): 마지막 enrichment 타임스탬프.
    * `hs_latest_source` (string, 선택): 최신 유입 경로.
    * `hs_latest_source_timestamp` (string, 선택): 최신 유입 경로 날짜.
    * `hs_legal_basis` (string, 선택): 연락처 데이터 처리를 위한 법적 근거.
    * `linkedinbio` (string, 선택): LinkedIn 바이오.
    * `linkedinconnections` (number, 선택): LinkedIn 연결 수.
    * `hs_linkedin_url` (string, 선택): LinkedIn URL.
    * `hs_linkedinid` (string, 선택): LinkedIn ID.
    * `hs_live_enrichment_deadline` (string, 선택): 라이브 enrichment 기한.
    * `marital_status` (string, 선택): 결혼 상태.
    * `hs_content_membership_email` (string, 선택): 멤버 이메일.
    * `hs_content_membership_notes` (string, 선택): 멤버십 노트.
    * `message` (string, 선택): 메시지.
    * `military_status` (string, 선택): 군복무 상태.
    * `mobilephone` (string, 선택): 휴대전화 번호.
    * `numemployees` (string, 선택): 직원 수.
    * `hs_analytics_source` (string, 선택): 원래 유입 경로.
    * `photo` (string, 선택): 사진.
    * `hs_pinned_engagement_id` (number, 선택): 고정된 참여 ID.
    * `zip` (string, 선택): 우편번호.
    * `hs_language` (string, 선택): 선호 언어. 미리 정의된 값 중 하나여야 합니다.
    * `associatedcompanyid` (number, 선택): 기본 연결된 회사 ID.
    * `hs_email_optout_survey_reason` (string, 선택): 이메일 수신 거부 사유.
    * `relationship_status` (string, 선택): 관계 상태.
    * `hs_returning_to_office_detected_date` (string, 선택): 사무실 복귀 감지 날짜.
    * `salutation` (string, 선택): 호칭.
    * `school` (string, 선택): 학교.
    * `seniority` (string, 선택): 직급.
    * `hs_feedback_show_nps_web_survey` (boolean, 선택): NPS 웹 설문조사를 표시할지 여부.
    * `start_date` (string, 선택): 시작일.
    * `state` (string, 선택): 주/지역.
    * `hs_state_code` (string, 선택): 주/지역 코드.
    * `hs_content_membership_status` (string, 선택): 상태.
    * `address` (string, 선택): 거리 주소.
    * `tax_exempt` (string, 선택): 세금 면제.
    * `hs_timezone` (string, 선택): 시간대. 미리 정의된 값 중 하나여야 합니다.
    * `twitterbio` (string, 선택): 트위터 바이오.
    * `hs_twitterid` (string, 선택): 트위터 ID.
    * `twitterprofilephoto` (string, 선택): 트위터 프로필 사진.
    * `twitterhandle` (string, 선택): 트위터 사용자명.
    * `vat_number` (string, 선택): 부가가치세 번호.
    * `ch_verified` (string, 선택): ACH/eCheck 결제 인증됨.
    * `website` (string, 선택): 웹사이트 URL.
    * `hs_whatsapp_phone_number` (string, 선택): WhatsApp 전화번호.
    * `work_email` (string, 선택): 업무용 이메일.
    * `hs_googleplusid` (string, 선택): googleplus ID.
  </Accordion>

  <Accordion title="hubspot/create_deal">
    **설명:** HubSpot에서 새로운 거래(deal) 레코드를 생성합니다.

    **파라미터:**

    * `dealname` (string, 필수): 거래 이름.
    * `amount` (number, 선택): 거래 금액.
    * `dealstage` (string, 선택): 거래의 파이프라인 단계.
    * `pipeline` (string, 선택): 거래가 속한 파이프라인.
    * `closedate` (string, 선택): 예상 마감일.
    * `hubspot_owner_id` (string, 선택): 거래 소유자.
    * `dealtype` (string, 선택): 거래 유형. 사용 가능한 값: `newbusiness`, `existingbusiness`.
    * `description` (string, 선택): 거래 설명.
    * `hs_priority` (string, 선택): 거래 우선순위. 사용 가능한 값: `low`, `medium`, `high`.
  </Accordion>

  <Accordion title="hubspot/create_record_engagements">
    **설명:** HubSpot에서 새로운 참여(예: 노트, 이메일, 통화, 미팅, 작업)를 생성합니다.

    **파라미터:**

    * `engagementType` (string, 필수): 참여 유형. 사용 가능한 값: `NOTE`, `EMAIL`, `CALL`, `MEETING`, `TASK`.
    * `hubspot_owner_id` (string, 선택): 이 활동이 할당된 사용자.
    * `hs_timestamp` (string, 선택): 활동 날짜 및 시간.
    * `hs_note_body` (string, 선택): 노트 본문. (`NOTE`에서 사용)
    * `hs_task_subject` (string, 선택): 작업 제목. (`TASK`에서 사용)
    * `hs_task_body` (string, 선택): 작업 노트. (`TASK`에서 사용)
    * `hs_task_status` (string, 선택): 작업 상태. (`TASK`에서 사용)
    * `hs_meeting_title` (string, 선택): 미팅 제목. (`MEETING`에서 사용)
    * `hs_meeting_body` (string, 선택): 미팅 설명. (`MEETING`에서 사용)
    * `hs_meeting_start_time` (string, 선택): 미팅 시작 시간. (`MEETING`에서 사용)
    * `hs_meeting_end_time` (string, 선택): 미팅 종료 시간. (`MEETING`에서 사용)
  </Accordion>

  <Accordion title="hubspot/update_company">
    **설명:** HubSpot에서 기존 회사 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 회사의 ID.
    * `name` (string, 선택): 회사명.
    * `domain` (string, 선택): 회사 도메인명.
    * `industry` (string, 선택): 산업군.
    * `phone` (string, 선택): 전화번호.
    * `city` (string, 선택): 도시.
    * `state` (string, 선택): 주/지역.
    * `zip` (string, 선택): 우편번호.
    * `numberofemployees` (number, 선택): 직원 수.
    * `annualrevenue` (number, 선택): 연간 매출.
    * `description` (string, 선택): 설명.
  </Accordion>

  <Accordion title="hubspot/create_record_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드를 생성합니다.

    **파라미터:**

    * `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * 추가 파라미터는 커스텀 오브젝트의 스키마에 따라 다릅니다.
  </Accordion>

  <Accordion title="hubspot/update_contact">
    **설명:** HubSpot에서 기존 연락처 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 연락처의 ID.
    * `firstname` (string, 선택): 이름.
    * `lastname` (string, 선택): 성.
    * `email` (string, 선택): 이메일 주소.
    * `phone` (string, 선택): 전화번호.
    * `company` (string, 선택): 회사명.
    * `jobtitle` (string, 선택): 직책.
    * `lifecyclestage` (string, 선택): 라이프사이클 단계.
  </Accordion>

  <Accordion title="hubspot/update_deal">
    **설명:** HubSpot에서 기존 거래 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 거래의 ID.
    * `dealname` (string, 선택): 거래 이름.
    * `amount` (number, 선택): 거래 금액.
    * `dealstage` (string, 선택): 거래의 파이프라인 단계.
    * `pipeline` (string, 선택): 거래가 속한 파이프라인.
    * `closedate` (string, 선택): 예상 마감일.
    * `dealtype` (string, 선택): 거래 유형.
  </Accordion>

  <Accordion title="hubspot/update_record_engagements">
    **설명:** HubSpot에서 기존 참여(engagement)를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 참여의 ID.
    * `hs_note_body` (string, 선택): 노트 본문.
    * `hs_task_subject` (string, 선택): 작업 제목.
    * `hs_task_body` (string, 선택): 작업 노트.
    * `hs_task_status` (string, 선택): 작업 상태.
  </Accordion>

  <Accordion title="hubspot/update_record_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드를 업데이트합니다.

    **파라미터:**

    * `recordId` (string, 필수): 업데이트할 레코드의 ID.
    * `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * 추가 파라미터는 커스텀 오브젝트의 스키마에 따라 다릅니다.
  </Accordion>

  <Accordion title="hubspot/list_companies">
    **설명:** HubSpot에서 회사 레코드 목록을 가져옵니다.

    **파라미터:**

    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/list_contacts">
    **설명:** HubSpot에서 연락처 레코드 목록을 가져옵니다.

    **파라미터:**

    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/list_deals">
    **설명:** HubSpot에서 거래 레코드 목록을 가져옵니다.

    **파라미터:**

    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/get_records_engagements">
    **설명:** HubSpot에서 참여(engagement) 레코드 목록을 가져옵니다.

    **파라미터:**

    * `objectName` (string, 필수): 가져올 참여 유형(예: "notes").
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/get_records_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드 목록을 가져옵니다.

    **파라미터:**

    * `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/get_company">
    **설명:** ID로 단일 회사 레코드를 가져옵니다.

    **파라미터:**

    * `recordId` (string, 필수): 가져올 회사의 ID.
  </Accordion>

  <Accordion title="hubspot/get_contact">
    **설명:** ID로 단일 연락처 레코드를 가져옵니다.

    **파라미터:**

    * `recordId` (string, 필수): 가져올 연락처의 ID.
  </Accordion>

  <Accordion title="hubspot/get_deal">
    **설명:** ID로 단일 거래 레코드를 가져옵니다.

    **파라미터:**

    * `recordId` (string, 필수): 가져올 거래의 ID.
  </Accordion>

  <Accordion title="hubspot/get_record_by_id_engagements">
    **설명:** ID로 단일 참여(engagement) 레코드를 가져옵니다.

    **파라미터:**

    * `recordId` (string, 필수): 가져올 참여의 ID.
  </Accordion>

  <Accordion title="hubspot/get_record_by_id_any">
    **설명:** 지정된 오브젝트 타입의 단일 레코드를 ID로 가져옵니다.

    **파라미터:**

    * `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * `recordId` (string, 필수): 가져올 레코드의 ID.
  </Accordion>

  <Accordion title="hubspot/search_companies">
    **설명:** 필터 수식을 사용해 HubSpot에서 회사 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 분리 정규형(OR of ANDs) 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/search_contacts">
    **설명:** 필터 수식을 사용해 HubSpot에서 연락처 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 분리 정규형(OR of ANDs) 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/search_deals">
    **설명:** 필터 수식을 사용해 HubSpot에서 거래 레코드를 검색합니다.

    **파라미터:**

    * `filterFormula` (object, 선택): 분리 정규형(OR of ANDs) 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/search_records_engagements">
    **설명:** 필터 수식을 사용해 HubSpot에서 참여(engagement) 레코드를 검색합니다.

    **파라미터:**

    * `engagementFilterFormula` (object, 선택): 참여 필터.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/search_records_any">
    **설명:** HubSpot에서 지정된 오브젝트 타입의 레코드를 검색합니다.

    **파라미터:**

    * `recordType` (string, 필수): 검색할 오브젝트 타입 ID.
    * `filterFormula` (string, 선택): 적용할 필터 수식.
    * `paginationParameters` (object, 선택): 다음 페이지를 가져오려면 `pageCursor`를 사용하세요.
  </Accordion>

  <Accordion title="hubspot/delete_record_companies">
    **설명:** ID로 회사 레코드를 삭제합니다.

    **파라미터:**

    * `recordId` (string, 필수): 삭제할 회사의 ID.
  </Accordion>

  <Accordion title="hubspot/delete_record_contacts">
    **설명:** ID로 연락처 레코드를 삭제합니다.

    **파라미터:**

    * `recordId` (string, 필수): 삭제할 연락처의 ID.
  </Accordion>

  <Accordion title="hubspot/delete_record_deals">
    **설명:** ID로 거래 레코드를 삭제합니다.

    **파라미터:**

    * `recordId` (string, 필수): 삭제할 거래의 ID.
  </Accordion>

  <Accordion title="hubspot/delete_record_engagements">
    **설명:** ID로 참여(engagement) 레코드를 삭제합니다.

    **파라미터:**

    * `recordId` (string, 필수): 삭제할 참여의 ID.
  </Accordion>

  <Accordion title="hubspot/delete_record_any">
    **설명:** 지정된 오브젝트 타입의 레코드를 ID로 삭제합니다.

    **파라미터:**

    * `recordType` (string, 필수): 커스텀 오브젝트의 오브젝트 타입 ID.
    * `recordId` (string, 필수): 삭제할 레코드의 ID.
  </Accordion>

  <Accordion title="hubspot/get_contacts_by_list_id">
    **설명:** 지정된 리스트 ID로부터 연락처 목록을 가져옵니다.

    **파라미터:**

    * `listId` (string, 필수): 연락처를 가져올 리스트의 ID.
    * `paginationParameters` (object, 선택): 이후 페이지를 위해 `pageCursor` 사용.
  </Accordion>

  <Accordion title="hubspot/describe_action_schema">
    **설명:** 특정 오브젝트 타입 및 작업에 대한 예상 스키마를 가져옵니다.

    **파라미터:**

    * `recordType` (string, 필수): 오브젝트 타입 ID(예: 'companies').
    * `operation` (string, 필수): 작업 유형(예: 'CREATE\_RECORD').
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 HubSpot 에이전트 설정
```

---

## 인증이 포함된 서버

**URL:** llms-txt#인증이-포함된-서버

"https://mcp.exa.ai/mcp?api_key=your_key&profile=your_profile"

---

## Personalizando Prompts

**URL:** llms-txt#personalizando-prompts

**Contents:**
- Por Que Personalizar Prompts?
- Entendendo o Sistema de Prompt do CrewAI
- Entendendo as Instruções de Sistema Padrão
  - O Que CrewAI Injeta Automaticamente
  - Visualizando o Prompt de Sistema Completo

Source: https://docs.crewai.com/pt-BR/guides/advanced/customizing-prompts

Aprofunde-se na personalização de prompts de baixo nível no CrewAI, habilitando casos de uso super customizados e complexos para diferentes modelos e idiomas.

## Por Que Personalizar Prompts?

Embora os prompts padrão do CrewAI funcionem bem para muitos cenários, a personalização de baixo nível permite comportamentos de agentes significativamente mais flexíveis e poderosos. Veja por que você pode querer aproveitar esse controle mais profundo:

1. **Otimizar para LLMs específicas** – Diferentes modelos (como GPT-4, Claude ou Llama) funcionam melhor com formatos de prompt adaptados às suas arquiteturas exclusivas.
2. **Alterar o idioma** – Construa agentes que operam exclusivamente em idiomas além do inglês, lidando com nuances com precisão.
3. **Especializar para domínios complexos** – Adapte prompts para setores altamente especializados como saúde, finanças ou jurídico.
4. **Ajustar tom e estilo** – Torne os agentes mais formais, casuais, criativos ou analíticos.
5. **Suportar casos de uso super customizados** – Utilize estruturas e formatações avançadas de prompt para atender requisitos detalhados e específicos do projeto.

Este guia explora como acessar os prompts do CrewAI em um nível mais baixo, oferecendo controle granular sobre como os agentes pensam e interagem.

## Entendendo o Sistema de Prompt do CrewAI

Nos bastidores, o CrewAI adota um sistema de prompt modular que pode ser amplamente customizado:

* **Templates de agente** – Determinam o modo como cada agente aborda o papel que lhe foi atribuído.
* **Prompt slices** – Controlam comportamentos especializados como tarefas, o uso de ferramentas e a estrutura de saída.
* **Tratamento de erros** – Definem como os agentes respondem a falhas, exceções ou timeouts.
* **Prompts específicos de ferramentas** – Definem instruções detalhadas para como as ferramentas são invocadas ou utilizadas.

Confira os [templates de prompt originais no repositório do CrewAI](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json) para ver como esses elementos são organizados. A partir daí, você pode sobrescrever ou adaptar conforme necessário para desbloquear comportamentos avançados.

## Entendendo as Instruções de Sistema Padrão

<Warning>
  **Questão de Transparência em Produção**: O CrewAI injeta automaticamente instruções padrão nos seus prompts que talvez você não conheça. Esta seção explica o que acontece nos bastidores e como obter controle total.
</Warning>

Ao definir um agente com `role`, `goal` e `backstory`, o CrewAI automaticamente adiciona instruções de sistema adicionais que controlam a formatação e o comportamento. Entender essas injeções padrão é essencial para sistemas em produção onde você precisa de total transparência nos prompts.

### O Que CrewAI Injeta Automaticamente

Baseado na configuração do seu agente, o CrewAI adiciona diferentes instruções padrão:

#### Para Agentes Sem Ferramentas

#### Para Agentes Com Ferramentas

#### Para Saídas Estruturadas (JSON/Pydantic)

### Visualizando o Prompt de Sistema Completo

Para ver exatamente qual prompt está sendo enviado para seu LLM, você pode inspecionar o prompt gerado:

```python  theme={null}
from crewai import Agent, Crew, Task
from crewai.utilities.prompts import Prompts

**Examples:**

Example 1 (unknown):
```unknown
#### Para Agentes Com Ferramentas
```

Example 2 (unknown):
```unknown
#### Para Saídas Estruturadas (JSON/Pydantic)
```

Example 3 (unknown):
```unknown
### Visualizando o Prompt de Sistema Completo

Para ver exatamente qual prompt está sendo enviado para seu LLM, você pode inspecionar o prompt gerado:
```

---

## Initialize the tool for semantic searches within a specific GitHub repository

**URL:** llms-txt#initialize-the-tool-for-semantic-searches-within-a-specific-github-repository

tool = GithubSearchTool(
	github_repo='https://github.com/example/repo',
	gh_token='your_github_personal_access_token',
	content_types=['code', 'issue'] # Options: code, repo, pr, issue
)

---

## Ask question to coworker(question: str, context: str, coworker: str)

**URL:** llms-txt#ask-question-to-coworker(question:-str,-context:-str,-coworker:-str)

**Contents:**
- Colaboração em Ação

python  theme={null}
from crewai import Agent, Crew, Task, Process

**Examples:**

Example 1 (unknown):
```unknown
## Colaboração em Ação

Veja um exemplo completo onde agentes colaboram em uma tarefa de criação de conteúdo:
```

---

## Initialize the tool with a specific directory,

**URL:** llms-txt#initialize-the-tool-with-a-specific-directory,

---

## 에이전트는 도구를 호출할 때 이러한 매개변수를 사용합니다

**URL:** llms-txt#에이전트는-도구를-호출할-때-이러한-매개변수를-사용합니다

---

## 특정 파일 경로로 도구를 초기화하여 에이전트가 지정된 파일의 내용만 읽을 수 있도록 합니다.

**URL:** llms-txt#특정-파일-경로로-도구를-초기화하여-에이전트가-지정된-파일의-내용만-읽을-수-있도록-합니다.

**Contents:**
- 인수

file_read_tool = FileReadTool(file_path='path/to/your/file.txt')
```

* `file_path`: 읽고자 하는 파일의 경로입니다. 절대 경로와 상대 경로 모두 허용됩니다. 파일이 존재하는지와 필요한 접근 권한이 있는지 반드시 확인하세요.

---

## Create an agent with the tool

**URL:** llms-txt#create-an-agent-with-the-tool

research_agent = Agent(
    role="Research Coordinator",
    goal="Coordinate and execute market research tasks",
    backstory="You are an expert at coordinating research tasks and leveraging automation tools.",
    tools=[market_research_tool],
    verbose=True
)

---

## Gere e inspecione o prompt atual

**URL:** llms-txt#gere-e-inspecione-o-prompt-atual

generated_prompt = prompt_generator.task_execution()

---

## Crie uma tarefa para o agente

**URL:** llms-txt#crie-uma-tarefa-para-o-agente

research_task = Task(
    description="""
    Search for information about recent advancements in artificial intelligence 
    in the YouTube video at {youtube_video_url}. 
    
    Focus on:
    1. Key AI technologies mentioned
    2. Real-world applications discussed
    3. Future predictions made by the speaker
    
    Provide a comprehensive summary of these points.
    """,
    expected_output="A detailed summary of AI advancements, applications, and future predictions from the video.",
    agent=video_researcher,
)

---

## Strict guardrail requiring high faithfulness score

**URL:** llms-txt#strict-guardrail-requiring-high-faithfulness-score

**Contents:**
  - 도구 응답 컨텍스트 포함하기

strict_guardrail = HallucinationGuardrail(
    context="Quantum computing uses qubits that exist in superposition states.",
    llm=LLM(model="gpt-4o-mini"),
    threshold=8.0  # Requires score >= 8 to pass validation
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 도구 응답 컨텍스트 포함하기

작업에서 도구를 사용할 때 더 정확한 검증을 위해 도구 응답을 포함할 수 있습니다:
```

---

## Link: https://tickets.paris2024.org/

**URL:** llms-txt#link:-https://tickets.paris2024.org/

---

## PDF 텍스트 작성 도구

**URL:** llms-txt#pdf-텍스트-작성-도구

Source: https://docs.crewai.com/ko/tools/file-document/pdf-text-writing-tool

PDFTextWritingTool은 PDF의 특정 위치에 텍스트를 작성하며, 커스텀 폰트를 지원합니다.

---

## Complex task involving multiple Google Drive operations

**URL:** llms-txt#complex-task-involving-multiple-google-drive-operations

organization_task = Task(
    description="""
    1. List all files in the shared folder
    2. Create folders for different document types (Reports, Presentations, Spreadsheets)
    3. Move files to appropriate folders based on their type
    4. Set appropriate sharing permissions for each folder
    5. Create a summary document of the organization changes
    """,
    agent=file_organizer,
    expected_output="Files organized into categorized folders with proper permissions and summary report"
)

crew = Crew(
    agents=[file_organizer],
    tasks=[organization_task]
)

---

## Define your state model

**URL:** llms-txt#define-your-state-model

class UserPreferences(BaseModel):
    theme: str = "light"
    language: str = "English"

class AppState(BaseModel):
    user_name: str = ""
    preferences: UserPreferences = UserPreferences()
    items: List[str] = []
    processed: bool = False
    completion_percentage: float = 0.0

---

## Sem isso, mesmo ele entregaria respostas genéricas

**URL:** llms-txt#sem-isso,-mesmo-ele-entregaria-respostas-genéricas

**Contents:**
  - c. Otimização Holística de Agente + LLM

**Examples:**

Example 1 (unknown):
```unknown
**Elementos de Backstory que Potencializam a Performance de LLMs:**

* **Experiência de Domínio**: "10+ anos em vendas enterprise SaaS"
* **Expertise Específica**: "Especialista em due diligence técnica para Série B+"
* **Estilo de Trabalho**: "Decisões orientadas a dados, documentação clara"
* **Padrões de Qualidade**: "Sempre cita fontes e mostra análise detalhada"

### c. Otimização Holística de Agente + LLM

As configurações mais eficazes criam sinergia entre função específica, profundidade do backstory e escolha do LLM. Cada elemento reforça o outro para maximizar rendimento.

**Framework de Otimização:**
```

---

## 에이전트 생성

**URL:** llms-txt#에이전트-생성

agent = Agent(
    role="Data Analyst",
    goal="Analyze data and provide insights",
    backstory="You are an expert data analyst with 10 years of experience.",
    verbose=True
)

---

## 새 문서 생성 작업

**URL:** llms-txt#새-문서-생성-작업

create_doc_task = Task(
    description="'프로젝트 상태 보고서'라는 제목으로 새 Google 문서를 만드세요",
    agent=docs_agent,
    expected_output="새 Google 문서 '프로젝트 상태 보고서'가 성공적으로 생성됨"
)

---

## Agent automatically gets this tool:

**URL:** llms-txt#agent-automatically-gets-this-tool:

---

## Link: https://link.springer.com/article/10.1007/s10439-023-03172-7

**URL:** llms-txt#link:-https://link.springer.com/article/10.1007/s10439-023-03172-7

---

## Pesquisa TXT RAG

**URL:** llms-txt#pesquisa-txt-rag

**Contents:**
- Visão Geral
- Instalação
- Exemplo

Source: https://docs.crewai.com/pt-BR/tools/file-document/txtsearchtool

O `TXTSearchTool` foi projetado para realizar uma busca RAG (Geração Aumentada por Recuperação) dentro do conteúdo de um arquivo de texto.

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, por isso pode haver comportamentos inesperados ou mudanças no futuro.
</Note>

Esta ferramenta é utilizada para realizar uma busca RAG (Geração Aumentada por Recuperação) dentro do conteúdo de um arquivo de texto.
Ela permite uma busca semântica de uma consulta dentro do conteúdo de um arquivo de texto especificado,
tornando-se um recurso valioso para extrair rapidamente informações ou encontrar seções específicas do texto com base na consulta fornecida.

Para usar o `TXTSearchTool`, primeiro é necessário instalar o pacote `crewai_tools`.
Isso pode ser feito usando o pip, um gerenciador de pacotes para Python.
Abra seu terminal ou prompt de comando e digite o seguinte comando:

Este comando fará o download e instalará o TXTSearchTool junto com todas as dependências necessárias.

O exemplo a seguir demonstra como usar o TXTSearchTool para pesquisar dentro de um arquivo de texto.
Este exemplo mostra tanto a inicialização da ferramenta com um arquivo de texto específico quanto a pesquisa subsequente dentro do conteúdo desse arquivo.

```python Code theme={null}
from crewai_tools import TXTSearchTool

**Examples:**

Example 1 (unknown):
```unknown
Este comando fará o download e instalará o TXTSearchTool junto com todas as dependências necessárias.

## Exemplo

O exemplo a seguir demonstra como usar o TXTSearchTool para pesquisar dentro de um arquivo de texto.
Este exemplo mostra tanto a inicialização da ferramenta com um arquivo de texto específico quanto a pesquisa subsequente dentro do conteúdo desse arquivo.
```

---

## In your main.py or flow.py file

**URL:** llms-txt#in-your-main.py-or-flow.py-file

from crewai.flow import Flow, listen, start
from my_listeners import MyCustomListener

---

## Assuming you have a flow instance

**URL:** llms-txt#assuming-you-have-a-flow-instance

**Contents:**
  - 플롯 이해하기
  - 결론
- 다음 단계
- 플로우 실행하기
  - Flow API 사용하기
  - CLI 사용하기

flow.plot("my_flow_plot")
bash  theme={null}
crewai flow plot
python  theme={null}
flow = ExampleFlow()
result = flow.kickoff()
shell  theme={null}
crewai run
shell  theme={null}
crewai flow kickoff
```

하지만 `crewai run` 명령어가 이제 crew와 flow 모두에 작동하므로 더욱 선호되는 방법입니다.

**Examples:**

Example 1 (unknown):
```unknown
이렇게 하면 현재 디렉토리에 `my_flow_plot.html`이라는 파일이 생성됩니다. 이 파일을 웹 브라우저에서 열어 인터랙티브 플롯을 볼 수 있습니다.

#### 옵션 2: 커맨드 라인 사용

구조화된 CrewAI 프로젝트 내에서 작업 중이라면 커맨드 라인을 사용하여 플롯을 생성할 수 있습니다. 이는 전체 플로우 설정을 시각화하고자 하는 대규모 프로젝트에서 특히 유용합니다.
```

Example 2 (unknown):
```unknown
이 명령은 플로우의 플롯이 포함된 HTML 파일을 생성하며, 이는 `plot()` 메서드와 유사합니다. 파일은 프로젝트 디렉터리에 저장되며, 웹 브라우저에서 열어 플로우를 탐색할 수 있습니다.

### 플롯 이해하기

생성된 플롯은 flow 내의 작업을 나타내는 노드와 실행 흐름을 나타내는 방향성이 있는 엣지를 표시합니다. 플롯은 인터랙티브하게 제공되어, 확대/축소를 하거나 노드 위에 마우스를 올려 추가 정보를 볼 수 있습니다.

flow를 시각화하면 워크플로의 구조를 더욱 명확하게 이해할 수 있어 디버깅, 최적화, 그리고 AI 프로세스를 다른 사람들에게 설명하는 데 도움이 됩니다.

### 결론

플로우를 시각적으로 표현하는 것은 CrewAI의 강력한 기능으로, 복잡한 AI 워크플로우를 설계하고 관리하는 능력을 크게 향상시켜줍니다. `plot()` 메서드나 커맨드 라인 중 어떤 방법을 사용하더라도, 플롯을 생성하면 워크플로우의 시각적 표현을 얻을 수 있어 개발과 발표 모두에 도움이 됩니다.

## 다음 단계

추가적인 flow 예제를 살펴보고 싶으시다면, 저희 examples 레포지토리에서 다양한 추천 예제를 확인하실 수 있습니다. 아래는 각각 고유한 사용 사례를 보여주는 네 가지 구체적인 flow 예제로, 현재 문제 유형에 맞는 예시를 찾는 데 도움이 될 것입니다:

1. **이메일 자동 응답자 Flow**: 이 예제는 백그라운드 작업이 계속 실행되면서 이메일 응답을 자동화하는 무한 루프를 보여줍니다. 수동 개입 없이 반복적으로 수행해야 하는 작업에 적합한 사용 사례입니다. [예제 보기](https://github.com/crewAIInc/crewAI-examples/tree/main/email_auto_responder_flow)

2. **리드 점수 Flow**: 이 flow 예제는 human-in-the-loop 피드백을 추가하고 router를 사용하여 다양한 조건 분기를 처리하는 방법을 보여줍니다. 워크플로우에 동적 의사결정과 인간의 관리·감독을 통합하는 방식을 확인할 수 있는 훌륭한 예시입니다. [예제 보기](https://github.com/crewAIInc/crewAI-examples/tree/main/lead-score-flow)

3. **책 집필 Flow**: 이 예제는 여러 crew를 연속적으로 연결하는 데 탁월하며, 한 crew의 출력 결과가 다른 crew에 의해 사용됩니다. 구체적으로, 한 crew가 전체 책의 개요를 작성하고, 다른 crew가 그 개요를 바탕으로 챕터를 생성합니다. 결국 모든 것이 연결되어 완성된 책이 만들어집니다. 여러 작업 간 조율이 필요한 복잡한 다단계 프로세스에 적합한 flow입니다. [예제 보기](https://github.com/crewAIInc/crewAI-examples/tree/main/write_a_book_with_flows)

4. **미팅 어시스턴트 Flow**: 이 flow는 하나의 이벤트가 여러 후속 작업을 트리거하도록 브로드캐스트하는 방법을 보여줍니다. 예를 들어, 미팅이 끝난 후 Trello 보드를 업데이트하고 Slack 메시지를 전송하며 결과를 저장할 수 있습니다. 하나의 이벤트로부터 여러 결과를 처리하는 좋은 예시로, 포괄적인 작업 관리 및 알림 시스템에 이상적입니다. [예제 보기](https://github.com/crewAIInc/crewAI-examples/tree/main/meeting_assistant_flow)

이 예제들을 통해 반복되는 작업 자동화부터 동적 의사결정과 인간 피드백이 포함된 복잡한 다단계 프로세스 관리에 이르기까지 다양한 사용 사례에서 CrewAI Flows를 어떻게 활용할 수 있는지에 대한 통찰력을 얻을 수 있습니다.

또한, 아래의 CrewAI에서 flows를 사용하는 방법에 대한 YouTube 영상을 확인해보세요!

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/MTb5my6VOT8" title="CrewAI Flows 개요" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen />

## 플로우 실행하기

플로우를 실행하는 방법에는 두 가지가 있습니다:

### Flow API 사용하기

플로우를 프로그래밍 방식으로 실행하려면, 플로우 클래스의 인스턴스를 생성하고 `kickoff()` 메서드를 호출하면 됩니다:
```

Example 3 (unknown):
```unknown
### CLI 사용하기

버전 0.103.0부터 `crewai run` 명령어를 사용하여 flow를 실행할 수 있습니다:
```

Example 4 (unknown):
```unknown
이 명령어는 프로젝트가 pyproject.toml의 `type = "flow"` 설정을 기반으로 flow인지 자동으로 감지하여 해당 방식으로 실행합니다. 명령줄에서 flow를 실행하는 권장 방법입니다.

하위 호환성을 위해 다음 명령어도 사용할 수 있습니다:
```

---

## Defina seu agente

**URL:** llms-txt#defina-seu-agente

researcher = Agent(
    role="Especialista em Pesquisa",
    goal="Pesquisar tópicos minuciosamente",
    backstory="Pesquisador especialista com habilidades em encontrar informações",
    llm=create_llm("openai/gpt-4o"), # Substitua pelo modelo que você quer usar
    verbose=True
)

---

## (não traduzir blocos de código)

**URL:** llms-txt#(não-traduzir-blocos-de-código)

Este guia cobre o essencial para implementar LLMs personalizados no CrewAI.

---

## Crie um agente com capacidades do Microsoft Teams

**URL:** llms-txt#crie-um-agente-com-capacidades-do-microsoft-teams

teams_agent = Agent(
    role="Coordenador do Teams",
    goal="Gerenciar comunicação e reuniões do Teams de forma eficiente",
    backstory="Um assistente IA especializado em operações do Microsoft Teams e colaboração em equipe.",
    apps=['microsoft_teams']  # Todas as ações do Teams estarão disponíveis
)

---

## Metadata - for additional information (can be customized)

**URL:** llms-txt#metadata---for-additional-information-(can-be-customized)

metadata = fingerprint.metadata  # A dictionary, defaults to {}
```

---

## AI 마인드 툴

**URL:** llms-txt#ai-마인드-툴

Source: https://docs.crewai.com/ko/tools/ai-ml/aimindtool

AIMindTool은 자연어로 데이터 소스를 질의하도록 설계되었습니다.

---

## Inicialize a ferramenta com o URI do banco de dados e o nome da tabela de destino

**URL:** llms-txt#inicialize-a-ferramenta-com-o-uri-do-banco-de-dados-e-o-nome-da-tabela-de-destino

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = MySQLSearchTool(
    db_uri='mysql://user:password@localhost:3306/mydatabase',
    table_name='employees'
)
python Code theme={null}
tool = MySQLSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # ou google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google",
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

O MySQLSearchTool requer os seguintes argumentos para sua operação:

* `db_uri`: Uma string representando o URI do banco de dados MySQL a ser consultado. Este argumento é obrigatório e deve incluir os detalhes de autenticação necessários e o local do banco de dados.
* `table_name`: Uma string especificando o nome da tabela dentro do banco de dados na qual será realizada a busca semântica. Este argumento é obrigatório.

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza o OpenAI tanto para embeddings quanto para sumarização. Para customizar o modelo, você pode usar um dicionário de configuração conforme o exemplo:
```

---

## Simple flow can use unstructured state

**URL:** llms-txt#simple-flow-can-use-unstructured-state

class SimpleGreetingFlow(Flow):
    @start()
    def greet(self):
        self.state["name"] = "World"
        return f"Hello, {self.state['name']}!"

---

## Portkey Integration

**URL:** llms-txt#portkey-integration

**Contents:**
- Introduction
  - Installation & Setup
- Production Features
  - 1. Enhanced Observability
  - 2. Reliability - Keep Your Crews Running Smoothly

Source: https://docs.crewai.com/en/observability/portkey

How to use Portkey with CrewAI

<img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/main/Portkey-CrewAI.png" alt="Portkey CrewAI Header Image" width="70%" />

Portkey enhances CrewAI with production-readiness features, turning your experimental agent crews into robust systems by providing:

* **Complete observability** of every agent step, tool use, and interaction
* **Built-in reliability** with fallbacks, retries, and load balancing
* **Cost tracking and optimization** to manage your AI spend
* **Access to 200+ LLMs** through a single integration
* **Guardrails** to keep agent behavior safe and compliant
* **Version-controlled prompts** for consistent agent performance

### Installation & Setup

<Steps>
  <Step title="Install the required packages">
    
  </Step>

<Step title="Generate API Key" icon="lock">
    Create a Portkey API key with optional budget/rate limits from the [Portkey dashboard](https://app.portkey.ai/). You can also attach configurations for reliability, caching, and more to this key. More on this later.
  </Step>

<Step title="Configure CrewAI with Portkey">
    The integration is simple - you just need to update the LLM configuration in your CrewAI setup:

<Info>
      **What are Virtual Keys?** Virtual keys in Portkey securely store your LLM provider API keys (OpenAI, Anthropic, etc.) in an encrypted vault. They allow for easier key rotation and budget management. [Learn more about virtual keys here](https://portkey.ai/docs/product/ai-gateway/virtual-keys).
    </Info>
  </Step>
</Steps>

## Production Features

### 1. Enhanced Observability

Portkey provides comprehensive observability for your CrewAI agents, helping you understand exactly what's happening during each execution.

<Tabs>
  <Tab title="Traces">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Product%2011.1.webp" />
    </Frame>

Traces provide a hierarchical view of your crew's execution, showing the sequence of LLM calls, tool invocations, and state transitions.

<Tab title="Logs">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Metadata.png" />
    </Frame>

Portkey logs every interaction with LLMs, including:

* Complete request and response payloads
    * Latency and token usage metrics
    * Cost calculations
    * Tool calls and function executions

All logs can be filtered by metadata, trace IDs, models, and more, making it easy to debug specific crew runs.
  </Tab>

<Tab title="Metrics & Dashboards">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Dashboard.png" />
    </Frame>

Portkey provides built-in dashboards that help you:

* Track cost and token usage across all crew runs
    * Analyze performance metrics like latency and success rates
    * Identify bottlenecks in your agent workflows
    * Compare different crew configurations and LLMs

You can filter and segment all metrics by custom metadata to analyze specific crew types, user groups, or use cases.
  </Tab>

<Tab title="Metadata Filtering">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" alt="Analytics with metadata filters" />
    </Frame>

Add custom metadata to your CrewAI LLM configuration to enable powerful filtering and segmentation:

This metadata can be used to filter logs, traces, and metrics on the Portkey dashboard, allowing you to analyze specific crew runs, users, or environments.
  </Tab>
</Tabs>

### 2. Reliability - Keep Your Crews Running Smoothly

When running crews in production, things can go wrong - API rate limits, network issues, or provider outages. Portkey's reliability features ensure your agents keep running smoothly even when problems occur.

It's simple to enable fallback in your CrewAI setup by using a Portkey Config:

```python  theme={null}
from crewai import LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Generate API Key" icon="lock">
    Create a Portkey API key with optional budget/rate limits from the [Portkey dashboard](https://app.portkey.ai/). You can also attach configurations for reliability, caching, and more to this key. More on this later.
  </Step>

  <Step title="Configure CrewAI with Portkey">
    The integration is simple - you just need to update the LLM configuration in your CrewAI setup:
```

Example 2 (unknown):
```unknown
<Info>
      **What are Virtual Keys?** Virtual keys in Portkey securely store your LLM provider API keys (OpenAI, Anthropic, etc.) in an encrypted vault. They allow for easier key rotation and budget management. [Learn more about virtual keys here](https://portkey.ai/docs/product/ai-gateway/virtual-keys).
    </Info>
  </Step>
</Steps>

## Production Features

### 1. Enhanced Observability

Portkey provides comprehensive observability for your CrewAI agents, helping you understand exactly what's happening during each execution.

<Tabs>
  <Tab title="Traces">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Product%2011.1.webp" />
    </Frame>

    Traces provide a hierarchical view of your crew's execution, showing the sequence of LLM calls, tool invocations, and state transitions.
```

Example 3 (unknown):
```unknown
</Tab>

  <Tab title="Logs">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Metadata.png" />
    </Frame>

    Portkey logs every interaction with LLMs, including:

    * Complete request and response payloads
    * Latency and token usage metrics
    * Cost calculations
    * Tool calls and function executions

    All logs can be filtered by metadata, trace IDs, models, and more, making it easy to debug specific crew runs.
  </Tab>

  <Tab title="Metrics & Dashboards">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Dashboard.png" />
    </Frame>

    Portkey provides built-in dashboards that help you:

    * Track cost and token usage across all crew runs
    * Analyze performance metrics like latency and success rates
    * Identify bottlenecks in your agent workflows
    * Compare different crew configurations and LLMs

    You can filter and segment all metrics by custom metadata to analyze specific crew types, user groups, or use cases.
  </Tab>

  <Tab title="Metadata Filtering">
    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Metadata%20Filters%20from%20CrewAI.png" alt="Analytics with metadata filters" />
    </Frame>

    Add custom metadata to your CrewAI LLM configuration to enable powerful filtering and segmentation:
```

Example 4 (unknown):
```unknown
This metadata can be used to filter logs, traces, and metrics on the Portkey dashboard, allowing you to analyze specific crew runs, users, or environments.
  </Tab>
</Tabs>

### 2. Reliability - Keep Your Crews Running Smoothly

When running crews in production, things can go wrong - API rate limits, network issues, or provider outages. Portkey's reliability features ensure your agents keep running smoothly even when problems occur.

It's simple to enable fallback in your CrewAI setup by using a Portkey Config:
```

---

## os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # 🇺🇸 Região EUA

**URL:** llms-txt#os.environ["langfuse_host"]-=-"https://us.cloud.langfuse.com"-#-🇺🇸-região-eua

---

## Executar tarefas

**URL:** llms-txt#executar-tarefas

**Contents:**
- Ferramentas CrewAI Disponíveis
- Criando suas próprias Ferramentas
  - Herança de `BaseTool`
- Suporte a Ferramentas Assíncronas
  - Criando Ferramentas Assíncronas
  - Utilizando Ferramentas Assíncronas

crew.kickoff()
python Code theme={null}
from crewai.tools import BaseTool
from pydantic import BaseModel, Field

class MyToolInput(BaseModel):
    """Input schema for MyCustomTool."""
    argument: str = Field(..., description="Description of the argument.")

class MyCustomTool(BaseTool):
    name: str = "Name of my tool"
    description: str = "What this tool does. It's vital for effective utilization."
    args_schema: Type[BaseModel] = MyToolInput

def _run(self, argument: str) -> str:
        # Seu código da ferramenta aqui
        return "Tool's result"
python Code theme={null}
from crewai.tools import tool

@tool("fetch_data_async")
async def fetch_data_async(query: str) -> str:
    """Asynchronously fetch data based on the query."""
    # Simulate async operation
    await asyncio.sleep(1)
    return f"Data retrieved for {query}"
python Code theme={null}
from crewai.tools import BaseTool

class AsyncCustomTool(BaseTool):
    name: str = "async_custom_tool"
    description: str = "An asynchronous custom tool"

async def _run(self, query: str = "") -> str:
        """Asynchronously run the tool"""
        # Sua implementação assíncrona aqui
        await asyncio.sleep(1)
        return f"Processed {query} asynchronously"
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Ferramentas CrewAI Disponíveis

* **Tratamento de Erros**: Todas as ferramentas são construídas com capacidades de tratamento de erros, permitindo que os agentes administrem exceções de forma adequada e prossigam com suas tarefas.
* **Mecanismo de Cache**: Todas as ferramentas suportam cache, possibilitando que agentes reutilizem de forma eficiente resultados obtidos anteriormente, reduzindo a carga em recursos externos e acelerando o tempo de execução. Também é possível definir controles mais precisos sobre o mecanismo de cache usando o atributo `cache_function` na ferramenta.

Aqui está uma lista das ferramentas disponíveis e suas descrições:

| Ferramenta                       | Descrição                                                                                            |
| :------------------------------- | :--------------------------------------------------------------------------------------------------- |
| **ApifyActorsTool**              | Ferramenta que integra Apify Actors aos seus fluxos de trabalho para web scraping e automação.       |
| **BrowserbaseLoadTool**          | Ferramenta para interação e extração de dados de navegadores web.                                    |
| **CodeDocsSearchTool**           | Uma ferramenta RAG otimizada para busca em documentações de código e documentos técnicos.            |
| **CodeInterpreterTool**          | Ferramenta para interpretar código Python.                                                           |
| **ComposioTool**                 | Permite o uso de ferramentas Composio.                                                               |
| **CSVSearchTool**                | Ferramenta RAG projetada para busca em arquivos CSV, ideal para dados estruturados.                  |
| **DALL-E Tool**                  | Ferramenta para gerar imagens utilizando a API do DALL-E.                                            |
| **DirectorySearchTool**          | Ferramenta RAG para busca em diretórios, útil para navegação em sistemas de arquivos.                |
| **DOCXSearchTool**               | Ferramenta RAG voltada para busca em documentos DOCX, ideal para processar arquivos Word.            |
| **DirectoryReadTool**            | Facilita a leitura e processamento de estruturas de diretórios e seus conteúdos.                     |
| **EXASearchTool**                | Ferramenta projetada para buscas exaustivas em diversas fontes de dados.                             |
| **FileReadTool**                 | Permite a leitura e extração de dados de arquivos, suportando diversos formatos.                     |
| **FirecrawlSearchTool**          | Ferramenta para buscar páginas web usando Firecrawl e retornar os resultados.                        |
| **FirecrawlCrawlWebsiteTool**    | Ferramenta para rastrear páginas web utilizando o Firecrawl.                                         |
| **FirecrawlScrapeWebsiteTool**   | Ferramenta para extrair o conteúdo de URLs usando Firecrawl.                                         |
| **GithubSearchTool**             | Ferramenta RAG para buscar em repositórios GitHub, útil para pesquisa de código e documentação.      |
| **SerperDevTool**                | Ferramenta especializada para finalidades de desenvolvimento, com funcionalidades em evolução.       |
| **TXTSearchTool**                | Ferramenta RAG voltada para busca em arquivos de texto (.txt), adaptada para dados não estruturados. |
| **JSONSearchTool**               | Ferramenta RAG para busca em arquivos JSON, voltada ao manuseio de dados estruturados.               |
| **LlamaIndexTool**               | Permite o uso das ferramentas LlamaIndex.                                                            |
| **MDXSearchTool**                | Ferramenta RAG para busca em arquivos Markdown (MDX), útil para documentação.                        |
| **PDFSearchTool**                | Ferramenta RAG para busca em documentos PDF, ideal para processar documentos digitalizados.          |
| **PGSearchTool**                 | Ferramenta RAG otimizada para busca em bancos de dados PostgreSQL, adequada para consultas.          |
| **Vision Tool**                  | Ferramenta para gerar imagens utilizando a API do DALL-E.                                            |
| **RagTool**                      | Ferramenta RAG de uso geral, capaz de lidar com diferentes fontes e tipos de dados.                  |
| **ScrapeElementFromWebsiteTool** | Permite extrair elementos específicos de sites, útil para extração de dados direcionada.             |
| **ScrapeWebsiteTool**            | Facilita o scraping de sites inteiros, ideal para coleta abrangente de dados.                        |
| **WebsiteSearchTool**            | Ferramenta RAG para busca em conteúdos de sites, otimizada para extração de dados web.               |
| **XMLSearchTool**                | Ferramenta RAG para busca em arquivos XML, adequada para formatos de dados estruturados.             |
| **YoutubeChannelSearchTool**     | Ferramenta RAG para busca em canais do YouTube, útil para análise de conteúdo em vídeo.              |
| **YoutubeVideoSearchTool**       | Ferramenta RAG para busca em vídeos do YouTube, ideal para extração de dados de vídeo.               |

## Criando suas próprias Ferramentas

<Tip>
  Desenvolvedores podem criar `ferramentas personalizadas` adaptadas para as necessidades de seus agentes ou utilizar opções pré-construídas.
</Tip>

Existem duas formas principais de criar uma ferramenta CrewAI:

### Herança de `BaseTool`
```

Example 2 (unknown):
```unknown
## Suporte a Ferramentas Assíncronas

O CrewAI suporta ferramentas assíncronas, permitindo que você implemente ferramentas que realizam operações não bloqueantes, como requisições de rede, I/O de arquivos ou outras operações async sem bloquear o fluxo principal de execução.

### Criando Ferramentas Assíncronas

Você pode criar ferramentas assíncronas de duas formas:

#### 1. Utilizando o Decorador `tool` com Funções Assíncronas
```

Example 3 (unknown):
```unknown
#### 2. Implementando Métodos Assíncronos em Classes de Ferramentas Personalizadas
```

Example 4 (unknown):
```unknown
### Utilizando Ferramentas Assíncronas

Ferramentas assíncronas funcionam perfeitamente tanto em fluxos tradicionais do Crew quanto em fluxos baseados em Flow:
```

---

## Opik 개요

**URL:** llms-txt#opik-개요

**Contents:**
- 설치
- 리소스

[Comet Opik](https://www.comet.com/docs/opik/)을(를) 사용하여, 포괄적인 트레이싱, 자동 평가, 프로덕션 준비가 된 대시보드를 통해 LLM 애플리케이션, RAG 시스템, 에이전트 워크플로우를 디버깅, 평가 및 모니터링할 수 있습니다.

<Frame caption="Opik 에이전트 대시보드">
  <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6b313c7d767211f2287d7dd074f9dfeb" alt="CrewAI와 함께하는 Opik 에이전트 모니터링 예시" data-og-width="1538" width="1538" data-og-height="877" height="877" data-path="images/opik-crewai-dashboard.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b0fd3eca42762838a806dc0d38d0313f 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ba1166f8b42afee86b3cd88532002fde 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d7905602ba2ac1dbca66a008be49ca26 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=51c2c8ce83af0d81fdf851dd378fe6f6 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5184c8370b92c51a03d970a01c7daba5 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=80d3fb638cd8ace74953775242cb68cd 2500w" />
</Frame>

Opik은 CrewAI 애플리케이션 개발의 모든 단계에서 포괄적인 지원을 제공합니다:

* **로그 트레이스 및 스팬**: 개발 및 프로덕션 시스템에서 LLM 호출과 애플리케이션 로직을 자동으로 추적하여 디버깅 및 분석이 가능합니다. 프로젝트 간 응답을 수동 또는 프로그램적으로 주석 달고, 조회하고, 비교할 수 있습니다.
* **LLM 애플리케이션 성능 평가**: 사용자 지정 테스트 세트로 평가하고, 내장된 평가 지표를 실행하거나 SDK 또는 UI에서 사용자만의 지표를 정의할 수 있습니다.
* **CI/CD 파이프라인 내 테스트**: PyTest 기반의 Opik LLM 단위 테스트로 신뢰할 수 있는 성능 기준선을 설정하세요. 프로덕션에서 연속 모니터링을 위한 온라인 평가도 실행할 수 있습니다.
* **프로덕션 데이터 모니터링 및 분석**: 프로덕션에서 보지 못한 데이터에 대한 모델의 성능을 이해하고, 새로운 개발 반복을 위한 데이터 세트를 생성할 수 있습니다.

Comet은 호스팅된 Opik 플랫폼을 제공하거나, 로컬에서 플랫폼을 실행할 수도 있습니다.

호스팅 버전을 사용하려면 [무료 Comet 계정 만들기](https://www.comet.com/signup?utm_medium=github\&utm_source=crewai_docs) 후 API 키를 발급받으세요.

Opik 플랫폼을 로컬에서 실행하려면, [설치 가이드](https://www.comet.com/docs/opik/self-host/overview/)에서 자세한 정보를 확인하세요.

이 가이드에서는 CrewAI의 빠른 시작 예제를 사용합니다.

<Steps>
  <Step title="필수 패키지 설치">
    
  </Step>

<Step title="Opik 구성">
    
  </Step>

<Step title="환경 준비">
    먼저, LLM 제공업체의 API 키를 환경 변수로 설정합니다:

<Step title="CrewAI 사용하기">
    첫 번째 단계는 프로젝트를 만드는 것입니다. CrewAI 문서의 예제를 사용하겠습니다:

이제 Opik의 추적기를 임포트하고 crew를 실행할 수 있습니다:

CrewAI 애플리케이션을 실행한 후에는 Opik 앱에서 다음을 확인할 수 있습니다:

* LLM 추적, span, 메타데이터
    * 에이전트 상호작용 및 태스크 실행 흐름
    * 지연 시간, 토큰 사용량 등의 성능 지표
    * 평가 지표(내장형 또는 사용자 정의)
  </Step>
</Steps>

* [🦉 Opik 문서](https://www.comet.com/docs/opik/)
* [👉 Opik + CrewAI Colab](https://colab.research.google.com/github/comet-ml/opik/blob/main/apps/opik-documentation/documentation/docs/cookbook/crewai.ipynb)
* [🐦 X](https://x.com/cometml)
* [💬 Slack](https://slack.comet.com/)

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Opik 구성">
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="환경 준비">
    먼저, LLM 제공업체의 API 키를 환경 변수로 설정합니다:
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="CrewAI 사용하기">
    첫 번째 단계는 프로젝트를 만드는 것입니다. CrewAI 문서의 예제를 사용하겠습니다:
```

Example 4 (unknown):
```unknown
이제 Opik의 추적기를 임포트하고 crew를 실행할 수 있습니다:
```

---

## Conectar ao Weaviate

**URL:** llms-txt#conectar-ao-weaviate

client = weaviate.connect_to_weaviate_cloud(
    cluster_url="https://your-weaviate-cluster-url.com",
    auth_credentials=Auth.api_key("your-weaviate-api-key"),
    headers={"X-OpenAI-Api-Key": "your-openai-api-key"}
)

---

## Directory Read

**URL:** llms-txt#directory-read

Source: https://docs.crewai.com/en/tools/file-document/directoryreadtool

The `DirectoryReadTool` is a powerful utility designed to provide a comprehensive listing of directory contents.

---

## 작업을 생성합니다

**URL:** llms-txt#작업을-생성합니다

task = Task(
    description="Analyze the provided sales data and identify key trends.",
    expected_output="A report highlighting the top 3 sales trends.",
    agent=agent
)

---

## Não é necessário gerenciamento manual de conexão ou configuração de ferramentas

**URL:** llms-txt#não-é-necessário-gerenciamento-manual-de-conexão-ou-configuração-de-ferramentas

**Contents:**
- Formatos de Referência Suportados
  - Servidores MCP Remotos Externos

**Examples:**

Example 1 (unknown):
```unknown
## Formatos de Referência Suportados

### Servidores MCP Remotos Externos
```

---

## Set custom storage location

**URL:** llms-txt#set-custom-storage-location

os.environ["CREWAI_STORAGE_DIR"] = "./my_project_storage"

---

## Run a natural language query

**URL:** llms-txt#run-a-natural-language-query

**Contents:**
- Parâmetros
- Exemplo de Integração com Agente

result = aimind_tool.run("How many 3 bedroom houses were sold in 2008?")
print(result)
python Code theme={null}
from crewai import Agent
from crewai.project import agent
from crewai_tools import AIMindTool

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros

O `AIMindTool` aceita os seguintes parâmetros:

* **api\_key**: Opcional. Sua chave de API da Minds. Se não for fornecida, será lida da variável de ambiente `MINDS_API_KEY`.
* **datasources**: Uma lista de dicionários, cada um contendo as seguintes chaves:
  * **description**: Uma descrição dos dados contidos na fonte de dados.
  * **engine**: O engine (ou tipo) da fonte de dados.
  * **connection\_data**: Um dicionário contendo os parâmetros de conexão da fonte de dados.
  * **tables**: Uma lista de tabelas que a fonte de dados irá utilizar. Isso é opcional e pode ser omitido caso todas as tabelas da fonte de dados devam ser utilizadas.

Uma lista das fontes de dados suportadas e seus parâmetros de conexão pode ser encontrada [aqui](https://docs.mdb.ai/docs/data_sources).

## Exemplo de Integração com Agente

Veja como integrar o `AIMindTool` com um agente CrewAI:
```

---

## Firecrawl 웹사이트 크롤링

**URL:** llms-txt#firecrawl-웹사이트-크롤링

Source: https://docs.crewai.com/ko/tools/web-scraping/firecrawlcrawlwebsitetool

FirecrawlCrawlWebsiteTool은(는) 웹사이트를 크롤링하여 깔끔한 마크다운이나 구조화된 데이터로 변환하도록 설계되었습니다.

---

## React Component Export

**URL:** llms-txt#react-component-export

**Contents:**
- Exporting a React Component
- Setting Up Your React Environment
- Customization
- Next Steps

Source: https://docs.crewai.com/en/enterprise/guides/react-component-export

Learn how to export and integrate CrewAI AMP React components into your applications

This guide explains how to export CrewAI AMP crews as React components and integrate them into your own applications.

## Exporting a React Component

<Steps>
  <Step title="Export the Component">
    Click on the ellipsis (three dots on the right of your deployed crew) and select the export option and save the file locally. We will be using `CrewLead.jsx` for our example.

<Frame>
      <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e0c72184b57eeae414674023197fca1b" alt="Export React Component" data-og-width="493" width="493" data-og-height="359" height="359" data-path="images/enterprise/export-react-component.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8493fbf39305d5f66dea0f19af860363 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=77698a5cf65d840dc81de4bd72bb4db1 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=fe2f4ee4cf620354f6413726983a33fb 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c817314a4164f7c55ecd424ab5de61cf 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6d982c3772ec31c866bcdcabaa8a6b5e 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=0b9e48143a23435526cf924906aac876 2500w" />
    </Frame>
  </Step>
</Steps>

## Setting Up Your React Environment

To run this React component locally, you'll need to set up a React development environment and integrate this component into a React project.

<Steps>
  <Step title="Install Node.js">
    * Download and install Node.js from the official website: [https://nodejs.org/](https://nodejs.org/)
    * Choose the LTS (Long Term Support) version for stability.
  </Step>

<Step title="Create a new React project">
    * Open Command Prompt or PowerShell
    * Navigate to the directory where you want to create your project
    * Run the following command to create a new React project:

* Change into the project directory:

<Step title="Install necessary dependencies">
    
  </Step>

<Step title="Create the CrewLead component">
    * Move the downloaded file `CrewLead.jsx` into the `src` folder of your project,
  </Step>

<Step title="Modify your App.js to use the CrewLead component">
    * Open `src/App.js`
    * Replace its contents with something like this:

* Replace `YOUR_API_BASE_URL` and `YOUR_BEARER_TOKEN` with the actual values for your API.
  </Step>

<Step title="Start the development server">
    * In your project directory, run:

* This will start the development server, and your default web browser should open automatically to [http://localhost:3000](http://localhost:3000), where you'll see your React app running.
  </Step>
</Steps>

You can then customise the `CrewLead.jsx` to add color, title etc

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4673fd3ac9eedc1c83b777afb8cf09c9" alt="Customise React Component" data-og-width="1119" width="1119" data-og-height="939" height="939" data-path="images/enterprise/customise-react-component.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=551606e5340b4eb48fa2ca617486ab17 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4861d2caa401af697527bbafe3cfdb8a 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=ce6d2304d336e487c9bfbd8e1fde5eaf 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1b2d7f443f10ff21f73e14ef42f91063 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=af6ddc00aa79e8b1606d74b587336a5d 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=997057d8f5ed2b15166ea3cec704a4f3 2500w" />
</Frame>

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=714c15d129b3db4bd96cdc55e80916dd" alt="Customise React Component" data-og-width="1058" width="1058" data-og-height="427" height="427" data-path="images/enterprise/customise-react-component-2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=5c589ec079cd09f29551136ee607d0a5 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=059851daaaf939d0a5bb2aa1598940cf 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3bad7a6f0f18aff57419ded53c398f15 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6753c201e535c8fcebd1d949436003c7 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=352df6d7283212880ef271a8fb673098 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=725cfe8688b8135dd25290296d787dbf 2500w" />
</Frame>

* Customize the component styling to match your application's design
* Add additional props for configuration
* Integrate with your application's state management
* Add error handling and loading states

**Examples:**

Example 1 (unknown):
```unknown
* Change into the project directory:
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Install necessary dependencies">
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="Create the CrewLead component">
    * Move the downloaded file `CrewLead.jsx` into the `src` folder of your project,
  </Step>

  <Step title="Modify your App.js to use the CrewLead component">
    * Open `src/App.js`
    * Replace its contents with something like this:
```

Example 4 (unknown):
```unknown
* Replace `YOUR_API_BASE_URL` and `YOUR_BEARER_TOKEN` with the actual values for your API.
  </Step>

  <Step title="Start the development server">
    * In your project directory, run:
```

---

## Scrape with markdown formatting (default)

**URL:** llms-txt#scrape-with-markdown-formatting-(default)

markdown_result = tool.run(
    url="https://docs.crewai.com",
    include_markdown=True
)

---

## Task 3

**URL:** llms-txt#task-3

**Contents:**
- Erros Comuns a Evitar
  - 1. Instruções de Tarefa Pouco Claras
  - 2. "Tarefas-Deus" Que Tentam Fazer Demais

visualization_task:
  description: "Create a visual representation of the analyzed trends."
  expected_output: "A description of a chart showing trends and their impact ratings."
yaml  theme={null}
analysis_task:
  description: >
    Analyze the customer feedback data from the CSV file.
    Focus on identifying recurring themes related to product usability.
    Consider sentiment and frequency when determining importance.
  expected_output: >
    A markdown report with the following sections:
    1. Executive summary (3-5 bullet points)
    2. Top 3 usability issues with supporting data
    3. Recommendations for improvement
yaml  theme={null}
competitor_analysis_task:
  description: >
    Analyze our three main competitors' pricing strategies.
    This analysis will inform our upcoming pricing model revision.
    Focus on identifying patterns in how they price premium features
    and how they structure their tiered offerings.
yaml  theme={null}
data_extraction_task:
  description: "Extract key metrics from the quarterly report."
  expected_output: "JSON object with the following keys: revenue, growth_rate, customer_acquisition_cost, and retention_rate."
yaml  theme={null}
research_task:
  description: "Research AI trends."
  expected_output: "A report on AI trends."
yaml  theme={null}
research_task:
  description: >
    Research the top emerging AI trends for 2024 with a focus on:
    1. Enterprise adoption patterns
    2. Technical breakthroughs in the past 6 months
    3. Regulatory developments affecting implementation

For each trend, identify key companies, technologies, and potential business impacts.
  expected_output: >
    A comprehensive markdown report with:
    - Executive summary (5 bullet points)
    - 5-7 major trends with supporting evidence
    - For each trend: definition, examples, and business implications
    - References to authoritative sources
yaml  theme={null}
comprehensive_task:
  description: "Research market trends, analyze competitor strategies, create a marketing plan, and design a launch timeline."
yaml  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### 2. Seja Explícito Sobre Entradas e Saídas

Sempre especifique claramente quais são as entradas da tarefa e como deve ser o resultado:

**Exemplo:**
```

Example 2 (unknown):
```unknown
#### 3. Inclua Propósito e Contexto

Explique por que a tarefa importa e como ela se encaixa no fluxo de trabalho maior:

**Exemplo:**
```

Example 3 (unknown):
```unknown
#### 4. Use Ferramentas de Saída Estruturada

Para saídas legíveis por máquina, especifique claramente o formato:

**Exemplo:**
```

Example 4 (unknown):
```unknown
## Erros Comuns a Evitar

Baseando-se em experiências de casos reais, estes são os erros mais comuns no design de agentes e tarefas:

### 1. Instruções de Tarefa Pouco Claras

**Problema:** Tarefas sem detalhes suficientes, dificultando a execução pelo agente.

**Exemplo de Design Ruim:**
```

---

## JSON RAG 검색

**URL:** llms-txt#json-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/jsonsearchtool

JSONSearchTool은 JSON 파일을 검색하여 가장 관련성 높은 결과를 반환하도록 설계되었습니다.

---

## Criar um mecanismo de consulta

**URL:** llms-txt#criar-um-mecanismo-de-consulta

query_engine = index.as_query_engine()

---

## Restringindo a busca a um arquivo JSON específico

**URL:** llms-txt#restringindo-a-busca-a-um-arquivo-json-específico

---

## Considerações de Segurança MCP

**URL:** llms-txt#considerações-de-segurança-mcp

**Contents:**
- Visão Geral
  - Riscos
  - 1. Confiando em Servidores MCP
  - 2. Prompt Injection Seguro via Metadados de Ferramentas: O Risco do "Model Control Protocol"
  - Segurança do Transporte Stdio
  - Ataques de Confused Deputy
  - Segurança no Transporte Remoto (SSE & HTTP Transmitível)
  - Considerações de Segurança SSE
  - a. Ataques de DNS Rebinding (Especialmente para SSE)
  - b. Use HTTPS

Source: https://docs.crewai.com/pt-BR/mcp/security

Saiba mais sobre as principais melhores práticas de segurança ao integrar servidores MCP com seus agentes CrewAI.

<Warning>
  O aspecto mais crítico da segurança MCP é a **confiança**. Você deve **apenas** conectar seus agentes CrewAI a servidores MCP nos quais confie plenamente.
</Warning>

Ao integrar serviços externos como servidores MCP (Model Context Protocol) aos seus agentes CrewAI, a segurança é fundamental.
Servidores MCP podem executar código, acessar dados ou interagir com outros sistemas com base nas ferramentas que expõem.
É crucial compreender as implicações e seguir as melhores práticas para proteger suas aplicações e dados.

* Executar código arbitrário na máquina onde o agente está rodando (especialmente com o transporte `Stdio` se o servidor puder controlar o comando executado).
* Expor dados sensíveis do seu agente ou do seu ambiente.
* Manipular o comportamento do seu agente de maneiras não intencionais, incluindo realizar chamadas de API não autorizadas em seu nome.
* Sequestrar o processo de raciocínio do agente através de técnicas sofisticadas de prompt injection (veja abaixo).

### 1. Confiando em Servidores MCP

<Warning>
  **Somente conecte-se a servidores MCP em que confie.**
</Warning>

Antes de configurar o `MCPServerAdapter` para conectar a um servidor MCP, certifique-se de saber:

* **Quem opera o servidor?** É um serviço conhecido, de reputação confiável, ou um servidor interno sob o seu controle?
* **Quais ferramentas ele expõe?** Entenda as capacidades das ferramentas. Elas poderiam ser mal utilizadas caso um invasor obtenha controle ou se o próprio servidor for malicioso?
* **Quais dados ele acessa ou processa?** Saiba se há informações sensíveis que possam ser enviadas ou manipuladas pelo servidor MCP.

Evite conectar-se a servidores MCP desconhecidos ou não verificados, especialmente se seus agentes lidam com tarefas ou dados sensíveis.

### 2. Prompt Injection Seguro via Metadados de Ferramentas: O Risco do "Model Control Protocol"

Um risco significativo e sutil é o potencial para prompt injection através dos metadados das ferramentas. Veja como funciona:

1. Quando seu agente CrewAI se conecta a um servidor MCP, ele normalmente solicita uma lista de ferramentas disponíveis.
2. O servidor MCP responde com metadados para cada ferramenta, incluindo nome, descrição e descrições de parâmetros.
3. O LLM (Modelo de Linguagem) subjacente do seu agente usa esses metadados para entender como e quando usar as ferramentas. Muitas vezes esses metadados são incorporados no system prompt ou contexto do LLM.
4. Um servidor MCP malicioso pode construir seus metadados (nomes, descrições) para incluir instruções ocultas ou explícitas. Essas instruções podem atuar como prompt injection, efetivamente fazendo o LLM se comportar de determinada maneira, revelar informações sensíveis ou executar ações maliciosas.

**Crucialmente, esse ataque pode ocorrer simplesmente ao conectar-se a um servidor malicioso e listar suas ferramentas, mesmo que seu agente nunca decida *usar* essas ferramentas.** A mera exposição aos metadados maliciosos pode ser suficiente para comprometer o comportamento do agente.

* **Extrema Cautela com Servidores Não Confiáveis:** Reitere: *Não conecte-se a servidores MCP nos quais você não confie totalmente.* O risco de injection de metadados torna isso fundamental.

### Segurança do Transporte Stdio

O transporte Stdio (Entrada/Saída Padrão) é tipicamente usado para servidores MCP locais, rodando na mesma máquina que sua aplicação CrewAI.

* **Isolamento de Processo**: Embora geralmente seja mais seguro pois não envolve exposição de rede por padrão, assegure-se de que o script ou comando executado pelo `StdioServerParameters` é de uma fonte confiável e possui permissões de sistema de arquivos adequadas. Um script Stdio servidor malicioso pode ainda prejudicar seu sistema local.
* **Saneamento de Entrada**: Se o seu script de servidor Stdio recebe entradas complexas derivadas das interações do agente, garanta que o script saneie essas entradas para evitar injection de comandos ou outras vulnerabilidades na lógica do script.
* **Limite de Recursos**: Esteja atento ao fato de que o processo servidor Stdio consome recursos locais (CPU, memória). Assegure-se de que seja bem comportado, evitando esgotar os recursos do sistema.

### Ataques de Confused Deputy

O [Problema do Confused Deputy](https://en.wikipedia.org/wiki/Confused_deputy_problem) é uma vulnerabilidade clássica de segurança que pode se manifestar em integrações MCP, especialmente quando um servidor MCP atua como proxy para outros serviços de terceiros (ex: Google Calendar, GitHub) que usam OAuth 2.0 para autorização.

1. Um servidor MCP (vamos chamá-lo de `MCP-Proxy`) permite que seu agente interaja com o `ThirdPartyAPI`.
2. O `MCP-Proxy` usa seu próprio `client_id` estático ao comunicar-se com o servidor de autorização do `ThirdPartyAPI`.
3. Você, como usuário, autoriza legitimamente o `MCP-Proxy` a acessar o `ThirdPartyAPI` em seu nome. Durante esse processo, o servidor de autenticação pode definir um cookie no seu navegador indicando seu consentimento para o `client_id` do `MCP-Proxy`.
4. Um invasor cria um link malicioso. Esse link inicia um fluxo OAuth com o `MCP-Proxy`, mas é projetado para enganar o servidor de autenticação do `ThirdPartyAPI`.
5. Se você clicar nesse link e o servidor de autenticação do `ThirdPartyAPI` encontrar seu cookie de consentimento existente para o `client_id` do `MCP-Proxy`, pode *deixar de* pedir seu consentimento novamente.
6. O `MCP-Proxy` pode, então, ser enganado a encaminhar um código de autorização (para o `ThirdPartyAPI`) para o atacante, ou um código de autorização MCP que o atacante possa usar para se passar por você perante o `MCP-Proxy`.

**Mitigação (Principalmente para Desenvolvedores de Servidores MCP):**

* Servidores proxy MCP usando IDs de cliente estáticos para serviços downstream **devem** obter consentimento explícito do usuário para *cada aplicação cliente ou agente* conectando-se a eles *antes* de iniciar um fluxo OAuth com o serviço de terceiros. Isso significa que o `MCP-Proxy` deve exibir uma tela de consentimento.

**Implicação para Usuários CrewAI:**

* Fique atento se um servidor MCP redireciona você para múltiplas autenticações OAuth, especialmente se isso for inesperado ou se as permissões solicitadas forem muito amplas.
* Prefira servidores MCP que deixem clara sua própria identidade e a identidade dos serviços de terceiros que possam fazer proxy.

### Segurança no Transporte Remoto (SSE & HTTP Transmitível)

Ao conectar-se a servidores MCP remotos via Server-Sent Events (SSE) ou HTTP transmitível, práticas padrão de segurança web são essenciais.

### Considerações de Segurança SSE

### a. Ataques de DNS Rebinding (Especialmente para SSE)

<Critical>
  **Proteja-se contra ataques de DNS Rebinding.**
</Critical>

DNS rebinding permite que um site controlado por atacante contorne a política de mesma origem e faça requisições para servidores na rede local do usuário (ex: `localhost`) ou intranet. Isso é particularmente arriscado se você roda um servidor MCP localmente (ex: para desenvolvimento) e um agente em um ambiente do tipo navegador (embora menos comum no backend CrewAI) ou se o servidor MCP está em uma rede interna.

**Estratégias de Mitigação para Implementadores de Servidores MCP:**

* **Valide os Headers `Origin` e `Host`**: Servidores MCP (especialmente com SSE) devem validar os headers HTTP `Origin` e/ou `Host` para garantir que as requisições venham dos domínios/clientes esperados.
* **Ligue em `localhost` (127.0.0.1)**: Ao rodar servidores MCP localmente para desenvolvimento, conecte-se a `127.0.0.1` em vez de `0.0.0.0`. Isso impede que sejam acessíveis por outras máquinas na rede.
* **Autenticação**: Exija autenticação para todas as conexões ao seu servidor MCP caso não seja destinado a acesso público anônimo.

* **Criptografe Dados em Trânsito**: Sempre use HTTPS (HTTP Seguro) para URLs de servidores MCP remotos. Isso criptografa a comunicação entre sua aplicação CrewAI e o servidor MCP, protegendo contra escuta e ataques Man-in-the-Middle (MitM). O `MCPServerAdapter` respeitará o esquema (`http` ou `https`) fornecido na URL.

### c. Token Passthrough (Anti-Padrão)

Isso é uma preocupação principalmente para desenvolvedores de servidores MCP, mas entender o conceito ajuda a escolher servidores seguros.

"Token passthrough" é quando um servidor MCP aceita um token de acesso do seu agente CrewAI (que pode ser um token para um serviço *diferente*, por exemplo, `ServiceA`) e simplesmente o repassa para outra API ( `ServiceB`) downstream sem validação adequada. Especificamente, `ServiceB` (ou o próprio servidor MCP) só deveria aceitar tokens explicitamente emitidos *para eles* (ou seja, o claim 'audience' no token deve corresponder ao servidor/serviço).

* Burlar controles de segurança (como limites de taxa ou permissões granulares) no servidor MCP ou na API downstream.
* Quebra trilhas de auditoria e responsabilização.
* Permite uso indevido de tokens roubados.

**Mitigação (Para Desenvolvedores de Servidores MCP):**

* Servidores MCP **NÃO DEVEM** aceitar tokens que não foram explicitamente emitidos para eles. Devem validar o claim de audiência dos tokens.

**Implicação para Usuários CrewAI:**

* Embora isso não seja diretamente controlável pelo usuário, destaca a importância de conectar-se a servidores MCP bem projetados e que sigam as melhores práticas de segurança.

#### Autenticação e Autorização

* **Verifique a Identidade**: Se o servidor MCP fornece ferramentas sensíveis ou acesso a dados privados, ele DEVE implementar mecanismos de autenticação robustos para verificar a identidade do cliente (sua aplicação CrewAI). Isso pode envolver chaves de API, tokens OAuth ou outros métodos padrão.
* **Princípio do Menor Privilégio**: Certifique-se de que as credenciais usadas pelo `MCPServerAdapter` (se houver) tenham apenas as permissões necessárias para acessar as ferramentas requeridas.

### d. Validação e Saneamento de Entrada

* **Validação de Entrada é Crítica**: Servidores MCP **devem** validar rigorosamente todas as entradas recebidas de agentes *antes* de processá-las ou passá-las para as ferramentas. Esta é a principal defesa contra diversas vulnerabilidades comuns:
  * **Injection de Comando:** Caso uma ferramenta construa comandos de shell, queries SQL ou outras instruções de linguagens interpretadas a partir da entrada, o servidor deve sanitizar cuidadosamente esta entrada para evitar que comandos maliciosos sejam injetados e executados.
  * **Path Traversal:** Se uma ferramenta acessa arquivos com base em parâmetros de entrada, o servidor deve validar e sanitizar esses caminhos para evitar acesso a arquivos ou diretórios não autorizados (por exemplo, bloqueando sequências `../`).
  * **Verificações de Tipo e Faixa de Dados:** Servidores devem garantir que os dados de entrada estejam nos tipos esperados (ex: string, número, booleano) e dentro de faixas aceitáveis ou em formatos definidos (ex: regex para URLs).
  * **Validação de Schema JSON:** Todos os parâmetros das ferramentas devem ser validados estritamente com seus esquemas JSON definidos. Isso ajuda a capturar requisições mal formatadas precocemente.
* **Atenção do Lado do Cliente**: Embora a validação no servidor seja fundamental, como usuário CrewAI, fique atento aos dados que seus agentes são configurados para enviar a ferramentas MCP, especialmente ao interagir com servidores MCP novos ou menos confiáveis.

### e. Limite de Taxa e Gerenciamento de Recursos

* **Previna Abusos**: Servidores MCP devem implementar limite de taxa para prevenir abusos, seja intencional (ataques de negação de serviço) ou não intencional (ex: um agente mal configurado fazendo muitas requisições).
* **Re-tentativas do Lado do Cliente**: Implemente lógica de repetição sensata em suas tarefas CrewAI se problemas de rede transitórios ou limites de taxa do servidor forem esperados, mas evite re-tentativas agressivas que possam aumentar a carga do servidor.

## 4. Conselhos para Implementação de Servidor MCP Seguro (Para Desenvolvedores)

Se você está desenvolvendo um servidor MCP ao qual agentes CrewAI possam se conectar, considere estas melhores práticas além dos pontos acima:

* **Siga Práticas de Código Seguro**: Adote princípios padrão de programação segura para sua linguagem e framework escolhidos (ex: OWASP Top 10).
* **Princípio do Menor Privilégio**: Certifique-se de que o processo que executa o servidor MCP (especialmente para `Stdio`) tenha apenas as permissões mínimas necessárias. As próprias ferramentas também devem operar com o mínimo de privilégio necessário para executar sua função.
* **Gerenciamento de Dependências**: Mantenha todas as dependências do lado do servidor, incluindo pacotes do sistema operacional, runtimes de linguagem e bibliotecas de terceiros, sempre atualizadas para corrigir vulnerabilidades conhecidas. Use ferramentas para escanear por dependências vulneráveis.
* **Padrões Seguros por Padrão**: Projete seu servidor e suas ferramentas para serem seguros por padrão. Por exemplo, recursos potencialmente arriscados devem ser desabilitados por padrão ou requerer ativação explícita, com avisos claros.
* **Controle de Acesso para Ferramentas**: Implemente mecanismos robustos para controlar quais agentes ou usuários autenticados e autorizados podem acessar ferramentas específicas, especialmente as que são poderosas, sensíveis ou incorram em custos.
* **Tratamento Seguro de Erros**: Servidores não devem expor mensagens detalhadas de erro interno, traces de stack ou informações de debug para o cliente, pois estas podem revelar detalhes internos ou potenciais vulnerabilidades. Logue os erros de forma abrangente no lado do servidor para diagnóstico.
* **Log e Monitoramento Abrangentes**: Implemente um log detalhado de eventos relevantes para segurança (ex: tentativas de autenticação, invocações de ferramenta, erros, mudanças de autorização). Monitore esses logs em busca de atividades suspeitas ou padrões de abuso.
* **Aderência à Especificação de Autorização MCP**: Caso implemente autenticação e autorização, siga estritamente a [especificação de autorização MCP](https://modelcontextprotocol.io/specification/draft/basic/authorization) e as [melhores práticas de segurança OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc9700) relevantes.
* **Auditorias de Segurança Regulares**: Caso seu servidor MCP manipule dados sensíveis, realize operações críticas ou seja exposto publicamente, considere auditorias de segurança periódicas conduzidas por profissionais qualificados.

## 5. Leituras Adicionais

Para informações mais detalhadas sobre segurança MCP, consulte a documentação oficial:

* **[Segurança de Transporte MCP](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations)**

Ao entender essas considerações de segurança e implementar as melhores práticas, você pode aproveitar com segurança o poder dos servidores MCP em seus projetos CrewAI.
Estes pontos não esgotam o assunto, mas cobrem as questões de segurança mais comuns e críticas.
As ameaças continuarão a evoluir, por isso é importante se manter informado e adaptar suas medidas de segurança de acordo.

---

## Microsoft Word 통합

**URL:** llms-txt#microsoft-word-통합

**Contents:**
- 개요
- 전제 조건
- Microsoft Word 통합 설정
  - 1. Microsoft 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Microsoft Word 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/microsoft_word

CrewAI를 위한 Microsoft Word 통합으로 문서 생성 및 관리.

에이전트가 OneDrive 또는 SharePoint에서 Word 문서와 텍스트 파일을 생성, 읽기 및 관리할 수 있도록 합니다. AI 기반 자동화로 문서 생성을 자동화하고, 콘텐츠를 검색하고, 문서 속성을 관리하며, 문서 워크플로를 간소화합니다.

Microsoft Word 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Word 및 OneDrive/SharePoint 액세스 권한이 있는 Microsoft 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Microsoft 계정 연결

## Microsoft Word 통합 설정

### 1. Microsoft 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Microsoft Word** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 파일 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="microsoft_word/get_documents">
    **설명:** OneDrive 또는 SharePoint에서 모든 Word 문서를 가져옵니다.

* `select` (string, 선택사항): 반환할 특정 속성 선택.
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬.
  </Accordion>

<Accordion title="microsoft_word/create_text_document">
    **설명:** 내용이 있는 텍스트 문서(.txt)를 만듭니다. 읽기 가능하고 편집 가능해야 하는 프로그래밍 방식 콘텐츠 생성에 권장됩니다.

* `file_name` (string, 필수): 텍스트 문서의 이름 (.txt로 끝나야 함).
    * `content` (string, 선택사항): 문서의 텍스트 내용. 기본값: "API를 통해 생성된 새 텍스트 문서입니다."
  </Accordion>

<Accordion title="microsoft_word/get_document_content">
    **설명:** 문서의 내용을 가져옵니다 (텍스트 파일에서 가장 잘 작동).

* `file_id` (string, 필수): 문서의 ID.
  </Accordion>

<Accordion title="microsoft_word/get_document_properties">
    **설명:** 문서의 속성과 메타데이터를 가져옵니다.

* `file_id` (string, 필수): 문서의 ID.
  </Accordion>

<Accordion title="microsoft_word/delete_document">
    **설명:** 문서를 삭제합니다.

* `file_id` (string, 필수): 삭제할 문서의 ID.
  </Accordion>
</AccordionGroup>

### 기본 Microsoft Word 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="microsoft_word/get_documents">
    **설명:** OneDrive 또는 SharePoint에서 모든 Word 문서를 가져옵니다.

    **매개변수:**

    * `select` (string, 선택사항): 반환할 특정 속성 선택.
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬.
  </Accordion>

  <Accordion title="microsoft_word/create_text_document">
    **설명:** 내용이 있는 텍스트 문서(.txt)를 만듭니다. 읽기 가능하고 편집 가능해야 하는 프로그래밍 방식 콘텐츠 생성에 권장됩니다.

    **매개변수:**

    * `file_name` (string, 필수): 텍스트 문서의 이름 (.txt로 끝나야 함).
    * `content` (string, 선택사항): 문서의 텍스트 내용. 기본값: "API를 통해 생성된 새 텍스트 문서입니다."
  </Accordion>

  <Accordion title="microsoft_word/get_document_content">
    **설명:** 문서의 내용을 가져옵니다 (텍스트 파일에서 가장 잘 작동).

    **매개변수:**

    * `file_id` (string, 필수): 문서의 ID.
  </Accordion>

  <Accordion title="microsoft_word/get_document_properties">
    **설명:** 문서의 속성과 메타데이터를 가져옵니다.

    **매개변수:**

    * `file_id` (string, 필수): 문서의 ID.
  </Accordion>

  <Accordion title="microsoft_word/delete_document">
    **설명:** 문서를 삭제합니다.

    **매개변수:**

    * `file_id` (string, 필수): 삭제할 문서의 ID.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Microsoft Word 에이전트 설정
```

---

## Envie atualizações após alterações no código

**URL:** llms-txt#envie-atualizações-após-alterações-no-código

---

## scrape_config={

**URL:** llms-txt#scrape_config={

---

## Code Docs RAG Search

**URL:** llms-txt#code-docs-rag-search

Source: https://docs.crewai.com/en/tools/search-research/codedocssearchtool

The `CodeDocsSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within code documentation.

---

## Integração com o Linear

**URL:** llms-txt#integração-com-o-linear

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o Linear
  - 1. Conecte sua Conta Linear
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Linear

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/linear

Acompanhamento de projetos de software e rastreamento de bugs com a integração Linear para CrewAI.

Permita que seus agentes gerenciem issues, projetos e fluxos de trabalho de desenvolvimento através do Linear. Crie e atualize issues, gerencie cronogramas de projetos, organize equipes e otimize seu processo de desenvolvimento de software com automação impulsionada por IA.

Antes de utilizar a integração com o Linear, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com uma assinatura ativa
* Uma conta Linear com permissões apropriadas no workspace
* Conectou sua conta Linear através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com o Linear

### 1. Conecte sua Conta Linear

1. Navegue até [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Linear** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de issues e projetos
5. Copie seu Token Empresarial em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="linear/create_issue">
    **Descrição:** Crie uma nova issue no Linear.

* `teamId` (string, obrigatório): ID da Equipe - Especifique o ID da equipe responsável para esta nova issue. Use as Configurações de Fluxo do Connect Portal para permitir que usuários escolham um ID de Equipe. (exemplo: "a70bdf0f-530a-4887-857d-46151b52b47c").
    * `title` (string, obrigatório): Título - Especifique um título para esta issue.
    * `description` (string, opcional): Descrição - Especifique uma descrição para esta issue.
    * `statusId` (string, opcional): Status - Especifique o status desta issue.
    * `priority` (string, opcional): Prioridade - Especifique a prioridade desta issue como um inteiro.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique a data de vencimento desta issue no formato ISO 8601.
    * `cycleId` (string, opcional): ID do Ciclo - Especifique o ciclo associado a esta issue.
    * `additionalFields` (object, opcional): Campos Adicionais.
      
  </Accordion>

<Accordion title="linear/update_issue">
    **Descrição:** Atualize uma issue no Linear.

* `issueId` (string, obrigatório): ID da Issue - Especifique o ID da issue a ser atualizada. (exemplo: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
    * `title` (string, opcional): Título - Especifique um título para esta issue.
    * `description` (string, opcional): Descrição - Especifique uma descrição para esta issue.
    * `statusId` (string, opcional): Status - Especifique o status desta issue.
    * `priority` (string, opcional): Prioridade - Especifique a prioridade desta issue como um inteiro.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique a data de vencimento desta issue no formato ISO 8601.
    * `cycleId` (string, opcional): ID do Ciclo - Especifique o ciclo associado a esta issue.
    * `additionalFields` (object, opcional): Campos Adicionais.
      
  </Accordion>

<Accordion title="linear/get_issue_by_id">
    **Descrição:** Obtenha uma issue pelo ID no Linear.

* `issueId` (string, obrigatório): ID da Issue - Especifique o ID do registro da issue a ser buscada. (exemplo: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
  </Accordion>

<Accordion title="linear/get_issue_by_issue_identifier">
    **Descrição:** Obtenha uma issue através do identificador da issue no Linear.

* `externalId` (string, obrigatório): ID Externo - Especifique o identificador legível da issue a ser buscada. (exemplo: "ABC-1").
  </Accordion>

<Accordion title="linear/search_issue">
    **Descrição:** Pesquise issues no Linear.

* `queryTerm` (string, obrigatório): Termo de Pesquisa - O termo a ser localizado na busca.
    * `issueFilterFormula` (object, opcional): Um filtro na forma normal disjuntiva – OU de grupos E de condições únicas.
      
      Campos disponíveis: `title`, `number`, `project`, `createdAt`
      Operadores disponíveis: `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringIsIn`, `$stringIsNotIn`, `$stringStartsWith`, `$stringDoesNotStartWith`, `$stringEndsWith`, `$stringDoesNotEndWith`, `$stringContains`, `$stringDoesNotContain`, `$stringGreaterThan`, `$stringLessThan`, `$numberGreaterThanOrEqualTo`, `$numberLessThanOrEqualTo`, `$numberGreaterThan`, `$numberLessThan`, `$dateTimeAfter`, `$dateTimeBefore`
  </Accordion>

<Accordion title="linear/delete_issue">
    **Descrição:** Exclua uma issue no Linear.

* `issueId` (string, obrigatório): ID da Issue - Especifique o ID do registro da issue a ser excluída. (exemplo: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
  </Accordion>

<Accordion title="linear/archive_issue">
    **Descrição:** Arquive uma issue no Linear.

* `issueId` (string, obrigatório): ID da Issue - Especifique o ID do registro da issue a ser arquivada. (exemplo: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
  </Accordion>

<Accordion title="linear/create_sub_issue">
    **Descrição:** Crie uma sub-issue no Linear.

* `parentId` (string, obrigatório): ID do Pai - Especifique o ID da issue pai desta nova issue.
    * `teamId` (string, obrigatório): ID da Equipe - Especifique o ID da equipe responsável pela nova sub-issue. Use as Configurações de Fluxo do Connect Portal para permitir que usuários escolham um ID de Equipe. (exemplo: "a70bdf0f-530a-4887-857d-46151b52b47c").
    * `title` (string, obrigatório): Título - Especifique um título para esta issue.
    * `description` (string, opcional): Descrição - Especifique uma descrição para esta issue.
    * `additionalFields` (object, opcional): Campos Adicionais.
      
  </Accordion>

<Accordion title="linear/create_project">
    **Descrição:** Crie um novo projeto no Linear.

* `teamIds` (object, obrigatório): ID da Equipe - Especifique o(s) ID(s) da equipe associada a este projeto como string ou array JSON. Use as Configurações de Usuário do Connect Portal para que seu usuário selecione um ID de Equipe.
      
    * `projectName` (string, obrigatório): Nome do Projeto - Especifique o nome do projeto. (exemplo: "Meu Projeto Linear").
    * `description` (string, opcional): Descrição do Projeto - Especifique uma descrição para este projeto.
    * `additionalFields` (object, opcional): Campos Adicionais.
      
  </Accordion>

<Accordion title="linear/update_project">
    **Descrição:** Atualize um projeto no Linear.

* `projectId` (string, obrigatório): ID do Projeto - Especifique o ID do projeto a ser atualizado. (exemplo: "a6634484-6061-4ac7-9739-7dc5e52c796b").
    * `projectName` (string, opcional): Nome do Projeto - Especifique o nome do projeto a ser atualizado. (exemplo: "Meu Projeto Linear").
    * `description` (string, opcional): Descrição do Projeto - Especifique uma descrição para este projeto.
    * `additionalFields` (object, opcional): Campos Adicionais.
      
  </Accordion>

<Accordion title="linear/get_project_by_id">
    **Descrição:** Obtenha um projeto pelo ID no Linear.

* `projectId` (string, obrigatório): ID do Projeto - Especifique o ID do projeto a ser buscado. (exemplo: "a6634484-6061-4ac7-9739-7dc5e52c796b").
  </Accordion>

<Accordion title="linear/delete_project">
    **Descrição:** Exclua um projeto no Linear.

* `projectId` (string, obrigatório): ID do Projeto - Especifique o ID do projeto a ser excluído. (exemplo: "a6634484-6061-4ac7-9739-7dc5e52c796b").
  </Accordion>

<Accordion title="linear/search_teams">
    **Descrição:** Pesquise equipes no Linear.

* `teamFilterFormula` (object, opcional): Um filtro na forma normal disjuntiva – OU de grupos E de condições únicas.
      
      Campos disponíveis: `id`, `name`
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Linear

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="linear/create_issue">
    **Descrição:** Crie uma nova issue no Linear.

    **Parâmetros:**

    * `teamId` (string, obrigatório): ID da Equipe - Especifique o ID da equipe responsável para esta nova issue. Use as Configurações de Fluxo do Connect Portal para permitir que usuários escolham um ID de Equipe. (exemplo: "a70bdf0f-530a-4887-857d-46151b52b47c").
    * `title` (string, obrigatório): Título - Especifique um título para esta issue.
    * `description` (string, opcional): Descrição - Especifique uma descrição para esta issue.
    * `statusId` (string, opcional): Status - Especifique o status desta issue.
    * `priority` (string, opcional): Prioridade - Especifique a prioridade desta issue como um inteiro.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique a data de vencimento desta issue no formato ISO 8601.
    * `cycleId` (string, opcional): ID do Ciclo - Especifique o ciclo associado a esta issue.
    * `additionalFields` (object, opcional): Campos Adicionais.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="linear/update_issue">
    **Descrição:** Atualize uma issue no Linear.

    **Parâmetros:**

    * `issueId` (string, obrigatório): ID da Issue - Especifique o ID da issue a ser atualizada. (exemplo: "90fbc706-18cd-42c9-ae66-6bd344cc8977").
    * `title` (string, opcional): Título - Especifique um título para esta issue.
    * `description` (string, opcional): Descrição - Especifique uma descrição para esta issue.
    * `statusId` (string, opcional): Status - Especifique o status desta issue.
    * `priority` (string, opcional): Prioridade - Especifique a prioridade desta issue como um inteiro.
    * `dueDate` (string, opcional): Data de Vencimento - Especifique a data de vencimento desta issue no formato ISO 8601.
    * `cycleId` (string, opcional): ID do Ciclo - Especifique o ciclo associado a esta issue.
    * `additionalFields` (object, opcional): Campos Adicionais.
```

---

## MDX RAG 검색

**URL:** llms-txt#mdx-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/mdxsearchtool

MDXSearchTool은 MDX 파일을 검색하고 가장 관련성 높은 결과를 반환하도록 설계되었습니다.

---

## Title: Potential use of chat gpt in global warming

**URL:** llms-txt#title:-potential-use-of-chat-gpt-in-global-warming

---

## 좋음 - 필요한 도구만 가져오기

**URL:** llms-txt#좋음---필요한-도구만-가져오기

mcps=["https://weather.api.com/mcp#get_forecast"]

---

## Example task to query sales data

**URL:** llms-txt#example-task-to-query-sales-data

query_task = Task(
    description="Query the sales data for the last quarter and summarize the top 5 products by revenue.",
    expected_output="A summary of the top 5 products by revenue for the last quarter.",
    agent=data_analyst_agent,
)

---

## que o agente aprender durante sua execução

**URL:** llms-txt#que-o-agente-aprender-durante-sua-execução

tool = TXTSearchTool()

---

## ✅ Bom: papéis específicos e complementares

**URL:** llms-txt#✅-bom:-papéis-específicos-e-complementares

researcher = Agent(role="Market Research Analyst", ...)
writer = Agent(role="Technical Content Writer", ...)

---

## Configure LLMs com diferentes provedores

**URL:** llms-txt#configure-llms-com-diferentes-provedores

openai_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY"
    )
)

anthropic_llm = LLM(
    model="claude-3-5-sonnet-latest",
    max_tokens=1000,
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_ANTHROPIC_VIRTUAL_KEY"
    )
)

---

## 연결 확인

**URL:** llms-txt#연결-확인

**Contents:**
  - 3단계: OpenLit 초기화
  - 4단계: 간단한 CrewAI 애플리케이션 만들기
  - 5단계: Langfuse에서 트레이스 확인하기
- 참고 자료

if langfuse.auth_check():
    print("Langfuse 클라이언트가 인증되었으며 준비되었습니다!")
else:
    print("인증에 실패했습니다. 자격 증명과 호스트를 확인하세요.")
python  theme={null}
import openlit

openlit.init()
python  theme={null}
from crewai import Agent, Task, Crew

from crewai_tools import (
    WebsiteSearchTool
)

web_rag_tool = WebsiteSearchTool()

writer = Agent(
        role="Writer",
        goal="You make math engaging and understandable for young children through poetry",
        backstory="You're an expert in writing haikus but you know nothing of math.",
        tools=[web_rag_tool],  
    )

task = Task(description=("What is {multiplication}?"),
            expected_output=("Compose a haiku that includes the answer."),
            agent=writer)

crew = Crew(
  agents=[writer],
  tasks=[task],
  share_crew=False
)
```

### 5단계: Langfuse에서 트레이스 확인하기

에이전트를 실행한 후 [Langfuse](https://cloud.langfuse.com)에서 CrewAI 애플리케이션에서 생성된 트레이스를 확인할 수 있습니다. 여기서 LLM 상호작용의 자세한 단계들을 볼 수 있으며, 이를 통해 AI 에이전트의 디버깅 및 최적화에 도움이 됩니다.

![Langfuse의 CrewAI 예시 트레이스](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png)

*[Langfuse의 공개 예시 트레이스](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\&observation=3b32338ee6a5d9af)*

* [Langfuse OpenTelemetry 문서](https://langfuse.com/docs/opentelemetry/get-started)

**Examples:**

Example 1 (unknown):
```unknown
### 3단계: OpenLit 초기화

OpenLit OpenTelemetry 계측 SDK를 초기화하여 OpenTelemetry 추적을 수집하기 시작합니다.
```

Example 2 (unknown):
```unknown
### 4단계: 간단한 CrewAI 애플리케이션 만들기

여러 에이전트가 협력하여 사용자의 질문에 답하는 간단한 CrewAI 애플리케이션을 만들어보겠습니다.
```

---

## Para instalações personalizadas do Ollama

**URL:** llms-txt#para-instalações-personalizadas-do-ollama

**Contents:**
  - Cohere Embeddings
  - VoyageAI Embeddings
  - AWS Bedrock Embeddings
  - Hugging Face Embeddings
  - IBM Watson Embeddings
  - Como Escolher o Provedor de Embedding Certo
  - Configuração via Variável de Ambiente

crew = Crew(
    memory=True,
    embedder={
        "provider": "ollama",
        "config": {
            "model": "mxbai-embed-large",
            "url": "http://your-ollama-server:11434/api/embeddings"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "cohere",
        "config": {
            "api_key": "your-cohere-api-key",
            "model": "embed-english-v3.0"  # ou "embed-multilingual-v3.0"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "voyageai",
        "config": {
            "api_key": "your-voyage-api-key",
            "model": "voyage-large-2",  # ou "voyage-code-2" para código
            "input_type": "document"  # ou "query"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "bedrock",
        "config": {
            "aws_access_key_id": "your-access-key",
            "aws_secret_access_key": "your-secret-key",
            "region_name": "us-east-1",
            "model": "amazon.titan-embed-text-v1"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "huggingface",
        "config": {
            "api_key": "your-hf-token",  # Opcional para modelos públicos
            "model": "sentence-transformers/all-MiniLM-L6-v2",
            "api_url": "https://api-inference.huggingface.co"  # ou seu endpoint customizado
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "watson",
        "config": {
            "api_key": "your-watson-api-key",
            "url": "your-watson-instance-url",
            "model": "ibm/slate-125m-english-rtrvr"
        }
    }
)
python  theme={null}
import os

**Examples:**

Example 1 (unknown):
```unknown
### Cohere Embeddings

Utilize os modelos de embedding da Cohere para suporte multilíngue.
```

Example 2 (unknown):
```unknown
### VoyageAI Embeddings

Embeddings de alto desempenho otimizados para tarefas de recuperação.
```

Example 3 (unknown):
```unknown
### AWS Bedrock Embeddings

Para usuários AWS com acesso ao Bedrock.
```

Example 4 (unknown):
```unknown
### Hugging Face Embeddings

Utilize modelos open-source do Hugging Face.
```

---

## Task to create a new text document

**URL:** llms-txt#task-to-create-a-new-text-document

create_doc_task = Task(
    description="Create a new text document named 'meeting_notes.txt' with content 'Meeting Notes from January 2024: Key discussion points and action items.'",
    agent=word_agent,
    expected_output="New text document 'meeting_notes.txt' created successfully."
)

---

## Extract all product information

**URL:** llms-txt#extract-all-product-information

result = stagehand_tool.run(
    instruction="Extract all product names, prices, and descriptions", 
    url="https://example.com/products",
    command_type="extract"
)

---

## Extract specific information with a selector

**URL:** llms-txt#extract-specific-information-with-a-selector

**Contents:**
  - 3. Comando Observe

result = stagehand_tool.run(
    instruction="Extract the main article title and content", 
    url="https://example.com/blog/article",
    command_type="extract",
    selector=".article-container"  # Optional CSS selector
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 3. Comando Observe

O tipo de comando `observe` identifica e analisa elementos da página web.
```

---

## `DallETool`

**URL:** llms-txt#`dalletool`

**Contents:**
- Descrição
- Instalação
- Exemplo

Esta ferramenta é utilizada para dar ao Agente a capacidade de gerar imagens usando o modelo DALL-E. Trata-se de um modelo baseado em transformer que gera imagens a partir de descrições textuais.
Esta ferramenta permite que o Agente gere imagens com base no texto de entrada fornecido pelo usuário.

Instale o pacote crewai\_tools

Lembre-se de que, ao usar esta ferramenta, o texto deve ser gerado pelo próprio Agente. O texto deve ser uma descrição da imagem que você deseja gerar.

Se necessário, você também pode ajustar os parâmetros do modelo DALL-E passando-os como argumentos para a classe `DallETool`. Por exemplo:

Os parâmetros são baseados no método `client.images.generate` da API OpenAI. Para mais informações sobre os parâmetros,
consulte a [documentação da API OpenAI](https://platform.openai.com/docs/guides/images/introduction?lang=python).

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Lembre-se de que, ao usar esta ferramenta, o texto deve ser gerado pelo próprio Agente. O texto deve ser uma descrição da imagem que você deseja gerar.
```

Example 2 (unknown):
```unknown
Se necessário, você também pode ajustar os parâmetros do modelo DALL-E passando-os como argumentos para a classe `DallETool`. Por exemplo:
```

---

## Uso

**URL:** llms-txt#uso

**Contents:**
- Criando Diretórios ao Salvar Arquivos
  - Comportamento Padrão

task = Task(
    description="Obtenha informações de contato do usuário",
    expected_output="E-mail e telefone",
    guardrail=chain_validations(
        validate_email_format,
        filter_sensitive_info
    )
)
python Code theme={null}
task = Task(
    description="Gerar dados",
    expected_output="Dados válidos",
    guardrail=validate_data,
    guardrail_max_retries=5  # Sobrescreve o limite padrão de tentativas
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### Lógica Customizada de Retentativas
```

Example 2 (unknown):
```unknown
## Criando Diretórios ao Salvar Arquivos

O parâmetro `create_directory` controla se o CrewAI deve criar automaticamente diretórios ao salvar saídas de tarefas em arquivos. Este recurso é particularmente útil para organizar outputs e garantir que os caminhos de arquivos estejam estruturados corretamente, especialmente ao trabalhar com hierarquias de projetos complexas.

### Comportamento Padrão

Por padrão, `create_directory=True`, o que significa que o CrewAI criará automaticamente qualquer diretório ausente no caminho do arquivo de saída:
```

---

## Para focar sua busca especificamente em um site de documentação

**URL:** llms-txt#para-focar-sua-busca-especificamente-em-um-site-de-documentação

---

## Inicialize a ferramenta com um arquivo de texto específico,

**URL:** llms-txt#inicialize-a-ferramenta-com-um-arquivo-de-texto-específico,

---

## (O código não é traduzido)

**URL:** llms-txt#(o-código-não-é-traduzido)

**Contents:**
  - Entendendo o Plot
  - Conclusão
- Próximos Passos
- Executando Flows
  - Usando a API do Flow

bash  theme={null}
crewai flow plot
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
Esse comando gera um arquivo chamado `my_flow_plot.html` no diretório atual. Abra esse arquivo em um navegador para visualizar o plot interativo.

#### Opção 2: Usando a Linha de Comando

Em projetos CrewAI estruturados, é possível gerar um plot pela linha de comando. Isso é útil para projetos maiores, onde você deseja visualizar toda a configuração do flow.
```

Example 2 (unknown):
```unknown
O comando gera um arquivo HTML com o plot do flow, semelhante ao método `plot()`. Basta abrir o arquivo no navegador para explorar o workflow.

### Entendendo o Plot

O plot gerado mostra nós representando as tarefas do seu flow, com setas indicando o fluxo de execução. A visualização é interativa, permitindo zoom, navegação e detalhes ao passar o mouse nos nós.

Ao visualizar seus flows, você tem clareza do formato do workflow, facilitando debug, otimização e comunicação dos seus processos de IA para outras pessoas.

### Conclusão

A plotagem dos flows é um recurso poderoso do CrewAI para aprimorar o design e o gerenciamento de fluxos de IA complexos. Usando o método `plot()` ou a linha de comando, você obtém uma visão visual dos workflows, benefício tanto para desenvolvimento quanto para apresentação.

## Próximos Passos

Se você deseja explorar exemplos adicionais de flows, acompanhe alguns exemplos em nosso repositório de exemplos. Aqui estão quatro sugestões específicas de flows, cada uma demonstrando casos de uso distintos para você escolher conforme seu problema:

1. **Email Auto Responder Flow**: Este exemplo demonstra um loop infinito, onde um job de background roda continuamente automatizando respostas de email. É ideal para tarefas rotineiras sem intervenção manual. [Ver Exemplo](https://github.com/crewAIInc/crewAI-examples/tree/main/email_auto_responder_flow)

2. **Lead Score Flow**: Destaca como adicionar feedback humano e manipular diferentes ramos condicionais usando router. Um ótimo aprendizado para workflows com decisão dinâmica e supervisão humana. [Ver Exemplo](https://github.com/crewAIInc/crewAI-examples/tree/main/lead-score-flow)

3. **Write a Book Flow**: Exemplo ideal para encadear múltiplas crews, onde a saída de uma é usada por outra. Uma crew faz um sumário do livro inteiro, outra gera capítulos... Tudo conectado para entregar um livro completo. Perfeito para processos longos e coordenados. [Ver Exemplo](https://github.com/crewAIInc/crewAI-examples/tree/main/write_a_book_with_flows)

4. **Meeting Assistant Flow**: Demonstra como transmitir um evento para desencadear múltiplas ações posteriores. Exemplo: ao finalizar uma reunião, atualizar um Trello, enviar mensagem no Slack e salvar resultados ao mesmo tempo. Indicado para gerenciamento completo de tarefas e notificações. [Ver Exemplo](https://github.com/crewAIInc/crewAI-examples/tree/main/meeting_assistant_flow)

Explore esses exemplos para descobrir como aproveitar CrewAI Flows em diferentes contextos – desde automação de tarefas repetitivas até o gerenciamento de processos dinâmicos com decisões e feedback humano.

Além disso, confira nosso vídeo no YouTube sobre como utilizar flows no CrewAI abaixo!

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/MTb5my6VOT8" title="Visão geral de Flows no CrewAI" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen />

## Executando Flows

Existem duas formas de executar um flow:

### Usando a API do Flow

Você pode executar um flow programaticamente criando uma instância da sua classe de flow e chamando o método `kickoff()`:
```

---

## 환각 방어책

**URL:** llms-txt#환각-방어책

**Contents:**
- 개요
- 환각(Hallucinations)이란 무엇인가요?
- 기본 사용법
  - 가드레일 설정하기

Source: https://docs.crewai.com/ko/enterprise/features/hallucination-guardrail

CrewAI 작업에서 AI 환각을 방지하고 감지합니다

Hallucination Guardrail은 AI가 생성한 콘텐츠가 사실에 기반하고 환각이 포함되어 있지 않은지 검증하는 엔터프라이즈 기능입니다. 이 기능은 작업 출력물을 참조 컨텍스트와 비교 분석하여, 잠재적으로 환각이 감지되었을 때 상세한 피드백을 제공합니다.

## 환각(Hallucinations)이란 무엇인가요?

AI 환각은 언어 모델이 그럴듯해 보이지만 사실과 다르거나 제공된 맥락에 의해 뒷받침되지 않는 내용을 생성할 때 발생합니다. Hallucination Guardrail은 다음과 같은 방법으로 이러한 문제를 방지합니다:

* 출력물을 참조 맥락과 비교
* 원본 자료에 대한 충실도 평가
* 문제 있는 콘텐츠에 대한 상세 피드백 제공
* 검증 엄격성을 위한 사용자 정의 임계값 지원

```python  theme={null}
from crewai.tasks.hallucination_guardrail import HallucinationGuardrail
from crewai import LLM

---

## 파일 나열 및 폴더 생성 작업

**URL:** llms-txt#파일-나열-및-폴더-생성-작업

organize_files_task = Task(
    description="OneDrive 루트 디렉토리의 모든 파일을 나열하고 '프로젝트 문서'라는 새 폴더를 만드세요.",
    agent=onedrive_agent,
    expected_output="파일 목록이 표시되고 새 폴더 '프로젝트 문서'가 생성됨."
)

---

## Remova uma implantação

**URL:** llms-txt#remova-uma-implantação

**Contents:**
- Opção 2: Implantar Diretamente pela Interface Web
- ⚠️ Requisitos de Segurança para Variáveis de Ambiente
  - Padrões de Variáveis de Ambiente Bloqueados
  - Exceções Permitidas
  - Como Corrigir Problemas de Nomeação

crewai deploy remove <deployment_id>
bash  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Opção 2: Implantar Diretamente pela Interface Web

Você também pode implantar seus crews diretamente pela interface web da CrewAI AMP conectando sua conta do GitHub. Esta abordagem não requer utilizar a CLI na sua máquina local.

<Steps>
  <Step title="Enviar no GitHub">
    Você precisa subir seu crew para um repositório do GitHub. Caso ainda não tenha criado um crew, você pode [seguir este tutorial](/pt-BR/quickstart).
  </Step>

  <Step title="Conectando o GitHub ao CrewAI AMP">
    1. Faça login em [CrewAI AMP](https://app.crewai.com)
    2. Clique no botão "Connect GitHub"

    <Frame>
            <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=e622053d392d9ca0033bb88b34d82f8d" alt="Botão Connect GitHub" data-og-width="1021" width="1021" data-og-height="327" height="327" data-path="images/enterprise/connect-github.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=67a2ba40e2c5dabacfafcb2359e569cf 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=533ddd0da6106dc71b9cbcd010f89a5c 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=d8a3f55321172ab1e4179c6d05f30b4d 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=5dc5f7c278ecc22125a1f641454cec2d 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1d8f3da31bd39d97f37b7f405ef3b048 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=7ce7bda27a7f94bb173f25fe9845a1cb 2500w" />
    </Frame>
  </Step>

  <Step title="Selecionar o Repositório">
    Após conectar sua conta GitHub, você poderá selecionar qual repositório deseja implantar:

    <Frame>
            <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=937cf62f283090f134e299aa157aad22" alt="Selecionar Repositório" data-og-width="3366" width="3366" data-og-height="956" height="956" data-path="images/enterprise/select-repo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3f5167362c6836f644ab356b61c7f8db 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c1293a61ff1fba1b19b8669b942595da 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8ac1c94be313ab5c3c3f64741e3696be 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7991df0620583adeb443551dfbf8eeb8 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1bf91d7875849fb251fa92c24c1564aa 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=17ab305443f30d6f4796b2415564a3dc 2500w" />
    </Frame>
  </Step>

  <Step title="Definir as Variáveis de Ambiente">
    Antes de implantar, você precisará configurar as variáveis de ambiente para conectar ao seu provedor de LLM ou outros serviços:

    1. Você pode adicionar variáveis individualmente ou em lote
    2. Digite suas variáveis no formato `KEY=VALUE` (uma por linha)

    <Frame>
            <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=84aa7644b9a1e20eb2e38309ce274ccb" alt="Definir Variáveis de Ambiente" data-og-width="3386" width="3386" data-og-height="606" height="606" data-path="images/enterprise/set-env-variables.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c5521837a0ea86776e2ac13883f72750 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=98882c7ba545f4a09bc2248af54bc1ac 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=884ffc4ddc80104657dd60429f262254 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6f811c643a2268d264d95a3701a4d151 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=efd5564b6b4ffe6d68654cbdc8e515cc 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=51fb85358802539cb78c5dc7cf997b92 2500w" />
    </Frame>
  </Step>

  <Step title="Implante Seu Crew">
    1. Clique no botão "Deploy" para iniciar o processo de implantação
    2. Você pode monitorar o progresso pela barra de progresso
    3. A primeira implantação geralmente demora de 10 a 15 minutos; as próximas serão mais rápidas

    <Frame>
            <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=2eb5fa4cf040c65462a372b6667adc60" alt="Progresso da Implantação" data-og-width="3386" width="3386" data-og-height="1170" height="1170" data-path="images/enterprise/deploy-progress.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=91d47e6e3edc1df183acb360cbc6af1f 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f917ef44ece66ef051db174b4dea47d8 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=dfc99edd2ff1678afa564ae33cb9c784 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=522b1ce917f9ecd15aee60c0e2241965 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=62ab85baa7a80d6fb98c50fdb7d588c7 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3190fa0b08cfbcdc75d385bde06535fa 2500w" />
    </Frame>

    Após a conclusão, você verá:

    * A URL exclusiva do seu crew
    * Um Bearer token para proteger sua API crew
    * Um botão "Delete" caso precise remover a implantação
  </Step>
</Steps>

## ⚠️ Requisitos de Segurança para Variáveis de Ambiente

<Warning>
  **Importante**: A CrewAI AMP possui restrições de segurança sobre os nomes de variáveis de ambiente que podem causar falha na implantação caso não sejam seguidas.
</Warning>

### Padrões de Variáveis de Ambiente Bloqueados

Por motivos de segurança, os seguintes padrões de nome de variável de ambiente são **automaticamente filtrados** e causarão problemas de implantação:

**Padrões Bloqueados:**

* Variáveis terminando em `_TOKEN` (ex: `MY_API_TOKEN`)
* Variáveis terminando em `_PASSWORD` (ex: `DB_PASSWORD`)
* Variáveis terminando em `_SECRET` (ex: `API_SECRET`)
* Variáveis terminando em `_KEY` em certos contextos

**Variáveis Bloqueadas Específicas:**

* `GITHUB_USER`, `GITHUB_TOKEN`
* `AWS_REGION`, `AWS_DEFAULT_REGION`
* Diversas variáveis internas do sistema CrewAI

### Exceções Permitidas

Algumas variáveis são explicitamente permitidas mesmo coincidindo com os padrões bloqueados:

* `AZURE_AD_TOKEN`
* `AZURE_OPENAI_AD_TOKEN`
* `ENTERPRISE_ACTION_TOKEN`
* `CREWAI_ENTEPRISE_TOOLS_TOKEN`

### Como Corrigir Problemas de Nomeação

Se sua implantação falhar devido a restrições de variáveis de ambiente:
```

---

## Criar agentes

**URL:** llms-txt#criar-agentes

researcher = Agent(
    role='Analista de Pesquisa',
    goal='Conduzir pesquisa de mercado detalhada',
    backstory='Analista de mercado especialista com atenção aos detalhes',
    llm=llm,
    verbose=True
)

writer = Agent(
    role='Redator de Conteúdo', 
    goal='Criar relatórios abrangentes',
    backstory='Redator técnico experiente',
    llm=llm,
    verbose=True
)

---

## Task to create a meeting notes page

**URL:** llms-txt#task-to-create-a-meeting-notes-page

create_notes_task = Task(
    description="Create a new meeting notes page in the team database with today's date and agenda items",
    agent=notion_agent,
    expected_output="Meeting notes page created successfully with structured content"
)

---

## Create LLM with fallback configuration

**URL:** llms-txt#create-llm-with-fallback-configuration

portkey_llm = LLM(
    model="gpt-4o",
    max_tokens=1000,
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        config={
            "strategy": {
                "mode": "fallback"
            },
            "targets": [
                {
                    "provider": "openai",
                    "api_key": "YOUR_OPENAI_API_KEY",
                    "override_params": {"model": "gpt-4o"}
                },
                {
                    "provider": "anthropic",
                    "api_key": "YOUR_ANTHROPIC_API_KEY",
                    "override_params": {"model": "claude-3-opus-20240229"}
                }
            ]
        }
    )
)

---

## Integração Maxim

**URL:** llms-txt#integração-maxim

**Contents:**
- Funcionalidades: Integração com Uma Linha
- Começando
  - Pré-requisitos
  - Instalação
  - Configuração Básica
  - 1. Configure as variáveis de ambiente
  - Configuração de Variáveis de Ambiente

Maxim AI oferece monitoramento completo de agentes, avaliação e observabilidade para suas aplicações CrewAI. Com a integração de uma linha do Maxim, você pode facilmente rastrear e analisar interações dos agentes, métricas de desempenho e muito mais.

## Funcionalidades: Integração com Uma Linha

* **Rastreamento de Agentes de Ponta a Ponta**: Monitore todo o ciclo de vida dos seus agentes
* **Análise de Desempenho**: Acompanhe latência, tokens consumidos e custos
* **Monitoramento de Hiperparâmetros**: Visualize detalhes de configuração das execuções dos agentes
* **Rastreamento de Chamadas de Ferramentas**: Observe quando e como os agentes usam suas ferramentas
* **Visualização Avançada**: Entenda as trajetórias dos agentes através de dashboards intuitivos

* Python versão >=3.10
* Uma conta Maxim ([cadastre-se aqui](https://getmaxim.ai/))
* Um projeto CrewAI

Instale o SDK do Maxim via pip:

Ou adicione ao seu `requirements.txt`:

### Configuração Básica

### 1. Configure as variáveis de ambiente

```python  theme={null}
### Configuração de Variáveis de Ambiente

**Examples:**

Example 1 (unknown):
```unknown
Ou adicione ao seu `requirements.txt`:
```

Example 2 (unknown):
```unknown
### Configuração Básica

### 1. Configure as variáveis de ambiente
```

---

## Obter apenas a ferramenta de previsão do servidor meteorológico

**URL:** llms-txt#obter-apenas-a-ferramenta-de-previsão-do-servidor-meteorológico

"https://weather.api.com/mcp#get_forecast"

---

## Criar um agente com a ferramenta

**URL:** llms-txt#criar-um-agente-com-a-ferramenta

**Contents:**
- Conclusão

rag_agent = Agent(
    name="rag_agent",
    role="Você é um assistente útil que pode responder perguntas com a ajuda do WeaviateVectorSearchTool.",
    llm="gpt-4o-mini",
    tools=[weaviate_tool],
)
```

O `WeaviateVectorSearchTool` fornece uma maneira poderosa de buscar documentos semanticamente similares em um banco de dados vetorial Weaviate. Ao utilizar embeddings vetoriais, ele permite resultados de busca mais precisos e relevantes em termos de contexto, quando comparado a buscas tradicionais baseadas em palavras-chave. Essa ferramenta é especialmente útil para aplicações que precisam encontrar informações a partir do significado e não apenas de correspondências exatas.

---

## XML RAG 검색

**URL:** llms-txt#xml-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/xmlsearchtool

XMLSearchTool은 XML 파일의 콘텐츠 내에서 RAG(Retrieval-Augmented Generation) 검색을 수행하도록 설계되었습니다.

---

## Example task to scrape content from a website

**URL:** llms-txt#example-task-to-scrape-content-from-a-website

scrape_task = Task(
    description="Extract the main content from the homepage of example.com. Use the CSS selector 'main' to target the main content area.",
    expected_output="The main content from example.com's homepage.",
    agent=web_scraper_agent,
)

---

## Initialize the Patronus client

**URL:** llms-txt#initialize-the-patronus-client

---

## Neatlogs Integration

**URL:** llms-txt#neatlogs-integration

Source: https://docs.crewai.com/pt-BR/observability/neatlogs

Understand, debug, and share your CrewAI agent runs

---

## Consulte o status de uma implantação

**URL:** llms-txt#consulte-o-status-de-uma-implantação

---

## Pesquisa Serper Google

**URL:** llms-txt#pesquisa-serper-google

Source: https://docs.crewai.com/pt-BR/tools/search-research/serperdevtool

O `SerperDevTool` é projetado para pesquisar na internet e retornar os resultados mais relevantes.

---

## ✅ Desative para especialistas focados (opcional)

**URL:** llms-txt#✅-desative-para-especialistas-focados-(opcional)

**Contents:**
  - 3. **Compartilhamento de Contexto**

specialist_agent = Agent(
    role="Data Analyst", 
    allow_delegation=False,  # Focuses on core expertise
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 3. **Compartilhamento de Contexto**
```

---

## Obter o caminho base de armazenamento

**URL:** llms-txt#obter-o-caminho-base-de-armazenamento

storage_path = db_storage_path()
print(f"CrewAI storage location: {storage_path}")

---

## 새 프레젠테이션 생성 작업

**URL:** llms-txt#새-프레젠테이션-생성-작업

create_presentation_task = Task(
    description="'분기별 매출 보고서'라는 제목으로 새 빈 프레젠테이션을 만드세요",
    agent=slides_agent,
    expected_output="새 프레젠테이션 '분기별 매출 보고서'가 성공적으로 생성됨"
)

---

## Before kickoff - knowledge not initialized

**URL:** llms-txt#before-kickoff---knowledge-not-initialized

print(f"Before kickoff - Agent knowledge: {getattr(agent, 'knowledge', None)}")

---

## Configure custom storage location

**URL:** llms-txt#configure-custom-storage-location

custom_storage_path = "./storage"
os.makedirs(custom_storage_path, exist_ok=True)

crew = Crew(
    memory=True,
    long_term_memory=LongTermMemory(
        storage=LTMSQLiteStorage(
            db_path=f"{custom_storage_path}/memory.db"
        )
    )
)
python  theme={null}
import os
from pathlib import Path

**Examples:**

Example 1 (unknown):
```unknown
#### 옵션 3: 프로젝트별 스토리지
```

---

## Marketplace

**URL:** llms-txt#marketplace

**Contents:**
- Visão geral
- Descoberta
- Instalar & Habilitar
- Relacionados

Source: https://docs.crewai.com/pt-BR/enterprise/features/marketplace

Descubra, instale e governe ativos reutilizáveis para seus crews enterprise.

O Marketplace oferece uma superfície curada para descobrir integrações, ferramentas internas e ativos reutilizáveis que aceleram o desenvolvimento de crews.

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=77786aca40c58c31775cb4de35b26d54" alt="Marketplace Visão Geral" data-og-width="3040" width="3040" data-og-height="2266" height="2266" data-path="images/enterprise/marketplace-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=ae939d5b2f6f4d087498ec8a3a342ea7 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=6113d807f99c7de5a4ac3012518dbfcc 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=9e21e42a266f06cb864455b8935f54fc 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=41b47b8f0c3694766edfffe121f81402 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b8d75afbe1aeb98abc3cfd55d90ebce0 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-overview.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=a798183edcdfddb19e6ae6b7ab0ab76b 2500w" />
</Frame>

* Navegue por categoria e capacidade
* Pesquise por nome ou palavra‑chave

## Instalar & Habilitar

* Instalação com um clique para ativos aprovados
* Habilite ou desabilite por crew conforme necessário
* Configure variáveis de ambiente e escopos necessários

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=cc15b069d1d4da8555e9630e1e874346" alt="Instalar & Configurar" data-og-width="2672" width="2672" data-og-height="2266" height="2266" data-path="images/enterprise/marketplace-install.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=cfdaa8690cb6651c51c5ba579364fb7a 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=2ddf18661fb7c7ad08e3f1029311813f 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b0c3ee1f87a674b1ae31956a201e4b10 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=cedd73cab5194bd1381d594d0b102e2a 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=acfc5d304485f464f7bb5780c97ab237 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/marketplace-install.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=1ea74be846d2c2eaf37cd372273f6347 2500w" />
</Frame>

Você também pode baixar templates diretamente do marketplace clicando em `Download` para usar localmente ou personalizar conforme necessário.

<CardGroup cols={3}>
  <Card title="Ferramentas & Integrações" href="/pt-BR/enterprise/features/tools-and-integrations" icon="wrench">
    Conecte apps externos e gerencie ferramentas internas que seus agentes podem usar.
  </Card>

<Card title="Repositório de Ferramentas" href="/pt-BR/enterprise/features/tool-repository" icon="toolbox">
    Publique e instale ferramentas para ampliar as capacidades dos seus crews.
  </Card>

<Card title="Repositório de Agentes" href="/pt-BR/enterprise/features/agent-repositories" icon="people-group">
    Armazene, compartilhe e reutilize definições de agentes entre equipes e projetos.
  </Card>
</CardGroup>

---

## Pesquisa RAG em DOCX

**URL:** llms-txt#pesquisa-rag-em-docx

Source: https://docs.crewai.com/pt-BR/tools/file-document/docxsearchtool

A `DOCXSearchTool` é uma ferramenta RAG projetada para busca semântica em documentos DOCX.

---

## Liste todas as suas implantações

**URL:** llms-txt#liste-todas-as-suas-implantações

---

## YouTube Video RAG Search

**URL:** llms-txt#youtube-video-rag-search

Source: https://docs.crewai.com/en/tools/search-research/youtubevideosearchtool

The `YoutubeVideoSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube video.

---

## Crie um agente para operações avançadas de documentos

**URL:** llms-txt#crie-um-agente-para-operações-avançadas-de-documentos

document_formatter = Agent(
    role="Formatador de Documentos",
    goal="Aplicar formatação avançada e estrutura a documentos do Google",
    backstory="Um assistente IA que lida com formatação complexa de documentos e organização.",
    apps=['google_docs/batch_update', 'google_docs/insert_page_break', 'google_docs/create_named_range']
)

---

## ✅ Habilite delegação para coordenadores e generalistas

**URL:** llms-txt#✅-habilite-delegação-para-coordenadores-e-generalistas

lead_agent = Agent(
    role="Content Lead",
    allow_delegation=True,  # Can delegate to specialists
    ...
)

---

## Consider creating new state:

**URL:** llms-txt#consider-creating-new-state:

**Contents:**
- Debugging Flow State
  - Logging State Changes
  - State Visualization
- Conclusion
- Next Steps

from pydantic import BaseModel
from typing import List

class ItemState(BaseModel):
    items: List[str] = []

class ImmutableFlow(Flow[ItemState]):
    @start()
    def add_item(self):
        # Create new list with the added item
        self.state.items = [*self.state.items, "new item"]
        return "Item added"
python  theme={null}
import logging
logging.basicConfig(level=logging.INFO)

class LoggingFlow(Flow):
    def log_state(self, step_name):
        logging.info(f"State after {step_name}: {self.state}")

@start()
    def initialize(self):
        self.state["counter"] = 0
        self.log_state("initialize")
        return "Initialized"

@listen(initialize)
    def increment(self, _):
        self.state["counter"] += 1
        self.log_state("increment")
        return f"Incremented to {self.state['counter']}"
python  theme={null}
def visualize_state(self):
    """Create a simple visualization of the current state"""
    import json
    from rich.console import Console
    from rich.panel import Panel

if hasattr(self.state, "model_dump"):
        # Pydantic v2
        state_dict = self.state.model_dump()
    elif hasattr(self.state, "dict"):
        # Pydantic v1
        state_dict = self.state.dict()
    else:
        # Unstructured state
        state_dict = dict(self.state)

# Remove id for cleaner output
    if "id" in state_dict:
        state_dict.pop("id")

state_json = json.dumps(state_dict, indent=2, default=str)
    console.print(Panel(state_json, title="Current Flow State"))
```

Mastering state management in CrewAI Flows gives you the power to build sophisticated, robust AI applications that maintain context, make complex decisions, and deliver consistent results.

Whether you choose unstructured or structured state, implementing proper state management practices will help you create flows that are maintainable, extensible, and effective at solving real-world problems.

As you develop more complex flows, remember that good state management is about finding the right balance between flexibility and structure, making your code both powerful and easy to understand.

<Check>
  You've now mastered the concepts and practices of state management in CrewAI Flows! With this knowledge, you can create robust AI workflows that effectively maintain context, share data between steps, and build sophisticated application logic.
</Check>

* Experiment with both structured and unstructured state in your flows
* Try implementing state persistence for long-running workflows
* Explore [building your first crew](/en/guides/crews/first-crew) to see how crews and flows can work together
* Check out the [Flow reference documentation](/en/concepts/flows) for more advanced features

**Examples:**

Example 1 (unknown):
```unknown
## Debugging Flow State

### Logging State Changes

When developing, add logging to track state changes:
```

Example 2 (unknown):
```unknown
### State Visualization

You can add methods to visualize your state for debugging:
```

---

## Perfect for document processing

**URL:** llms-txt#perfect-for-document-processing

document_processor = Agent(
    role="Document Analyst",
    goal="Extract insights from large research papers",
    backstory="Expert at analyzing extensive documentation",
    respect_context_window=True,  # Handle large documents gracefully
    max_iter=50,  # Allow more iterations for complex analysis
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### `respect_context_window=False`를 사용할 때:

* **정확성이 매우 중요**하고 정보 손실이 허용되지 않을 때
* **법률 또는 의료 업무**에서 전체 맥락이 필요한 경우
* **코드 리뷰**에서 누락된 세부 정보가 버그를 유발할 수 있는 경우
* **금융 분석**에서 정확도가 최우선인 경우
```

---

## Crie um Agent usando layouts específicos do Llama

**URL:** llms-txt#crie-um-agent-usando-layouts-específicos-do-llama

principal_engineer = Agent(
    role="Principal Engineer",
    goal="Oversee AI architecture and make high-level decisions",
    backstory="You are the lead engineer responsible for critical AI systems",
    verbose=True,
    llm="groq/llama-3.3-70b-versatile",  # Usando o modelo Llama 3
    system_template=system_template,
    prompt_template=prompt_template,
    response_template=response_template,
    tools=[DirectoryReadTool(), FileReadTool()]
)

---

## Manager-led task

**URL:** llms-txt#manager-led-task

project_task = Task(
    description="Crie um relatório de análise de mercado completo com recomendações",
    expected_output="Resumo executivo, análise detalhada e recomendações estratégicas",
    agent=manager  # O gerente delega para especialistas
)

---

## Get or create collection

**URL:** llms-txt#get-or-create-collection

test_docs = client.collections.get("example_collections")
if not test_docs:
    test_docs = client.collections.create(
        name="example_collections",
        vectorizer_config=Configure.Vectorizer.text2vec_openai(model="nomic-embed-text"),
        generative_config=Configure.Generative.openai(model="gpt-4o"),
    )

---

## Langtrace 개요

**URL:** llms-txt#langtrace-개요

**Contents:**
- 설정 지침
  - 기능 및 CrewAI에의 적용

Langtrace는 대형 언어 모델(LLM), LLM 프레임워크, 벡터 데이터베이스에 대한 관측 가능성과 평가를 설정할 수 있도록 도와주는 오픈소스 외부 도구입니다.\
Langtrace는 CrewAI에 직접 내장되어 있지는 않지만, CrewAI와 함께 사용하여 CrewAI 에이전트의 비용, 지연 시간, 성능에 대해 깊이 있는 가시성을 확보할 수 있습니다.\
이 통합을 통해 하이퍼파라미터를 기록하고, 성능 회귀를 모니터링하며, 에이전트의 지속적인 개선을 위한 프로세스를 수립할 수 있습니다.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=85b67e42028ca9383087737279f8931f" alt="에이전트 세션 실행 시리즈 개요" data-og-width="1717" width="1717" data-og-height="1299" height="1299" data-path="images/langtrace1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ba769f765ef36edf033e2caf8c7df4c7 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9e24743472c91a4b42dc235c8b16691a 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f70296efa8dd1619670008b9af8d7e78 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c8281aea8f979aa38ff1b6519e3fb840 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c55eafbe3e6fee44aaa208f8ce988847 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=677e866fb2e110afc4e7f6800abafdc3 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=24f08e5c56b6200e386d305a7bee347c" alt="에이전트 트레이스 개요" data-og-width="1725" width="1725" data-og-height="1094" height="1094" data-path="images/langtrace2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9182a51d34df98e5a5b7b994b6d11d4d 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=fa10f203c90f5394c5a3fe5b96b52685 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1a1d34a1ac4c2d2d5a4748e4a4a46c97 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=81bb4d002d59c63f80c2cff7f2afbadd 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=de0fe6458f4595f73615ce7acb6b5d37 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1cf56b30d10a0ef841aa762fa27c74a2 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f1a8624e0c05d59deded640e4751a986" alt="상세한 llm 트레이스 개요" data-og-width="1710" width="1710" data-og-height="1217" height="1217" data-path="images/langtrace3.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=3483f588b90a032d4919847e6e63772a 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c638c41d0e0e156c2c2e0ed1e80bfde1 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6d2b588d0a6c176a8fd80e4d3844d955 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=611c9167a54facb43c95a2239bba6a39 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=62a6bfc0052934c423ce245ddef1a28e 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=726ee5e7feed10e6f507233807e70ae9 2500w" />

<Steps>
  <Step title="Langtrace에 가입하기">
    [https://langtrace.ai/signup](https://langtrace.ai/signup)에서 가입하세요.
  </Step>

<Step title="프로젝트 생성">
    프로젝트 유형을 `CrewAI`로 설정하고 API 키를 생성하세요.
  </Step>

<Step title="CrewAI 프로젝트에 Langtrace 설치하기">
    다음 명령어를 사용하세요:

<Step title="Langtrace 임포트하기">
    스크립트의 시작 부분, CrewAI를 임포트하기 전에 Langtrace를 임포트하고 초기화하세요:

1. **LLM 토큰 및 비용 추적**

* 각 CrewAI 에이전트 상호작용에 대한 토큰 사용량과 관련 비용을 모니터링합니다.

2. **실행 단계에 대한 추적 그래프**

* CrewAI 작업의 실행 흐름을 시각화하며, 지연 시간과 로그를 포함합니다.
   * 에이전트 워크플로우의 병목 지점을 파악하는 데 유용합니다.

3. **수동 주석을 통한 데이터셋 큐레이션**

* 미래의 학습 또는 평가를 위해 CrewAI 작업 출력으로부터 데이터셋을 생성합니다.

4. **프롬프트 버전 관리 및 관리**

* CrewAI 에이전트에서 사용된 다양한 프롬프트 버전을 추적합니다.
   * A/B 테스트 및 에이전트 성능 최적화에 유용합니다.

5. **프롬프트 플레이그라운드 및 모델 비교**

* 배포 전에 CrewAI 에이전트에 사용할 다양한 프롬프트와 모델을 테스트 및 비교합니다.

* CrewAI 에이전트 및 작업에 대한 자동화된 테스트를 설정합니다.

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Langtrace 임포트하기">
    스크립트의 시작 부분, CrewAI를 임포트하기 전에 Langtrace를 임포트하고 초기화하세요:
```

---

## ✅ Solução: Certifique-se que a delegação está habilitada

**URL:** llms-txt#✅-solução:-certifique-se-que-a-delegação-está-habilitada

**Contents:**
  - Problema: Troca Excessiva de Perguntas

agent = Agent(
    role="...",
    allow_delegation=True,  # This is required!
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Problema: Troca Excessiva de Perguntas

**Sintomas:** Agentes fazem perguntas em excesso, progresso lento
```

---

## Server with custom path

**URL:** llms-txt#server-with-custom-path

**Contents:**
  - Specific Tool Selection

"https://services.company.com/api/v1/mcp"
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Specific Tool Selection

Use the `#` syntax to select specific tools from a server:
```

---

## 다른 조직으로 전환

**URL:** llms-txt#다른-조직으로-전환

crewai org switch <org_id>

---

## Exemplo com kickoff_for_each

**URL:** llms-txt#exemplo-com-kickoff_for_each

inputs_array = [{'topic': 'AI in healthcare'}, {'topic': 'AI in finance'}]
results = my_crew.kickoff_for_each(inputs=inputs_array)
for result in results:
    print(result)

---

## Trigger Salesforce

**URL:** llms-txt#trigger-salesforce

**Contents:**
- Visão Geral
- Demonstração
- Primeiros Passos
- Casos de Uso
- Próximos Passos

Source: https://docs.crewai.com/pt-BR/enterprise/guides/salesforce-trigger

Dispare equipes CrewAI a partir de fluxos de trabalho do Salesforce para automação de CRM

A CrewAI AMP pode ser acionada a partir do Salesforce para automatizar fluxos de trabalho de gestão de relacionamento com o cliente e aprimorar suas operações de vendas.

O Salesforce é uma das principais plataformas de gestão de relacionamento com o cliente (CRM), que ajuda empresas a otimizar operações de vendas, atendimento e marketing. Ao configurar triggers da CrewAI a partir do Salesforce, você pode:

* Automatizar a classificação e qualificação de leads
* Gerar materiais de vendas personalizados
* Aprimorar o atendimento ao cliente com respostas baseadas em IA
* Otimizar análise e relatórios de dados

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/oJunVqjjfu4" title="Demonstração de trigger CrewAI + Salesforce" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

Para configurar triggers no Salesforce:

1. **Contato com o Suporte**: Entre em contato com o suporte da CrewAI AMP para obter assistência na configuração dos triggers no Salesforce
2. **Revisar Requisitos**: Certifique-se de possuir as permissões necessárias no Salesforce e acesso à API
3. **Configurar Conexão**: Trabalhe com a equipe de suporte para estabelecer a conexão entre a CrewAI e sua instância do Salesforce
4. **Testar Triggers**: Verifique se os triggers funcionam corretamente para os seus casos de uso específicos

Cenários comuns de uso de triggers Salesforce + CrewAI incluem:

* **Processamento de Leads**: Analisar e classificar leads recebidos automaticamente
* **Geração de Propostas**: Criar propostas personalizadas com base nos dados das oportunidades
* **Insights de Clientes**: Gerar relatórios de análise a partir do histórico de interações com clientes
* **Automação de Follow-up**: Criar mensagens de follow-up e recomendações personalizadas

Para instruções detalhadas de configuração e opções avançadas, entre em contato com o suporte da CrewAI AMP, que pode fornecer orientações personalizadas para o seu ambiente Salesforce e necessidades de negócio.

---

## 메타데이터 - 추가 정보용 (사용자 지정 가능)

**URL:** llms-txt#메타데이터---추가-정보용-(사용자-지정-가능)

metadata = fingerprint.metadata  # 딕셔너리, 기본값은 {}
```

---

## Add content from a web page

**URL:** llms-txt#add-content-from-a-web-page

rag_tool.add(data_type="web_page", url="https://example.com")

---

## reasoning 중 오류가 발생해도 로그에 기록되며 실행은 계속됩니다

**URL:** llms-txt#reasoning-중-오류가-발생해도-로그에-기록되며-실행은-계속됩니다

**Contents:**
- 예시 Reasoning 출력

result = agent.execute_task(task)

Task: Analyze the provided sales data and identify key trends.

Reasoning Plan:
I'll analyze the sales data to identify the top 3 trends.

1. Understanding of the task:
   I need to analyze sales data to identify key trends that would be valuable for business decision-making.

2. Key steps I'll take:
   - First, I'll examine the data structure to understand what fields are available
   - Then I'll perform exploratory data analysis to identify patterns
   - Next, I'll analyze sales by time periods to identify temporal trends
   - I'll also analyze sales by product categories and customer segments
   - Finally, I'll identify the top 3 most significant trends

3. Approach to challenges:
   - If the data has missing values, I'll decide whether to fill or filter them
   - If the data has outliers, I'll investigate whether they're valid data points or errors
   - If trends aren't immediately obvious, I'll apply statistical methods to uncover patterns

4. Use of available tools:
   - I'll use data analysis tools to explore and visualize the data
   - I'll use statistical tools to identify significant patterns
   - I'll use knowledge retrieval to access relevant information about sales analysis

5. Expected outcome:
   A concise report highlighting the top 3 sales trends with supporting evidence from the data.

READY: I am ready to execute the task.
```

이 reasoning 계획은 agent가 작업에 접근하는 방식을 체계적으로 구성하고, 발생할 수 있는 잠재적 문제를 고려하며, 기대되는 결과를 제공하도록 돕습니다.

**Examples:**

Example 1 (unknown):
```unknown
## 예시 Reasoning 출력

다음은 데이터 분석 작업을 위한 reasoning 계획의 예시입니다:
```

---

## Define the task with output_json set to the Blog model

**URL:** llms-txt#define-the-task-with-output_json-set-to-the-blog-model

task1 = Task(
    description="""Create a blog title and content on a given topic. Make sure the content is under 200 words.""",
    expected_output="A JSON object with 'title' and 'content' fields.",
    agent=blog_agent,
    output_json=Blog,
)

---

## ✅ 특정 역할 - 명확한 LLM 요구

**URL:** llms-txt#✅-특정-역할---명확한-llm-요구

**Contents:**
  - b. 모델 컨텍스트 증폭기로서의 백스토리

specific_agent = Agent(
    role="SaaS Revenue Operations Analyst",  # 명확한 도메인 전문성 필요
    goal="Analyze recurring revenue metrics and identify growth opportunities",
    backstory="Specialist in SaaS business models with deep understanding of ARR, churn, and expansion revenue",
    llm=LLM(model="gpt-4o")  # 복잡한 분석에 적합한 reasoning 모델
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**역할-모델 매핑 전략:**

* **"Research Analyst"** → 복잡한 분석을 위한 reasoning 모델 (GPT-4o, Claude Sonnet)
* **"Content Editor"** → 작문 품질을 위한 creative 모델 (Claude, GPT-4o)
* **"Data Processor"** → 구조화된 태스크를 위한 효율적인 모델 (GPT-4o-mini, Gemini Flash)
* **"API Coordinator"** → 도구 사용을 위한 function-calling 최적화 모델 (GPT-4o, Claude)

### b. 모델 컨텍스트 증폭기로서의 백스토리

<Info>
  전략적으로 구성된 백스토리는 도메인 특화 컨텍스트를 제공하여 일반적인 프롬프트로는 달성할 수 없는 수준으로 선택한 LLM의 효율성을 획기적으로 높여줍니다.
</Info>

잘 설계된 백스토리는 LLM을 단순한 범용 모델에서 전문적인 전문가로 탈바꿈시켜 줍니다. 이는 비용 최적화 관점에서 특히 중요합니다. 효율적인 모델이라도 컨텍스트가 잘 구축되면, 적절한 컨텍스트 없이 고가의 모델보다 더 뛰어난 성능을 발휘할 수 있습니다.

**컨텍스트 기반 퍼포먼스 예시:**
```

---

## Initialize the tool with the custom evaluator

**URL:** llms-txt#initialize-the-tool-with-the-custom-evaluator

patronus_eval_tool = PatronusLocalEvaluatorTool(
    patronus_client=client,
    evaluator="random_evaluator",
    evaluated_model_gold_answer="example label",
)

---

## Integração Microsoft SharePoint

**URL:** llms-txt#integração-microsoft-sharepoint

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Microsoft SharePoint
  - 1. Conecte sua Conta Microsoft
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Microsoft SharePoint

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/microsoft_sharepoint

Gerenciamento de sites, listas e documentos com integração Microsoft SharePoint para CrewAI.

Permita que seus agentes acessem e gerenciem sites, listas e bibliotecas de documentos do SharePoint. Recupere informações do site, gerencie itens de lista, faça upload e organize arquivos, e simplifique seus fluxos de trabalho do SharePoint com automação alimentada por IA.

Antes de usar a integração Microsoft SharePoint, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Microsoft com acesso ao SharePoint
* Conectado sua conta Microsoft através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Microsoft SharePoint

### 1. Conecte sua Conta Microsoft

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Microsoft SharePoint** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a sites e arquivos do SharePoint
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="microsoft_sharepoint/get_sites">
    **Descrição:** Obter todos os sites do SharePoint aos quais o usuário tem acesso.

* `search` (string, opcional): Consulta de pesquisa para filtrar sites.
    * `select` (string, opcional): Selecionar propriedades específicas para retornar (ex: 'displayName,id,webUrl').
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `skip` (integer, opcional): Número de itens a pular (mín 0).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas (ex: 'displayName desc').
  </Accordion>

<Accordion title="microsoft_sharepoint/get_site">
    **Descrição:** Obter informações sobre um site específico do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `select` (string, opcional): Selecionar propriedades específicas para retornar (ex: 'displayName,id,webUrl,drives').
    * `expand` (string, opcional): Expandir recursos relacionados inline (ex: 'drives,lists').
  </Accordion>

<Accordion title="microsoft_sharepoint/get_site_lists">
    **Descrição:** Obter todas as listas em um site do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
  </Accordion>

<Accordion title="microsoft_sharepoint/get_list">
    **Descrição:** Obter informações sobre uma lista específica.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
  </Accordion>

<Accordion title="microsoft_sharepoint/get_list_items">
    **Descrição:** Obter itens de uma lista do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `expand` (string, opcional): Expandir dados relacionados (ex: 'fields').
  </Accordion>

<Accordion title="microsoft_sharepoint/create_list_item">
    **Descrição:** Criar um novo item em uma lista do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `fields` (object, obrigatório): Os valores de campo para o novo item.
  </Accordion>

<Accordion title="microsoft_sharepoint/update_list_item">
    **Descrição:** Atualizar um item em uma lista do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `item_id` (string, obrigatório): O ID do item a atualizar.
    * `fields` (object, obrigatório): Os valores de campo a atualizar.
  </Accordion>

<Accordion title="microsoft_sharepoint/delete_list_item">
    **Descrição:** Excluir um item de uma lista do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `item_id` (string, obrigatório): O ID do item a excluir.
  </Accordion>

<Accordion title="microsoft_sharepoint/upload_file_to_library">
    **Descrição:** Fazer upload de um arquivo para uma biblioteca de documentos do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `file_path` (string, obrigatório): O caminho onde fazer upload do arquivo (ex: 'pasta/nomeDoArquivo.txt').
    * `content` (string, obrigatório): O conteúdo do arquivo a fazer upload.
  </Accordion>

<Accordion title="microsoft_sharepoint/get_drive_items">
    **Descrição:** Obter arquivos e pastas de uma biblioteca de documentos do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
  </Accordion>

<Accordion title="microsoft_sharepoint/delete_drive_item">
    **Descrição:** Excluir um arquivo ou pasta da biblioteca de documentos do SharePoint.

* `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `item_id` (string, obrigatório): O ID do arquivo ou pasta a excluir.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Microsoft SharePoint

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="microsoft_sharepoint/get_sites">
    **Descrição:** Obter todos os sites do SharePoint aos quais o usuário tem acesso.

    **Parâmetros:**

    * `search` (string, opcional): Consulta de pesquisa para filtrar sites.
    * `select` (string, opcional): Selecionar propriedades específicas para retornar (ex: 'displayName,id,webUrl').
    * `filter` (string, opcional): Filtrar resultados usando sintaxe OData.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
    * `top` (integer, opcional): Número de itens a retornar (mín 1, máx 999).
    * `skip` (integer, opcional): Número de itens a pular (mín 0).
    * `orderby` (string, opcional): Ordenar resultados por propriedades especificadas (ex: 'displayName desc').
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_site">
    **Descrição:** Obter informações sobre um site específico do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `select` (string, opcional): Selecionar propriedades específicas para retornar (ex: 'displayName,id,webUrl,drives').
    * `expand` (string, opcional): Expandir recursos relacionados inline (ex: 'drives,lists').
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_site_lists">
    **Descrição:** Obter todas as listas em um site do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_list">
    **Descrição:** Obter informações sobre uma lista específica.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_list_items">
    **Descrição:** Obter itens de uma lista do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `expand` (string, opcional): Expandir dados relacionados (ex: 'fields').
  </Accordion>

  <Accordion title="microsoft_sharepoint/create_list_item">
    **Descrição:** Criar um novo item em uma lista do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `fields` (object, obrigatório): Os valores de campo para o novo item.
  </Accordion>

  <Accordion title="microsoft_sharepoint/update_list_item">
    **Descrição:** Atualizar um item em uma lista do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `item_id` (string, obrigatório): O ID do item a atualizar.
    * `fields` (object, obrigatório): Os valores de campo a atualizar.
  </Accordion>

  <Accordion title="microsoft_sharepoint/delete_list_item">
    **Descrição:** Excluir um item de uma lista do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `list_id` (string, obrigatório): O ID da lista.
    * `item_id` (string, obrigatório): O ID do item a excluir.
  </Accordion>

  <Accordion title="microsoft_sharepoint/upload_file_to_library">
    **Descrição:** Fazer upload de um arquivo para uma biblioteca de documentos do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `file_path` (string, obrigatório): O caminho onde fazer upload do arquivo (ex: 'pasta/nomeDoArquivo.txt').
    * `content` (string, obrigatório): O conteúdo do arquivo a fazer upload.
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_drive_items">
    **Descrição:** Obter arquivos e pastas de uma biblioteca de documentos do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
  </Accordion>

  <Accordion title="microsoft_sharepoint/delete_drive_item">
    **Descrição:** Excluir um arquivo ou pasta da biblioteca de documentos do SharePoint.

    **Parâmetros:**

    * `site_id` (string, obrigatório): O ID do site do SharePoint.
    * `item_id` (string, obrigatório): O ID do arquivo ou pasta a excluir.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Microsoft SharePoint
```

---

## UUID 문자열 - 고유 식별자 (자동 생성)

**URL:** llms-txt#uuid-문자열---고유-식별자-(자동-생성)

uuid_str = fingerprint.uuid_str  # e.g., "123e4567-e89b-12d3-a456-426614174000"

---

## The agent will use these defaults

**URL:** llms-txt#the-agent-will-use-these-defaults

**Contents:**
- Features
- Response Format

agent_with_custom_tool = Agent(
    role="Advanced Researcher",
    goal="Conduct detailed research with comprehensive results",
    tools=[custom_tavily_tool]
)
```

* **Comprehensive Search**: Access to Tavily's powerful search index
* **Configurable Depth**: Choose between basic and advanced search modes
* **Topic Filtering**: Focus searches on general, news, or finance topics
* **Time Range Control**: Limit results to specific time periods
* **Domain Control**: Include or exclude specific domains
* **Direct Answers**: Get synthesized answers from search results
* **Content Filtering**: Prevent context window issues with automatic content truncation

The tool returns search results as a JSON string containing:

* Search results with titles, URLs, and content snippets
* Optional direct answers to queries
* Optional image results
* Optional raw HTML content (when enabled)

Content for each result is automatically truncated to prevent context window issues while maintaining the most relevant information.

---

## e retornará os 3 resultados mais relevantes com pontuação > 0.35

**URL:** llms-txt#e-retornará-os-3-resultados-mais-relevantes-com-pontuação->-0.35

**Contents:**
- Exemplo Completo e Funcional

python  theme={null}
import os
import uuid
import pdfplumber
from openai import OpenAI
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process, LLM
from crewai_tools import QdrantVectorSearchTool
from qdrant_client import QdrantClient
from qdrant_client.models import PointStruct, Distance, VectorParams

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo Completo e Funcional

Veja um exemplo completo mostrando como:

1. Extrair texto de um PDF
2. Gerar embeddings usando OpenAI
3. Armazenar no Qdrant
4. Criar um fluxo de trabalho RAG agente CrewAI para busca semântica
```

---

## Comparar desempenho

**URL:** llms-txt#comparar-desempenho

**Contents:**
- 2. Memória Externa
  - Memória Externa Básica com Mem0

openai_time = test_embedding_performance({
    "provider": "openai",
    "config": {"model": "text-embedding-3-small"}
})

ollama_time = test_embedding_performance({
    "provider": "ollama", 
    "config": {"model": "mxbai-embed-large"}
})

print(f"OpenAI: {openai_time:.2f}s")
print(f"Ollama: {ollama_time:.2f}s")
python  theme={null}
import os
from crewai import Agent, Crew, Process, Task
from crewai.memory.external.external_memory import ExternalMemory

**Examples:**

Example 1 (unknown):
```unknown
## 2. Memória Externa

A Memória Externa fornece um sistema de memória autônomo que opera independentemente da memória interna da crew. Isso é ideal para provedores de memória especializados ou compartilhamento de memória entre aplicações.

### Memória Externa Básica com Mem0
```

---

## TrueFoundry Integration

**URL:** llms-txt#truefoundry-integration

**Contents:**
- How TrueFoundry Integrates with CrewAI
  - Installation & Setup
  - Complete CrewAI Example

Source: https://docs.crewai.com/ko/observability/truefoundry

TrueFoundry provides an enterprise-ready [AI Gateway](https://www.truefoundry.com/ai-gateway) which can integrate with agentic frameworks like CrewAI and provides governance and observability for your AI Applications. TrueFoundry AI Gateway serves as a unified interface for LLM access, providing:

* **Unified API Access**: Connect to 250+ LLMs (OpenAI, Claude, Gemini, Groq, Mistral) through one API
* **Low Latency**: Sub-3ms internal latency with intelligent routing and load balancing
* **Enterprise Security**: SOC 2, HIPAA, GDPR compliance with RBAC and audit logging
* **Quota and cost management**: Token-based quotas, rate limiting, and comprehensive usage tracking
* **Observability**: Full request/response logging, metrics, and traces with customizable retention

## How TrueFoundry Integrates with CrewAI

### Installation & Setup

<Steps>
  <Step title="Install CrewAI">
    
  </Step>

<Step title="Get TrueFoundry Access Token">
    1. Sign up for a [TrueFoundry account](https://www.truefoundry.com/register)
    2. Follow the steps here in [Quick start](https://docs.truefoundry.com/gateway/quick-start)
  </Step>

<Step title="Configure CrewAI with TrueFoundry">
        <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=746c0bd23a77535f35b0b2bcf3320bf5" alt="TrueFoundry Code Configuration" data-og-width="2940" width="2940" data-og-height="1664" height="1664" data-path="images/new-code-snippet.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1d7f4e8883760766aa1ae1274fba2ffe 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4604432c1e1121d24c3fa6ad93bc0bd9 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=8dd95282de37aa70090ac61a00b6e1bb 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=920a67bee38e979c770d775195b60864 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4173b6e99ed12b00b54bf3f222589863 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=176dd84222c8c1a6f40af3e0adb88e37 2500w" />

### Complete CrewAI Example

```python  theme={null}
from crewai import Agent, Task, Crew, LLM

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Get TrueFoundry Access Token">
    1. Sign up for a [TrueFoundry account](https://www.truefoundry.com/register)
    2. Follow the steps here in [Quick start](https://docs.truefoundry.com/gateway/quick-start)
  </Step>

  <Step title="Configure CrewAI with TrueFoundry">
        <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=746c0bd23a77535f35b0b2bcf3320bf5" alt="TrueFoundry Code Configuration" data-og-width="2940" width="2940" data-og-height="1664" height="1664" data-path="images/new-code-snippet.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1d7f4e8883760766aa1ae1274fba2ffe 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4604432c1e1121d24c3fa6ad93bc0bd9 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=8dd95282de37aa70090ac61a00b6e1bb 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=920a67bee38e979c770d775195b60864 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=4173b6e99ed12b00b54bf3f222589863 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/new-code-snippet.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=176dd84222c8c1a6f40af3e0adb88e37 2500w" />
```

Example 2 (unknown):
```unknown
</Step>
</Steps>

### Complete CrewAI Example
```

---

## Exemplo de tarefa para buscar informações em um vídeo específico

**URL:** llms-txt#exemplo-de-tarefa-para-buscar-informações-em-um-vídeo-específico

research_task = Task(
    description="Search for information about machine learning frameworks in the YouTube video at {youtube_video_url}",
    expected_output="A summary of the key machine learning frameworks mentioned in the video.",
    agent=video_researcher,
)

---

## Exemplo de tarefa

**URL:** llms-txt#exemplo-de-tarefa

task = Task(
    description='Encontre e resuma as últimas notícias de IA',
    expected_output='Uma lista em bullet points com o resumo das 5 notícias mais importantes de IA',
    agent=research_agent,
    tools=[search_tool]
)

---

## Set environment variables

**URL:** llms-txt#set-environment-variables

**Contents:**
  - 3단계: Phoenix와 함께 OpenTelemetry 초기화하기
  - 4단계: CrewAI 애플리케이션 생성하기

os.environ["PHOENIX_CLIENT_HEADERS"] = f"api_key={PHOENIX_API_KEY}"
os.environ["PHOENIX_COLLECTOR_ENDPOINT"] = "https://app.phoenix.arize.com" # Phoenix Cloud, change this to your own endpoint if you are using a self-hosted instance
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
os.environ["SERPER_API_KEY"] = SERPER_API_KEY
python  theme={null}
from phoenix.otel import register

tracer_provider = register(
    project_name="crewai-tracing-demo",
    auto_instrument=True,
)
python  theme={null}
from crewai import Agent, Crew, Process, Task
from crewai_tools import SerperDevTool
from openinference.instrumentation.crewai import CrewAIInstrumentor
from phoenix.otel import register

**Examples:**

Example 1 (unknown):
```unknown
### 3단계: Phoenix와 함께 OpenTelemetry 초기화하기

OpenInference OpenTelemetry 계측 SDK를 초기화하여 트레이스를 수집하고 Phoenix로 전송합니다.
```

Example 2 (unknown):
```unknown
### 4단계: CrewAI 애플리케이션 생성하기

두 명의 에이전트가 협력하여 AI 발전에 관한 블로그 글을 조사하고 작성하는 CrewAI 애플리케이션을 만들어 보겠습니다.
```

---

## 사용자 지정 Ollama 설치의 경우

**URL:** llms-txt#사용자-지정-ollama-설치의-경우

**Contents:**
  - Cohere 임베딩
  - VoyageAI 임베딩
  - AWS Bedrock 임베딩
  - Hugging Face 임베딩
  - IBM Watson 임베딩
  - 적합한 임베딩 제공업체 선택하기
  - 환경 변수 설정

crew = Crew(
    memory=True,
    embedder={
        "provider": "ollama",
        "config": {
            "model": "mxbai-embed-large",
            "url": "http://your-ollama-server:11434/api/embeddings"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "cohere",
        "config": {
            "api_key": "your-cohere-api-key",
            "model": "embed-english-v3.0"  # or "embed-multilingual-v3.0"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "voyageai",
        "config": {
            "api_key": "your-voyage-api-key",
            "model": "voyage-large-2",  # or "voyage-code-2" for code
            "input_type": "document"  # or "query"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "bedrock",
        "config": {
            "aws_access_key_id": "your-access-key",
            "aws_secret_access_key": "your-secret-key",
            "region_name": "us-east-1",
            "model": "amazon.titan-embed-text-v1"
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "huggingface",
        "config": {
            "api_key": "your-hf-token",  # Optional for public models
            "model": "sentence-transformers/all-MiniLM-L6-v2",
            "api_url": "https://api-inference.huggingface.co"  # or your custom endpoint
        }
    }
)
python  theme={null}
crew = Crew(
    memory=True,
    embedder={
        "provider": "watson",
        "config": {
            "api_key": "your-watson-api-key",
            "url": "your-watson-instance-url",
            "model": "ibm/slate-125m-english-rtrvr"
        }
    }
)
python  theme={null}
import os

**Examples:**

Example 1 (unknown):
```unknown
### Cohere 임베딩

Cohere의 임베딩 모델을 사용하여 다국어 지원을 제공합니다.
```

Example 2 (unknown):
```unknown
### VoyageAI 임베딩

검색 작업에 최적화된 고성능 임베딩입니다.
```

Example 3 (unknown):
```unknown
### AWS Bedrock 임베딩

Bedrock 액세스 권한이 있는 AWS 사용자용.
```

Example 4 (unknown):
```unknown
### Hugging Face 임베딩

Hugging Face의 오픈 소스 모델을 사용합니다.
```

---

## Github 검색

**URL:** llms-txt#github-검색

Source: https://docs.crewai.com/ko/tools/search-research/githubsearchtool

GithubSearchTool은 웹사이트를 검색하고 이를 깔끔한 마크다운 또는 구조화된 데이터로 변환하도록 설계되었습니다.

---

## Connect to Weaviate

**URL:** llms-txt#connect-to-weaviate

client = weaviate.connect_to_weaviate_cloud(
    cluster_url="https://your-weaviate-cluster-url.com",
    auth_credentials=Auth.api_key("your-weaviate-api-key"),
    headers={"X-OpenAI-Api-Key": "your-openai-api-key"}
)

---

## Create an agent for file organization and sharing

**URL:** llms-txt#create-an-agent-for-file-organization-and-sharing

file_organizer = Agent(
    role="File Organizer",
    goal="Organize files and create sharing links for collaboration",
    backstory="An AI assistant that excels at organizing files and managing sharing permissions.",
    apps=['microsoft_onedrive/search_files', 'microsoft_onedrive/move_item', 'microsoft_onedrive/share_item', 'microsoft_onedrive/create_folder']
)

---

## `S3WriterTool`

**URL:** llms-txt#`s3writertool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

A `S3WriterTool` foi projetada para escrever conteúdo em arquivos em buckets Amazon S3. Esta ferramenta permite que agentes CrewAI criem ou atualizem arquivos no S3, tornando-a ideal para fluxos de trabalho que exigem armazenamento de dados, salvamento de arquivos de configuração ou persistência de qualquer outro conteúdo no armazenamento AWS S3.

Para usar esta ferramenta, você precisa instalar as dependências necessárias:

## Passos para Começar

Para usar a `S3WriterTool` de forma eficaz, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários usando o comando acima.
2. **Configure as Credenciais AWS**: Defina suas credenciais AWS como variáveis de ambiente.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta.
4. **Especifique o Caminho no S3 e o Conteúdo**: Forneça o caminho no S3 onde deseja gravar o arquivo e o conteúdo a ser escrito.

O exemplo a seguir demonstra como usar a `S3WriterTool` para gravar conteúdo em um arquivo em um bucket S3:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools.aws.s3 import S3WriterTool

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para usar a `S3WriterTool` de forma eficaz, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários usando o comando acima.
2. **Configure as Credenciais AWS**: Defina suas credenciais AWS como variáveis de ambiente.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta.
4. **Especifique o Caminho no S3 e o Conteúdo**: Forneça o caminho no S3 onde deseja gravar o arquivo e o conteúdo a ser escrito.

## Exemplo

O exemplo a seguir demonstra como usar a `S3WriterTool` para gravar conteúdo em um arquivo em um bucket S3:
```

---

## Set specific collaboration guidelines in agent backstory

**URL:** llms-txt#set-specific-collaboration-guidelines-in-agent-backstory

**Contents:**
  - Monitoramento da Colaboração
- Memória e Aprendizado
- Próximos Passos

agent = Agent(
    role="Senior Developer",
    backstory="""You lead development projects and coordinate with team members.
    
    Collaboration guidelines:
    - Delegate research tasks to the Research Analyst
    - Ask the Designer for UI/UX guidance  
    - Consult the QA Engineer for testing strategies
    - Only escalate blocking issues to the Project Manager""",
    allow_delegation=True
)
python  theme={null}
def track_collaboration(output):
    """Track collaboration patterns"""
    if "Delegate work to coworker" in output.raw:
        print("🤝 Delegation occurred")
    if "Ask question to coworker" in output.raw:
        print("❓ Question asked")

crew = Crew(
    agents=[...],
    tasks=[...],
    step_callback=track_collaboration,  # Monitor collaboration
    verbose=True
)
python  theme={null}
agent = Agent(
    role="Content Lead",
    memory=True,  # Remembers past interactions
    allow_delegation=True,
    verbose=True
)
```

Com a memória ativada, os agentes aprendem com colaborações anteriores e aprimoram suas decisões de delegação ao longo do tempo.

* **Teste os exemplos**: Comece pelo exemplo básico de colaboração
* **Experimente diferentes papéis**: Teste combinações variadas de papéis de agentes
* **Monitore as interações**: Use `verbose=True` para ver a colaboração em ação
* **Otimize descrições de tarefas**: Tarefas claras geram melhor colaboração
* **Escale**: Experimente processos hierárquicos para projetos complexos

A colaboração transforma agentes de IA individuais em equipes poderosas capazes de enfrentar desafios complexos e multifacetados juntos.

**Examples:**

Example 1 (unknown):
```unknown
### Monitoramento da Colaboração
```

Example 2 (unknown):
```unknown
## Memória e Aprendizado

Permita que agentes se lembrem de colaborações passadas:
```

---

## Use custom embeddings with the tool

**URL:** llms-txt#use-custom-embeddings-with-the-tool

**Contents:**
- 오류 처리
- 환경 변수

from crewai_tools import QdrantConfig

tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_url",
        qdrant_api_key="your_key",
        collection_name="your_collection"
    ),
    custom_embedding_fn=custom_embeddings  # Pass your custom function
)
bash  theme={null}
export QDRANT_URL="your_qdrant_url"  # If not provided in constructor
export QDRANT_API_KEY="your_api_key"  # If not provided in constructor
export OPENAI_API_KEY="your_openai_key"  # If using default embeddings
```

**Examples:**

Example 1 (unknown):
```unknown
## 오류 처리

이 도구는 다음과 같은 특정 오류를 처리합니다:

* `qdrant-client`가 설치되어 있지 않으면 ImportError를 발생시킵니다 (자동 설치 옵션 제공)
* `QDRANT_URL`이 설정되어 있지 않으면 ValueError를 발생시킵니다
* 누락된 경우 `uv add qdrant-client`를 사용하여 `qdrant-client` 설치를 안내합니다

## 환경 변수

필수 환경 변수:
```

---

## Processos Sequenciais

**URL:** llms-txt#processos-sequenciais

**Contents:**
- Introdução
- Visão Geral do Processo Sequencial
  - Principais Características
- Implementando o Processo Sequencial

Source: https://docs.crewai.com/pt-BR/learn/sequential-process

Um guia abrangente para utilizar os processos sequenciais na execução de tarefas em projetos CrewAI.

O CrewAI oferece uma estrutura flexível para execução de tarefas de maneira estruturada, suportando tanto processos sequenciais quanto hierárquicos.
Este guia descreve como implementar esses processos de forma eficaz para garantir execução eficiente das tarefas e a conclusão do projeto.

## Visão Geral do Processo Sequencial

O processo sequencial garante que as tarefas sejam executadas uma após a outra, seguindo um progresso linear.
Essa abordagem é ideal para projetos nos quais as tarefas precisam ser concluídas em uma ordem específica.

### Principais Características

* **Fluxo Linear de Tarefas**: Garante o progresso ordenado ao tratar tarefas em uma sequência pré-determinada.
* **Simplicidade**: Melhor opção para projetos com tarefas claras e passo a passo.
* **Fácil Monitoramento**: Facilita o acompanhamento da conclusão das tarefas e do progresso do projeto.

## Implementando o Processo Sequencial

Para utilizar o processo sequencial, monte sua crew e defina as tarefas na ordem em que devem ser executadas.

```python Code theme={null}
from crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput

---

## Use with an agent

**URL:** llms-txt#use-with-an-agent

agent = Agent(
    role="Research Assistant",
    goal="Find and analyze information",
    backstory="You are a research assistant.",
    llm=custom_llm
)

---

## Perform a search with custom parameters

**URL:** llms-txt#perform-a-search-with-custom-parameters

**Contents:**
- 반환 형식
- 오류 처리
- 결론

results = linkup_tool.run(
    query="Women Nobel Prize Physics",
    depth="deep",
    output_type="searchResults"
)
json  theme={null}
{
  "success": true,
  "results": [
    {
      "name": "Result Title",
      "url": "https://example.com/result",
      "content": "Content of the result..."
    },
    // Additional results...
  ]
}
json  theme={null}
{
  "success": false,
  "error": "Error message"
}
```

이 도구는 API 오류를 우아하게 처리하고 구조화된 피드백을 제공합니다. API 요청이 실패할 경우, 도구는 `success: false`와 오류 메시지가 포함된 딕셔너리를 반환합니다.

`LinkupSearchTool`은 Linkup의 컨텍스트 기반 정보 검색 기능을 CrewAI agent에 원활하게 통합할 수 있는 방법을 제공합니다. 이 도구를 활용하여 agent는 의사 결정 및 작업 수행을 향상시키기 위해 관련성 높고 최신의 정보에 접근할 수 있습니다.

**Examples:**

Example 1 (unknown):
```unknown
## 반환 형식

도구는 다음과 같은 형식으로 결과를 반환합니다:
```

Example 2 (unknown):
```unknown
오류가 발생한 경우 응답은 다음과 같습니다:
```

---

## Both stored in same ChromaDB instance but different collections

**URL:** llms-txt#both-stored-in-same-chromadb-instance-but-different-collections

---

## `ScrapegraphScrapeTool`

**URL:** llms-txt#`scrapegraphscrapetool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

A `ScrapegraphScrapeTool` foi projetada para utilizar a API SmartScraper da Scrapegraph AI e extrair conteúdo de sites de maneira inteligente. Esta ferramenta oferece recursos avançados de web scraping com extração de conteúdo potencializada por IA, tornando-se ideal para coleta de dados direcionada e tarefas de análise de conteúdo. Diferente dos scrapers tradicionais, ela entende o contexto e a estrutura das páginas da web para extrair as informações mais relevantes, com base em instruções em linguagem natural.

Para utilizar esta ferramenta, é necessário instalar o cliente Python do Scrapegraph:

Você também precisa definir sua chave de API do Scrapegraph como uma variável de ambiente:

Você pode obter uma chave de API em [Scrapegraph AI](https://scrapegraphai.com).

## Passos para Começar

Para usar efetivamente a `ScrapegraphScrapeTool`, siga estes passos:

1. **Instale as dependências**: Instale o pacote necessário usando o comando acima.
2. **Configure a chave de API**: Defina sua chave de API do Scrapegraph como variável de ambiente ou forneça-a durante a inicialização.
3. **Inicialize a ferramenta**: Crie uma instância da ferramenta com os parâmetros necessários.
4. **Defina instruções de extração**: Crie prompts em linguagem natural para guiar a extração de conteúdos específicos.

O exemplo a seguir demonstra como usar a `ScrapegraphScrapeTool` para extrair conteúdo de um site:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import ScrapegraphScrapeTool

**Examples:**

Example 1 (unknown):
```unknown
Você também precisa definir sua chave de API do Scrapegraph como uma variável de ambiente:
```

Example 2 (unknown):
```unknown
Você pode obter uma chave de API em [Scrapegraph AI](https://scrapegraphai.com).

## Passos para Começar

Para usar efetivamente a `ScrapegraphScrapeTool`, siga estes passos:

1. **Instale as dependências**: Instale o pacote necessário usando o comando acima.
2. **Configure a chave de API**: Defina sua chave de API do Scrapegraph como variável de ambiente ou forneça-a durante a inicialização.
3. **Inicialize a ferramenta**: Crie uma instância da ferramenta com os parâmetros necessários.
4. **Defina instruções de extração**: Crie prompts em linguagem natural para guiar a extração de conteúdos específicos.

## Exemplo

O exemplo a seguir demonstra como usar a `ScrapegraphScrapeTool` para extrair conteúdo de um site:
```

---

## 웹후크 자동화

**URL:** llms-txt#웹후크-자동화

**Contents:**
- Webhook 설정하기
- Webhook 출력 예시

Source: https://docs.crewai.com/ko/enterprise/guides/webhook-automation

ActivePieces, Zapier, Make.com과 같은 플랫폼을 사용하여 CrewAI AMP 워크플로우를 웹후크로 자동화하세요

CrewAI AMP를 사용하면 웹훅을 통해 워크플로우를 자동화할 수 있습니다. 이 문서에서는 웹훅을 설정하고 사용하는 과정을 안내하며, Zapier와 Make.com과 유사한 워크플로우 자동화 플랫폼인 ActivePieces와의 통합에 중점을 두고 crew 실행을 시작하는 방법을 설명합니다.

<Steps>
  <Step title="Kickoff 인터페이스 접근">
    * CrewAI AMP 대시보드로 이동하세요.
    * crew 실행을 시작할 때 사용하는 `/kickoff` 섹션을 찾으세요.
      <Frame>
        <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=4e6a4b1f098388c7f76e91c25ed4b077" alt="Kickoff 인터페이스" data-og-width="670" width="670" data-og-height="358" height="358" data-path="images/enterprise/kickoff-interface.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=31eccbe3c20da734c90a1b2dd681261d 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b8f8311eeece00d69760069cf8f218cf 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=cd690e83cafc2b4675f5343d779fd413 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=640bf42c471ed898f434ff1b837aaf3f 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2ea591f56996cddcd1ab99a6ca951050 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/kickoff-interface.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c76d12bbd6580f8211a0c75c58105f41 2500w" />
      </Frame>
  </Step>

<Step title="JSON Content 구성하기">
    JSON Content 섹션에서 다음 정보를 입력해야 합니다:

* **inputs**: 다음 항목이 포함된 JSON 객체:
      * `company`: 회사 이름 (예: "tesla")
      * `product_name`: 제품 이름 (예: "crewai")
      * `form_response`: 응답 유형 (예: "financial")
      * `icp_description`: 이상적인 고객 프로필(ICP)에 대한 간략한 설명
      * `product_description`: 제품에 대한 짧은 설명
      * `taskWebhookUrl`, `stepWebhookUrl`, `crewWebhookUrl`: 다양한 webhook 엔드포인트의 URL (ActivePieces, Zapier, Make.com 또는 기타 호환 플랫폼)
  </Step>

<Step title="ActivePieces와 통합하기">
    이 예시에서는 ActivePieces를 사용합니다. 또한 Zapier, Make.com 등 다른 플랫폼도 사용할 수 있습니다.

1. ActivePieces에서 새 flow를 설정하세요.

2. 트리거를 추가하세요 (예: `Every Day` 스케줄).
       <Frame>
         <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1a52fc1bb47bef6228955360d00f190f" alt="ActivePieces 트리거" data-og-width="595" width="595" data-og-height="773" height="773" data-path="images/enterprise/activepieces-trigger.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a08bb69bed1a61d5e8febbfe10ca5e7f 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=b1b5e3f75dc328b09023661ce318b68b 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a64f6e3cfd68c9c66e4248cf92e2f7f1 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=aedf530314a9542c8f217ba77feec4e8 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=95f0dc03528daddca61ad04822e7ba7c 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-trigger.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=48e52a1d3960d50b027f8c92f4a62e11 2500w" />
       </Frame>

3. HTTP 액션 단계를 추가하세요.
       * 액션을 `Send HTTP request`로 설정하세요.

* 메소드는 `POST`로 사용하세요.

* URL은 CrewAI AMP kickoff 엔드포인트로 설정하세요.

* 필요한 헤더 추가 (예: `Bearer Token`)
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=602a5ed1aa2b462b0a81a122a5e2d35f" alt="ActivePieces 헤더" data-og-width="449" width="449" data-og-height="572" height="572" data-path="images/enterprise/activepieces-headers.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=fb1852f1834f3ca324d88201890454c2 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3ac86c364aa02800cb7563d6f7a0cc4b 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1433e902dc31e3c5bba03cea45fca103 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=9ca4bc723b91d7681c7798019f933e00 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=d6efc61f86f20c2d850bbc6e43057084 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-headers.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=508d671fe743548d52b5fa6f70d8c6f1 2500w" />
         </Frame>

* Body에는 2단계에서 구성한 JSON content를 포함하세요.
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f238e1630f7be667cce2d208315ddc75" alt="ActivePieces 본문" data-og-width="670" width="670" data-og-height="401" height="401" data-path="images/enterprise/activepieces-body.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=184acb105d21412a7a2cb184d57b067e 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=2820fd618992f3299a713701cf6d3a3e 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=988d687157f7dea236e152edb382ac4f 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=9c7603e394ffb44676be999c9bfd8843 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=84b3aa1d756e36d3578c11a81a1bba03 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-body.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f8ca588c964165c10b66d26478b1201a 2500w" />
         </Frame>

* crew가 미리 정의된 시간에 kickoff됩니다.
  </Step>

<Step title="Webhook 설정하기">
    1. ActivePieces에서 새 flow를 만들고 이름을 지정하세요.
       <Frame>
         <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c23af88ea2df7919f680706318eb1506" alt="ActivePieces Flow" data-og-width="544" width="544" data-og-height="683" height="683" data-path="images/enterprise/activepieces-flow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3efbff7b8131db3e87a41b0885447729 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1993b2b3ba57a859e42efcf21737c351 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3f46a4b1b2a17fcb0c0f3a9373699b5a 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3eff0450a0f63e2ed5b00797ee1295ea 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f3ca2cd9eb16b9f4642a27df234b191c 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-flow.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=ffa10bab192e9b54be9ad3df31ce9036 2500w" />
       </Frame>

2. 트리거로 webhook 단계를 추가하세요:
       * 트리거 유형으로 `Catch Webhook`을 선택하세요.

* 이 작업을 통해 HTTP 요청을 수신하고 flow를 트리거하는 고유 URL이 생성됩니다.
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=8236fd9a97149eff4fd86f1c9a9b0f1a" alt="ActivePieces Webhook" data-og-width="451" width="451" data-og-height="488" height="488" data-path="images/enterprise/activepieces-webhook.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=67e441a99da496ffc5c7267f7a9edf38 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=bd59361f9c3c3cc590116b69ae938e62 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6baa9171275b63542d4518d517def191 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=d2ca4c48d4c27d35f86634a8cff980aa 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=791a725473ebaa655f55060dc60ba4a2 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-webhook.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c84dd08fd3ec706b43868a9a7b5629a8 2500w" />
         </Frame>

* 이메일이 crew webhook 본문 텍스트를 사용하도록 구성하세요.
         <Frame>
           <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=484c8d88ed96322d21894e9663f5fc4a" alt="ActivePieces 이메일" data-og-width="461" width="461" data-og-height="518" height="518" data-path="images/enterprise/activepieces-email.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=619ef405e48854a83bfdfcc2d6ef44ec 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=43448b60f1c1686da67239865b31586c 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=79a570bad87d3beeebe8f87437823cac 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=180ce65773e5fd6007f08fa159f21dfb 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=80df8a27d8ba193f531db980a9697f6a 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/activepieces-email.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=a8e77053f8fed779ccff7474435f3cc8 2500w" />
         </Frame>
  </Step>
</Steps>

**참고:** kickoff 요청에 제공된 모든 `meta` 객체는 모든 webhook 페이로드에 포함되어, 전체 crew 실행 생명주기에 걸쳐 요청을 추적하고 컨텍스트를 유지할 수 있습니다.

<Tabs>
  <Tab title="Step Webhook">
    `stepWebhookUrl` - 각 agent의 inner thought가 실행될 때마다 호출되는 콜백

<Tab title="Task Webhook">
    `taskWebhookUrl` - 각 task가 종료될 때마다 호출되는 콜백

<Tab title="Crew Webhook">
    `crewWebhookUrl` - crew 실행 종료 시 호출되는 콜백

**Examples:**

Example 1 (unknown):
```unknown
</Tab>

  <Tab title="Task Webhook">
    `taskWebhookUrl` - 각 task가 종료될 때마다 호출되는 콜백
```

Example 2 (unknown):
```unknown
</Tab>

  <Tab title="Crew Webhook">
    `crewWebhookUrl` - crew 실행 종료 시 호출되는 콜백
```

---

## Initialize the tool with custom parameters

**URL:** llms-txt#initialize-the-tool-with-custom-parameters

**Contents:**
- Parâmetros
  - Parâmetros do SnowflakeConfig
  - Parâmetros do SnowflakeSearchTool
- Uso

snowflake_tool = SnowflakeSearchTool(
    config=config,
    pool_size=10,
    max_retries=5,
    retry_delay=2.0,
    enable_caching=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros

### Parâmetros do SnowflakeConfig

A classe `SnowflakeConfig` aceita os seguintes parâmetros:

* **account**: Obrigatório. Identificador da conta Snowflake.
* **user**: Obrigatório. Nome de usuário do Snowflake.
* **password**: Opcional\*. Senha do Snowflake.
* **private\_key\_path**: Opcional\*. Caminho para o arquivo de chave privada (alternativa à senha).
* **warehouse**: Obrigatório. Nome do warehouse do Snowflake.
* **database**: Obrigatório. Banco de dados padrão.
* **snowflake\_schema**: Obrigatório. Schema padrão.
* **role**: Opcional. Papel de usuário Snowflake.
* **session\_parameters**: Opcional. Parâmetros de sessão personalizados como dicionário.

\*É necessário fornecer `password` ou `private_key_path`.

### Parâmetros do SnowflakeSearchTool

O `SnowflakeSearchTool` aceita os seguintes parâmetros durante a inicialização:

* **config**: Obrigatório. Um objeto `SnowflakeConfig` contendo detalhes da conexão.
* **pool\_size**: Opcional. Número de conexões no pool. O padrão é 5.
* **max\_retries**: Opcional. Número máximo de tentativas para consultas que falharem. Padrão é 3.
* **retry\_delay**: Opcional. Intervalo entre tentativas em segundos. Padrão é 1.0.
* **enable\_caching**: Opcional. Define se o cache de resultados de consultas será habilitado. Padrão é True.

## Uso

Ao utilizar o `SnowflakeSearchTool`, você deve fornecer os seguintes parâmetros:

* **query**: Obrigatório. Consulta SQL a ser executada.
* **database**: Opcional. Sobrescreve o banco de dados padrão especificado na configuração.
* **snowflake\_schema**: Opcional. Sobrescreve o schema padrão especificado na configuração.
* **timeout**: Opcional. Tempo limite da consulta em segundos. O padrão é 300.

A ferramenta retornará os resultados da consulta como uma lista de dicionários, onde cada dicionário representa uma linha com os nomes das colunas como chaves.
```

---

## Initialize the tool for general YouTube video searches

**URL:** llms-txt#initialize-the-tool-for-general-youtube-video-searches

youtube_search_tool = YoutubeVideoSearchTool()

---

## `BraveSearchTool`

**URL:** llms-txt#`bravesearchtool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

Esta ferramenta foi desenvolvida para realizar buscas na web utilizando a Brave Search API. Ela permite que você pesquise na internet com uma consulta especificada e recupere resultados relevantes. A ferramenta suporta a personalização do número de resultados e buscas específicas por país.

Para incorporar esta ferramenta ao seu projeto, siga as instruções de instalação abaixo:

## Passos para Começar

Para utilizar o `BraveSearchTool` de forma eficaz, siga estes passos:

1. **Instalação do Pacote**: Confirme que o pacote `crewai[tools]` está instalado no seu ambiente Python.
2. **Obtenção da Chave de API**: Obtenha uma chave de API do Brave Search registrando-se em [Brave Search API](https://api.search.brave.com/app/keys).
3. **Configuração do Ambiente**: Armazene a chave de API obtida em uma variável de ambiente chamada `BRAVE_API_KEY` para facilitar seu uso pela ferramenta.

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca com uma determinada consulta:

```python Code theme={null}
from crewai_tools import BraveSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para utilizar o `BraveSearchTool` de forma eficaz, siga estes passos:

1. **Instalação do Pacote**: Confirme que o pacote `crewai[tools]` está instalado no seu ambiente Python.
2. **Obtenção da Chave de API**: Obtenha uma chave de API do Brave Search registrando-se em [Brave Search API](https://api.search.brave.com/app/keys).
3. **Configuração do Ambiente**: Armazene a chave de API obtida em uma variável de ambiente chamada `BRAVE_API_KEY` para facilitar seu uso pela ferramenta.

## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca com uma determinada consulta:
```

---

## Escolha qual LLM usar para cada agente conforme necessário

**URL:** llms-txt#escolha-qual-llm-usar-para-cada-agente-conforme-necessário

**Contents:**
- Configure Governança Corporativa para o CrewAI
- Perguntas Frequentes
- Recursos

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=openai_llm  # Use anthropic_llm para Anthropic
)
json  theme={null}
       {
           "virtual_key": "YOUR_VIRTUAL_KEY_FROM_STEP1",
          	"override_params": {
             "model": "gpt-4o" // Nome do seu modelo preferido
           }
       }
       python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import PORTKEY_GATEWAY_URL

# Configure o LLM com sua chave de API
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="YOUR_PORTKEY_API_KEY"
    )

# Crie agente com LLM habilitado para Portkey
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    json  theme={null}
    {
    	"strategy": {
    		"mode": "single"
    	},
    	"targets": [
    		{
    			"virtual_key": "YOUR_OPENAI_VIRTUAL_KEY",
    			"override_params": {
    				"model": "gpt-4o"
    			}
    		}
    	]
    }
    python  theme={null}
    from portkey_ai import Portkey

portkey = Portkey(api_key="YOUR_ADMIN_API_KEY")

api_key = portkey.api_keys.create(
        name="engineering-team",
        type="organisation",
        workspace_id="YOUR_WORKSPACE_ID",
        defaults={
            "config_id": "your-config-id",
            "metadata": {
                "environment": "production",
                "department": "engineering"
            }
        },
        scopes=["logs.view", "configs.read"]
    )
    ```

Para instruções detalhadas de gerenciamento de chaves, veja nossa [documentação de API Keys](/pt-BR/api-reference/admin-api/control-plane/api-keys/create-api-key).
  </Accordion>

<Accordion title="Etapa 4: Implante & Monitore">
    ### Etapa 4: Implante & Monitore

Após distribuir as chaves de API para os membros da equipe, seu setup corporativo CrewAI está pronto. Cada membro pode agora usar suas chaves designadas com os níveis de acesso e controles de orçamento apropriados.

Monitore o uso no painel Portkey:

* Rastreamento de custos por departamento
    * Padrões de uso de modelos
    * Volume de requisições
    * Taxa de erros
  </Accordion>
</AccordionGroup>

<Note>
  ### Recursos Corporativos Agora Disponíveis

**Sua integração CrewAI agora conta com:**

* Controles de orçamento departamental
  * Governança de acesso a modelos
  * Rastreamento de uso & atribuição
  * Guardrails de segurança
  * Recursos de confiabilidade
</Note>

## Perguntas Frequentes

<AccordionGroup>
  <Accordion title="Como o Portkey aprimora o CrewAI?">
    Portkey adiciona prontidão para produção ao CrewAI através de observabilidade abrangente (traces, logs, métricas), recursos de confiabilidade (fallbacks, tentativas automáticas, cache) e acesso a mais de 200 LLMs por meio de uma interface unificada. Isso facilita depurar, otimizar e escalar suas aplicações de agentes.
  </Accordion>

<Accordion title="Posso usar Portkey com aplicações CrewAI existentes?">
    Sim! Portkey integra-se perfeitamente a aplicações CrewAI existentes. Basta atualizar o código de configuração do LLM com a versão habilitada do Portkey. O restante do seu código de agente e crew permanece inalterado.
  </Accordion>

<Accordion title="Portkey funciona com todos os recursos do CrewAI?">
    Portkey suporta todos os recursos do CrewAI, incluindo agentes, ferramentas, workflows human-in-the-loop e todos os tipos de processo de tarefas (sequencial, hierárquico, etc.). Ele adiciona observabilidade e confiabilidade sem limitar nenhuma funcionalidade do framework.
  </Accordion>

<Accordion title="Posso rastrear o uso em múltiplos agentes de um crew?">
    Sim, o Portkey permite que você use um `trace_id` consistente em múltiplos agentes de um crew para rastrear todo o fluxo de trabalho. Isso é especialmente útil para crews complexos onde você deseja entender o caminho completo de execução entre os agentes.
  </Accordion>

<Accordion title="Como filtro logs e traces para execuções específicas de crew?">
    O Portkey permite adicionar metadados personalizados à configuração do seu LLM, que podem ser usados para filtragem. Adicione campos como `crew_name`, `crew_type`, ou `session_id` para encontrar e analisar facilmente execuções específicas do crew.
  </Accordion>

<Accordion title="Posso usar minhas próprias chaves de API com o Portkey?">
    Sim! O Portkey utiliza suas próprias chaves de API dos provedores LLM. Elas são armazenadas com segurança como virtual keys, permitindo que você gerencie e gire as chaves facilmente sem alterar seu código.
  </Accordion>
</AccordionGroup>

<CardGroup cols="3">
  <Card title="CrewAI Docs" icon="book" href="https://docs.crewai.com/">
    <p>Documentação oficial do CrewAI</p>
  </Card>

<Card title="Agende uma Demonstração" icon="calendar" href="https://calendly.com/portkey-ai">
    <p>Receba orientação personalizada sobre como implementar essa integração</p>
  </Card>
</CardGroup>

**Examples:**

Example 1 (unknown):
```unknown
Portkey oferece acesso a LLMs de provedores como:

* OpenAI (GPT-4o, GPT-4 Turbo, etc.)
* Anthropic (Claude 3.5 Sonnet, Claude 3 Opus, etc.)
* Mistral AI (Mistral Large, Mistral Medium, etc.)
* Google Vertex AI (Gemini 1.5 Pro, etc.)
* Cohere (Command, Command-R, etc.)
* AWS Bedrock (Claude, Titan, etc.)
* Modelos locais/privados

<Card title="Provedores Suportados" icon="server" href="https://portkey.ai/docs/integrations/llms">
  Veja a lista completa de provedores LLM suportados pelo Portkey
</Card>

## Configure Governança Corporativa para o CrewAI

**Por que Governança Corporativa?**
Se você utiliza CrewAI dentro de sua organização, é importante considerar diversos aspectos de governança:

* **Gestão de Custos**: Controlar e rastrear os gastos com IA entre equipes
* **Controle de Acesso**: Gerenciar quais equipes podem usar modelos específicos
* **Analytics de Uso**: Compreender como a IA está sendo utilizada na organização
* **Segurança & Compliance**: Manutenção de padrões corporativos de segurança
* **Confiabilidade**: Garantir serviço consistente para todos os usuários

O Portkey adiciona uma camada abrangente de governança para atender a essas necessidades corporativas. Vamos implementar esses controles passo a passo.

<Steps>
  <Step title="Crie uma Virtual Key">
    Virtual Keys são a maneira segura do Portkey para gerenciar as chaves de API dos provedores de LLM. Elas fornecem controles essenciais como:

    * Limites de orçamento para uso da API
    * Capacidade de rate limiting
    * Armazenamento seguro das chaves de API

    Para criar uma virtual key:
    Vá até [Virtual Keys](https://app.portkey.ai/virtual-keys) no app Portkey. Salve e copie o ID da virtual key

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Virtual%20Key%20from%20Portkey%20Docs.png" width="500" />
    </Frame>

    <Note>
      Salve o ID da sua virtual key – você precisará dele no próximo passo.
    </Note>
  </Step>

  <Step title="Crie um Config Padrão">
    Os Configs no Portkey definem como suas requisições são roteadas, com recursos como roteamento avançado, fallbacks e tentativas automáticas.

    Para criar seu config:

    1. Vá até [Configs](https://app.portkey.ai/configs) no painel Portkey
    2. Crie um novo config com:
```

Example 2 (unknown):
```unknown
3. Salve e anote o nome do Config para o próximo passo

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Config.png" width="500" />
    </Frame>
  </Step>

  <Step title="Configure a Chave de API Portkey">
    Agora crie uma chave de API Portkey e anexe a config criada no Passo 2:

    1. Vá até [API Keys](https://app.portkey.ai/api-keys) na Portkey e crie uma nova chave de API
    2. Selecione sua config do `Passo 2`
    3. Gere e salve sua chave de API

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20API%20Key.png" width="500" />
    </Frame>
  </Step>

  <Step title="Conecte ao CrewAI">
    Após configurar sua chave de API Portkey com a config anexada, conecte-a aos seus agentes CrewAI:
```

Example 3 (unknown):
```unknown
</Step>
</Steps>

<AccordionGroup>
  <Accordion title="Etapa 1: Implementar Controles de Orçamento & Rate Limits">
    ### Etapa 1: Implementar Controles de Orçamento & Rate Limits

    Virtual Keys permitem controle granular sobre o acesso ao LLM por equipe/departamento. Isso ajuda você a:

    * Definir [limites de orçamento](https://portkey.ai/docs/product/ai-gateway/virtual-keys/budget-limits)
    * Prevenir picos inesperados de uso através de Rate limits
    * Rastrear gastos por departamento

    #### Configurando controles específicos de departamento:

    1. Vá até [Virtual Keys](https://app.portkey.ai/virtual-keys) no painel Portkey
    2. Crie uma nova Virtual Key para cada departamento com limites de orçamento e rate limits
    3. Configure limites específicos por departamento

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Virtual%20Key%20from%20Portkey%20Docs.png" width="500" />
    </Frame>
  </Accordion>

  <Accordion title="Etapa 2: Definir Regras de Acesso a Modelos">
    ### Etapa 2: Definir Regras de Acesso a Modelos

    À medida que o uso de IA cresce, controlar quais equipes têm acesso a quais modelos se torna fundamental. Os Configs do Portkey fornecem essa camada de controle com recursos como:

    #### Recursos de Controle de Acesso:

    * **Restrições de Modelo**: Limite o acesso a modelos específicos
    * **Proteção de Dados**: Implemente guardrails para dados sensíveis
    * **Controles de Confiabilidade**: Adicione fallbacks e tentativas automáticas

    #### Exemplo de Configuração:

    Aqui está um exemplo básico para rotear requisições ao OpenAI, usando especificamente o GPT-4o:
```

Example 4 (unknown):
```unknown
Crie seu config na [página de Configs](https://app.portkey.ai/configs) no painel do Portkey.

    <Note>
      Os configs podem ser atualizados a qualquer momento para ajustar controles sem afetar aplicações em execução.
    </Note>
  </Accordion>

  <Accordion title="Etapa 3: Implementar Controles de Acesso">
    ### Etapa 3: Implementar Controles de Acesso

    Crie chaves de API específicas por usuário que automaticamente:

    * Rastreiam uso por usuário/equipe com o auxílio das virtual keys
    * Aplicam configs adequadas para rotear requisições
    * Coletam metadados relevantes para filtragem de logs
    * Impõem permissões de acesso

    Crie chaves de API através de:

    * [Portkey App](https://app.portkey.ai/)
    * [API Key Management API](/pt-BR/api-reference/admin-api/control-plane/api-keys/create-api-key)

    Exemplo usando Python SDK:
```

---

## Integração com Gmail

**URL:** llms-txt#integração-com-gmail

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com o Gmail
  - 1. Conecte sua Conta do Gmail
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de Agente Gmail

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/gmail

Gerenciamento de e-mails e contatos com a integração do Gmail para o CrewAI.

Permita que seus agentes gerenciem e-mails, contatos e rascunhos através do Gmail. Envie e-mails, pesquise mensagens, gerencie contatos, crie rascunhos e otimize suas comunicações por e-mail com automação impulsionada por IA.

Antes de usar a integração com o Gmail, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta do Gmail com as permissões adequadas
* Conectou sua conta do Gmail através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com o Gmail

### 1. Conecte sua Conta do Gmail

1. Navegue até [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Gmail** na seção de Integrações de Autenticação
3. Clique em **Conectar** e conclua o fluxo OAuth
4. Conceda as permissões necessárias para o gerenciamento de e-mail e contato
5. Copie seu Token Empresarial em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="gmail/send_email">
    **Descrição:** Envia um e-mail pelo Gmail.

* `toRecipients` (array, obrigatório): Para - Especifique os destinatários como uma única string ou um array JSON.
      
    * `from` (string, obrigatório): De - Especifique o e-mail do remetente.
    * `subject` (string, obrigatório): Assunto - Especifique o assunto da mensagem.
    * `messageContent` (string, obrigatório): Conteúdo da Mensagem - Especifique o conteúdo do e-mail em texto simples ou HTML.
    * `attachments` (string, opcional): Anexos - Aceita um único objeto de arquivo ou um array JSON de objetos de arquivo.
    * `additionalHeaders` (object, opcional): Cabeçalhos Adicionais - Especifique quaisquer campos de cabeçalho adicionais aqui.
      
  </Accordion>

<Accordion title="gmail/get_email_by_id">
    **Descrição:** Obtém um e-mail pelo ID no Gmail.

* `userId` (string, obrigatório): ID do Usuário - Especifique o endereço de e-mail do usuário. (exemplo: "[user@domain.com](mailto:user@domain.com)").
    * `messageId` (string, obrigatório): ID da Mensagem - Especifique o ID da mensagem a ser recuperada.
  </Accordion>

<Accordion title="gmail/fetch_emails">
    **Descrição:** Pesquisa e-mails no Gmail usando filtros avançados.

* `emailFilterFormula` (object, opcional): Um filtro na forma normal disjuntiva - OU de grupos E de condições únicas.
      
      Campos disponíveis: `from`, `to`, `date`, `label`, `subject`, `cc`, `bcc`, `category`, `deliveredto:`, `size`, `filename`, `older_than`, `newer_than`, `list`, `is:important`, `is:unread`, `is:snoozed`, `is:starred`, `is:read`, `has:drive`, `has:document`, `has:spreadsheet`, `has:presentation`, `has:attachment`, `has:youtube`, `has:userlabels`
    * `paginationParameters` (object, opcional): Parâmetros de Paginação.
      
  </Accordion>

<Accordion title="gmail/delete_email">
    **Descrição:** Exclui um e-mail no Gmail.

* `userId` (string, obrigatório): ID do Usuário - Especifique o endereço de e-mail do usuário. (exemplo: "[user@domain.com](mailto:user@domain.com)").
    * `messageId` (string, obrigatório): ID da Mensagem - Especifique o ID da mensagem para enviar para a lixeira.
  </Accordion>

<Accordion title="gmail/create_a_contact">
    **Descrição:** Cria um contato no Gmail.

* `givenName` (string, obrigatório): Primeiro Nome - Especifique o Primeiro Nome do contato a ser criado. (exemplo: "João").
    * `familyName` (string, obrigatório): Sobrenome - Especifique o Sobrenome do contato a ser criado. (exemplo: "Silva").
    * `email` (string, obrigatório): E-mail - Especifique o endereço de e-mail do contato a ser criado.
    * `additionalFields` (object, opcional): Campos Adicionais - Informações adicionais de contato.
      
  </Accordion>

<Accordion title="gmail/get_contact_by_resource_name">
    **Descrição:** Obtém um contato pelo nome do recurso no Gmail.

* `resourceName` (string, obrigatório): Nome do Recurso - Especifique o nome do recurso do contato a ser buscado.
  </Accordion>

<Accordion title="gmail/search_for_contact">
    **Descrição:** Pesquisa um contato no Gmail.

* `searchTerm` (string, obrigatório): Termo - Especifique um termo para buscar correspondências aproximadas ou exatas nos campos nome, apelido, endereços de e-mail, números de telefone ou organizações do contato.
  </Accordion>

<Accordion title="gmail/delete_contact">
    **Descrição:** Exclui um contato no Gmail.

* `resourceName` (string, obrigatório): Nome do Recurso - Especifique o nome do recurso do contato a ser excluído.
  </Accordion>

<Accordion title="gmail/create_draft">
    **Descrição:** Cria um rascunho no Gmail.

* `toRecipients` (array, opcional): Para - Especifique os destinatários como uma única string ou um array JSON.
      
    * `from` (string, opcional): De - Especifique o e-mail do remetente.
    * `subject` (string, opcional): Assunto - Especifique o assunto da mensagem.
    * `messageContent` (string, opcional): Conteúdo da Mensagem - Especifique o conteúdo do e-mail em texto simples ou HTML.
    * `attachments` (string, opcional): Anexos - Aceita um único objeto de arquivo ou um array JSON de objetos de arquivo.
    * `additionalHeaders` (object, opcional): Cabeçalhos Adicionais - Especifique quaisquer campos de cabeçalho adicionais aqui.
      
  </Accordion>
</AccordionGroup>

### Configuração Básica de Agente Gmail

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="gmail/send_email">
    **Descrição:** Envia um e-mail pelo Gmail.

    **Parâmetros:**

    * `toRecipients` (array, obrigatório): Para - Especifique os destinatários como uma única string ou um array JSON.
```

Example 4 (unknown):
```unknown
* `from` (string, obrigatório): De - Especifique o e-mail do remetente.
    * `subject` (string, obrigatório): Assunto - Especifique o assunto da mensagem.
    * `messageContent` (string, obrigatório): Conteúdo da Mensagem - Especifique o conteúdo do e-mail em texto simples ou HTML.
    * `attachments` (string, opcional): Anexos - Aceita um único objeto de arquivo ou um array JSON de objetos de arquivo.
    * `additionalHeaders` (object, opcional): Cabeçalhos Adicionais - Especifique quaisquer campos de cabeçalho adicionais aqui.
```

---

## Create a flow class

**URL:** llms-txt#create-a-flow-class

class MarketResearchFlow(Flow[MarketResearchState]):
    @start()
    def initialize_research(self) -> Dict[str, Any]:
        print(f"Starting market research for {self.state.product}")
        return {"product": self.state.product}

@listen(initialize_research)
    async def analyze_market(self) -> Dict[str, Any]:
        # Create an Agent for market research
        analyst = Agent(
            role="Market Research Analyst",
            goal=f"Analyze the market for {self.state.product}",
            backstory="You are an experienced market analyst with expertise in "
            "identifying market trends and opportunities.",
            tools=[SerperDevTool()],
            verbose=True,
        )

# Define the research query
        query = f"""
        Research the market for {self.state.product}. Include:
        1. Key market trends
        2. Market size
        3. Major competitors

Format your response according to the specified structure.
        """

# Execute the analysis with structured output format
        result = await analyst.kickoff_async(query, response_format=MarketAnalysis)
        if result.pydantic:
            print("result", result.pydantic)
        else:
            print("result", result)

# Return the analysis to update the state
        return {"analysis": result.pydantic}

@listen(analyze_market)
    def present_results(self, analysis) -> None:
        print("\nMarket Analysis Results")
        print("=====================")

if isinstance(analysis, dict):
            # If we got a dict with 'analysis' key, extract the actual analysis object
            market_analysis = analysis.get("analysis")
        else:
            market_analysis = analysis

if market_analysis and isinstance(market_analysis, MarketAnalysis):
            print("\nKey Market Trends:")
            for trend in market_analysis.key_trends:
                print(f"- {trend}")

print(f"\nMarket Size: {market_analysis.market_size}")

print("\nMajor Competitors:")
            for competitor in market_analysis.competitors:
                print(f"- {competitor}")
        else:
            print("No structured analysis data available.")
            print("Raw analysis:", analysis)

---

## Criar um índice

**URL:** llms-txt#criar-um-índice

index = VectorStoreIndex.from_documents(documents)

---

## 새 통합 문서 생성 작업

**URL:** llms-txt#새-통합-문서-생성-작업

create_workbook_task = Task(
    description="'월간보고서.xlsx'라는 이름으로 새 Excel 통합 문서를 만들고 '매출데이터'라는 초기 워크시트를 포함하세요.",
    agent=excel_agent,
    expected_output="새 통합 문서 '월간보고서.xlsx'가 '매출데이터' 워크시트와 함께 생성됨."
)

---

## Integração Microsoft Outlook

**URL:** llms-txt#integração-microsoft-outlook

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Microsoft Outlook
  - 1. Conecte sua Conta Microsoft
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Microsoft Outlook

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/microsoft_outlook

Gerenciamento de email, calendário e contatos com integração Microsoft Outlook para CrewAI.

Permita que seus agentes acessem e gerenciem emails, eventos de calendário e contatos do Outlook. Envie emails, recupere mensagens, gerencie eventos de calendário e organize contatos com automação alimentada por IA.

Antes de usar a integração Microsoft Outlook, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Microsoft com acesso ao Outlook
* Conectado sua conta Microsoft através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Microsoft Outlook

### 1. Conecte sua Conta Microsoft

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Microsoft Outlook** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a email, calendário e contatos
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="microsoft_outlook/get_messages">
    **Descrição:** Obter mensagens de email da caixa de correio do usuário.

* `top` (integer, opcional): Número de mensagens a recuperar (máx 1000). Padrão: 10.
    * `filter` (string, opcional): Expressão de filtro OData (ex: "isRead eq false").
    * `search` (string, opcional): String de consulta de pesquisa.
    * `orderby` (string, opcional): Ordenar por campo (ex: "receivedDateTime desc"). Padrão: "receivedDateTime desc".
    * `select` (string, opcional): Selecionar propriedades específicas para retornar.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
  </Accordion>

<Accordion title="microsoft_outlook/send_email">
    **Descrição:** Enviar uma mensagem de email.

* `to_recipients` (array, obrigatório): Array de endereços de email dos destinatários.
    * `cc_recipients` (array, opcional): Array de endereços de email dos destinatários em cópia.
    * `bcc_recipients` (array, opcional): Array de endereços de email dos destinatários em cópia oculta.
    * `subject` (string, obrigatório): Assunto do email.
    * `body` (string, obrigatório): Conteúdo do corpo do email.
    * `body_type` (string, opcional): Tipo de conteúdo do corpo. Opções: Text, HTML. Padrão: HTML.
    * `importance` (string, opcional): Nível de importância da mensagem. Opções: low, normal, high. Padrão: normal.
    * `reply_to` (array, opcional): Array de endereços de email para resposta.
    * `save_to_sent_items` (boolean, opcional): Se deve salvar a mensagem na pasta Itens Enviados. Padrão: true.
  </Accordion>

<Accordion title="microsoft_outlook/get_calendar_events">
    **Descrição:** Obter eventos de calendário do calendário do usuário.

* `top` (integer, opcional): Número de eventos a recuperar (máx 1000). Padrão: 10.
    * `skip` (integer, opcional): Número de eventos a pular. Padrão: 0.
    * `filter` (string, opcional): Expressão de filtro OData (ex: "start/dateTime ge '2024-01-01T00:00:00Z'").
    * `orderby` (string, opcional): Ordenar por campo (ex: "start/dateTime asc"). Padrão: "start/dateTime asc".
  </Accordion>

<Accordion title="microsoft_outlook/create_calendar_event">
    **Descrição:** Criar um novo evento de calendário.

* `subject` (string, obrigatório): Assunto/título do evento.
    * `body` (string, opcional): Corpo/descrição do evento.
    * `start_datetime` (string, obrigatório): Data e hora de início no formato ISO 8601 (ex: '2024-01-20T10:00:00').
    * `end_datetime` (string, obrigatório): Data e hora de término no formato ISO 8601.
    * `timezone` (string, opcional): Fuso horário (ex: 'Pacific Standard Time'). Padrão: UTC.
    * `location` (string, opcional): Local do evento.
    * `attendees` (array, opcional): Array de endereços de email dos participantes.
  </Accordion>

<Accordion title="microsoft_outlook/get_contacts">
    **Descrição:** Obter contatos do catálogo de endereços do usuário.

* `top` (integer, opcional): Número de contatos a recuperar (máx 1000). Padrão: 10.
    * `skip` (integer, opcional): Número de contatos a pular. Padrão: 0.
    * `filter` (string, opcional): Expressão de filtro OData.
    * `orderby` (string, opcional): Ordenar por campo (ex: "displayName asc"). Padrão: "displayName asc".
  </Accordion>

<Accordion title="microsoft_outlook/create_contact">
    **Descrição:** Criar um novo contato no catálogo de endereços do usuário.

* `displayName` (string, obrigatório): Nome de exibição do contato.
    * `givenName` (string, opcional): Primeiro nome do contato.
    * `surname` (string, opcional): Sobrenome do contato.
    * `emailAddresses` (array, opcional): Array de endereços de email. Cada item é um objeto com `address` (string) e `name` (string).
    * `businessPhones` (array, opcional): Array de números de telefone comerciais.
    * `homePhones` (array, opcional): Array de números de telefone residenciais.
    * `jobTitle` (string, opcional): Cargo do contato.
    * `companyName` (string, opcional): Nome da empresa do contato.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Microsoft Outlook

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="microsoft_outlook/get_messages">
    **Descrição:** Obter mensagens de email da caixa de correio do usuário.

    **Parâmetros:**

    * `top` (integer, opcional): Número de mensagens a recuperar (máx 1000). Padrão: 10.
    * `filter` (string, opcional): Expressão de filtro OData (ex: "isRead eq false").
    * `search` (string, opcional): String de consulta de pesquisa.
    * `orderby` (string, opcional): Ordenar por campo (ex: "receivedDateTime desc"). Padrão: "receivedDateTime desc".
    * `select` (string, opcional): Selecionar propriedades específicas para retornar.
    * `expand` (string, opcional): Expandir recursos relacionados inline.
  </Accordion>

  <Accordion title="microsoft_outlook/send_email">
    **Descrição:** Enviar uma mensagem de email.

    **Parâmetros:**

    * `to_recipients` (array, obrigatório): Array de endereços de email dos destinatários.
    * `cc_recipients` (array, opcional): Array de endereços de email dos destinatários em cópia.
    * `bcc_recipients` (array, opcional): Array de endereços de email dos destinatários em cópia oculta.
    * `subject` (string, obrigatório): Assunto do email.
    * `body` (string, obrigatório): Conteúdo do corpo do email.
    * `body_type` (string, opcional): Tipo de conteúdo do corpo. Opções: Text, HTML. Padrão: HTML.
    * `importance` (string, opcional): Nível de importância da mensagem. Opções: low, normal, high. Padrão: normal.
    * `reply_to` (array, opcional): Array de endereços de email para resposta.
    * `save_to_sent_items` (boolean, opcional): Se deve salvar a mensagem na pasta Itens Enviados. Padrão: true.
  </Accordion>

  <Accordion title="microsoft_outlook/get_calendar_events">
    **Descrição:** Obter eventos de calendário do calendário do usuário.

    **Parâmetros:**

    * `top` (integer, opcional): Número de eventos a recuperar (máx 1000). Padrão: 10.
    * `skip` (integer, opcional): Número de eventos a pular. Padrão: 0.
    * `filter` (string, opcional): Expressão de filtro OData (ex: "start/dateTime ge '2024-01-01T00:00:00Z'").
    * `orderby` (string, opcional): Ordenar por campo (ex: "start/dateTime asc"). Padrão: "start/dateTime asc".
  </Accordion>

  <Accordion title="microsoft_outlook/create_calendar_event">
    **Descrição:** Criar um novo evento de calendário.

    **Parâmetros:**

    * `subject` (string, obrigatório): Assunto/título do evento.
    * `body` (string, opcional): Corpo/descrição do evento.
    * `start_datetime` (string, obrigatório): Data e hora de início no formato ISO 8601 (ex: '2024-01-20T10:00:00').
    * `end_datetime` (string, obrigatório): Data e hora de término no formato ISO 8601.
    * `timezone` (string, opcional): Fuso horário (ex: 'Pacific Standard Time'). Padrão: UTC.
    * `location` (string, opcional): Local do evento.
    * `attendees` (array, opcional): Array de endereços de email dos participantes.
  </Accordion>

  <Accordion title="microsoft_outlook/get_contacts">
    **Descrição:** Obter contatos do catálogo de endereços do usuário.

    **Parâmetros:**

    * `top` (integer, opcional): Número de contatos a recuperar (máx 1000). Padrão: 10.
    * `skip` (integer, opcional): Número de contatos a pular. Padrão: 0.
    * `filter` (string, opcional): Expressão de filtro OData.
    * `orderby` (string, opcional): Ordenar por campo (ex: "displayName asc"). Padrão: "displayName asc".
  </Accordion>

  <Accordion title="microsoft_outlook/create_contact">
    **Descrição:** Criar um novo contato no catálogo de endereços do usuário.

    **Parâmetros:**

    * `displayName` (string, obrigatório): Nome de exibição do contato.
    * `givenName` (string, opcional): Primeiro nome do contato.
    * `surname` (string, opcional): Sobrenome do contato.
    * `emailAddresses` (array, opcional): Array de endereços de email. Cada item é um objeto com `address` (string) e `name` (string).
    * `businessPhones` (array, opcional): Array de números de telefone comerciais.
    * `homePhones` (array, opcional): Array de números de telefone residenciais.
    * `jobTitle` (string, opcional): Cargo do contato.
    * `companyName` (string, opcional): Nome da empresa do contato.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Microsoft Outlook
```

---

## Create an instance of your listener

**URL:** llms-txt#create-an-instance-of-your-listener

**Contents:**
  - Fontes de Knowledge Personalizadas
- Depuração e Solução de Problemas
  - Depurando Problemas de Knowledge

knowledge_monitor = KnowledgeMonitorListener()
python Code theme={null}
  from crewai import Agent, Task, Crew, Process, LLM
  from crewai.knowledge.source.base_knowledge_source import BaseKnowledgeSource
  import requests
  from datetime import datetime
  from typing import Dict, Any
  from pydantic import BaseModel, Field

class SpaceNewsKnowledgeSource(BaseKnowledgeSource):
      """Knowledge source that fetches data from Space News API."""

api_endpoint: str = Field(description="API endpoint URL")
      limit: int = Field(default=10, description="Number of articles to fetch")

def load_content(self) -> Dict[Any, str]:
          """Fetch and format space news articles."""
          try:
              response = requests.get(
                  f"{self.api_endpoint}?limit={self.limit}"
              )
              response.raise_for_status()

data = response.json()
              articles = data.get('results', [])

formatted_data = self.validate_content(articles)
              return {self.api_endpoint: formatted_data}
          except Exception as e:
              raise ValueError(f"Failed to fetch space news: {str(e)}")

def validate_content(self, articles: list) -> str:
          """Format articles into readable text."""
          formatted = "Space News Articles:\n\n"
          for article in articles:
              formatted += f"""
                  Title: {article['title']}
                  Published: {article['published_at']}
                  Summary: {article['summary']}
                  News Site: {article['news_site']}
                  URL: {article['url']}
                  -------------------"""
          return formatted

def add(self) -> None:
          """Process and store the articles."""
          content = self.load_content()
          for _, text in content.items():
              chunks = self._chunk_text(text)
              self.chunks.extend(chunks)

self._save_documents()

# Create knowledge source
  recent_news = SpaceNewsKnowledgeSource(
      api_endpoint="https://api.spaceflightnewsapi.net/v4/articles",
      limit=10,
  )

# Create specialized agent
  space_analyst = Agent(
      role="Space News Analyst",
      goal="Answer questions about space news accurately and comprehensively",
      backstory="""You are a space industry analyst with expertise in space exploration,
      satellite technology, and space industry trends. You excel at answering questions
      about space news and providing detailed, accurate information.""",
      knowledge_sources=[recent_news],
      llm=LLM(model="gpt-4", temperature=0.0)
  )

# Create task that handles user questions
  analysis_task = Task(
      description="Answer this question about space news: {user_question}",
      expected_output="A detailed answer based on the recent space news articles",
      agent=space_analyst
  )

# Create and run the crew
  crew = Crew(
      agents=[space_analyst],
      tasks=[analysis_task],
      verbose=True,
      process=Process.sequential
  )

# Example usage
  result = crew.kickoff(
      inputs={"user_question": "What are the latest developments in space exploration?"}
  )
  output Output theme={null}
  # Agent: Space News Analyst
  ## Task: Answer this question about space news: What are the latest developments in space exploration?

# Agent: Space News Analyst
  ## Final Answer:
  The latest developments in space exploration, based on recent space news articles, include the following:

1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)

2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)

3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)

4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)

5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)

6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)

7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)
  python  theme={null}
from crewai import Agent, Crew, Task
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

knowledge_source = StringKnowledgeSource(content="Test knowledge")

agent = Agent(
    role="Test Agent",
    goal="Test knowledge",
    backstory="Testing",
    knowledge_sources=[knowledge_source]
)

crew = Crew(agents=[agent], tasks=[Task(...)])

**Examples:**

Example 1 (unknown):
```unknown
Para mais informações sobre como usar eventos, consulte a documentação [Event Listeners](https://docs.crewai.com/concepts/event-listener).

### Fontes de Knowledge Personalizadas

O CrewAI permite que você crie fontes de knowledge personalizadas para qualquer tipo de dados estendendo a classe `BaseKnowledgeSource`. Vamos criar um exemplo prático que busca e processa artigos de notícias espaciais.

#### Exemplo de Fonte de Knowledge de Notícias Espaciais

<CodeGroup>
```

Example 2 (unknown):
```unknown

```

Example 3 (unknown):
```unknown
</CodeGroup>

## Depuração e Solução de Problemas

### Depurando Problemas de Knowledge

#### Verificar Inicialização de Knowledge do Agente
```

---

## Automação externa

**URL:** llms-txt#automação-externa

analysis_automation = InvokeCrewAIAutomationTool(
    crew_api_url="https://analysis-crew.acme.crewai.com",
    crew_bearer_token="YOUR_BEARER_TOKEN",
    crew_name="Analysis Automation",
    crew_description="Executa o pipeline de análise em produção",
)

---

## Scrape without markdown formatting for plain text

**URL:** llms-txt#scrape-without-markdown-formatting-for-plain-text

**Contents:**
- Use Cases
- Error Handling
- Security Considerations

plain_result = tool.run(
    url="https://docs.crewai.com",
    include_markdown=False
)

print("Markdown formatted content:")
print(markdown_result)

print("\nPlain text content:")
print(plain_result)
```

The `SerperScrapeWebsiteTool` is particularly useful for:

* **Content Analysis**: Extract and analyze website content for research purposes
* **Data Collection**: Gather structured information from web pages
* **Documentation Processing**: Convert web-based documentation into readable formats
* **Competitive Analysis**: Scrape competitor websites for market research
* **Content Migration**: Extract content from existing websites for migration purposes

The tool includes comprehensive error handling for:

* **Network Issues**: Handles connection timeouts and network errors gracefully
* **API Errors**: Provides detailed error messages for API-related issues
* **Invalid URLs**: Validates and reports issues with malformed URLs
* **Authentication**: Clear error messages for missing or invalid API keys

## Security Considerations

* Always store your `SERPER_API_KEY` in environment variables, never hardcode it in your source code
* Be mindful of rate limits imposed by the Serper API
* Respect robots.txt and website terms of service when scraping content
* Consider implementing delays between requests for large-scale scraping operations

---

## Quick fix: Enable automatic handling

**URL:** llms-txt#quick-fix:-enable-automatic-handling

agent.respect_context_window = True

---

## 동일한 시드로 항상 동일한 지문이 생성됨

**URL:** llms-txt#동일한-시드로-항상-동일한-지문이-생성됨

same_fingerprint = Fingerprint.generate(seed="my-agent-id")
assert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str

---

## Initialize the tool and add content

**URL:** llms-txt#initialize-the-tool-and-add-content

rag_tool = RagTool()
rag_tool.add(data_type="web_page", url="https://docs.crewai.com")
rag_tool.add(data_type="file", path="company_data.pdf")

---

## Initialize the tool for general YouTube channel searches

**URL:** llms-txt#initialize-the-tool-for-general-youtube-channel-searches

youtube_channel_tool = YoutubeChannelSearchTool()

---

## Pesquisa RAG em Vídeos do YouTube

**URL:** llms-txt#pesquisa-rag-em-vídeos-do-youtube

Source: https://docs.crewai.com/pt-BR/tools/search-research/youtubevideosearchtool

O `YoutubeVideoSearchTool` foi projetado para realizar uma busca RAG (Geração Auxiliada por Recuperação) no conteúdo de um vídeo do Youtube.

---

## To enable scrapping any website it finds during it's execution

**URL:** llms-txt#to-enable-scrapping-any-website-it-finds-during-it's-execution

tool = ScrapeWebsiteTool()

---

## Execute a ferramenta com parâmetros de entrada

**URL:** llms-txt#execute-a-ferramenta-com-parâmetros-de-entrada

results = tool.run(run_input={"query": "What is CrewAI?", "maxResults": 5})

---

## Para permitir a raspagem de qualquer site encontrado durante a execução

**URL:** llms-txt#para-permitir-a-raspagem-de-qualquer-site-encontrado-durante-a-execução

tool = ScrapeWebsiteTool()

---

## Without it, even it would produce generic marketing advice

**URL:** llms-txt#without-it,-even-it-would-produce-generic-marketing-advice

**Contents:**
  - c. 총체적 Agent-LLM 최적화

**Examples:**

Example 1 (unknown):
```unknown
**LLM 성능을 높여주는 백스토리 요소:**

* **도메인 경험**: "10년 이상의 엔터프라이즈 SaaS 영업 경력"
* **특정 전문성**: "시리즈 B+ 라운드의 기술 실사 전문"
* **업무 스타일**: "명확한 문서화와 데이터 기반 의사결정을 선호"
* **품질 기준**: "출처 인용과 분석 근거 제시를 중시"

### c. 총체적 Agent-LLM 최적화

가장 효과적인 agent 구성은 역할 특이성, 백스토리 깊이, 그리고 LLM 선택 간의 시너지를 창출합니다. 각 요소는 서로를 강화하여 모델 성능을 극대화합니다.

**최적화 프레임워크:**
```

---

## High-capability reasoning model for strategic planning

**URL:** llms-txt#high-capability-reasoning-model-for-strategic-planning

manager_llm = LLM(model="gemini-2.5-flash-preview-05-20", temperature=0.1)

---

## timeout=600

**URL:** llms-txt#timeout=600

---

## Switch to a different organization

**URL:** llms-txt#switch-to-a-different-organization

crewai org switch <org_id>

---

## Tarefa para listar equipes e canais

**URL:** llms-txt#tarefa-para-listar-equipes-e-canais

explore_teams_task = Task(
    description="Listar todas as equipes das quais sou membro e depois obter os canais da primeira equipe.",
    agent=teams_agent,
    expected_output="Lista de equipes e canais exibida."
)

---

## Create your agent

**URL:** llms-txt#create-your-agent

researcher = Agent(
    role='Senior Research Analyst',
    goal='Uncover cutting-edge developments in AI',
    backstory="You are an expert researcher at a tech think tank...",
    verbose=True,
    llm=llm
)

---

## Context amplifies model effectiveness

**URL:** llms-txt#context-amplifies-model-effectiveness

domain_expert = Agent(
    role="B2B SaaS Marketing Strategist",
    goal="Develop comprehensive go-to-market strategies for enterprise software",
    backstory="""
    You have 10+ years of experience scaling B2B SaaS companies from Series A to IPO.
    You understand the nuances of enterprise sales cycles, the importance of product-market
    fit in different verticals, and how to balance growth metrics with unit economics.
    You've worked with companies like Salesforce, HubSpot, and emerging unicorns, giving
    you perspective on both established and disruptive go-to-market strategies.
    """,
    llm=LLM(model="claude-3-5-sonnet", temperature=0.3)  # Balanced creativity with domain knowledge
)

---

## Imprimir as strings UUID

**URL:** llms-txt#imprimir-as-strings-uuid

**Contents:**
  - Trabalhando com metadados das impressões digitais

print(f"Agent fingerprint: {agent_fingerprint.uuid_str}")
print(f"Crew fingerprint: {crew_fingerprint.uuid_str}")
print(f"Task fingerprint: {task_fingerprint.uuid_str}")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Trabalhando com metadados das impressões digitais

Você pode adicionar metadados às impressões digitais para fornecer contexto adicional:
```

---

## Agent will:

**URL:** llms-txt#agent-will:

---

## Integração Google Drive

**URL:** llms-txt#integração-google-drive

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Google Drive
  - 1. Conecte sua Conta Google
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Solução de Problemas
  - Problemas Comuns
  - Obtendo Ajuda

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/google_drive

Gerenciamento de arquivos e pastas com integração Google Drive para CrewAI.

Permita que seus agentes acessem e gerenciem arquivos e pastas no Google Drive. Faça upload, download, organize conteúdo, crie links de compartilhamento e simplifique seus fluxos de trabalho de armazenamento em nuvem com automação alimentada por IA.

Antes de usar a integração Google Drive, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Google com acesso ao Google Drive
* Conectado sua conta Google através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Google Drive

### 1. Conecte sua Conta Google

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Google Drive** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a arquivos
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

Para informações detalhadas sobre parâmetros e uso, consulte a [documentação em inglês](../../../en/enterprise/integrations/google_drive).

## Solução de Problemas

**Erros de Autenticação**

* Certifique-se de que sua conta Google tenha as permissões necessárias para acesso ao Google Drive.

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nossa equipe de suporte para assistência com configuração ou solução de problemas da integração Google Drive.
</Card>

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

---

## Result:

**URL:** llms-txt#result:

---

## 역할과 목표가 설정된 에이전트 정의

**URL:** llms-txt#역할과-목표가-설정된-에이전트-정의

researcher = Agent(
    role="Senior Research Analyst",
    goal="AI 및 데이터 과학의 최첨단 발전 사항 발견",
    backstory="""당신은 최고 수준의 기술 싱크탱크에서 근무합니다.
    새로운 트렌드를 식별하는 데 전문성이 있습니다.
    복잡한 데이터를 분석하고 실행 가능한 인사이트로 제시하는 데 뛰어납니다.""",
    verbose=True,
    allow_delegation=False,
    # 원하는 모델을 지정할 수 있는 optional llm 속성을 전달할 수 있습니다.
    # llm=ChatOpenAI(model_name="gpt-3.5", temperature=0.7),
    tools=[search_tool],
)
writer = Agent(
    role="Tech Content Strategist",
    goal="기술 발전에 대한 매력적인 콘텐츠 작성",
    backstory="""당신은 통찰력 있고 흥미로운 기사로 유명한 콘텐츠 전략가입니다.
    복잡한 개념을 매력적인 스토리로 전환합니다.""",
    verbose=True,
    allow_delegation=True,
)

---

## 파일 읽기

**URL:** llms-txt#파일-읽기

**Contents:**
- 개요
- 설치
- 사용 예시

Source: https://docs.crewai.com/ko/tools/file-document/filereadtool

FileReadTool은 로컬 파일 시스템에서 파일을 읽도록 설계되었습니다.

<Note>
  우리는 도구를 계속 개선하고 있으므로, 향후 예기치 않은 동작이나 변경 사항이 발생할 수 있습니다.
</Note>

FileReadTool은 crewai\_tools 패키지 내에서 파일 읽기와 콘텐츠 검색을 용이하게 하는 기능 모음입니다.
이 모음에는 배치 텍스트 파일 처리, 런타임 구성 파일 읽기, 분석을 위한 데이터 가져오기 등 다양한 도구가 포함되어 있습니다.
`.txt`, `.csv`, `.json` 등 다양한 텍스트 기반 파일 형식을 지원합니다. 파일 유형에 따라 이 모음은
JSON 콘텐츠를 Python 딕셔너리로 변환하여 사용을 쉽게 하는 등 특화된 기능을 제공합니다.

이전에 FileReadTool에 할당된 기능을 사용하려면 crewai\_tools 패키지를 설치하세요:

```python Code theme={null}
from crewai_tools import FileReadTool

**Examples:**

Example 1 (unknown):
```unknown
## 사용 예시

FileReadTool을 시작하려면:
```

---

## Store text and embeddings in Qdrant

**URL:** llms-txt#store-text-and-embeddings-in-qdrant

def load_pdf_to_qdrant(pdf_path, qdrant, collection_name):
    # Extract text from PDF
    text_chunks = extract_text_from_pdf(pdf_path)

# Create Qdrant collection
    if qdrant.collection_exists(collection_name):
        qdrant.delete_collection(collection_name)
    qdrant.create_collection(
        collection_name=collection_name,
        vectors_config=VectorParams(size=3072, distance=Distance.COSINE)
    )

# Store embeddings
    points = []
    for chunk in text_chunks:
        embedding = get_openai_embedding(chunk)
        points.append(PointStruct(
            id=str(uuid.uuid4()),
            vector=embedding,
            payload={"text": chunk}
        ))
    qdrant.upsert(collection_name=collection_name, points=points)

---

## Execute the task

**URL:** llms-txt#execute-the-task

---

## Instalação

**URL:** llms-txt#instalação

**Contents:**
- Tutorial em Vídeo
- Tutorial em Texto

Source: https://docs.crewai.com/pt-BR/installation

Comece a usar o CrewAI - Instale, configure e crie seu primeiro crew de IA

Assista a este tutorial em vídeo para uma demonstração passo a passo do processo de instalação:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/-kSOTtYzgEw" title="CrewAI Installation Guide" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

<Note>
  **Requisitos de Versão do Python**

CrewAI requer `Python >=3.10 e <3.14`. Veja como verificar sua versão:

Se você precisar atualizar o Python, acesse [python.org/downloads](https://python.org/downloads)
</Note>

CrewAI utiliza o `uv` como ferramenta de gerenciamento de dependências e pacotes. Ele simplifica a configuração e execução do projeto, oferecendo uma experiência fluida.

Se você ainda não instalou o `uv`, siga o **passo 1** para instalá-lo rapidamente em seu sistema, caso contrário, avance para o **passo 2**.

<Steps>
  <Step title="Instale o uv">
    * **No macOS/Linux:**

Use `curl` para baixar o script e executá-lo com `sh`:

Se seu sistema não possuir `curl`, você pode usar `wget`:

Use `irm` para baixar o script e `iex` para executá-lo:

Caso enfrente algum problema, consulte o [guia de instalação do UV](https://docs.astral.sh/uv/getting-started/installation/) para mais informações.
  </Step>

<Step title="Instale o CrewAI 🚀">
    * Execute o seguinte comando para instalar o CLI do `crewai`:

<Warning>
        Se aparecer um aviso relacionado ao `PATH`, execute este comando para atualizar seu shell:

<Warning>
        Se você encontrar o erro de build ao instalar `chroma-hnswlib==0.7.6` (`fatal error C1083: Cannot open include file: 'float.h'`) no Windows, instale o (Visual Studio Build Tools)\[[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)] com o *Desenvolvimento de Desktop com C++*.
      </Warning>

* Para verificar se o `crewai` está instalado, execute:

* Você deverá ver algo assim:

* Caso precise atualizar o `crewai`, execute:

<Check>Instalação realizada com sucesso! Você está pronto para criar seu primeiro crew! 🎉</Check>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
Se você precisar atualizar o Python, acesse [python.org/downloads](https://python.org/downloads)
</Note>

CrewAI utiliza o `uv` como ferramenta de gerenciamento de dependências e pacotes. Ele simplifica a configuração e execução do projeto, oferecendo uma experiência fluida.

Se você ainda não instalou o `uv`, siga o **passo 1** para instalá-lo rapidamente em seu sistema, caso contrário, avance para o **passo 2**.

<Steps>
  <Step title="Instale o uv">
    * **No macOS/Linux:**

      Use `curl` para baixar o script e executá-lo com `sh`:
```

Example 2 (unknown):
```unknown
Se seu sistema não possuir `curl`, você pode usar `wget`:
```

Example 3 (unknown):
```unknown
* **No Windows:**

      Use `irm` para baixar o script e `iex` para executá-lo:
```

Example 4 (unknown):
```unknown
Caso enfrente algum problema, consulte o [guia de instalação do UV](https://docs.astral.sh/uv/getting-started/installation/) para mais informações.
  </Step>

  <Step title="Instale o CrewAI 🚀">
    * Execute o seguinte comando para instalar o CLI do `crewai`:
```

---

## Modo estrito - o diretório já deve existir

**URL:** llms-txt#modo-estrito---o-diretório-já-deve-existir

**Contents:**
  - Configuração YAML
  - Casos de Uso
  - Tratamento de Erros
- Conclusão

strict_output_task = Task(
    description='Salvar dados críticos que requerem infraestrutura existente',
    expected_output='Dados salvos em localização pré-configurada',
    agent=data_agent,
    output_file='secure/vault/critical_data.json',
    create_directory=False  # Gerará RuntimeError se 'secure/vault/' não existir
)
yaml tasks.yaml theme={null}
analysis_task:
  description: >
    Gerar análise financeira trimestral
  expected_output: >
    Um relatório financeiro abrangente com insights trimestrais
  agent: financial_analyst
  output_file: reports/quarterly/q4_2024_analysis.pdf
  create_directory: true  # Criar automaticamente o diretório 'reports/quarterly/'

audit_task:
  description: >
    Realizar auditoria de conformidade e salvar no diretório de auditoria existente
  expected_output: >
    Um relatório de auditoria de conformidade
  agent: auditor
  output_file: audit/compliance_report.md
  create_directory: false  # O diretório já deve existir
python Code theme={null}
try:
    result = crew.kickoff()
except RuntimeError as e:
    # Tratar erro de diretório ausente
    print(f"Falha na criação do diretório: {e}")
    # Criar diretório manualmente ou usar local alternativo
```

Veja o vídeo abaixo para aprender como utilizar saídas estruturadas no CrewAI:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/dNpKQk5uxHw" title="Saídas estruturadas no CrewAI" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen />

Tarefas são a força motriz por trás das ações dos agentes no CrewAI.
Ao definir corretamente as tarefas e seus resultados, você prepara seus agentes de IA para trabalhar de forma eficaz, seja de forma independente ou colaborativa.
Equipar tarefas com as ferramentas adequadas, compreender o processo de execução e seguir práticas sólidas de validação são fundamentais para maximizar o potencial do CrewAI,
assegurando que os agentes estejam devidamente preparados para suas atribuições e que as tarefas sejam executadas conforme o esperado.

**Examples:**

Example 1 (unknown):
```unknown
### Configuração YAML

Você também pode configurar este comportamento em suas definições de tarefas YAML:
```

Example 2 (unknown):
```unknown
### Casos de Uso

**Criação Automática de Diretórios (`create_directory=True`):**

* Ambientes de desenvolvimento e prototipagem
* Geração dinâmica de relatórios com pastas baseadas em datas
* Fluxos de trabalho automatizados onde a estrutura de diretórios pode variar
* Aplicações multi-tenant com pastas específicas do usuário

**Gerenciamento Manual de Diretórios (`create_directory=False`):**

* Ambientes de produção com controles rígidos do sistema de arquivos
* Aplicações sensíveis à segurança onde diretórios devem ser pré-configurados
* Sistemas com requisitos específicos de permissão
* Ambientes de conformidade onde a criação de diretórios é auditada

### Tratamento de Erros

Quando `create_directory=False` e o diretório não existe, o CrewAI gerará um `RuntimeError`:
```

---

## 실행 중 인간 입력

**URL:** llms-txt#실행-중-인간-입력

**Contents:**
- 에이전트 실행에서의 인간 입력
- CrewAI에서 인간 입력 사용하기
  - 예시:

Source: https://docs.crewai.com/ko/learn/human-input-on-execution

복잡한 의사결정 과정에서 실행 중 CrewAI와 인간 입력을 통합하고, 에이전트의 속성과 도구의 모든 기능을 활용하는 방법.

인간 입력은 여러 에이전트 실행 시나리오에서 매우 중요하며, 에이전트가 필요할 때 추가 정보나 설명을 요청할 수 있게 해줍니다.
이 기능은 특히 복잡한 의사결정 과정이나 에이전트가 작업을 효과적으로 완료하기 위해 더 많은 세부 정보가 필요할 때 유용하게 사용됩니다.

## CrewAI에서 인간 입력 사용하기

에이전트 실행에 인간 입력을 통합하려면, 태스크 정의에서 `human_input` 플래그를 설정하세요. 이 기능이 활성화되면 에이전트는 최종 답변을 제공하기 전에 사용자에게 입력을 요청합니다.
이 입력은 추가적인 컨텍스트를 제공하거나, 모호성을 해소하거나, 에이전트의 출력을 검증하는 데 사용할 수 있습니다.

```python Code theme={null}
import os
from crewai import Agent, Task, Crew
from crewai_tools import SerperDevTool

os.environ["SERPER_API_KEY"] = "Your Key"  # serper.dev API key
os.environ["OPENAI_API_KEY"] = "Your Key"

**Examples:**

Example 1 (unknown):
```unknown

```

---

## Ver todos os comandos disponíveis

**URL:** llms-txt#ver-todos-os-comandos-disponíveis

---

## OpenLIT 개요

**URL:** llms-txt#openlit-개요

**Contents:**
  - 기능
- 설치 안내

[OpenLIT](https://github.com/openlit/openlit?src=crewai-docs)은 오픈 소스 도구로, 단 **한** 줄의 코드만으로 AI 에이전트, LLM, VectorDB, GPU의 성능을 간편하게 모니터링할 수 있습니다.

OpenTelemetry-기반의 트레이싱 및 메트릭을 제공하여 비용, 지연 시간, 상호작용, 작업 시퀀스와 같은 주요 파라미터를 추적할 수 있습니다.\
이 설정을 통해 하이퍼파라미터를 추적하고 성능 문제를 모니터링하며, 시간이 지남에 따라 에이전트를 개선하고 미세 조정할 방법을 찾을 수 있습니다.

<Frame caption="OpenLIT 대시보드">
  <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=2b7fe9d84e9ec2b33c5eae6fa5668bee" alt="비용 및 토큰을 포함한 에이전트 사용 개요" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/openlit1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c971bf515a852fd31020a8b1324f1c1c 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=84c289d1cb65df00729c0265b937953d 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a2f16c0fff510b112190d86e4d660f57 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d16913f544b0bab3b1b6df63f9d221eb 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f3fb2555418f5a64d567b5ab2c16da87 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=58ca748851de32f75bfeb36bb2cbdcfa 2500w" />

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=74bb57f622b6eeb67fd33d93d682df26" alt="에이전트 otel 트레이스 및 메트릭 개요" data-og-width="3024" width="3024" data-og-height="1728" height="1728" data-path="images/openlit2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5f8faf220f9d7a5660652ec531dd07f9 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a02410c4bf920c9aafe972416e52a400 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=21b69af51e7ed46fb5b38a932a64471b 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b32ebaa0e210ff7151bb831d4e2fd5fc 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c360d0388bd1af92dedde1967e41017f 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9f14c8d65a0ca1177c2aa848c7a57aaa 2500w" />

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=734cbc0c8fee538986d74b063c20cef6" alt="에이전트 트레이스 상세 개요" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/openlit3.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=37d3f6eb4f5b66f6466fba0c02137aec 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9769fd3fdadf6acd8eadb2f80b4cc352 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=0f3367e37d8642fe4aa81f444c17b03d 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a2c9c17452fde4610823a981d60ce226 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=bf6526be4832980353137d0e19e38768 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a0c09334de9c7d1bb7f90a7ea636379f 2500w" />
</Frame>

* **분석 대시보드**: 에이전트의 상태와 성능을 모니터링할 수 있는 대시보드를 통해 지표, 비용, 사용자 상호작용을 자세히 추적할 수 있습니다.
* **OpenTelemetry-네이티브 가시성 SDK**: Grafana, DataDog 등 기존 가시성 도구로 추적 및 지표를 전송할 수 있는 벤더 중립적 SDK를 제공합니다.
* **커스텀 및 파인튜닝 모델 비용 추적**: 정확한 예산 책정을 위해 커스텀 가격 파일을 사용하여 특정 모델의 비용 추정치를 맞춤화할 수 있습니다.
* **예외 모니터링 대시보드**: 모니터링 대시보드를 통해 일반적인 예외 및 오류를 추적하여 문제를 신속하게 찾아내고 해결할 수 있습니다.
* **컴플라이언스 및 보안**: 욕설 및 PII 유출과 같은 잠재적인 위협을 탐지합니다.
* **프롬프트 인젝션 탐지**: 잠재적인 코드 인젝션 및 비밀 유출을 식별합니다.
* **API 키 및 비밀 관리**: LLM API 키와 비밀을 중앙에서 안전하게 관리하여 안전하지 않은 관행을 방지합니다.
* **프롬프트 관리**: PromptHub을 사용하여 에이전트 프롬프트를 관리 및 버전 관리하고, 모든 에이전트에서 일관되고 쉽게 접근할 수 있습니다.
* **모델 플레이그라운드**: 배포 전에 CrewAI 에이전트에 사용할 다양한 모델을 테스트하고 비교할 수 있습니다.

<Steps>
  <Step title="OpenLIT 배포">
    <Steps>
      <Step title="OpenLIT 저장소 Git Clone">
        
      </Step>

<Step title="Docker Compose 시작">
        [OpenLIT 저장소](https://github.com/openlit/openlit)의 루트 디렉토리에서 아래 명령어를 실행하세요:

</Step>
    </Steps>
  </Step>

<Step title="OpenLIT SDK 설치">
    
  </Step>

<Step title="애플리케이션에서 OpenLIT 초기화">
    아래 두 줄을 애플리케이션 코드에 추가하세요:

<Tabs>
      <Tab title="함수 인자 사용 설정">

CrewAI Agent 모니터링 예제:

<Tab title="환경 변수 사용 설정">
        아래 두 줄을 애플리케이션 코드에 추가하세요:

OTEL export endpoint를 설정하려면 다음 명령어를 실행하세요:

CrewAI Async Agent 모니터링 예제:

더 고급 설정 및 사용 사례는 OpenLIT [Python SDK 저장소](https://github.com/openlit/openlit/tree/main/sdk/python)를 참고하세요.
  </Step>

<Step title="시각화 및 분석">
    이제 에이전트 관찰 데이터가 수집되어 OpenLIT으로 전송되고 있으므로, 다음 단계는 이 데이터를 시각화하고 분석하여 에이전트의 성능, 행동 및 개선이 필요한 영역에 대한 인사이트를 얻는 것입니다.

브라우저에서 `127.0.0.1:3000`으로 접속하여 바로 시작할 수 있습니다. 기본 자격 증명으로 로그인 가능합니다

* **이메일**: `user@openlit.io`
    * **비밀번호**: `openlituser`

<Frame caption="OpenLIT 대시보드">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=2b7fe9d84e9ec2b33c5eae6fa5668bee" alt="비용 및 토큰을 포함한 에이전트 사용 개요" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/openlit1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c971bf515a852fd31020a8b1324f1c1c 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=84c289d1cb65df00729c0265b937953d 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a2f16c0fff510b112190d86e4d660f57 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d16913f544b0bab3b1b6df63f9d221eb 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f3fb2555418f5a64d567b5ab2c16da87 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=58ca748851de32f75bfeb36bb2cbdcfa 2500w" />

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=74bb57f622b6eeb67fd33d93d682df26" alt="에이전트 otel trace 및 메트릭 개요" data-og-width="3024" width="3024" data-og-height="1728" height="1728" data-path="images/openlit2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5f8faf220f9d7a5660652ec531dd07f9 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a02410c4bf920c9aafe972416e52a400 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=21b69af51e7ed46fb5b38a932a64471b 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b32ebaa0e210ff7151bb831d4e2fd5fc 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c360d0388bd1af92dedde1967e41017f 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9f14c8d65a0ca1177c2aa848c7a57aaa 2500w" />
    </Frame>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

      <Step title="Docker Compose 시작">
        [OpenLIT 저장소](https://github.com/openlit/openlit)의 루트 디렉토리에서 아래 명령어를 실행하세요:
```

Example 2 (unknown):
```unknown
</Step>
    </Steps>
  </Step>

  <Step title="OpenLIT SDK 설치">
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="애플리케이션에서 OpenLIT 초기화">
    아래 두 줄을 애플리케이션 코드에 추가하세요:

    <Tabs>
      <Tab title="함수 인자 사용 설정">
```

Example 4 (unknown):
```unknown
CrewAI Agent 모니터링 예제:
```

---

## Create LLM with guardrails

**URL:** llms-txt#create-llm-with-guardrails

portkey_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
        config={
            "input_guardrails": ["guardrails-id-xxx", "guardrails-id-yyy"],
            "output_guardrails": ["guardrails-id-zzz"]
        }
    )
)

---

## Test different providers with the same data

**URL:** llms-txt#test-different-providers-with-the-same-data

**Contents:**
  - 임베딩 문제 해결

providers_to_test = [
    {
        "name": "OpenAI",
        "config": {
            "provider": "openai",
            "config": {"model": "text-embedding-3-small"}
        }
    },
    {
        "name": "Ollama",
        "config": {
            "provider": "ollama",
            "config": {"model": "mxbai-embed-large"}
        }
    }
]

for provider in providers_to_test:
    print(f"\nTesting {provider['name']} embeddings...")

# Create crew with specific embedder
    crew = Crew(
        agents=[...],
        tasks=[...],
        memory=True,
        embedder=provider['config']
    )

# Run your test and measure performance
    result = crew.kickoff()
    print(f"{provider['name']} completed successfully")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 임베딩 문제 해결

**모델을 찾을 수 없음 오류:**
```

---

## ✅ Função específica - requisitos claros de LLM

**URL:** llms-txt#✅-função-específica---requisitos-claros-de-llm

**Contents:**
  - b. Backstory como Amplificador de Contexto do Modelo

specific_agent = Agent(
    role="SaaS Revenue Operations Analyst",  # Expertise de domínio clara
    goal="Analyze recurring revenue metrics and identify growth opportunities",
    backstory="Specialist in SaaS business models with deep understanding of ARR, churn, and expansion revenue",
    llm=LLM(model="gpt-4o")  # Raciocínio justificado para análise complexa
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Estratégia de Mapeamento de Função para Modelo:**

* **"Research Analyst"** → Modelo de raciocínio (GPT-4o, Claude Sonnet) para análise complexa
* **"Content Editor"** → Modelo criativo (Claude, GPT-4o) para qualidade de escrita
* **"Data Processor"** → Modelo eficiente (GPT-4o-mini, Gemini Flash) para tarefas estruturadas
* **"API Coordinator"** → Modelo otimizado para function calling (GPT-4o, Claude) para uso de ferramentas

### b. Backstory como Amplificador de Contexto do Modelo

<Info>
  Backstories estratégicos maximizam a eficácia do LLM ao contextualizar as respostas de forma que prompts genéricos não conseguem.
</Info>

Um bom backstory transforma a escolha do LLM de genérica a especializada. Isso é crucial para otimizar custos: um modelo eficiente com contexto certo pode superar um premium sem contexto.

**Exemplo de Performance Guiada por Contexto:**
```

---

## Disable auto-summarization and use RAG instead

**URL:** llms-txt#disable-auto-summarization-and-use-rag-instead

**Contents:**
- Direct Agent Interaction with `kickoff()`
  - How `kickoff()` Works

agent = Agent(
    role="Detailed Analyst",
    goal="Maintain complete information accuracy",
    backstory="Expert requiring full context",
    respect_context_window=False,  # No summarization
    tools=[RagTool()],  # Use RAG for large data
    verbose=True
)
python Code theme={null}
from crewai import Agent
from crewai_tools import SerperDevTool

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  The context window management feature works automatically in the background. You don't need to call any special functions - just set `respect_context_window` to your preferred behavior and CrewAI handles the rest!
</Note>

## Direct Agent Interaction with `kickoff()`

Agents can be used directly without going through a task or crew workflow using the `kickoff()` method. This provides a simpler way to interact with an agent when you don't need the full crew orchestration capabilities.

### How `kickoff()` Works

The `kickoff()` method allows you to send messages directly to an agent and get a response, similar to how you would interact with an LLM but with all the agent's capabilities (tools, reasoning, etc.).
```

---

## OU

**URL:** llms-txt#ou

---

## Google Slides 통합

**URL:** llms-txt#google-slides-통합

**Contents:**
- 개요
- 전제 조건
- Google Slides 통합 설정
  - 1. Google 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Google Slides 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/google_slides

CrewAI를 위한 Google Slides 통합으로 프레젠테이션 생성 및 관리.

에이전트가 Google Slides 프레젠테이션을 생성, 편집 및 관리할 수 있도록 합니다. AI 기반 자동화로 프레젠테이션 생성을 자동화하고, 콘텐츠를 업데이트하고, Google Sheets에서 데이터를 가져오며, 프레젠테이션 워크플로를 간소화합니다.

Google Slides 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Google Slides 액세스 권한이 있는 Google 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Google 계정 연결

## Google Slides 통합 설정

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Google Slides** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 프레젠테이션, 스프레드시트 및 드라이브 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="google_slides/create_blank_presentation">
    **설명:** 내용이 없는 빈 프레젠테이션을 만듭니다.

* `title` (string, 필수): 프레젠테이션의 제목.
  </Accordion>

<Accordion title="google_slides/get_presentation">
    **설명:** ID로 프레젠테이션을 검색합니다.

* `presentationId` (string, 필수): 검색할 프레젠테이션의 ID.
    * `fields` (string, 선택사항): 응답에 포함할 필드. 성능 향상을 위해 필요한 데이터만 반환하는 데 사용.
  </Accordion>

<Accordion title="google_slides/batch_update_presentation">
    **설명:** 프레젠테이션에 업데이트를 적용하거나 콘텐츠를 추가하거나 제거합니다.

* `presentationId` (string, 필수): 업데이트할 프레젠테이션의 ID.
    * `requests` (array, 필수): 프레젠테이션에 적용할 업데이트 목록. 각 항목은 요청을 나타내는 객체.
    * `writeControl` (object, 선택사항): 쓰기 요청이 실행되는 방식을 제어합니다. `requiredRevisionId` (string)를 포함.
  </Accordion>

<Accordion title="google_slides/get_page">
    **설명:** ID로 특정 페이지를 검색합니다.

* `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `pageObjectId` (string, 필수): 검색할 페이지의 ID.
  </Accordion>

<Accordion title="google_slides/get_thumbnail">
    **설명:** 페이지 썸네일을 생성합니다.

* `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `pageObjectId` (string, 필수): 썸네일 생성을 위한 페이지의 ID.
  </Accordion>

<Accordion title="google_slides/import_data_from_sheet">
    **설명:** Google 시트에서 프레젠테이션으로 데이터를 가져옵니다.

* `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `sheetId` (string, 필수): 가져올 Google 시트의 ID.
    * `dataRange` (string, 필수): 시트에서 가져올 데이터 범위.
  </Accordion>

<Accordion title="google_slides/upload_file_to_drive">
    **설명:** 프레젠테이션과 연결된 Google 드라이브에 파일을 업로드합니다.

* `file` (string, 필수): 업로드할 파일 데이터.
    * `presentationId` (string, 필수): 업로드된 파일을 연결할 프레젠테이션의 ID.
  </Accordion>

<Accordion title="google_slides/link_file_to_presentation">
    **설명:** Google 드라이브의 파일을 프레젠테이션에 연결합니다.

* `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `fileId` (string, 필수): 연결할 파일의 ID.
  </Accordion>

<Accordion title="google_slides/get_all_presentations">
    **설명:** 사용자가 액세스할 수 있는 모든 프레젠테이션을 나열합니다.

* `pageSize` (integer, 선택사항): 페이지당 반환할 프레젠테이션 수.
    * `pageToken` (string, 선택사항): 페이지네이션을 위한 토큰.
  </Accordion>

<Accordion title="google_slides/delete_presentation">
    **설명:** ID로 프레젠테이션을 삭제합니다.

* `presentationId` (string, 필수): 삭제할 프레젠테이션의 ID.
  </Accordion>
</AccordionGroup>

### 기본 Google Slides 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="google_slides/create_blank_presentation">
    **설명:** 내용이 없는 빈 프레젠테이션을 만듭니다.

    **매개변수:**

    * `title` (string, 필수): 프레젠테이션의 제목.
  </Accordion>

  <Accordion title="google_slides/get_presentation">
    **설명:** ID로 프레젠테이션을 검색합니다.

    **매개변수:**

    * `presentationId` (string, 필수): 검색할 프레젠테이션의 ID.
    * `fields` (string, 선택사항): 응답에 포함할 필드. 성능 향상을 위해 필요한 데이터만 반환하는 데 사용.
  </Accordion>

  <Accordion title="google_slides/batch_update_presentation">
    **설명:** 프레젠테이션에 업데이트를 적용하거나 콘텐츠를 추가하거나 제거합니다.

    **매개변수:**

    * `presentationId` (string, 필수): 업데이트할 프레젠테이션의 ID.
    * `requests` (array, 필수): 프레젠테이션에 적용할 업데이트 목록. 각 항목은 요청을 나타내는 객체.
    * `writeControl` (object, 선택사항): 쓰기 요청이 실행되는 방식을 제어합니다. `requiredRevisionId` (string)를 포함.
  </Accordion>

  <Accordion title="google_slides/get_page">
    **설명:** ID로 특정 페이지를 검색합니다.

    **매개변수:**

    * `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `pageObjectId` (string, 필수): 검색할 페이지의 ID.
  </Accordion>

  <Accordion title="google_slides/get_thumbnail">
    **설명:** 페이지 썸네일을 생성합니다.

    **매개변수:**

    * `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `pageObjectId` (string, 필수): 썸네일 생성을 위한 페이지의 ID.
  </Accordion>

  <Accordion title="google_slides/import_data_from_sheet">
    **설명:** Google 시트에서 프레젠테이션으로 데이터를 가져옵니다.

    **매개변수:**

    * `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `sheetId` (string, 필수): 가져올 Google 시트의 ID.
    * `dataRange` (string, 필수): 시트에서 가져올 데이터 범위.
  </Accordion>

  <Accordion title="google_slides/upload_file_to_drive">
    **설명:** 프레젠테이션과 연결된 Google 드라이브에 파일을 업로드합니다.

    **매개변수:**

    * `file` (string, 필수): 업로드할 파일 데이터.
    * `presentationId` (string, 필수): 업로드된 파일을 연결할 프레젠테이션의 ID.
  </Accordion>

  <Accordion title="google_slides/link_file_to_presentation">
    **설명:** Google 드라이브의 파일을 프레젠테이션에 연결합니다.

    **매개변수:**

    * `presentationId` (string, 필수): 프레젠테이션의 ID.
    * `fileId` (string, 필수): 연결할 파일의 ID.
  </Accordion>

  <Accordion title="google_slides/get_all_presentations">
    **설명:** 사용자가 액세스할 수 있는 모든 프레젠테이션을 나열합니다.

    **매개변수:**

    * `pageSize` (integer, 선택사항): 페이지당 반환할 프레젠테이션 수.
    * `pageToken` (string, 선택사항): 페이지네이션을 위한 토큰.
  </Accordion>

  <Accordion title="google_slides/delete_presentation">
    **설명:** ID로 프레젠테이션을 삭제합니다.

    **매개변수:**

    * `presentationId` (string, 필수): 삭제할 프레젠테이션의 ID.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Google Slides 에이전트 설정
```

---

## Inicializa a ferramenta com o handle específico de um canal do YouTube

**URL:** llms-txt#inicializa-a-ferramenta-com-o-handle-específico-de-um-canal-do-youtube

youtube_channel_tool = YoutubeChannelSearchTool(
    youtube_channel_handle='@exampleChannel'
)

---

## Metadados - informações adicionais (podem ser customizadas)

**URL:** llms-txt#metadados---informações-adicionais-(podem-ser-customizadas)

metadata = fingerprint.metadata  # Um dicionário, padrão {}
```

---

## Check server documentation for required parameters

**URL:** llms-txt#check-server-documentation-for-required-parameters

---

## Inicializar ferramenta de busca Qdrant

**URL:** llms-txt#inicializar-ferramenta-de-busca-qdrant

from crewai_tools import QdrantConfig

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url=os.getenv("QDRANT_URL"),
        qdrant_api_key=os.getenv("QDRANT_API_KEY"),
        collection_name=collection_name,
        limit=3,
        score_threshold=0.35
    )
)

---

## Ambos os filtros serão combinados (lógica AND)

**URL:** llms-txt#ambos-os-filtros-serão-combinados-(lógica-and)

**Contents:**
- Parâmetros de Busca
- Formato de Retorno
- Embedding Padrão
- Embeddings Personalizados

json  theme={null}
[
  {
    "metadata": {
      // Todos os metadados armazenados junto com o documento
    },
    "context": "O conteúdo textual real do documento",
    "distance": 0.95  // Pontuação de similaridade
  }
]
python  theme={null}
from transformers import AutoTokenizer, AutoModel
import torch

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros de Busca

A ferramenta aceita estes parâmetros em seu schema:

* `query` (str): Consulta de busca para encontrar documentos similares
* `filter_by` (str, opcional): Campo de metadado para filtrar
* `filter_value` (Any, opcional): Valor para filtrar

## Formato de Retorno

A ferramenta retorna resultados no formato JSON:
```

Example 2 (unknown):
```unknown
## Embedding Padrão

Por padrão, a ferramenta utiliza o modelo `text-embedding-3-large` da OpenAI para vetorização. Isso requer:

* Chave de API da OpenAI definida na variável de ambiente: `OPENAI_API_KEY`

## Embeddings Personalizados

Em vez de utilizar o modelo padrão de embeddings, você pode utilizar sua própria função de embeddings nos casos em que:

1. Deseja usar um modelo de embeddings diferente (ex: Cohere, HuggingFace, modelos Ollama)
2. Precisa reduzir custos utilizando modelos de código aberto
3. Tem requisitos específicos quanto à dimensão dos vetores ou à qualidade dos embeddings
4. Deseja utilizar embeddings específicos para determinado domínio (ex: textos médicos ou jurídicos)

Veja um exemplo utilizando um modelo HuggingFace:
```

---

## Create an agent that uses the tool

**URL:** llms-txt#create-an-agent-that-uses-the-tool

researcher = Agent(
    role='Market Researcher',
    goal='Find information about the latest AI trends',
    backstory='An expert market researcher specializing in technology.',
    tools=[tavily_tool],
    verbose=True
)

---

## 역할 기반 접근 제어 (RBAC)

**URL:** llms-txt#역할-기반-접근-제어-(rbac)

**Contents:**
- 개요
- 사용자와 역할
  - 구성 요약
- 자동화 수준 접근 제어
  - Private 모드 접근 결과

Source: https://docs.crewai.com/ko/enterprise/features/rbac

역할과 자동화별 가시성으로 crews, 도구, 데이터 접근을 제어합니다.

CrewAI AMP의 RBAC는 **조직 수준 역할**과 **자동화(Automation) 수준 가시성**을 결합하여 안전하고 확장 가능한 접근 제어를 제공합니다.

<Frame>
  <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=31b2661025e9813f32938f9d583228b5" alt="CrewAI AMP RBAC 개요" data-og-width="1365" width="1365" data-og-height="1044" height="1044" data-path="images/enterprise/users_and_roles.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c3863373e71e9e7190b4e68024e82ad6 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e9bfbec405004555d4a862a97e29945e 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8b3c5a5d5a1ba5417537c6ae6cae8f1c 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=50ba9cfdd73790c67ed3a7cce74d4f39 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=aed9da1d5c9044e026f1674463f9adc2 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=64a041f4e9ee05456c86d7259cef7e61 2500w" />
</Frame>

워크스페이스의 각 구성원은 역할이 있으며, 이는 기능 접근 범위를 결정합니다.

* 사전 정의된 역할 사용 (Owner, Member)
* 권한을 세분화한 커스텀 역할 생성
* 설정 화면에서 언제든 역할 할당/변경

설정 위치: Settings → Roles

<Steps>
  <Step title="Roles 열기">
    <b>Settings → Roles</b>로 이동합니다.
  </Step>

<Step title="역할 선택">
    <b>Owner</b> 또는 <b>Member</b>를 사용하거나 <b>Create role</b>로 커스텀 역할을 만듭니다.
  </Step>

<Step title="멤버에 할당">
    사용자들을 선택하여 역할을 지정합니다. 언제든 변경할 수 있습니다.
  </Step>
</Steps>

| 영역       | 위치                                 | 옵션                     |
| :------- | :--------------------------------- | :--------------------- |
| 사용자 & 역할 | Settings → Roles                   | Owner, Member; 커스텀 역할  |
| 자동화 가시성  | Automation → Settings → Visibility | Private; 사용자/역할 화이트리스트 |

조직 역할과 별개로, **Automations**는 사용자/역할별로 특정 자동화 접근을 제한하는 가시성 설정을 제공합니다.

* 민감/실험 자동화를 비공개로 유지
* 대규모 팀/외부 협업에서 가시성 관리
* 격리된 컨텍스트에서 자동화 테스트

Private 모드에서는 화이트리스트에 포함된 사용자/역할만 다음 작업이 가능합니다:

* 자동화 보기
* 실행/API 사용
* 로그, 메트릭, 설정 접근

조직 Owner는 항상 접근 가능하며, 가시성 설정에 영향을 받지 않습니다.

설정 위치: Automation → Settings → Visibility

<Steps>
  <Step title="Visibility 탭 열기">
    <b>Automation → Settings → Visibility</b>로 이동합니다.
  </Step>

<Step title="가시성 설정">
    <b>Private</b>를 선택합니다. Owner는 항상 접근 가능합니다.
  </Step>

<Step title="허용 대상 추가">
    보기/실행/로그·메트릭·설정 접근이 가능한 사용자/역할을 추가합니다.
  </Step>

<Step title="저장 및 확인">
    저장 후, 목록에 없는 사용자가 보거나 실행할 수 없는지 확인합니다.
  </Step>
</Steps>

| 동작        | Owner | 화이트리스트 사용자/역할 | 비포함 |
| :-------- | :---- | :------------ | :-- |
| 자동화 보기    | ✓     | ✓             | ✗   |
| 실행/API    | ✓     | ✓             | ✗   |
| 로그/메트릭/설정 | ✓     | ✓             | ✗   |

<Tip>
  Owner는 항상 접근 가능하며, Private 모드에서는 화이트리스트에 포함된 사용자/역할만 권한이 부여됩니다.
</Tip>

<Frame>
  <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=48e3dd12b9d55da6f7adc82ea80be56d" alt="CrewAI AMP 가시성 설정" data-og-width="2028" width="2028" data-og-height="1498" height="1498" data-path="images/enterprise/visibility.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=382d272d44871f509846140dc972592e 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6d6ba4cf2fcc360c7ce05266f5cc27e9 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b9fff488a36423a05ccb3f8e592ffd07 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=00471ecc85192b53abbcd64416e2b624 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9008ee6b24abd22593938021d2093174 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=27fde319cbc6fae3e4c1e0a9044c264f 2500w" />
</Frame>

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  RBAC 구성과 점검에 대한 지원이 필요하면 연락해 주세요.
</Card>

---

## Crie uma tarefa para o agente extrair elementos específicos

**URL:** llms-txt#crie-uma-tarefa-para-o-agente-extrair-elementos-específicos

extract_task = Task(
    description="""
    Extraia todos os títulos de produtos da seção de produtos em destaque no example.com.
    Use o seletor CSS '.product-title' para atingir os elementos de título.
    """,
    expected_output="Uma lista de títulos de produtos do site",
    agent=web_scraper_agent,
)

---

## Obtenha ferramentas empresariais (ferramentas do Linear serão incluídas)

**URL:** llms-txt#obtenha-ferramentas-empresariais-(ferramentas-do-linear-serão-incluídas)

---

## Customizing Prompts

**URL:** llms-txt#customizing-prompts

**Contents:**
- Why Customize Prompts?
- Understanding CrewAI's Prompt System
- Understanding Default System Instructions
  - What CrewAI Automatically Injects
  - Viewing the Complete System Prompt

Source: https://docs.crewai.com/en/guides/advanced/customizing-prompts

Dive deeper into low-level prompt customization for CrewAI, enabling super custom and complex use cases for different models and languages.

## Why Customize Prompts?

Although CrewAI's default prompts work well for many scenarios, low-level customization opens the door to significantly more flexible and powerful agent behavior. Here's why you might want to take advantage of this deeper control:

1. **Optimize for specific LLMs** – Different models (such as GPT-4, Claude, or Llama) thrive with prompt formats tailored to their unique architectures.
2. **Change the language** – Build agents that operate exclusively in languages beyond English, handling nuances with precision.
3. **Specialize for complex domains** – Adapt prompts for highly specialized industries like healthcare, finance, or legal.
4. **Adjust tone and style** – Make agents more formal, casual, creative, or analytical.
5. **Support super custom use cases** – Utilize advanced prompt structures and formatting to meet intricate, project-specific requirements.

This guide explores how to tap into CrewAI's prompts at a lower level, giving you fine-grained control over how agents think and interact.

## Understanding CrewAI's Prompt System

Under the hood, CrewAI employs a modular prompt system that you can customize extensively:

* **Agent templates** – Govern each agent's approach to their assigned role.
* **Prompt slices** – Control specialized behaviors such as tasks, tool usage, and output structure.
* **Error handling** – Direct how agents respond to failures, exceptions, or timeouts.
* **Tool-specific prompts** – Define detailed instructions for how tools are invoked or utilized.

Check out the [original prompt templates in CrewAI's repository](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json) to see how these elements are organized. From there, you can override or adapt them as needed to unlock advanced behaviors.

## Understanding Default System Instructions

<Warning>
  **Production Transparency Issue**: CrewAI automatically injects default instructions into your prompts that you might not be aware of. This section explains what's happening under the hood and how to gain full control.
</Warning>

When you define an agent with `role`, `goal`, and `backstory`, CrewAI automatically adds additional system instructions that control formatting and behavior. Understanding these default injections is crucial for production systems where you need full prompt transparency.

### What CrewAI Automatically Injects

Based on your agent configuration, CrewAI adds different default instructions:

#### For Agents Without Tools

#### For Agents With Tools

#### For Structured Outputs (JSON/Pydantic)

### Viewing the Complete System Prompt

To see exactly what prompt is being sent to your LLM, you can inspect the generated prompt:

```python  theme={null}
from crewai import Agent, Crew, Task
from crewai.utilities.prompts import Prompts

**Examples:**

Example 1 (unknown):
```unknown
#### For Agents With Tools
```

Example 2 (unknown):
```unknown
#### For Structured Outputs (JSON/Pydantic)
```

Example 3 (unknown):
```unknown
### Viewing the Complete System Prompt

To see exactly what prompt is being sent to your LLM, you can inspect the generated prompt:
```

---

## Task para criar nova empresa

**URL:** llms-txt#task-para-criar-nova-empresa

create_company_task = Task(
    description="Create a new company in HubSpot with name 'Innovate Corp' and domain 'innovatecorp.com'.",
    agent=hubspot_agent,
    expected_output="Company created successfully with confirmation"
)

---

## Menos eficiente - obter todas as ferramentas do servidor

**URL:** llms-txt#menos-eficiente---obter-todas-as-ferramentas-do-servidor

**Contents:**
  - 2. Lidar com Autenticação de Forma Segura

mcps=["https://weather.api.com/mcp"]
python  theme={null}
import os

**Examples:**

Example 1 (unknown):
```unknown
### 2. Lidar com Autenticação de Forma Segura
```

---

## Arxiv Paper Tool

**URL:** llms-txt#arxiv-paper-tool

Source: https://docs.crewai.com/pt-BR/tools/search-research/arxivpapertool

The `ArxivPaperTool` searches arXiv for papers matching a query and optionally downloads PDFs.

---

## Para buscas em diretório fixo

**URL:** llms-txt#para-buscas-em-diretório-fixo

**Contents:**
- Argumentos
- Modelo Personalizado e Embeddings

tool = DirectorySearchTool(directory='/path/to/directory')
python Code theme={null}
from chromadb.config import Settings

tool = DirectorySearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # ou "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `directory`: Um argumento do tipo string que especifica o diretório de busca. Este parâmetro é opcional durante a inicialização, mas obrigatório para buscas caso não tenha sido definido inicialmente.

## Modelo Personalizado e Embeddings

O DirectorySearchTool utiliza OpenAI para embeddings e sumarização por padrão. As opções de personalização dessas configurações incluem a alteração do provedor de modelo e configurações, ampliando a flexibilidade para usuários avançados.
```

---

## MLflow 개요

**URL:** llms-txt#mlflow-개요

**Contents:**
  - 기능
- 설치 안내

[MLflow](https://mlflow.org/)는 머신러닝 실무자와 팀이 머신러닝 프로세스의 복잡성을 관리할 수 있도록 돕는 오픈소스 플랫폼입니다.

MLflow는 귀하의 생성형 AI 애플리케이션에서 서비스 실행에 대한 상세 정보를 캡처하여 LLM 가시성을 향상시키는 트레이싱 기능을 제공합니다.
트레이싱은 요청의 각 중간 단계에 관련된 입력값, 출력값, 메타데이터를 기록하는 방법을 제공하여, 버그 및 예기치 않은 동작의 원인을 쉽게 찾아낼 수 있게 합니다.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow-tracing.gif?s=be88ff36aec776c005102164d804322a" alt="MLflow crewAI 트레이싱 사용 개요" data-og-width="1144" width="1144" data-og-height="720" height="720" data-path="images/mlflow-tracing.gif" data-optimize="true" data-opv="3" />

* **트레이싱 대시보드**: crewAI 에이전트의 활동을 입력값, 출력값, 스팬의 메타데이터와 함께 자세한 대시보드로 모니터링할 수 있습니다.
* **자동 트레이싱**: 완전 자동화된 crewAI 통합 기능으로, `mlflow.crewai.autolog()`를 실행하여 활성화할 수 있습니다.
* **약간의 노력만으로 수동 추적 계측**: 데코레이터, 함수 래퍼, 컨텍스트 매니저 등 MLflow의 고수준 fluent API를 통해 추적 계측을 커스터마이즈할 수 있습니다.
* **OpenTelemetry 호환성**: MLflow Tracing은 OpenTelemetry Collector로 트레이스를 내보내는 것을 지원하며, 이를 통해 Jaeger, Zipkin, AWS X-Ray 등 다양한 백엔드로 트레이스를 내보낼 수 있습니다.
* **에이전트 패키징 및 배포**: crewAI 에이전트를 다양한 배포 대상으로 추론 서버에 패키징 및 배포할 수 있습니다.
* **LLM을 안전하게 호스팅**: 여러 공급자의 LLM을 MFflow 게이트웨이를 통해 하나의 통합 엔드포인트에서 호스팅할 수 있습니다.
* **평가**: 편리한 API `mlflow.evaluate()`를 사용하여 다양한 지표로 crewAI 에이전트를 평가할 수 있습니다.

<Steps>
  <Step title="MLflow 패키지 설치">
    
  </Step>

<Step title="MLflow 추적 서버 시작">
    
  </Step>

<Step title="애플리케이션에서 MLflow 초기화">
    다음 두 줄을 애플리케이션 코드에 추가하세요:

CrewAI Agents 추적 예시 사용법:

더 많은 설정 및 사용 예시는 [MLflow Tracing 문서](https://mlflow.org/docs/latest/llms/tracing/index.html)를 참고하세요.
  </Step>

<Step title="에이전트 활동 시각화">
    이제 crewAI agents의 추적 정보가 MLflow에서 캡처됩니다.
    MLflow 추적 서버에 접속하여 추적 내역을 확인하고 에이전트의 인사이트를 얻으세요.

브라우저에서 `127.0.0.1:5000`을 열어 MLflow 추적 서버에 접속하세요.

<Frame caption="MLflow 추적 대시보드">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=0685aeb79319ad21ff842053ce5303c9" alt="MLflow tracing example with crewai" data-og-width="3024" width="3024" data-og-height="1712" height="1712" data-path="images/mlflow1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f45f73922d8ea58f0e72c16c0e22d977 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5025f431d9c88bb7a094ab032aeaa753 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=385879dd49ee957a4c25c5f94a9766e1 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c779a19494038367ecb7f1caefe1014c 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ff45740a0aaab934952c2928edbdcbc6 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=af14478b932df5a9f9261514f38d5e14 2500w" />
    </Frame>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="MLflow 추적 서버 시작">
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="애플리케이션에서 MLflow 초기화">
    다음 두 줄을 애플리케이션 코드에 추가하세요:
```

Example 3 (unknown):
```unknown
CrewAI Agents 추적 예시 사용법:
```

---

## Braintrust

**URL:** llms-txt#braintrust

Source: https://docs.crewai.com/pt-BR/observability/braintrust

Integração do Braintrust para CrewAI com rastreamento OpenTelemetry e avaliação

---

## Ou use fontes de conhecimento no lugar de prompts extensos

**URL:** llms-txt#ou-use-fontes-de-conhecimento-no-lugar-de-prompts-extensos

python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Se o resumo automático perder informações importantes:**
```

---

## PG RAG 검색

**URL:** llms-txt#pg-rag-검색

**Contents:**
- 개요
- 설명
- 설치
- 예시 사용법

Source: https://docs.crewai.com/ko/tools/database-data/pgsearchtool

PGSearchTool은 PostgreSQL 데이터베이스를 검색하고 가장 관련성 높은 결과를 반환하도록 설계되었습니다.

생각: 이제 훌륭한 답변을 드릴 수 있습니다.
최종 답변:

<Note>
  PGSearchTool은 현재 개발 중입니다. 이 문서에서는 의도된 기능과 인터페이스에 대해 설명합니다.
  개발이 진행됨에 따라 일부 기능이 제공되지 않거나 변경될 수 있으니 참고하시기 바랍니다.
</Note>

PGSearchTool은 PostgreSQL 데이터베이스 테이블 내에서 시맨틱 검색을 용이하게 하는 강력한 도구로 구상되었습니다. 고급 Retrieve and Generate (RAG) 기술을 활용하여, 이 도구는 특히 PostgreSQL 데이터베이스에 최적화된 데이터베이스 테이블 콘텐츠 쿼리를 위한 효율적인 수단을 제공하는 것을 목표로 합니다.
이 도구의 목표는 시맨틱 검색 쿼리를 통해 관련 데이터를 찾는 과정을 단순화하여, PostgreSQL 환경에서 방대한 데이터셋에 대한 고급 쿼리가 필요한 사용자에게 유용한 리소스를 제공하는 것입니다.

`crewai_tools` 패키지는 출시 시 PGSearchTool을 포함하게 되며, 다음 명령어를 사용하여 설치할 수 있습니다:

<Note>
  PGSearchTool은 현재 버전의 `crewai_tools` 패키지에는 아직 포함되어 있지 않습니다. 이 설치 명령어는 도구가 출시되는 즉시 업데이트될 예정입니다.
</Note>

아래는 PostgreSQL 데이터베이스 내의 테이블에서 의미론적 검색을 수행하기 위해 PGSearchTool을 사용하는 방법을 보여주는 예시입니다:

```python Code theme={null}
from crewai_tools import PGSearchTool

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  PGSearchTool은 현재 버전의 `crewai_tools` 패키지에는 아직 포함되어 있지 않습니다. 이 설치 명령어는 도구가 출시되는 즉시 업데이트될 예정입니다.
</Note>

## 예시 사용법

아래는 PostgreSQL 데이터베이스 내의 테이블에서 의미론적 검색을 수행하기 위해 PGSearchTool을 사용하는 방법을 보여주는 예시입니다:
```

---

## Define structured state

**URL:** llms-txt#define-structured-state

class SupportTicketState(BaseModel):
    ticket_id: str = ""
    customer_name: str = ""
    issue_description: str = ""
    category: str = ""
    priority: str = "medium"
    resolution: str = ""
    satisfaction_score: int = 0

class CustomerSupportFlow(Flow[SupportTicketState]):
    @start()
    def receive_ticket(self):
        # In a real app, this might come from an API
        self.state.ticket_id = "TKT-12345"
        self.state.customer_name = "Alex Johnson"
        self.state.issue_description = "Unable to access premium features after payment"
        return "Ticket received"

@listen(receive_ticket)
    def categorize_ticket(self, _):
        # Use a direct LLM call for categorization
        from crewai import LLM
        llm = LLM(model="openai/gpt-4o-mini")

prompt = f"""
        Categorize the following customer support issue into one of these categories:
        - Billing
        - Account Access
        - Technical Issue
        - Feature Request
        - Other

Issue: {self.state.issue_description}

Return only the category name.
        """

self.state.category = llm.call(prompt).strip()
        return self.state.category

@router(categorize_ticket)
    def route_by_category(self, category):
        # Route to different handlers based on category
        return category.lower().replace(" ", "_")

@listen("billing")
    def handle_billing_issue(self):
        # Handle billing-specific logic
        self.state.priority = "high"
        # More billing-specific processing...
        return "Billing issue handled"

@listen("account_access")
    def handle_access_issue(self):
        # Handle access-specific logic
        self.state.priority = "high"
        # More access-specific processing...
        return "Access issue handled"

# Additional category handlers...

@listen("billing", "account_access", "technical_issue", "feature_request", "other")
    def resolve_ticket(self, resolution_info):
        # Final resolution step
        self.state.resolution = f"Issue resolved: {resolution_info}"
        return self.state.resolution

---

## 시드 문자열을 사용하여 결정론적 지문 생성

**URL:** llms-txt#시드-문자열을-사용하여-결정론적-지문-생성

deterministic_fingerprint = Fingerprint.generate(seed="my-agent-id")

---

## 마크다운 형식으로 스크레이프 (기본값)

**URL:** llms-txt#마크다운-형식으로-스크레이프-(기본값)

markdown_result = tool.run(
    url="https://docs.crewai.com",
    include_markdown=True
)

---

## ✅ 대신 다음과 같은 네이밍 패턴을 사용하세요

**URL:** llms-txt#✅-대신-다음과-같은-네이밍-패턴을-사용하세요

**Contents:**
  - 모범 사례
  - 배포된 Crew와 상호작용하기
  - 실행 트리거하기
  - 모니터링 및 분석
  - 고급 기능

OPENAI_API_KEY=sk-...
DATABASE_CREDENTIALS=mypassword
API_CONFIG=secret123
```

1. **표준 명명 규칙 사용**: `PROVIDER_TOKEN` 대신 `PROVIDER_API_KEY` 사용
2. **먼저 로컬에서 테스트**: crew가 이름이 변경된 변수로 제대로 동작하는지 확인
3. **코드 업데이트**: 이전 변수 이름을 참조하는 부분을 모두 변경
4. **변경 내용 문서화**: 팀을 위해 이름이 변경된 변수를 기록

<Tip>
  배포 실패 시, 환경 변수 에러 메시지가 난해하다면 먼저 변수 이름이 이 패턴을 따르는지 확인하세요.
</Tip>

배포가 완료되면 다음을 통해 crew에 접근할 수 있습니다:

1. **REST API**: 플랫폼에서 아래의 주요 경로가 포함된 고유한 HTTPS 엔드포인트를 생성합니다:
   * `/inputs`: 필요한 입력 파라미터 목록
   * `/kickoff`: 제공된 입력값으로 실행 시작
   * `/status/{kickoff_id}`: 실행 상태 확인

2. **웹 인터페이스**: [app.crewai.com](https://app.crewai.com)에 방문하여 다음을 확인할 수 있습니다:
   * **Status 탭**: 배포 정보, API 엔드포인트 세부 정보 및 인증 토큰 확인
   * **Run 탭**: crew 구조의 시각적 표현
   * **Executions 탭**: 모든 실행 내역
   * **Metrics 탭**: 성능 분석
   * **Traces 탭**: 상세 실행 인사이트

Enterprise 대시보드에서 다음 작업을 수행할 수 있습니다:

1. crew 이름을 클릭하여 상세 정보를 엽니다
2. 관리 인터페이스에서 "Trigger Crew"를 선택합니다
3. 나타나는 모달에 필요한 입력값을 입력합니다
4. 파이프라인을 따라 실행의 진행 상황을 모니터링합니다

Enterprise 플랫폼은 포괄적인 가시성 기능을 제공합니다:

* **실행 관리**: 활성 및 완료된 실행 추적
* **트레이스**: 각 실행의 상세 분해
* **메트릭**: 토큰 사용량, 실행 시간, 비용
* **타임라인 보기**: 작업 시퀀스의 시각적 표현

Enterprise 플랫폼은 또한 다음을 제공합니다:

* **환경 변수 관리**: API 키를 안전하게 저장 및 관리
* **LLM 연결**: 다양한 LLM 공급자와의 통합 구성
* **Custom Tools Repository**: 도구 생성, 공유 및 설치
* **Crew Studio**: 코드를 작성하지 않고 채팅 인터페이스를 통해 crew 빌드

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  Enterprise 플랫폼의 배포 문제 또는 문의 사항이 있으시면 지원팀에 연락해 주십시오.
</Card>

---

## Testar diferentes provedores com os mesmos dados

**URL:** llms-txt#testar-diferentes-provedores-com-os-mesmos-dados

**Contents:**
  - Solução de Problemas de Embeddings

providers_to_test = [
    {
        "name": "OpenAI",
        "config": {
            "provider": "openai",
            "config": {"model": "text-embedding-3-small"}
        }
    },
    {
        "name": "Ollama",
        "config": {
            "provider": "ollama", 
            "config": {"model": "mxbai-embed-large"}
        }
    }
]

for provider in providers_to_test:
    print(f"\nTesting {provider['name']} embeddings...")
    
    # Criar crew com embedder específico
    crew = Crew(
        agents=[...],
        tasks=[...],
        memory=True,
        embedder=provider['config']
    )
    
    # Execute o teste e meça o desempenho
    result = crew.kickoff()
    print(f"{provider['name']} completed successfully")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Solução de Problemas de Embeddings

**Erros de modelo não encontrado:**
```

---

## Tarefa para criar uma nova apresentação

**URL:** llms-txt#tarefa-para-criar-uma-nova-apresentação

create_presentation_task = Task(
    description="Criar uma nova apresentação em branco intitulada 'Relatório de Vendas Trimestral'",
    agent=slides_agent,
    expected_output="Nova apresentação 'Relatório de Vendas Trimestral' criada com sucesso"
)

---

## For Simple DSL Integration (Recommended)

**URL:** llms-txt#for-simple-dsl-integration-(recommended)

---

## Define parameters for multiple MCP servers

**URL:** llms-txt#define-parameters-for-multiple-mcp-servers

**Contents:**
- Gerenciamento de Conexão

server_params_list = [
    # Streamable HTTP Server
    {
        "url": "http://localhost:8001/mcp", 
        "transport": "streamable-http"
    },
    # SSE Server
    {
        "url": "http://localhost:8000/sse",
        "transport": "sse"
    },
    # StdIO Server
    StdioServerParameters(
        command="python3",
        args=["servers/your_stdio_server.py"],
        env={"UV_PYTHON": "3.12", **os.environ},
    )
]

try:
    with MCPServerAdapter(server_params_list) as aggregated_tools:
        print(f"Available aggregated tools: {[tool.name for tool in aggregated_tools]}")

agente_multiservidor = Agent(
            role="Assistente Versátil",
            goal="Utilizar ferramentas de servidores MCP locais Stdio, remotos SSE e remotos HTTP.",
            backstory="Um agente de IA capaz de aproveitar um conjunto diversificado de ferramentas de múltiplas fontes.",
            tools=aggregated_tools, # Todas as ferramentas estão disponíveis aqui
            verbose=True,
        )

... # Your other agent, tasks, and crew code here

except Exception as e:
    print(f"Error connecting to or using multiple MCP servers (Managed): {e}")
    print("Ensure all MCP servers are running and accessible with correct configurations.")

## Gerenciamento de Conexão

Ao utilizar o gerenciador de contexto (`with` statement), o `MCPServerAdapter` gerencia o ciclo de vida (início e término) de todas as conexões aos servidores MCP configurados. Isso simplifica o gerenciamento de recursos e garante que todas as conexões sejam devidamente fechadas ao sair do contexto.

---

## `FirecrawlCrawlWebsiteTool`

**URL:** llms-txt#`firecrawlcrawlwebsitetool`

**Contents:**
- Descrição
- Instalação
- Exemplo
- Argumentos

[Firecrawl](https://firecrawl.dev) é uma plataforma para rastrear e converter qualquer site em markdown limpo ou dados estruturados.

* Obtenha uma chave de API em [firecrawl.dev](https://firecrawl.dev) e defina-a nas variáveis de ambiente (`FIRECRAWL_API_KEY`).
* Instale o [SDK do Firecrawl](https://github.com/mendableai/firecrawl) junto com o pacote `crewai[tools]`:

Utilize o FirecrawlScrapeFromWebsiteTool como a seguir para permitir que seu agente carregue sites:

* `api_key`: Opcional. Especifica a chave de API do Firecrawl. Por padrão, utiliza a variável de ambiente `FIRECRAWL_API_KEY`.
* `url`: A URL base para iniciar o rastreamento.
* `page_options`: Opcional.
  * `onlyMainContent`: Opcional. Retorna apenas o conteúdo principal da página, excluindo cabeçalhos, navegações, rodapés, etc.
  * `includeHtml`: Opcional. Inclui o conteúdo HTML bruto da página. Vai adicionar uma chave html na resposta.
* `crawler_options`: Opcional. Opções para controlar o comportamento do rastreamento.
  * `includes`: Opcional. Padrões de URL para incluir no rastreamento.
  * `exclude`: Opcional. Padrões de URL para excluir do rastreamento.
  * `generateImgAltText`: Opcional. Gera texto alternativo para imagens usando LLMs (requer um plano pago).
  * `returnOnlyUrls`: Opcional. Se verdadeiro, retorna apenas as URLs como uma lista no status do rastreamento. Nota: a resposta será uma lista de URLs dentro do campo data, não uma lista de documentos.
  * `maxDepth`: Opcional. Profundidade máxima de rastreamento. Profundidade 1 é a URL base, profundidade 2 inclui a URL base e seus filhos diretos, e assim por diante.
  * `mode`: Opcional. O modo de rastreamento a ser utilizado. O modo rápido rastreia 4x mais rápido em sites sem sitemap, mas pode não ser tão preciso e não deve ser usado em sites fortemente renderizados com JavaScript.
  * `limit`: Opcional. Número máximo de páginas a serem rastreadas.
  * `timeout`: Opcional. Tempo limite em milissegundos para a operação de rastreamento.

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Utilize o FirecrawlScrapeFromWebsiteTool como a seguir para permitir que seu agente carregue sites:
```

---

## Imprima o prompt completo de sistema que será enviado ao LLM

**URL:** llms-txt#imprima-o-prompt-completo-de-sistema-que-será-enviado-ao-llm

if "system" in generated_prompt:
    print("=== SYSTEM PROMPT ===")
    print(generated_prompt["system"])
    print("\n=== USER PROMPT ===")
    print(generated_prompt["user"])
else:
    print("=== COMPLETE PROMPT ===")
    print(generated_prompt["prompt"])

---

## `ScrapeWebsiteTool`

**URL:** llms-txt#`scrapewebsitetool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, então pode haver comportamentos inesperados ou mudanças futuras.
</Note>

Uma ferramenta desenvolvida para extrair e ler o conteúdo de um site especificado. Ela é capaz de lidar com diversos tipos de páginas web fazendo requisições HTTP e analisando o conteúdo HTML recebido.
Esta ferramenta pode ser especialmente útil para tarefas de raspagem de dados, coleta de dados ou extração de informações específicas de sites.

Instale o pacote crewai\_tools

```python  theme={null}
from crewai_tools import ScrapeWebsiteTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo
```

---

## assim o agente só poderá raspar o conteúdo do site especificado

**URL:** llms-txt#assim-o-agente-só-poderá-raspar-o-conteúdo-do-site-especificado

tool = ScrapeWebsiteTool(website_url='https://www.example.com')

---

## 에이전트를 위한 task 생성

**URL:** llms-txt#에이전트를-위한-task-생성

task1 = Task(
    description="""2024년 AI 분야의 최신 발전 상황에 대한 포괄적인 분석을 수행하세요.
    주요 트렌드, 획기적 기술, 산업에 미칠 잠재적 영향을 식별하세요.""",
    expected_output="주요 내용을 불릿 포인트로 정리한 전체 분석 보고서",
    agent=researcher,
)

task2 = Task(
    description="""제공된 인사이트를 활용하여
    가장 중요한 AI 발전 내용을 강조하는 흥미로운 블로그 글을 작성하세요.
    글은 정보성 있고, 기술에 밝은 독자를 대상으로 하면서 읽기 쉽게 써야 합니다.
    멋지게 들리도록 쓰되, 복잡한 단어는 피하여 AI처럼 들리지 않게 하세요.""",
    expected_output="최소 4개의 단락으로 구성된 전체 블로그 글",
    agent=writer,
)

---

## ollama pull mxbai-embed-large

**URL:** llms-txt#ollama-pull-mxbai-embed-large

crew = Crew(
    memory=True,
    embedder={
        "provider": "ollama",
        "config": {
            "model": "mxbai-embed-large",  # ou "nomic-embed-text"
            "url": "http://localhost:11434/api/embeddings"  # URL padrão do Ollama
        }
    }
)

---

## Inicialize uma ferramenta de busca

**URL:** llms-txt#inicialize-uma-ferramenta-de-busca

search_tool = SerperDevTool()

---

## Tavily 추출기 도구

**URL:** llms-txt#tavily-추출기-도구

**Contents:**
- 설치
- 예제 사용법

Source: https://docs.crewai.com/ko/tools/search-research/tavilyextractortool

Tavily API를 사용하여 웹 페이지에서 구조화된 콘텐츠를 추출합니다

`TavilyExtractorTool`은 CrewAI 에이전트가 Tavily API를 사용하여 웹 페이지에서 구조화된 콘텐츠를 추출할 수 있도록 합니다. 이 도구는 단일 URL 또는 URL 목록을 처리할 수 있으며, 추출 깊이를 제어하고 이미지를 포함하는 등의 옵션을 제공합니다.

`TavilyExtractorTool`을 사용하려면 `tavily-python` 라이브러리를 설치해야 합니다:

또한 Tavily API 키를 환경 변수로 설정해야 합니다:

다음은 CrewAI agent 내에서 `TavilyExtractorTool`을 초기화하고 사용하는 방법입니다:

```python  theme={null}
import os
from crewai import Agent, Task, Crew
from crewai_tools import TavilyExtractorTool

**Examples:**

Example 1 (unknown):
```unknown
또한 Tavily API 키를 환경 변수로 설정해야 합니다:
```

Example 2 (unknown):
```unknown
## 예제 사용법

다음은 CrewAI agent 내에서 `TavilyExtractorTool`을 초기화하고 사용하는 방법입니다:
```

---

## Extraia o texto do site

**URL:** llms-txt#extraia-o-texto-do-site

**Contents:**
- Argumentos

text = tool.run()
print(text)
```

| Argumento        | Tipo     | Descrição                                                                                                                                                     |
| :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **website\_url** | `string` | **Obrigatório** URL do site para leitura do arquivo. Esta é a entrada principal da ferramenta, especificando de qual site o conteúdo deve ser raspado e lido. |

---

## Example 1: Initialize from FunctionTool

**URL:** llms-txt#example-1:-initialize-from-functiontool

def search_data(query: str) -> str:
    """Search for information in the data."""
    # Your implementation here
    return f"Results for: {query}"

---

## so the agent can only read the content of the specified directory

**URL:** llms-txt#so-the-agent-can-only-read-the-content-of-the-specified-directory

**Contents:**
- Argumentos

tool = DirectoryReadTool(directory='/path/to/your/directory')
```

Os seguintes parâmetros podem ser usados para personalizar o comportamento do `DirectoryReadTool`:

| Argumento     | Tipo     | Descrição                                                                                                                                                                                                                    |
| :------------ | :------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **directory** | `string` | *Opcional*. Um argumento que especifica o caminho para o diretório cujo conteúdo você deseja listar. Aceita caminhos absolutos e relativos, direcionando a ferramenta para o diretório desejado para a listagem do conteúdo. |

---

## by providing its URL:

**URL:** llms-txt#by-providing-its-url:

**Contents:**
- Arguments
- Custom model and embeddings

tool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')
python Code theme={null}
tool = CodeDocsSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # or google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # or openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  Substitute '[https://docs.example.com/reference](https://docs.example.com/reference)' with your target documentation URL
  and 'How to use search tool' with the search query relevant to your needs.
</Note>

## Arguments

The following parameters can be used to customize the `CodeDocsSearchTool`'s behavior:

| Argument      | Type     | Description                                                             |
| :------------ | :------- | :---------------------------------------------------------------------- |
| **docs\_url** | `string` | *Optional*. Specifies the URL of the code documentation to be searched. |

## Custom model and embeddings

By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:
```

---

## Defina um agente que utilizará a ferramenta

**URL:** llms-txt#defina-um-agente-que-utilizará-a-ferramenta

web_scraper_agent = Agent(
    role="Web Scraper",
    goal="Extrair informações específicas de websites",
    backstory="Um especialista em web scraping capaz de capturar conteúdos direcionados de páginas web.",
    tools=[scrape_tool],
    verbose=True,
)

---

## assim os agentes podem buscar somente dentro desse site

**URL:** llms-txt#assim-os-agentes-podem-buscar-somente-dentro-desse-site

**Contents:**
- Argumentos
- Opções de Personalização

tool = WebsiteSearchTool(website='https://example.com')
python Code theme={null}
tool = WebsiteSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # ou google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # ou openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `website`: Um argumento opcional destinado a especificar a URL do site para buscas direcionadas. Este argumento foi projetado para aumentar a flexibilidade da ferramenta, permitindo buscas mais focadas quando necessário.

## Opções de Personalização

Por padrão, a ferramenta utiliza a OpenAI tanto para embeddings quanto para sumarização. Para personalizar o modelo, você pode usar um dicionário de configuração, conforme o exemplo abaixo:
```

---

## Access the raw response

**URL:** llms-txt#access-the-raw-response

**Contents:**
  - 매개변수 및 반환 값
  - 구조화된 출력

print(result.raw)
python Code theme={null}
from pydantic import BaseModel
from typing import List

class ResearchFindings(BaseModel):
    main_points: List[str]
    key_technologies: List[str]
    future_predictions: str

**Examples:**

Example 1 (unknown):
```unknown
### 매개변수 및 반환 값

| 매개변수              | 타입                                 | 설명                                 |
| :---------------- | :--------------------------------- | :--------------------------------- |
| `messages`        | `Union[str, List[Dict[str, str]]]` | 문자열 쿼리 또는 역할/내용이 포함된 메시지 딕셔너리의 리스트 |
| `response_format` | `Optional[Type[Any]]`              | 구조화된 출력을 위한 선택적 Pydantic 모델        |

이 메서드는 다음과 같은 속성을 가진 `LiteAgentOutput` 객체를 반환합니다:

* `raw`: 원시 출력 텍스트를 포함하는 문자열
* `pydantic`: 파싱된 Pydantic 모델 (`response_format`이 제공된 경우)
* `agent_role`: 출력을 생성한 agent의 역할
* `usage_metrics`: 실행에 대한 토큰 사용 지표

### 구조화된 출력

`response_format`으로 Pydantic 모델을 제공하여 구조화된 출력을 받을 수 있습니다:
```

---

## Obtenha apenas ferramentas lineares específicas

**URL:** llms-txt#obtenha-apenas-ferramentas-lineares-específicas

actions_list=["linear/create_issue", "linear/update_issue", "linear/search_issue"]
)

issue_manager = Agent(
    role="Issue Manager",
    goal="Criar e gerenciar issues no Linear de forma eficiente",
    backstory="Um assistente de IA focado na criação e no gerenciamento do ciclo de vida de issues.",
    apps=['linear']
)

---

## Obtenha uma resposta livre (texto)

**URL:** llms-txt#obtenha-uma-resposta-livre-(texto)

result = analyst.kickoff("Analise o mercado de IA em 2025")
print(result.raw)  # Acessa a resposta bruta

---

## Primeiro, instale e rode Ollama localmente, depois baixe um modelo de embedding:

**URL:** llms-txt#primeiro,-instale-e-rode-ollama-localmente,-depois-baixe-um-modelo-de-embedding:

---

## Firecrawl Scrape Website

**URL:** llms-txt#firecrawl-scrape-website

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/firecrawlscrapewebsitetool

A ferramenta `FirecrawlScrapeWebsiteTool` foi projetada para fazer scraping de sites e convertê-los em markdown limpo ou dados estruturados.

---

## se a URL for conhecida ou descoberta durante a execução:

**URL:** llms-txt#se-a-url-for-conhecida-ou-descoberta-durante-a-execução:

tool = CodeDocsSearchTool()

---

## Delegate work to coworker(task: str, context: str, coworker: str)

**URL:** llms-txt#delegate-work-to-coworker(task:-str,-context:-str,-coworker:-str)

**Contents:**
  - 2. **Ferramenta de Fazer Pergunta**

**Examples:**

Example 1 (unknown):
```unknown
### 2. **Ferramenta de Fazer Pergunta**

Permite que agentes façam perguntas específicas para obter informações de colegas.
```

---

## main.py 또는 flow.py 파일에서

**URL:** llms-txt#main.py-또는-flow.py-파일에서

from crewai.flow import Flow, listen, start
from my_listeners import MyCustomListener

---

## `JSONSearchTool`

**URL:** llms-txt#`jsonsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplos de Uso

<Note>
  O JSONSearchTool está atualmente em fase experimental. Isso significa que a ferramenta
  está em desenvolvimento ativo, e os usuários podem encontrar comportamentos inesperados ou
  alterações. Incentivamos fortemente o envio de feedback sobre quaisquer problemas ou sugestões de
  melhorias.
</Note>

O JSONSearchTool foi projetado para facilitar buscas eficientes e precisas dentro do conteúdo de arquivos JSON. Ele utiliza um mecanismo de busca RAG (Retrieve and Generate), permitindo que os usuários especifiquem um caminho JSON para buscas direcionadas dentro de um arquivo JSON específico. Essa capacidade melhora significativamente a precisão e relevância dos resultados de busca.

Para instalar o JSONSearchTool, utilize o seguinte comando pip:

Aqui estão exemplos atualizados de como utilizar o JSONSearchTool de forma eficaz para buscar dentro de arquivos JSON. Esses exemplos consideram a implementação e padrões de uso atuais identificados na base de código.

```python Code theme={null}
from crewai_tools import JSONSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplos de Uso

Aqui estão exemplos atualizados de como utilizar o JSONSearchTool de forma eficaz para buscar dentro de arquivos JSON. Esses exemplos consideram a implementação e padrões de uso atuais identificados na base de código.
```

---

## Test agent knowledge retrieval

**URL:** llms-txt#test-agent-knowledge-retrieval

if hasattr(agent, 'knowledge') and agent.knowledge:
    test_query = ["test query"]
    results = agent.knowledge.query(test_query)
    print(f"Agent knowledge results: {len(results)} documents found")

# Test crew knowledge retrieval (if exists)
    if hasattr(crew, 'knowledge') and crew.knowledge:
        crew_results = crew.query_knowledge(test_query)
        print(f"Crew knowledge results: {len(crew_results)} documents found")
python  theme={null}
import chromadb
from crewai.utilities.paths import db_storage_path
import os

**Examples:**

Example 1 (unknown):
```unknown
#### Inspecionar Coleções de Knowledge
```

---

## `YoutubeChannelSearchTool`

**URL:** llms-txt#`youtubechannelsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, então pode haver comportamentos inesperados ou alterações no futuro.
</Note>

Esta ferramenta foi desenvolvida para realizar buscas semânticas dentro do conteúdo de um canal específico do Youtube.
Aproveitando a metodologia RAG (Retrieval-Augmented Generation), ela fornece resultados de busca relevantes,
tornando-se indispensável para extrair informações ou encontrar conteúdos específicos sem a necessidade de percorrer manualmente os vídeos.
Ela otimiza o processo de busca em canais do Youtube, sendo ideal para pesquisadores, criadores de conteúdo e espectadores que buscam informações ou temas específicos.

Para utilizar o YoutubeChannelSearchTool, é necessário instalar o pacote `crewai_tools`. Execute o seguinte comando no seu terminal para instalar:

O exemplo a seguir demonstra como utilizar o `YoutubeChannelSearchTool` com um agente CrewAI:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import YoutubeChannelSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O exemplo a seguir demonstra como utilizar o `YoutubeChannelSearchTool` com um agente CrewAI:
```

---

## Link: https://link.springer.com/article/10.1007/s10439-023-03171-8

**URL:** llms-txt#link:-https://link.springer.com/article/10.1007/s10439-023-03171-8

---

## Pesquisa com RAG em Documentação de Código

**URL:** llms-txt#pesquisa-com-rag-em-documentação-de-código

Source: https://docs.crewai.com/pt-BR/tools/search-research/codedocssearchtool

O `CodeDocsSearchTool` é uma poderosa ferramenta RAG (Geração Aumentada por Recuperação) projetada para buscas semânticas em documentação de código.

---

## Verify connection

**URL:** llms-txt#verify-connection

**Contents:**
  - Step 3: Initialize OpenLit
  - Step 4: Create a Simple CrewAI Application
  - Step 5: See Traces in Langfuse
- References

if langfuse.auth_check():
    print("Langfuse client is authenticated and ready!")
else:
    print("Authentication failed. Please check your credentials and host.")
python  theme={null}
import openlit

openlit.init()
python  theme={null}
from crewai import Agent, Task, Crew

from crewai_tools import (
    WebsiteSearchTool
)

web_rag_tool = WebsiteSearchTool()

writer = Agent(
        role="Writer",
        goal="You make math engaging and understandable for young children through poetry",
        backstory="You're an expert in writing haikus but you know nothing of math.",
        tools=[web_rag_tool],  
    )

task = Task(description=("What is {multiplication}?"),
            expected_output=("Compose a haiku that includes the answer."),
            agent=writer)

crew = Crew(
  agents=[writer],
  tasks=[task],
  share_crew=False
)
```

### Step 5: See Traces in Langfuse

After running the agent, you can view the traces generated by your CrewAI application in [Langfuse](https://cloud.langfuse.com). You should see detailed steps of the LLM interactions, which can help you debug and optimize your AI agent.

![CrewAI example trace in Langfuse](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png)

*[Public example trace in Langfuse](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\&observation=3b32338ee6a5d9af)*

* [Langfuse OpenTelemetry Docs](https://langfuse.com/docs/opentelemetry/get-started)

**Examples:**

Example 1 (unknown):
```unknown
### Step 3: Initialize OpenLit

Initialize the OpenLit OpenTelemetry instrumentation SDK to start capturing OpenTelemetry traces.
```

Example 2 (unknown):
```unknown
### Step 4: Create a Simple CrewAI Application

We'll create a simple CrewAI application where multiple agents collaborate to answer a user's question.
```

---

## The tool will automatically use OpenAI embeddings

**URL:** llms-txt#the-tool-will-automatically-use-openai-embeddings

---

## Modify the agent

**URL:** llms-txt#modify-the-agent

agent.goal = "New goal for analysis"

---

## Integração com Langtrace

**URL:** llms-txt#integração-com-langtrace

Source: https://docs.crewai.com/pt-BR/observability/langtrace

Como monitorar custo, latência e desempenho dos Agentes CrewAI usando o Langtrace, uma ferramenta externa de observabilidade.

---

## Initialize the tool allowing for any PDF content search if the path is provided during execution

**URL:** llms-txt#initialize-the-tool-allowing-for-any-pdf-content-search-if-the-path-is-provided-during-execution

tool = PDFSearchTool()

---

## Load environment variables

**URL:** llms-txt#load-environment-variables

---

## 특정 채널에서 정보를 검색하기 위한 예시 작업

**URL:** llms-txt#특정-채널에서-정보를-검색하기-위한-예시-작업

research_task = Task(
    description="YouTube 채널 {youtube_channel_handle}에서 머신러닝 튜토리얼에 대한 정보를 검색하세요.",
    expected_output="채널에서 제공되는 주요 머신러닝 튜토리얼 요약.",
    agent=channel_researcher,
)

---

## Crie com permissões apropriadas

**URL:** llms-txt#crie-com-permissões-apropriadas

if not os.path.exists(storage_path):
    os.makedirs(storage_path, mode=0o755, exist_ok=True)
    print(f"Created storage directory: {storage_path}")
python  theme={null}
import chromadb
from crewai.utilities.paths import db_storage_path

**Examples:**

Example 1 (unknown):
```unknown
#### Inspecione Coleções do ChromaDB
```

---

## A mesma seed sempre gera a mesma impressão digital

**URL:** llms-txt#a-mesma-seed-sempre-gera-a-mesma-impressão-digital

same_fingerprint = Fingerprint.generate(seed="my-agent-id")
assert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str

---

## Use secure storage paths

**URL:** llms-txt#use-secure-storage-paths

**Contents:**
- 문제 해결
  - 일반적인 문제
  - 성능 팁
- CrewAI의 메모리 시스템 사용의 이점
- 메모리 이벤트
  - 사용 가능한 메모리 이벤트
  - 실용적인 응용 사례

storage_path = os.getenv("CREWAI_STORAGE_DIR", "./storage")
os.makedirs(storage_path, mode=0o700, exist_ok=True)  # Restricted permissions

crew = Crew(
    memory=True,
    long_term_memory=LongTermMemory(
        storage=LTMSQLiteStorage(
            db_path=f"{storage_path}/memory.db"
        )
    )
)
python  theme={null}
from crewai.events import (
    BaseEventListener,
    MemoryQueryCompletedEvent,
    MemorySaveCompletedEvent
)
import time

class MemoryPerformanceMonitor(BaseEventListener):
    def __init__(self):
        super().__init__()
        self.query_times = []
        self.save_times = []

def setup_listeners(self, crewai_event_bus):
        @crewai_event_bus.on(MemoryQueryCompletedEvent)
        def on_memory_query_completed(source, event: MemoryQueryCompletedEvent):
            self.query_times.append(event.query_time_ms)
            print(f"Memory query completed in {event.query_time_ms:.2f}ms. Query: '{event.query}'")
            print(f"Average query time: {sum(self.query_times)/len(self.query_times):.2f}ms")

@crewai_event_bus.on(MemorySaveCompletedEvent)
        def on_memory_save_completed(source, event: MemorySaveCompletedEvent):
            self.save_times.append(event.save_time_ms)
            print(f"Memory save completed in {event.save_time_ms:.2f}ms")
            print(f"Average save time: {sum(self.save_times)/len(self.save_times):.2f}ms")

**Examples:**

Example 1 (unknown):
```unknown
## 문제 해결

### 일반적인 문제

**세션 간에 메모리가 유지되지 않나요?**

* `CREWAI_STORAGE_DIR` 환경 변수를 확인하세요
* 저장소 디렉터리에 대한 쓰기 권한을 확인하세요
* `memory=True`로 메모리가 활성화되어 있는지 확인하세요

**Mem0 인증 오류가 발생하나요?**

* `MEM0_API_KEY` 환경 변수가 설정되어 있는지 확인하세요
* Mem0 대시보드에서 API 키 권한을 확인하세요
* `mem0ai` 패키지가 설치되어 있는지 확인하세요

**대용량 데이터셋에서 메모리 사용량이 높은가요?**

* 커스텀 저장소와 함께 외부 메모리 사용을 고려하세요
* 커스텀 저장소 검색 방법에 페이지네이션을 구현하세요
* 메모리 사용량을 줄이기 위해 더 작은 임베딩 모델을 사용하세요

### 성능 팁

* 대부분의 사용 사례에서는 `memory=True`를 사용하세요 (가장 간단하고 빠릅니다)
* 사용자별 지속성이 필요한 경우에만 User Memory를 사용하세요
* 대규모 또는 특수 요구 사항에는 External Memory를 고려하세요
* 더 빠른 처리를 위해 더 작은 embedding 모델을 선택하세요
* 메모리 검색 크기를 제어하기 위해 적절한 검색 한도를 설정하세요

## CrewAI의 메모리 시스템 사용의 이점

* 🦾 **적응형 학습:** 크루는 시간이 지남에 따라 더욱 효율적으로 변하며, 새로운 정보에 적응하고 작업 접근 방식을 정제합니다.
* 🫡 **향상된 개인화:** 메모리를 통해 에이전트는 사용자 선호도와 과거 상호작용을 기억하여, 맞춤형 경험을 제공합니다.
* 🧠 **향상된 문제 해결:** 풍부한 메모리 저장소에 접근함으로써 에이전트는 과거의 학습과 맥락적 통찰을 활용하여 더 나은 의사 결정을 내릴 수 있습니다.

## 메모리 이벤트

CrewAI의 이벤트 시스템은 메모리 작업에 대한 강력한 인사이트를 제공합니다. 메모리 이벤트를 활용하면 메모리 시스템의 성능과 동작을 모니터링하고, 디버깅하며, 최적화할 수 있습니다.

### 사용 가능한 메모리 이벤트

CrewAI는 다음과 같은 메모리 관련 이벤트를 발생시킵니다:

| 이벤트                               | 설명                            | 주요 속성                                                           |
| :-------------------------------- | :---------------------------- | :-------------------------------------------------------------- |
| **MemoryQueryStartedEvent**       | 메모리 쿼리가 시작될 때 발생              | `query`, `limit`, `score_threshold`                             |
| **MemoryQueryCompletedEvent**     | 메모리 쿼리가 성공적으로 완료될 때 발생        | `query`, `results`, `limit`, `score_threshold`, `query_time_ms` |
| **MemoryQueryFailedEvent**        | 메모리 쿼리가 실패할 때 발생              | `query`, `limit`, `score_threshold`, `error`                    |
| **MemorySaveStartedEvent**        | 메모리 저장 작업이 시작될 때 발생           | `value`, `metadata`, `agent_role`                               |
| **MemorySaveCompletedEvent**      | 메모리 저장 작업이 성공적으로 완료될 때 발생     | `value`, `metadata`, `agent_role`, `save_time_ms`               |
| **MemorySaveFailedEvent**         | 메모리 저장 작업이 실패할 때 발생           | `value`, `metadata`, `agent_role`, `error`                      |
| **MemoryRetrievalStartedEvent**   | 태스크 프롬프트에 대한 메모리 검색이 시작될 때 발생 | `task_id`                                                       |
| **MemoryRetrievalCompletedEvent** | 메모리 검색이 성공적으로 완료될 때 발생        | `task_id`, `memory_content`, `retrieval_time_ms`                |

### 실용적인 응용 사례

#### 1. 메모리 성능 모니터링

애플리케이션을 최적화하기 위해 메모리 작업 타이밍을 추적하세요:
```

---

## Desative o resumo automático e use RAG

**URL:** llms-txt#desative-o-resumo-automático-e-use-rag

**Contents:**
- Considerações e Boas Práticas Importantes
  - Segurança e Execução de Código
  - Otimização de Performance
  - Gerenciamento de Memória e Contexto
  - Funcionalidades Avançadas
  - Colaboração entre Agentes
  - Consciência de Data e Raciocínio
  - Compatibilidade de Modelos
- Solução de Problemas Comuns

agent = Agent(
    role="Detailed Analyst",
    goal="Maintain complete information accuracy",
    backstory="Expert requiring full context",
    respect_context_window=False,  # Sem resumo automático
    tools=[RagTool()],  # Use RAG para grandes volumes de dados
    verbose=True
)
```

<Note>
  O recurso de gerenciamento da janela de contexto funciona automaticamente em segundo plano. Você não precisa chamar funções especiais – basta definir `respect_context_window` conforme deseja e o CrewAI cuida do resto!
</Note>

## Considerações e Boas Práticas Importantes

### Segurança e Execução de Código

* Ao usar `allow_code_execution`, seja cauteloso com entradas do usuário e sempre as valide
* Use `code_execution_mode: "safe"` (Docker) em ambientes de produção
* Considere definir limites adequados de `max_execution_time` para evitar loops infinitos

### Otimização de Performance

* Use `respect_context_window: true` para evitar problemas com limite de tokens
* Ajuste `max_rpm` para evitar rate limiting
* Ative `cache: true` para melhorar performance em tarefas repetitivas
* Ajuste `max_iter` e `max_retry_limit` conforme a complexidade da tarefa

### Gerenciamento de Memória e Contexto

* Considere `knowledge_sources` para informações específicas de domínio
* Configure `embedder` ao usar modelos de embedding personalizados
* Use templates personalizados (`system_template`, `prompt_template`, `response_template`) para controle fino do comportamento do agente

### Funcionalidades Avançadas

* Ative `reasoning: true` para agentes que precisam planejar e refletir antes de tarefas complexas
* Defina `max_reasoning_attempts` para controlar as iterações de planejamento (`None` para ilimitadas)
* Use `inject_date: true` para dar consciência temporal a agentes em tarefas que dependem de datas
* Personalize o formato de data com `date_format` usando códigos padrões do Python datetime
* Ative `multimodal: true` para agentes que precisam processar texto e imagem

### Colaboração entre Agentes

* Ative `allow_delegation: true` quando agentes precisarem trabalhar juntos
* Use `step_callback` para monitorar e registrar interações dos agentes
* Considere usar LLMs diferentes para propósitos distintos:
  * `llm` principal para raciocínio complexo
  * `function_calling_llm` para uso eficiente de ferramentas

### Consciência de Data e Raciocínio

* Use `inject_date: true` para fornecer consciência temporal aos agentes em tarefas sensíveis ao tempo
* Customize o formato de data com `date_format` usando códigos standards de datetime do Python
* Códigos válidos incluem: %Y (ano), %m (mês), %d (dia), %B (nome completo do mês), etc.
* Formatos de data inválidos serão registrados como avisos e não modificarão a descrição da tarefa
* Ative `reasoning: true` para tarefas complexas que se beneficiam de planejamento e reflexão antecipados

### Compatibilidade de Modelos

* Defina `use_system_prompt: false` para modelos antigos que não suportam mensagens de sistema
* Certifique-se que o `llm` escolhido suporta as funcionalidades necessárias (como function calling)

## Solução de Problemas Comuns

1. **Limite de Taxa (Rate Limiting)**: Se atingir limites de API:
   * Implemente o `max_rpm` adequado
   * Use cache para operações repetitivas
   * Considere agrupar requisições em lote

2. **Erros de Janela de Contexto**: Se exceder limites de contexto:
   * Habilite `respect_context_window`
   * Otimize seus prompts
   * Limpe periodicamente a memória do agente

3. **Problemas de Execução de Código**: Se a execução de código falhar:
   * Verifique se o Docker está instalado para o modo seguro
   * Cheque permissões de execução
   * Revise as configurações do sandbox de código

4. **Problemas de Memória**: Se as respostas do agente parecerem inconsistentes:
   * Cheque a configuração das fontes de conhecimento
   * Analise o gerenciamento do histórico de conversas

Lembre-se de que agentes são mais eficientes quando configurados de acordo com o caso de uso específico. Reserve um tempo para entender seus requisitos e ajustar esses parâmetros conforme necessário.

---

## 특정 YouTube 채널 핸들로 도구를 초기화합니다

**URL:** llms-txt#특정-youtube-채널-핸들로-도구를-초기화합니다

youtube_channel_tool = YoutubeChannelSearchTool(
    youtube_channel_handle='@exampleChannel'
)

---

## 지문 인식

**URL:** llms-txt#지문-인식

**Contents:**
- 개요
- 지문(Fingerprints)의 작동 방식
- 기본 사용법
  - 지문 접근하기

Source: https://docs.crewai.com/ko/guides/advanced/fingerprinting

CrewAI의 지문 인식 시스템을 사용하여 컴포넌트를 전체 라이프사이클 동안 고유하게 식별하고 추적하는 방법을 알아보세요.

CrewAI의 Fingerprints는 컴포넌트를 고유하게 식별하고 그 생애주기를 추적할 수 있는 방법을 제공합니다. 각 `Agent`, `Crew`, `Task`는 생성 시 자동으로 고유한 fingerprint를 부여받으며, 이는 수동으로 변경할 수 없습니다.

이러한 fingerprints는 다음과 같은 용도로 사용할 수 있습니다:

* 컴포넌트 사용 감사 및 추적
* 컴포넌트 식별 무결성 보장
* 컴포넌트에 메타데이터 첨부
* 추적 가능한 작업 체인 생성

## 지문(Fingerprints)의 작동 방식

지문(fingerprint)은 `crewai.security` 모듈의 `Fingerprint` 클래스의 인스턴스입니다. 각 지문에는 다음과 같은 정보가 포함되어 있습니다:

* UUID 문자열: 컴포넌트의 고유 식별자로, 자동으로 생성되며 수동으로 설정할 수 없습니다.
* 생성 타임스탬프: 지문이 생성된 시점을 나타내며, 자동으로 설정되고 수동으로 수정할 수 없습니다.
* 메타데이터: 추가 정보를 담은 사전(dictionary)으로, 사용자 정의가 가능합니다.

지문은 컴포넌트가 생성될 때 자동으로 생성되어 할당됩니다. 각 컴포넌트는 읽기 전용 속성을 통해 자신의 지문을 제공합니다.

```python  theme={null}
from crewai import Agent, Crew, Task

---

## Agent will use these parameters when calling the tool

**URL:** llms-txt#agent-will-use-these-parameters-when-calling-the-tool

---

## Ferramenta específica do serviço AMP

**URL:** llms-txt#ferramenta-específica-do-serviço-amp

"crewai-amp:research-tools#pubmed_search"

---

## Inicialize a ferramenta com parâmetros personalizados

**URL:** llms-txt#inicialize-a-ferramenta-com-parâmetros-personalizados

tool = BraveSearchTool(
    country="US",
    n_results=5,
    save_file=True
)

---

## You can also set metadata

**URL:** llms-txt#you-can-also-set-metadata

**Contents:**
- Advanced Usage
  - Fingerprint Structure

custom_fingerprint = Fingerprint.generate(
    seed="my-agent-id",
    metadata={"version": "1.0"}
)
python  theme={null}
from crewai.security import Fingerprint

fingerprint = agent.fingerprint

**Examples:**

Example 1 (unknown):
```unknown
## Advanced Usage

### Fingerprint Structure

Each fingerprint has the following structure:
```

---

## Weaviate 벡터 검색

**URL:** llms-txt#weaviate-벡터-검색

**Contents:**
- 개요
- 설치
- 시작하는 단계
- 예시

Source: https://docs.crewai.com/ko/tools/database-data/weaviatevectorsearchtool

WeaviateVectorSearchTool은(는) Weaviate 벡터 데이터베이스에서 의미적으로 유사한 문서를 검색하도록 설계되었습니다.

`WeaviateVectorSearchTool`은 Weaviate 벡터 데이터베이스에 저장된 문서 내에서 의미론적 검색을 수행하도록 특별히 설계되었습니다. 이 도구를 사용하면 주어진 쿼리에 대해 의미적으로 유사한 문서를 찾을 수 있으며, 벡터 임베딩의 강점을 활용하여 더욱 정확하고 문맥에 맞는 검색 결과를 제공합니다.

[Weaviate](https://weaviate.io/)는 벡터 임베딩을 저장하고 쿼리할 수 있는 벡터 데이터베이스로, 의미론적 검색 기능을 제공합니다.

이 도구를 프로젝트에 포함하려면 Weaviate 클라이언트를 설치해야 합니다:

`WeaviateVectorSearchTool`을 효과적으로 사용하려면 다음 단계를 따르세요:

1. **패키지 설치**: Python 환경에 `crewai[tools]` 및 `weaviate-client` 패키지가 설치되어 있는지 확인하세요.
2. **Weaviate 설정**: Weaviate 클러스터를 설정하세요. 안내는 [Weaviate 공식 문서](https://weaviate.io/developers/wcs/manage-clusters/connect)를 참고하세요.
3. **API 키**: Weaviate 클러스터 URL과 API 키를 확보하세요.
4. **OpenAI API 키**: 환경 변수에 `OPENAI_API_KEY`로 OpenAI API 키가 설정되어 있는지 확인하세요.

다음 예시는 도구를 초기화하고 검색을 실행하는 방법을 보여줍니다:

```python Code theme={null}
from crewai_tools import WeaviateVectorSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## 시작하는 단계

`WeaviateVectorSearchTool`을 효과적으로 사용하려면 다음 단계를 따르세요:

1. **패키지 설치**: Python 환경에 `crewai[tools]` 및 `weaviate-client` 패키지가 설치되어 있는지 확인하세요.
2. **Weaviate 설정**: Weaviate 클러스터를 설정하세요. 안내는 [Weaviate 공식 문서](https://weaviate.io/developers/wcs/manage-clusters/connect)를 참고하세요.
3. **API 키**: Weaviate 클러스터 URL과 API 키를 확보하세요.
4. **OpenAI API 키**: 환경 변수에 `OPENAI_API_KEY`로 OpenAI API 키가 설정되어 있는지 확인하세요.

## 예시

다음 예시는 도구를 초기화하고 검색을 실행하는 방법을 보여줍니다:
```

---

## Crie um agente com capacidades Salesforce

**URL:** llms-txt#crie-um-agente-com-capacidades-salesforce

salesforce_agent = Agent(
    role="CRM Manager",
    goal="Manage customer relationships and sales processes efficiently",
    backstory="An AI assistant specialized in CRM operations and sales automation.",
    apps=['salesforce']
)

---

## The agent is loaded with all its predefined configurations

**URL:** llms-txt#the-agent-is-loaded-with-all-its-predefined-configurations

**Contents:**
  - 저장소 설정 재정의
  - 예제: Repository 에이전트로 Crew 생성하기

researcher = Agent(
    from_repository="market-research-agent"
)

python  theme={null}
researcher = Agent(
    from_repository="market-research-agent",
    goal="Research the latest trends in AI development",  # Override the repository goal
    verbose=True  # Add a setting not in the repository
)
python  theme={null}
from crewai import Crew, Agent, Task

**Examples:**

Example 1 (unknown):
```unknown
### 저장소 설정 재정의

구성에서 특정 설정을 제공하여 저장소의 설정을 재정의할 수 있습니다.
```

Example 2 (unknown):
```unknown
### 예제: Repository 에이전트로 Crew 생성하기
```

---

## Automations

**URL:** llms-txt#automations

**Contents:**
- Overview
- Deployment Methods
  - Deploy from GitHub
  - Deploy from ZIP
- Automations Dashboard
- Best Practices
- Related

Source: https://docs.crewai.com/en/enterprise/features/automations

Manage, deploy, and monitor your live crews (automations) in one place.

Automations is the live operations hub for your deployed crews. Use it to deploy from GitHub or a ZIP file, manage environment variables, re‑deploy when needed, and monitor the status of each automation.

<Frame>
    <img src="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=a7d0655da82c70b0ca152715cb8253f4" alt="Automations Overview" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/automations-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=280&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=18456289664a18d4b83b2acdae616a44 280w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=560&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=4737cb32db15d7f121a1366ae5c80c0e 560w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=840&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=69473aff76b3ea16974be8226590d114 840w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=1100&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=a742c3a1f81537f0a2d9668e5671c1aa 1100w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=1650&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=6a9aed77a2491e2dc3da8f511f391487 1650w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=2500&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=c64e992c5464916085b9114abab0d7c0 2500w" />
</Frame>

## Deployment Methods

### Deploy from GitHub

Use this for version‑controlled projects and continuous deployment.

<Steps>
  <Step title="Connect GitHub">
    Click <b>Configure GitHub</b> and authorize access.
  </Step>

<Step title="Select Repository & Branch">
    Choose the <b>Repository</b> and <b>Branch</b> you want to deploy from.
  </Step>

<Step title="Enable Auto‑deploy (optional)">
    Turn on <b>Automatically deploy new commits</b> to ship updates on every push.
  </Step>

<Step title="Add Environment Variables">
    Add secrets individually or use <b>Bulk View</b> for multiple variables.
  </Step>

<Step title="Deploy">
    Click <b>Deploy</b> to create your live automation.
  </Step>
</Steps>

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=4fb72dc68799d5a0c35e2e74f1a7cc6c" alt="GitHub Deployment" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/deploy-from-github.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b15575b0b30c64e8b7a20de9e97468e5 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=c041da5b5b79d38cb2a3f8d6f00e14a7 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=0783c12a6f83d09ce83e66aa34edcacd 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=d703da835283f7e73079ef66f664587c 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=f73b6afc4c3c3075ded4da6559676fa3 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=c3d82425923c1f57264b7cb5af9004b3 2500w" />
</Frame>

Ship quickly without Git—upload a compressed package of your project.

<Steps>
  <Step title="Choose File">
    Select the ZIP archive from your computer.
  </Step>

<Step title="Add Environment Variables">
    Provide any required variables or keys.
  </Step>

<Step title="Deploy">
    Click <b>Deploy</b> to create your live automation.
  </Step>
</Steps>

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=8cea74868a553d34b0aa182ad5489099" alt="ZIP Deployment" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/deploy-from-zip.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=961637aa95a2795071b4a54e921f3f03 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=62994bfdf5667fc17880ed33c32a7aa6 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b0c4ef28de74989c1fdbf1076d12ba3c 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=19fe8b770051a0426f120d6b661a6f40 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=a80e4bf6e8befdf57a5ea79840b45136 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=61e870a88f47df3e282a134e754fc09d 2500w" />
</Frame>

## Automations Dashboard

The table lists all live automations with key details:

* **CREW**: Automation name
* **STATUS**: Online / Failed / In Progress
* **URL**: Endpoint for kickoff/status
* **TOKEN**: Automation token
* **ACTIONS**: Re‑deploy, delete, and more

Use the top‑right controls to filter and search:

* Search by name
* Filter by <b>Status</b>
* Filter by <b>Source</b> (GitHub / Studio / ZIP)

Once deployed, you can view the automation details and have the **Options** dropdown menu to `chat with this crew`, `Export React Component` and `Export as MCP`.

<Frame>
    <img src="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=f7fb571e8473f5cb7940c3e3bb34f95c" alt="Automations Table" data-og-width="2874" width="2874" data-og-height="932" height="932" data-path="images/enterprise/automations-table.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=280&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=5833733acf6f2e07d0a39abffe87de40 280w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=560&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=858a8b93744d4f23e07e9ec58227aac0 560w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=840&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=e0fe6df6d821e1edc729681e8d314d22 840w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=1100&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=cb68b81e23a169714985d93bb0913170 1100w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=1650&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=401736c16a6074de6b60de8234cbe206 1650w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=2500&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=1b9a5f852f474d6a68a5cf4dda5a0021 2500w" />
</Frame>

* Prefer GitHub deployments for version control and CI/CD
* Use re‑deploy to roll forward after code or config updates or set it to auto-deploy on every push

<CardGroup cols={3}>
  <Card title="Deploy a Crew" href="/en/enterprise/guides/deploy-crew" icon="rocket">
    Deploy a Crew from GitHub or ZIP file.
  </Card>

<Card title="Automation Triggers" href="/en/enterprise/guides/automation-triggers" icon="trigger">
    Trigger automations via webhooks or API.
  </Card>

<Card title="Webhook Automation" href="/en/enterprise/guides/webhook-automation" icon="webhook">
    Stream real-time events and updates to your systems.
  </Card>
</CardGroup>

---

## Task 1: Research

**URL:** llms-txt#task-1:-research

market_research_task:
  description: "Research current market trends in the SaaS project management space."
  expected_output: "A markdown summary of key market trends."

---

## Defina seus agentes com papéis e objetivos

**URL:** llms-txt#defina-seus-agentes-com-papéis-e-objetivos

pesquisador = Agent(
    role="Analista Sênior de Pesquisa",
    goal="Descobrir os avanços mais recentes em IA e ciência de dados",
    backstory="""
Você trabalha em um importante think tank de tecnologia. Sua especialidade é identificar tendências emergentes. Você tem habilidade para dissecar dados complexos e apresentar insights acionáveis.
""",
    verbose=True,
    allow_delegation=False,
    tools=[search_tool],
)
writer = Agent(
    role="Estrategista de Conteúdo Técnico",
    goal="Criar conteúdo envolvente sobre avanços tecnológicos",
    backstory="Você é um Estrategista de Conteúdo renomado, conhecido por seus artigos perspicazes e envolventes. Você transforma conceitos complexos em narrativas atraentes.",
    verbose=True,
    allow_delegation=True,
)

---

## 모든 배포 목록 확인

**URL:** llms-txt#모든-배포-목록-확인

---

## Busca RAG em XML

**URL:** llms-txt#busca-rag-em-xml

Source: https://docs.crewai.com/pt-BR/tools/file-document/xmlsearchtool

O `XMLSearchTool` foi projetado para realizar uma busca RAG (Geração Aumentada por Recuperação) dentro do conteúdo de um arquivo XML.

---

## Get structured output

**URL:** llms-txt#get-structured-output

result = researcher.kickoff(
    "Summarize the latest developments in AI for 2025",
    response_format=ResearchFindings
)

---

## 첫 번째 에이전트 생성 - 서버에서 도구 발견

**URL:** llms-txt#첫-번째-에이전트-생성---서버에서-도구-발견

agent1 = Agent(role="첫 번째", goal="테스트", backstory="테스트",
               mcps=["https://api.example.com/mcp"])

---

## Integração Google Docs

**URL:** llms-txt#integração-google-docs

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Google Docs
  - 1. Conecte sua Conta Google
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Google Docs

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/google_docs

Criação e edição de documentos com integração Google Docs para CrewAI.

Permita que seus agentes criem, editem e gerenciem documentos do Google Docs com manipulação de texto e formatação. Automatize a criação de documentos, insira e substitua texto, gerencie intervalos de conteúdo e simplifique seus fluxos de trabalho de documentos com automação alimentada por IA.

Antes de usar a integração Google Docs, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Google com acesso ao Google Docs
* Conectado sua conta Google através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Google Docs

### 1. Conecte sua Conta Google

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Google Docs** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a documentos
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="google_docs/create_document">
    **Descrição:** Criar um novo documento do Google.

* `title` (string, opcional): O título para o novo documento.
  </Accordion>

<Accordion title="google_docs/get_document">
    **Descrição:** Obter o conteúdo e metadados de um documento do Google.

* `documentId` (string, obrigatório): O ID do documento a recuperar.
    * `includeTabsContent` (boolean, opcional): Se deve incluir conteúdo de abas. Padrão: false
    * `suggestionsViewMode` (string, opcional): O modo de visualização de sugestões a aplicar ao documento. Opções: DEFAULT\_FOR\_CURRENT\_ACCESS, PREVIEW\_SUGGESTIONS\_ACCEPTED, PREVIEW\_WITHOUT\_SUGGESTIONS. Padrão: DEFAULT\_FOR\_CURRENT\_ACCESS
  </Accordion>

<Accordion title="google_docs/batch_update">
    **Descrição:** Aplicar uma ou mais atualizações a um documento do Google.

* `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `requests` (array, obrigatório): Uma lista de atualizações a aplicar ao documento. Cada item é um objeto representando uma solicitação.
    * `writeControl` (object, opcional): Fornece controle sobre como as solicitações de escrita são executadas. Contém `requiredRevisionId` (string) e `targetRevisionId` (string).
  </Accordion>

<Accordion title="google_docs/insert_text">
    **Descrição:** Inserir texto em um documento do Google em um local específico.

* `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `text` (string, obrigatório): O texto a inserir.
    * `index` (integer, opcional): O índice baseado em zero onde inserir o texto. Padrão: 1
  </Accordion>

<Accordion title="google_docs/replace_text">
    **Descrição:** Substituir todas as instâncias de texto em um documento do Google.

* `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `containsText` (string, obrigatório): O texto a encontrar e substituir.
    * `replaceText` (string, obrigatório): O texto para substituir.
    * `matchCase` (boolean, opcional): Se a pesquisa deve respeitar maiúsculas e minúsculas. Padrão: false
  </Accordion>

<Accordion title="google_docs/delete_content_range">
    **Descrição:** Excluir conteúdo de um intervalo específico em um documento do Google.

* `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `startIndex` (integer, obrigatório): O índice inicial do intervalo a excluir.
    * `endIndex` (integer, obrigatório): O índice final do intervalo a excluir.
  </Accordion>

<Accordion title="google_docs/insert_page_break">
    **Descrição:** Inserir uma quebra de página em um local específico em um documento do Google.

* `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `index` (integer, opcional): O índice baseado em zero onde inserir a quebra de página. Padrão: 1
  </Accordion>

<Accordion title="google_docs/create_named_range">
    **Descrição:** Criar um intervalo nomeado em um documento do Google.

* `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `name` (string, obrigatório): O nome para o intervalo nomeado.
    * `startIndex` (integer, obrigatório): O índice inicial do intervalo.
    * `endIndex` (integer, obrigatório): O índice final do intervalo.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Google Docs

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="google_docs/create_document">
    **Descrição:** Criar um novo documento do Google.

    **Parâmetros:**

    * `title` (string, opcional): O título para o novo documento.
  </Accordion>

  <Accordion title="google_docs/get_document">
    **Descrição:** Obter o conteúdo e metadados de um documento do Google.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a recuperar.
    * `includeTabsContent` (boolean, opcional): Se deve incluir conteúdo de abas. Padrão: false
    * `suggestionsViewMode` (string, opcional): O modo de visualização de sugestões a aplicar ao documento. Opções: DEFAULT\_FOR\_CURRENT\_ACCESS, PREVIEW\_SUGGESTIONS\_ACCEPTED, PREVIEW\_WITHOUT\_SUGGESTIONS. Padrão: DEFAULT\_FOR\_CURRENT\_ACCESS
  </Accordion>

  <Accordion title="google_docs/batch_update">
    **Descrição:** Aplicar uma ou mais atualizações a um documento do Google.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `requests` (array, obrigatório): Uma lista de atualizações a aplicar ao documento. Cada item é um objeto representando uma solicitação.
    * `writeControl` (object, opcional): Fornece controle sobre como as solicitações de escrita são executadas. Contém `requiredRevisionId` (string) e `targetRevisionId` (string).
  </Accordion>

  <Accordion title="google_docs/insert_text">
    **Descrição:** Inserir texto em um documento do Google em um local específico.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `text` (string, obrigatório): O texto a inserir.
    * `index` (integer, opcional): O índice baseado em zero onde inserir o texto. Padrão: 1
  </Accordion>

  <Accordion title="google_docs/replace_text">
    **Descrição:** Substituir todas as instâncias de texto em um documento do Google.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `containsText` (string, obrigatório): O texto a encontrar e substituir.
    * `replaceText` (string, obrigatório): O texto para substituir.
    * `matchCase` (boolean, opcional): Se a pesquisa deve respeitar maiúsculas e minúsculas. Padrão: false
  </Accordion>

  <Accordion title="google_docs/delete_content_range">
    **Descrição:** Excluir conteúdo de um intervalo específico em um documento do Google.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `startIndex` (integer, obrigatório): O índice inicial do intervalo a excluir.
    * `endIndex` (integer, obrigatório): O índice final do intervalo a excluir.
  </Accordion>

  <Accordion title="google_docs/insert_page_break">
    **Descrição:** Inserir uma quebra de página em um local específico em um documento do Google.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `index` (integer, opcional): O índice baseado em zero onde inserir a quebra de página. Padrão: 1
  </Accordion>

  <Accordion title="google_docs/create_named_range">
    **Descrição:** Criar um intervalo nomeado em um documento do Google.

    **Parâmetros:**

    * `documentId` (string, obrigatório): O ID do documento a atualizar.
    * `name` (string, obrigatório): O nome para o intervalo nomeado.
    * `startIndex` (integer, obrigatório): O índice inicial do intervalo.
    * `endIndex` (integer, obrigatório): O índice final do intervalo.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Google Docs
```

---

## - vectordb (required): choose vector DB and pass its config

**URL:** llms-txt#--vectordb-(required):-choose-vector-db-and-pass-its-config

tool = PDFSearchTool(
    config={
        "embedding_model": {
            # Supported providers: "openai", "azure", "google-generativeai", "google-vertex",
            # "voyageai", "cohere", "huggingface", "jina", "sentence-transformer",
            # "text2vec", "ollama", "openclip", "instructor", "onnx", "roboflow", "watsonx", "custom"
            "provider": "openai",  # or: "google-generativeai", "cohere", "ollama", ...
            "config": {
                # Model identifier for the chosen provider. "model" will be auto-mapped to "model_name" internally.
                "model": "text-embedding-3-small",
                # Optional: API key. If omitted, the tool will use provider-specific env vars when available
                # (e.g., OPENAI_API_KEY for provider="openai").
                # "api_key": "sk-...",

# Provider-specific examples:
                # --- Google Generative AI ---
                # (Set provider="google-generativeai" above)
                # "model": "models/embedding-001",
                # "task_type": "retrieval_document",
                # "title": "Embeddings",

# --- Cohere ---
                # (Set provider="cohere" above)
                # "model": "embed-english-v3.0",

# --- Ollama (local) ---
                # (Set provider="ollama" above)
                # "model": "nomic-embed-text",
            },
        },
        "vectordb": {
                    "provider": "chromadb",  # or "qdrant"
                    "config": {
                        # For ChromaDB: pass "settings" (chromadb.config.Settings) or rely on defaults.
                        # Example (uncomment and import):
                        # from chromadb.config import Settings
                        # "settings": Settings(
                        #     persist_directory="/content/chroma",
                        #     allow_reset=True,
                        #     is_persistent=True,
                        # ),

# For Qdrant: pass "vectors_config" (qdrant_client.models.VectorParams).
                        # Example (uncomment and import):
                        # from qdrant_client.models import VectorParams, Distance
                        # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),

# Note: collection name is controlled by the tool (default: "rag_tool_collection"), not set here.
                    }
        },
    }
)
```

---

## Complex presentation automation task

**URL:** llms-txt#complex-presentation-automation-task

**Contents:**
  - Template and Content Creation

automation_task = Task(
    description="""
    1. Create multiple presentations for different departments
    2. Import relevant data from various spreadsheets
    3. Update existing presentations with new content
    4. Generate thumbnails for all presentations
    5. Link supporting documents from Drive
    6. Create a master index presentation with links to all others
    """,
    agent=presentation_automator,
    expected_output="Automated presentation workflow completed with multiple presentations and organized structure"
)

crew = Crew(
    agents=[presentation_automator],
    tasks=[automation_task]
)

crew.kickoff()
python  theme={null}
from crewai import Agent, Task, Crew

template_creator = Agent(
    role="Template Creator",
    goal="Create presentation templates and standardized content",
    backstory="An AI assistant that creates consistent presentation templates and content standards.",
    apps=['google_slides']
)

**Examples:**

Example 1 (unknown):
```unknown
### Template and Content Creation
```

---

## MCP 연결은 도구가 실제로 실행될 때만 만들어집니다

**URL:** llms-txt#mcp-연결은-도구가-실제로-실행될-때만-만들어집니다

---

## XML RAG Search

**URL:** llms-txt#xml-rag-search

Source: https://docs.crewai.com/en/tools/file-document/xmlsearchtool

The `XMLSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a XML file.

---

## Você também pode ver como a descrição da tarefa é formatada

**URL:** llms-txt#você-também-pode-ver-como-a-descrição-da-tarefa-é-formatada

**Contents:**
  - Sobrescrevendo Instruções Padrão

print("\n=== TASK CONTEXT ===")
print(f"Task Description: {task.description}")
print(f"Expected Output: {task.expected_output}")
python  theme={null}
from crewai import Agent

**Examples:**

Example 1 (unknown):
```unknown
### Sobrescrevendo Instruções Padrão

Você tem várias opções para obter controle total sobre os prompts:

#### Opção 1: Templates Personalizados (Recomendado)
```

---

## Create a `.env` file in your project root:

**URL:** llms-txt#create-a-`.env`-file-in-your-project-root:

---

## and return the 3 most relevant results with scores > 0.35

**URL:** llms-txt#and-return-the-3-most-relevant-results-with-scores->-0.35

**Contents:**
- 완전한 작동 예시

python  theme={null}
import os
import uuid
import pdfplumber
from openai import OpenAI
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process, LLM
from crewai_tools import QdrantVectorSearchTool
from qdrant_client import QdrantClient
from qdrant_client.models import PointStruct, Distance, VectorParams

**Examples:**

Example 1 (unknown):
```unknown
## 완전한 작동 예시

아래는 다음과 같은 방법을 보여주는 완전한 예시입니다:

1. PDF에서 텍스트 추출
2. OpenAI를 사용하여 임베딩 생성
3. Qdrant에 저장
4. CrewAI agentic RAG 워크플로우로 시맨틱 검색 생성
```

---

## Visão Geral do Langtrace

**URL:** llms-txt#visão-geral-do-langtrace

**Contents:**
- Instruções de Configuração
  - Funcionalidades e Sua Aplicação no CrewAI

O Langtrace é uma ferramenta externa e open-source que auxilia na configuração de observabilidade e avaliações para Modelos de Linguagem de Grande Porte (LLMs), frameworks de LLM e Bancos de Dados Vetoriais.
Apesar de não ser integrado diretamente ao CrewAI, o Langtrace pode ser utilizado em conjunto com o CrewAI para fornecer uma visibilidade aprofundada sobre o custo, latência e desempenho dos seus Agentes CrewAI.
Essa integração permite o registro de hiperparâmetros, o monitoramento de regressões de desempenho e o estabelecimento de um processo de melhoria contínua dos seus Agentes.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=85b67e42028ca9383087737279f8931f" alt="Visão geral de uma seleção de execuções de sessões de agentes" data-og-width="1717" width="1717" data-og-height="1299" height="1299" data-path="images/langtrace1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ba769f765ef36edf033e2caf8c7df4c7 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9e24743472c91a4b42dc235c8b16691a 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f70296efa8dd1619670008b9af8d7e78 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c8281aea8f979aa38ff1b6519e3fb840 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c55eafbe3e6fee44aaa208f8ce988847 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=677e866fb2e110afc4e7f6800abafdc3 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=24f08e5c56b6200e386d305a7bee347c" alt="Visão geral dos traces de agentes" data-og-width="1725" width="1725" data-og-height="1094" height="1094" data-path="images/langtrace2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9182a51d34df98e5a5b7b994b6d11d4d 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=fa10f203c90f5394c5a3fe5b96b52685 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1a1d34a1ac4c2d2d5a4748e4a4a46c97 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=81bb4d002d59c63f80c2cff7f2afbadd 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=de0fe6458f4595f73615ce7acb6b5d37 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=1cf56b30d10a0ef841aa762fa27c74a2 2500w" />
<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f1a8624e0c05d59deded640e4751a986" alt="Visão detalhada dos traces de LLM" data-og-width="1710" width="1710" data-og-height="1217" height="1217" data-path="images/langtrace3.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=3483f588b90a032d4919847e6e63772a 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c638c41d0e0e156c2c2e0ed1e80bfde1 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6d2b588d0a6c176a8fd80e4d3844d955 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=611c9167a54facb43c95a2239bba6a39 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=62a6bfc0052934c423ce245ddef1a28e 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/langtrace3.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=726ee5e7feed10e6f507233807e70ae9 2500w" />

## Instruções de Configuração

<Steps>
  <Step title="Crie uma conta no Langtrace">
    Cadastre-se acessando [https://langtrace.ai/signup](https://langtrace.ai/signup).
  </Step>

<Step title="Crie um projeto">
    Defina o tipo do projeto como `CrewAI` e gere uma chave de API.
  </Step>

<Step title="Instale o Langtrace no seu projeto CrewAI">
    Use o seguinte comando:

<Step title="Importe o Langtrace">
    Importe e inicialize o Langtrace no início do seu script, antes de quaisquer imports do CrewAI:

### Funcionalidades e Sua Aplicação no CrewAI

1. **Rastreamento de Token e Custo do LLM**

* Monitore o uso de tokens e os custos associados para cada interação dos agentes CrewAI.

2. **Gráfico de Trace para Etapas de Execução**

* Visualize o fluxo de execução das suas tarefas CrewAI, incluindo latência e logs.
   * Útil para identificar gargalos nos fluxos de trabalho dos seus agentes.

3. **Curadoria de Dataset com Anotação Manual**

* Crie conjuntos de dados a partir das saídas das suas tarefas CrewAI para futuros treinamentos ou avaliações.

4. **Versionamento e Gerenciamento de Prompt**

* Acompanhe as diferentes versões de prompts utilizados em seus agentes CrewAI.
   * Útil para testes A/B e otimização de desempenho dos agentes.

5. **Playground de Prompt com Comparações de Modelos**

* Teste e compare diferentes prompts e modelos para seus agentes CrewAI antes da implantação.

6. **Testes e Avaliações**

* Configure testes automatizados para seus agentes e tarefas CrewAI.

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Importe o Langtrace">
    Importe e inicialize o Langtrace no início do seu script, antes de quaisquer imports do CrewAI:
```

---

## 실제 payload로 Outlook 트리거 시뮬레이션

**URL:** llms-txt#실제-payload로-outlook-트리거-시뮬레이션

**Contents:**
- Troubleshooting

crewai triggers run microsoft_outlook/email_received
```

`crewai triggers run` 명령은 완전한 Outlook payload로 크루를 실행하여 배포 전에 파싱 로직을 테스트할 수 있게 해줍니다.

<Warning>
  개발 중에는 `crewai triggers run microsoft_outlook/email_received`를 사용하세요 (`crewai run`이 아님). 배포 후에는 크루가 자동으로 트리거 payload를 받습니다.
</Warning>

* Verify the Outlook connector is still authorized; the subscription must be renewed periodically
* `crewai triggers run microsoft_outlook/email_received`로 로컬 테스트하여 정확한 payload 구조를 확인하세요
* If attachments are missing, confirm the webhook subscription includes the `includeResourceData` flag
* Review execution logs when events fail to match—cancellation payloads lack attendee lists by design and the crew should account for that
* 주의: 트리거 실행을 시뮬레이션하려면 `crewai triggers run`을 사용하세요 (`crewai run`이 아님)

---

## Use essa configuração LLM com seus agentes

**URL:** llms-txt#use-essa-configuração-llm-com-seus-agentes

**Contents:**
  - 3. Prompting no CrewAI
  - 4. Guardrails para Crews Seguros

python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL, Portkey

# Inicialize o cliente admin do Portkey
    portkey_admin = Portkey(api_key="YOUR_PORTKEY_API_KEY")

# Recupere o prompt usando a render API
    prompt_data = portkey_client.prompts.render(
        prompt_id="YOUR_PROMPT_ID",
        variables={
            "agent_role": "Senior Research Scientist",
        }
    )

backstory_agent_prompt=prompt_data.data.messages[0]["content"]

# Configure o LLM com integração Portkey
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="dummy",
        extra_headers=createHeaders(
            api_key="YOUR_PORTKEY_API_KEY",
            virtual_key="YOUR_OPENAI_VIRTUAL_KEY"
        )
    )

# Crie o agente utilizando o prompt renderizado
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory=backstory_agent,  # Use o prompt renderizado
        verbose=True,
        llm=portkey_llm
    )
    python  theme={null}
    # Use uma versão específica do prompt
    prompt_data = portkey_admin.prompts.render(
        prompt_id="YOUR_PROMPT_ID@version_number",
        variables={
            "agent_role": "Senior Research Scientist",
            "agent_goal": "Discover groundbreaking insights"
        }
    )
    
    You are a {{agent_role}} with expertise in {{domain}}.

Your mission is to {{agent_goal}} by leveraging your knowledge
    and experience in the field.

Always maintain a {{tone}} tone and focus on providing {{focus_area}}.
    python  theme={null}
    prompt_data = portkey_admin.prompts.render(
        prompt_id="YOUR_PROMPT_ID",
        variables={
            "agent_role": "Senior Research Scientist",
            "domain": "artificial intelligence",
            "agent_goal": "discover groundbreaking insights",
            "tone": "professional",
            "focus_area": "practical applications"
        }
    )
    python  theme={null}
from crewai import Agent, LLM
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL

**Examples:**

Example 1 (unknown):
```unknown
Essa configuração automaticamente tentará o Claude caso a requisição para o GPT-4o falhe, garantindo que seu crew continue funcionando.

<CardGroup cols="2">
  <Card title="Tentativas Automáticas" icon="rotate" href="https://portkey.ai/docs/product/ai-gateway/automatic-retries">
    Lida automaticamente com falhas temporárias. Se uma chamada LLM falhar, o Portkey fará novas tentativas o número especificado de vezes – perfeito para limites de taxa ou instabilidades de rede.
  </Card>

  <Card title="Timeouts de Requisição" icon="clock" href="https://portkey.ai/docs/product/ai-gateway/request-timeouts">
    Evite que seus agentes fiquem travados. Defina timeouts para garantir respostas (ou falhas controladas) dentro do tempo necessário.
  </Card>

  <Card title="Roteamento Condicional" icon="route" href="https://portkey.ai/docs/product/ai-gateway/conditional-routing">
    Envie diferentes solicitações para diferentes provedores. Direcione raciocínios complexos para o GPT-4, tarefas criativas para Claude e respostas rápidas para Gemini conforme sua necessidade.
  </Card>

  <Card title="Fallbacks" icon="shield" href="https://portkey.ai/docs/product/ai-gateway/fallbacks">
    Mantenha-se em funcionamento mesmo se seu provedor principal falhar. Troque automaticamente para provedores de backup para manter a disponibilidade.
  </Card>

  <Card title="Balanceamento de Carga" icon="scale-balanced" href="https://portkey.ai/docs/product/ai-gateway/load-balancing">
    Distribua solicitações entre várias chaves de API ou provedores. Ótimo para operações de crew em grande escala e para permanecer dentro dos limites de taxa.
  </Card>
</CardGroup>

### 3. Prompting no CrewAI

O Prompt Engineering Studio do Portkey ajuda você a criar, gerenciar e otimizar os prompts usados em seus agentes CrewAI. Em vez de codificar prompts ou instruções manualmente, use a API de renderização de prompts do Portkey para buscar e aplicar dinâmicamente seus prompts versionados.

<Frame caption="Gerencie prompts na Prompt Library do Portkey">
  ![Prompt Playground Interface](https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs.webp)
</Frame>

<Tabs>
  <Tab title="Prompt Playground">
    Prompt Playground é um local para comparar, testar e implantar prompts perfeitos para sua aplicação de IA. É onde você experimenta com diferentes modelos, testa variáveis, compara saídas e refina sua estratégia de engenharia de prompts antes de implantar em produção. Ele permite:

    1. Desenvolver prompts de forma iterativa antes de usá-los em seus agentes
    2. Testar prompts com diferentes variáveis e modelos
    3. Comparar saídas entre diferentes versões de prompts
    4. Colaborar com membros da equipe no desenvolvimento de prompts

    Esse ambiente visual facilita a criação de prompts eficazes para cada etapa do fluxo de trabalho dos seus agentes CrewAI.
  </Tab>

  <Tab title="Usando Templates de Prompt">
    A API Prompt Render recupera seus templates de prompt com todos os parâmetros configurados:
```

Example 2 (unknown):
```unknown
</Tab>

  <Tab title="Versionamento de Prompts">
    Você pode:

    * Criar múltiplas versões do mesmo prompt
    * Comparar o desempenho entre versões
    * Voltar a versões anteriores se necessário
    * Especificar qual versão usar em seu código:
```

Example 3 (unknown):
```unknown
</Tab>

  <Tab title="Mustache Templating para variáveis">
    Os prompts do Portkey usam modelos estilo Mustache para fácil substituição de variáveis:
```

Example 4 (unknown):
```unknown
Ao renderizar, basta passar as variáveis:
```

---

## Alternativa: Divida as tarefas em partes menores

**URL:** llms-txt#alternativa:-divida-as-tarefas-em-partes-menores

---

## Snippet: Achetez vos billets exclusivement sur le site officiel de la billetterie de Paris 2024 pour participer au plus grand événement sportif au monde.

**URL:** llms-txt#snippet:-achetez-vos-billets-exclusivement-sur-le-site-officiel-de-la-billetterie-de-paris-2024-pour-participer-au-plus-grand-événement-sportif-au-monde.

---

## Carregador Web Browserbase

**URL:** llms-txt#carregador-web-browserbase

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/browserbaseloadtool

O Browserbase é uma plataforma para desenvolvedores para executar, gerenciar e monitorar navegadores headless de forma confiável.

---

## Create an agent with code execution enabled

**URL:** llms-txt#create-an-agent-with-code-execution-enabled

**Contents:**
  - Habilitando o `unsafe_mode`
- Parâmetros
- Exemplo de Integração com Agente

programmer_agent = Agent(
    role="Python Programmer",
    goal="Write and execute Python code to solve problems",
    backstory="An expert Python programmer who can write efficient code to solve complex problems.",
    allow_code_execution=True,  # This automatically adds the CodeInterpreterTool
    verbose=True,
)
python Code theme={null}
from crewai_tools import CodeInterpreterTool

code = """
import os
os.system("ls -la")
"""

CodeInterpreterTool(unsafe_mode=True).run(code=code)
python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import CodeInterpreterTool

**Examples:**

Example 1 (unknown):
```unknown
### Habilitando o `unsafe_mode`
```

Example 2 (unknown):
```unknown
## Parâmetros

O `CodeInterpreterTool` aceita os seguintes parâmetros durante a inicialização:

* **user\_dockerfile\_path**: Opcional. Caminho para um Dockerfile personalizado a ser utilizado pelo container do interpretador de código.
* **user\_docker\_base\_url**: Opcional. URL do daemon Docker que será usado para rodar o container.
* **unsafe\_mode**: Opcional. Indica se o código será executado diretamente na máquina hospedeira ao invés de um container Docker ou sandbox. O padrão é `False`. Use com cautela!
* **default\_image\_tag**: Opcional. Tag padrão da imagem Docker. O padrão é `code-interpreter:latest`

Ao utilizar a ferramenta com um agente, o agente precisará fornecer:

* **code**: Obrigatório. O código Python 3 a ser executado.
* **libraries\_used**: Opcional. Uma lista de bibliotecas usadas no código que precisam ser instaladas. O padrão é `[]`

## Exemplo de Integração com Agente

Aqui está um exemplo mais detalhado de como integrar o `CodeInterpreterTool` com um agente CrewAI:
```

---

## 전략적 LLM 선택 가이드

**URL:** llms-txt#전략적-llm-선택-가이드

**Contents:**
- CrewAI의 LLM 선택 접근 방식
- 빠른 결정 프레임워크
- 코어 선택 프레임워크
  - a. Task-First Thinking
  - b. 모델 역량 매핑
- 전략적 구성 패턴
  - a. 멀티-모델 접근 방식

Source: https://docs.crewai.com/ko/learn/llm-selection-guide

CrewAI AI 에이전트를 위한 적합한 LLM 선택 및 효과적인 작업과 에이전트 정의 작성에 대한 전략적 프레임워크

## CrewAI의 LLM 선택 접근 방식

처방적인 모델 추천보다는, **사고 프레임워크**를 제안하여 특정 사용 사례, 제약 조건, 요구 사항에 따라 정보에 입각한 결정을 내릴 수 있도록 돕고자 합니다. LLM 환경은 빠르게 변화하고 있으며, 새로운 모델이 정기적으로 등장하고 기존 모델도 자주 업데이트되고 있습니다. 가장 중요한 것은 어떤 특정 모델이 제공되는지와 상관없이 평가를 위한 체계적인 접근법을 개발하는 것입니다.

<Note>
  이 가이드는 LLM 환경이 빠르게 변화하고 있기 때문에 특정 모델 추천보다는 전략적 사고에 초점을 맞추고 있습니다.
</Note>

<Steps>
  <Step title="작업 분석">
    먼저, 작업이 실제로 무엇을 요구하는지 깊이 이해하세요. 필요한 인지 복잡성, 요구되는 추론의 깊이, 기대되는 출력 형식, 모델이 처리해야 할 맥락의 양을 고려합니다. 이러한 기본 분석이 이후의 모든 결정을 안내할 것입니다.
  </Step>

<Step title="모델 역량 매핑">
    요구 사항을 이해한 후, 이를 모델의 강점에 매핑하세요. 서로 다른 모델 계열은 작업 유형에 따라 특화되어 있습니다. 일부는 추론 및 분석에 최적화되어 있고, 일부는 창의성이나 콘텐츠 생성, 또 다른 일부는 속도와 효율성에 최적화되어 있습니다.
  </Step>

<Step title="제약 조건 고려">
    예산 제한, 지연 시간 요구사항, 데이터 프라이버시 필요성, 인프라 역량 등 실제 운영상의 제약 조건을 반영하세요. 이론적으로 가장 좋은 모델이 실제로는 최선의 선택이 아닐 수 있습니다.
  </Step>

<Step title="테스트 및 반복">
    신뢰할 수 있고 잘 이해된 모델로 시작하여, 특정 사용 사례에서 실제 성능을 바탕으로 최적화하세요. 실제 결과는 이론적 벤치마크와 다를 수 있으므로, 경험적 테스트가 매우 중요합니다.
  </Step>
</Steps>

### a. Task-First Thinking

LLM을 선택할 때 가장 중요한 단계는 실제로 여러분의 작업이 무엇을 요구하는지 이해하는 것입니다. 너무 자주 팀들은 특정 요구 사항을 면밀하게 분석하지 않고, 일반적인 평판이나 벤치마크 점수를 기반으로 모델을 선택합니다. 이런 접근 방식은 단순한 작업에 비싸고 복잡한 모델을 과도하게 적용하거나, 정교한 업무에 필요한 기능이 부족한 모델을 선택하게 만들어 결과적으로 과소 성능 문제를 야기합니다.

<Tabs>
  <Tab title="Reasoning Complexity">
    * **Simple Tasks**는 대부분의 일상적인 AI 작업을 대표하며, 기본 명령 수행, 간단한 데이터 처리, 단순한 포맷팅 작업 등을 포함합니다. 이러한 작업은 일반적으로 명확한 입력과 출력을 가지고 있으며 모호성이 거의 없습니다. 인지적 부하는 낮고, 모델은 복잡한 추론보다는 명확한 지시에 따라 움직이면 됩니다.

* **Complex Tasks**는 다단계 추론, 전략적 사고, 모호하거나 불완전한 정보를 처리하는 능력을 필요로 합니다. 여러 데이터 소스를 분석하거나, 포괄적 전략을 개발하거나, 더 작은 구성 요소로 분해해야 하는 문제 해결 작업 등이 이에 해당합니다. 모델은 여러 추론 단계를 거치는 동안 맥락을 유지해야 하며, 명시적으로 언급되지 않은 내용을 추론해야 할 때가 많습니다.

* **Creative Tasks**는 새롭고, 흥미로우며, 맥락에 적합한 콘텐츠를 생성하는 데 중점을 둔 새로운 인지적 능력을 요구합니다. 여기에는 스토리텔링, 마케팅 카피 작성, 창의적 문제 해결이 포함됩니다. 모델은 뉘앙스, 톤, 대상 청중을 이해하고, 공식적이지 않고 진정성 있고 흥미로운 콘텐츠를 제작해야 합니다.
  </Tab>

<Tab title="Output Requirements">
    * **Structured Data** 작업은 포맷 규칙 준수의 정확성과 일관성을 요구합니다. JSON, XML, 데이터베이스 포맷 등을 다루는 경우, 모델은 구문적으로 올바른 출력을 안정적으로 생성할 수 있어야 하며, 이는 프로그램적으로 처리 가능해야 합니다. 이런 작업에는 엄격한 검증 요구 사항이 있으며 포맷 에러에 대한 허용 오차가 매우 적기 때문에, 창의성보다는 신뢰성이 더 중요합니다.

* **Creative Content** 출력은 기술적 역량과 창의적 감각의 균형을 필요로 합니다. 모델은 대상 청중, 톤, 브랜드 보이스를 이해하고, 독자의 관심을 끌며 특정 커뮤니케이션 목표를 달성하는 콘텐츠를 제작할 수 있어야 합니다. 이 영역의 품질은 주관적인 경우가 많으며, 다양한 맥락과 목적에 맞게 글쓰기 스타일을 조정할 수 있는 모델이 필요합니다.

* **Technical Content**는 구조화된 데이터와 창의적 콘텐츠의 중간에 위치하며, 정확성과 명확성을 모두 필요로 합니다. 문서화, 코드 생성, 기술 분석 등은 정밀하면서도 포괄적으로 작성되어야 하며, 대상이 되는 청중에게 효과적으로 전달되어야 합니다. 모델은 복잡한 기술 개념을 이해하고 이를 명확하게 설명할 수 있어야 합니다.
  </Tab>

<Tab title="Context Needs">
    * **Short Context** 시나리오는 모델이 한정된 정보를 신속하게 처리해야 하는 즉각적이고 집중된 업무를 포함합니다. 이는 대체로 속도와 효율성이 심도 있는 이해보다 더 중요한 거래성 상호작용에서 주로 발생합니다. 모델은 긴 대화 내역이나 대용량 문서를 유지할 필요가 없습니다.

* **Long Context** 요구 사항은 방대한 문서 작업, 장기간 대화, 복잡한 다중 파트 작업을 처리할 때 발생합니다. 모델은 수천 토큰에 걸쳐 일관성을 유지해야 하며, 앞선 정보를 정확히 참조할 수 있어야 합니다. 이는 문서 분석, 포괄적 연구, 정교한 대화 시스템에 매우 중요한 기능입니다.

* **Very Long Context** 시나리오는 현재 가능한 한계를 뛰어넘는 경우로, 대규모 문서 처리, 광범위한 연구 종합, 복잡한 다중 세션 상호작용 등이 있습니다. 이러한 활용 사례는 확장된 컨텍스트 처리를 위해 특별히 설계된 모델이 필요하며, 종종 컨텍스트 길이와 처리 속도 간의 절충이 발생합니다.
  </Tab>
</Tabs>

모델 역량을 이해하기 위해서는 마케팅 주장이나 벤치마크 점수 너머를 바라보고, 다양한 모델 구조와 학습 접근법의 근본적인 강점과 한계를 파악해야 합니다.

<AccordionGroup>
  <Accordion title="Reasoning Models" icon="brain">
    Reasoning 모델은 복잡하고 다단계의 사고가 필요한 작업을 위해 특별히 설계된 특수 카테고리를 나타냅니다. 이러한 모델은 문제를 신중하게 분석하거나 전략적으로 계획을 세우거나 체계적으로 문제를 분해해야 하는 경우에 뛰어납니다. 일반적으로 chain-of-thought reasoning 혹은 tree-of-thought processing과 같은 기법을 사용하여 복잡한 문제를 단계별로 해결합니다.

Reasoning 모델의 강점은 확장된 reasoning 체인에서 논리적 일관성을 유지하고, 복잡한 문제를 관리 가능한 구성 요소로 나눌 수 있다는 점에 있습니다. 전략적 계획, 복잡한 분석, 그리고 응답 속도보다 reasoning의 질이 더 중요한 상황에서 특히 가치가 있습니다.

하지만 reasoning 모델은 속도와 비용 면에서 트레이드오프가 따르는 경우가 많습니다. 또한 그들의 고도화된 reasoning 역량이 필요 없는 창의적인 작업이나 간단한 작업에는 덜 적합할 수 있습니다. 체계적이고 단계적인 분석이 요구되는 진정한 복잡성이 관련된 작업에서 이러한 모델을 고려하십시오.
  </Accordion>

<Accordion title="General Purpose Models" icon="microchip">
    General purpose 모델은 LLM 선택에서 가장 균형 잡힌 접근 방식을 제공하며, 특정 영역에 극단적으로 특화되지 않으면서도 다양한 작업에 대해 견고한 성능을 제공합니다. 이러한 모델은 다양한 데이터셋으로 학습되었으며, 특정 도메인에서의 최고 성능보다는 다재다능함에 최적화되어 있습니다.

General purpose 모델의 주요 장점은 다양한 유형의 작업에서 예측 가능한 신뢰성과 일관성입니다. 조사, 분석, 콘텐츠 제작, 데이터 처리 등 대부분의 표준 비즈니스 작업을 충분히 처리할 수 있습니다. 이로 인해 다양한 워크플로우 전반에서 일관된 성능이 필요한 팀에 매우 적합한 선택이 됩니다.

General purpose 모델은 특정 도메인에서 특화된 대안들이 보여주는 최고 성능에는 미치지 않을 수 있지만, 운영의 단순성과 모델 관리의 복잡성 감소라는 이점이 있습니다. 신규 프로젝트의 시작점으로 가장 좋은 선택인 경우가 많으며, 팀이 구체적인 필요를 이해하고 나서 특화 모델로 최적화할 수 있습니다.
  </Accordion>

<Accordion title="Fast & Efficient Models" icon="bolt">
    Fast and efficient 모델은 고도화된 reasoning 역량보다 속도, 비용 효율, 리소스 효율성을 우선순위에 둡니다. 이러한 모델은 빠른 응답성과 낮은 운영비용이 중요하고, 미묘한 이해나 복잡한 reasoning이 덜 요구되는 고처리량 시나리오에 최적화되어 있습니다.

이러한 모델은 일상적인 운영, 간단한 데이터 처리, 함수 호출, 대용량 작업 등 인지적 요구가 비교적 단순한 시나리오에서 뛰어납니다. 많은 요청을 신속하게 처리해야 하거나 예산 제약 내에서 운영되어야 하는 애플리케이션에 특히 유용합니다.

효율적인 모델에서 가장 중요한 고려사항은 그들의 역량이 귀하의 작업 요구와 일치하는지 확인하는 것입니다. 많은 일상적 작업은 효과적으로 처리할 수 있지만, Nuanced한 이해, 복잡한 reasoning, 혹은 고도화된 콘텐츠 생성이 필요한 작업에는 어려움을 겪을 수 있습니다. 정교함보다 속도와 비용이 더 중요한 명확하고 일상적인 작업에 가장 적합합니다.
  </Accordion>

<Accordion title="Creative Models" icon="pen">
    Creative 모델은 콘텐츠 생성, 글쓰기 품질, 창의적 사고가 요구되는 작업에 특별히 최적화되어 있습니다. 이러한 모델은 뉘앙스, 톤, 스타일을 이해하면서도 자연스럽고 진정성 있게 느껴지는 매력적이고 맥락에 맞는 콘텐츠를 생성하는 데 뛰어납니다.

Creative 모델의 강점은 다양한 대상에 맞춰 글쓰기 스타일을 조정하고, 일관된 목소리와 톤을 유지하며, 독자를 효과적으로 사로잡는 콘텐츠를 생성할 수 있다는 점입니다. 스토리텔링, 마케팅 카피, 브랜드 커뮤니케이션 등 창의성과 몰입이 주요 목적이 되는 콘텐츠 작업에서 더 우수한 성과를 보입니다.

Creative 모델을 선택할 때는 단순한 텍스트 생성 능력뿐 아니라, 대상, 맥락, 목적에 대한 이해력도 함께 고려해야 합니다. 최상의 creative 모델은 특정 브랜드 목소리에 맞게 출력 내용을 조정하고, 다양한 대상 그룹을 타깃팅하며, 긴 콘텐츠에서도 일관성을 유지할 수 있습니다.
  </Accordion>

<Accordion title="Open Source Models" icon="code">
    Open source 모델은 비용 통제, 맞춤화 가능성, 데이터 프라이버시, 배포 유연성 측면에서 독특한 이점을 제공합니다. 이러한 모델은 로컬이나 사설 인프라에서 운용이 가능하여 데이터 처리 및 모델 동작에 대해 완전한 통제권을 제공합니다.

Open source 모델의 주요 이점으로는 토큰당 비용의 제거, 특정 용도에 맞춘 파인튜닝 가능성, 완전한 데이터 프라이버시, 외부 API 제공자에 대한 의존성 해소가 있습니다. 특히 엄격한 데이터 프라이버시 요구사항, 예산 제약, 특정 맞춤화 필요가 있는 조직에 매우 유용합니다.

그러나 open source 모델은 효과적으로 배포 및 유지관리하기 위해 더 많은 기술 전문성이 필요합니다. 팀에서는 인프라 비용, 모델 관리 복잡성, 지속적인 모델 업데이트 및 최적화를 위한 지속적인 노력을 고려해야 합니다. 기술적 오버헤드를 감안하면 전체 소유 비용이 클라우드 기반 대안보다 높을 수 있습니다.
  </Accordion>
</AccordionGroup>

<Tip>
  동일 crew 내에서 다양한 목적에 맞는 서로 다른 모델을 사용해 성능과 비용을 모두 최적화할 수 있습니다.
</Tip>

가장 정교하게 구현된 CrewAI의 경우, 여러 개의 모델을 전략적으로 활용하여 각 agent의 역할과 요구 사항에 맞는 모델을 지정합니다. 이 접근 방식은 각 작업 유형에 가장 적합한 모델을 사용함으로써 성능과 비용을 모두 최적화할 수 있게 해줍니다.

planning agent는 복잡한 전략적 사고와 다단계 분석을 처리할 수 있는 reasoning 모델을 활용할 때 이점을 얻습니다. 이 agent들은 운영의 “두뇌” 역할을 하며, 전략 수립과 다른 agent들의 작업을 조정합니다. 반면 content agent는 글의 품질과 독자 참여에 뛰어난 creative 모델을 통해 최고의 성능을 발휘합니다. 일상적인 작업과 운영을 담당하는 processing agent는 속도와 비용 효율을 우선시하는 효율적인 모델을 사용할 수 있습니다.

**예시: Research and Analysis Crew**

```python  theme={null}
from crewai import Agent, Task, Crew, LLM

---

## Visão Geral do Opik

**URL:** llms-txt#visão-geral-do-opik

**Contents:**
- Configuração
- Recursos

Com o [Comet Opik](https://www.comet.com/docs/opik/), depure, avalie e monitore suas aplicações LLM, sistemas RAG e fluxos de trabalho agentic com rastreamento detalhado, avaliações automatizadas e dashboards prontos para produção.

<Frame caption="Dashboard do Agente Opik">
  <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6b313c7d767211f2287d7dd074f9dfeb" alt="Exemplo de monitoramento de agente Opik com CrewAI" data-og-width="1538" width="1538" data-og-height="877" height="877" data-path="images/opik-crewai-dashboard.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b0fd3eca42762838a806dc0d38d0313f 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ba1166f8b42afee86b3cd88532002fde 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d7905602ba2ac1dbca66a008be49ca26 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=51c2c8ce83af0d81fdf851dd378fe6f6 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5184c8370b92c51a03d970a01c7daba5 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/opik-crewai-dashboard.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=80d3fb638cd8ace74953775242cb68cd 2500w" />
</Frame>

O Opik oferece suporte abrangente para cada etapa do desenvolvimento da sua aplicação CrewAI:

* **Registrar Traces e Spans**: Acompanhe automaticamente chamadas LLM e lógica da aplicação para depurar e analisar sistemas em desenvolvimento e em produção. Anote manualmente ou programaticamente, visualize e compare respostas entre projetos.
* **Avalie a Performance da sua Aplicação LLM**: Avalie contra um conjunto de testes personalizado e execute métricas de avaliação nativas ou defina suas próprias métricas via SDK ou UI.
* **Teste no Pipeline CI/CD**: Estabeleça bases de performance confiáveis com os testes unitários LLM do Opik, baseados em PyTest. Execute avaliações online para monitoramento contínuo em produção.
* **Monitore & Analise Dados de Produção**: Entenda a performance dos seus modelos em dados inéditos em produção e gere conjuntos de dados para novas iterações de desenvolvimento.

A Comet oferece uma versão hospedada da plataforma Opik, ou você pode rodar a plataforma localmente.

Para usar a versão hospedada, basta [criar uma conta gratuita na Comet](https://www.comet.com/signup?utm_medium=github\&utm_source=crewai_docs) e obter sua chave de API.

Para rodar a plataforma Opik localmente, veja nosso [guia de instalação](https://www.comet.com/docs/opik/self-host/overview/) para mais informações.

Neste guia, utilizaremos o exemplo de início rápido da CrewAI.

<Steps>
  <Step title="Instale os pacotes necessários">
    
  </Step>

<Step title="Configure o Opik">
    
  </Step>

<Step title="Prepare o ambiente">
    Primeiro, configuramos nossas chaves de API do provedor LLM como variáveis de ambiente:

<Step title="Usando a CrewAI">
    O primeiro passo é criar nosso projeto. Vamos utilizar um exemplo da documentação do CrewAI:

Agora podemos importar o tracker do Opik e executar nossa crew:

Após rodar sua aplicação CrewAI, acesse o app Opik para visualizar:

* Traces LLM, spans e seus metadados
    * Interações dos agentes e fluxo de execução das tarefas
    * Métricas de performance, como latência e uso de tokens
    * Métricas de avaliação (nativas ou personalizadas)
  </Step>
</Steps>

* [🦉 Documentação Opik](https://www.comet.com/docs/opik/)
* [👉 Opik + CrewAI Colab](https://colab.research.google.com/github/comet-ml/opik/blob/main/apps/opik-documentation/documentation/docs/cookbook/crewai.ipynb)
* [🐦 X](https://x.com/cometml)
* [💬 Slack](https://slack.comet.com/)

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Configure o Opik">
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Prepare o ambiente">
    Primeiro, configuramos nossas chaves de API do provedor LLM como variáveis de ambiente:
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="Usando a CrewAI">
    O primeiro passo é criar nosso projeto. Vamos utilizar um exemplo da documentação do CrewAI:
```

Example 4 (unknown):
```unknown
Agora podemos importar o tracker do Opik e executar nossa crew:
```

---

## Generate OpenAI embeddings

**URL:** llms-txt#generate-openai-embeddings

def get_openai_embedding(text):
    response = client.embeddings.create(
        input=text,
        model="text-embedding-3-large"
    )
    return response.data[0].embedding

---

## 코드 인터프리터

**URL:** llms-txt#코드-인터프리터

Source: https://docs.crewai.com/ko/tools/ai-ml/codeinterpretertool

CodeInterpreterTool은(는) 안전하고 격리된 환경 내에서 Python 3 코드를 실행하도록 설계된 강력한 도구입니다.

---

## Creation timestamp (auto-generated)

**URL:** llms-txt#creation-timestamp-(auto-generated)

created_at = fingerprint.created_at  # A datetime object

---

## Your OpenAI key

**URL:** llms-txt#your-openai-key

os.environ["OPENAI_API_KEY"] = "sk-proj-..."
python  theme={null}
from langfuse import get_client
 
langfuse = get_client()

**Examples:**

Example 1 (unknown):
```unknown
With the environment variables set, we can now initialize the Langfuse client. get\_client() initializes the Langfuse client using the credentials provided in the environment variables.
```

---

## Inicialize a ferramenta permitindo buscas em qualquer conteúdo PDF caso o caminho seja informado durante a execução

**URL:** llms-txt#inicialize-a-ferramenta-permitindo-buscas-em-qualquer-conteúdo-pdf-caso-o-caminho-seja-informado-durante-a-execução

tool = PDFSearchTool()

---

## Scrapegraph Scrape Tool

**URL:** llms-txt#scrapegraph-scrape-tool

Source: https://docs.crewai.com/en/tools/web-scraping/scrapegraphscrapetool

The `ScrapegraphScrapeTool` leverages Scrapegraph AI's SmartScraper API to intelligently extract content from websites.

---

## Integração com Salesforce

**URL:** llms-txt#integração-com-salesforce

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Salesforce
  - 1. Conecte sua Conta Salesforce
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ferramentas Disponíveis
  - **Gerenciamento de Registros**
  - **Atualização de Registros**
  - **Recuperação de Registros**

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/salesforce

Automação de vendas e CRM com integração Salesforce para CrewAI.

Permita que seus agentes gerenciem relacionamentos com clientes, processos de vendas e dados através do Salesforce. Crie e atualize registros, gerencie leads e oportunidades, execute consultas SOQL e otimize seus fluxos de trabalho de CRM com automação potencializada por IA.

Antes de usar a integração Salesforce, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Salesforce com permissões apropriadas
* Sua conta Salesforce conectada via a [página de Integrações](https://app.crewai.com/integrations)

## Configurando a Integração Salesforce

### 1. Conecte sua Conta Salesforce

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Salesforce** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de CRM e vendas
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

## Ferramentas Disponíveis

### **Gerenciamento de Registros**

<AccordionGroup>
  <Accordion title="salesforce/create_record_contact">
    **Descrição:** Crie um novo registro de Contato no Salesforce.

* `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, obrigatório): Sobrenome - Este campo é obrigatório
    * `accountId` (string, opcional): ID da Conta - Conta à qual o contato pertence
    * `Email` (string, opcional): Endereço de e-mail
    * `Title` (string, opcional): Cargo do contato, como CEO ou Vice-presidente
    * `Description` (string, opcional): Descrição do contato
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Contato
  </Accordion>

<Accordion title="salesforce/create_record_lead">
    **Descrição:** Crie um novo registro de Lead no Salesforce.

* `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, obrigatório): Sobrenome - Este campo é obrigatório
    * `Company` (string, obrigatório): Empresa - Este campo é obrigatório
    * `Email` (string, opcional): Endereço de e-mail
    * `Phone` (string, opcional): Número de telefone
    * `Website` (string, opcional): URL do site
    * `Title` (string, opcional): Cargo do contato, como CEO ou Vice-presidente
    * `Status` (string, opcional): Status do Lead - Use as Configurações de Workflow do Connect Portal para selecionar o status do Lead
    * `Description` (string, opcional): Descrição do lead
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Lead
  </Accordion>

<Accordion title="salesforce/create_record_opportunity">
    **Descrição:** Crie um novo registro de Oportunidade no Salesforce.

* `Name` (string, obrigatório): Nome da Oportunidade - Este campo é obrigatório
    * `StageName` (string, opcional): Estágio da Oportunidade - Use as Configurações de Workflow do Connect Portal para selecionar o estágio
    * `CloseDate` (string, opcional): Data de fechamento no formato YYYY-MM-DD - Padrão para 30 dias a partir da data atual
    * `AccountId` (string, opcional): Conta à qual a Oportunidade pertence
    * `Amount` (string, opcional): Valor total estimado da venda
    * `Description` (string, opcional): Descrição da oportunidade
    * `OwnerId` (string, opcional): Usuário Salesforce designado para esta Oportunidade
    * `NextStep` (string, opcional): Descrição da próxima tarefa no fechamento da Oportunidade
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Oportunidade
  </Accordion>

<Accordion title="salesforce/create_record_task">
    **Descrição:** Crie um novo registro de Tarefa no Salesforce.

* `whatId` (string, opcional): Relacionado ao ID - ID da Conta ou Oportunidade relacionada à Tarefa
    * `whoId` (string, opcional): ID do Nome - ID do Contato ou Lead relacionado à Tarefa
    * `subject` (string, obrigatório): Assunto da tarefa
    * `activityDate` (string, opcional): Data da Atividade no formato YYYY-MM-DD
    * `description` (string, opcional): Descrição da tarefa
    * `taskSubtype` (string, obrigatório): Subtipo da Tarefa - Opções: task, email, listEmail, call
    * `Status` (string, opcional): Status - Opções: Not Started, In Progress, Completed
    * `ownerId` (string, opcional): ID do responsável - Usuário Salesforce designado para a Tarefa
    * `callDurationInSeconds` (string, opcional): Duração da chamada em segundos
    * `isReminderSet` (boolean, opcional): Se o lembrete está definido
    * `reminderDateTime` (string, opcional): Data/Hora do lembrete no formato ISO
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Tarefa
  </Accordion>

<Accordion title="salesforce/create_record_account">
    **Descrição:** Crie um novo registro de Conta no Salesforce.

* `Name` (string, obrigatório): Nome da Conta - Este campo é obrigatório
    * `OwnerId` (string, opcional): Usuário Salesforce responsável por esta Conta
    * `Website` (string, opcional): URL do site
    * `Phone` (string, opcional): Número de telefone
    * `Description` (string, opcional): Descrição da conta
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Conta
  </Accordion>

<Accordion title="salesforce/create_record_any">
    **Descrição:** Crie um registro de qualquer tipo de objeto no Salesforce.

**Nota:** Esta é uma ferramenta flexível para criar registros de tipos de objetos personalizados ou desconhecidos.
  </Accordion>
</AccordionGroup>

### **Atualização de Registros**

<AccordionGroup>
  <Accordion title="salesforce/update_record_contact">
    **Descrição:** Atualize um registro de Contato existente no Salesforce.

* `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, opcional): Sobrenome
    * `accountId` (string, opcional): ID da Conta à qual o contato pertence
    * `Email` (string, opcional): Endereço de e-mail
    * `Title` (string, opcional): Cargo do contato
    * `Description` (string, opcional): Descrição do contato
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Contato
  </Accordion>

<Accordion title="salesforce/update_record_lead">
    **Descrição:** Atualize um registro de Lead existente no Salesforce.

* `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, opcional): Sobrenome
    * `Company` (string, opcional): Nome da empresa
    * `Email` (string, opcional): Endereço de e-mail
    * `Phone` (string, opcional): Número de telefone
    * `Website` (string, opcional): URL do site
    * `Title` (string, opcional): Cargo do contato
    * `Status` (string, opcional): Status do Lead
    * `Description` (string, opcional): Descrição do lead
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Lead
  </Accordion>

<Accordion title="salesforce/update_record_opportunity">
    **Descrição:** Atualize um registro de Oportunidade existente no Salesforce.

* `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `Name` (string, opcional): Nome da Oportunidade
    * `StageName` (string, opcional): Estágio da oportunidade
    * `CloseDate` (string, opcional): Data de fechamento no formato YYYY-MM-DD
    * `AccountId` (string, opcional): Conta à qual a Oportunidade pertence
    * `Amount` (string, opcional): Valor total estimado da venda
    * `Description` (string, opcional): Descrição da oportunidade
    * `OwnerId` (string, opcional): Usuário Salesforce responsável por esta Oportunidade
    * `NextStep` (string, opcional): Descrição da próxima tarefa no fechamento da Oportunidade
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Oportunidade
  </Accordion>

<Accordion title="salesforce/update_record_task">
    **Descrição:** Atualize um registro de Tarefa existente no Salesforce.

* `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `whatId` (string, opcional): Relacionado ao ID - ID da Conta ou Oportunidade relacionada
    * `whoId` (string, opcional): ID do Nome - ID do Contato ou Lead relacionado à Tarefa
    * `subject` (string, opcional): Assunto da tarefa
    * `activityDate` (string, opcional): Data da Atividade no formato YYYY-MM-DD
    * `description` (string, opcional): Descrição da tarefa
    * `Status` (string, opcional): Status - Opções: Not Started, In Progress, Completed
    * `ownerId` (string, opcional): ID do responsável - Usuário Salesforce designado para a Tarefa
    * `callDurationInSeconds` (string, opcional): Duração da chamada em segundos
    * `isReminderSet` (boolean, opcional): Se o lembrete está definido
    * `reminderDateTime` (string, opcional): Data/Hora do lembrete em formato ISO
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Tarefa
  </Accordion>

<Accordion title="salesforce/update_record_account">
    **Descrição:** Atualize um registro de Conta existente no Salesforce.

* `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `Name` (string, opcional): Nome da Conta
    * `OwnerId` (string, opcional): Usuário Salesforce responsável por esta Conta
    * `Website` (string, opcional): URL do site
    * `Phone` (string, opcional): Número de telefone
    * `Description` (string, opcional): Descrição da conta
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Conta
  </Accordion>

<Accordion title="salesforce/update_record_any">
    **Descrição:** Atualize um registro de qualquer tipo de objeto no Salesforce.

**Nota:** Esta é uma ferramenta flexível para atualizar registros de tipos de objetos personalizados ou desconhecidos.
  </Accordion>
</AccordionGroup>

### **Recuperação de Registros**

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_id_contact">
    **Descrição:** Obtenha um registro de Contato pelo seu ID.

* `recordId` (string, obrigatório): ID do registro do Contato
  </Accordion>

<Accordion title="salesforce/get_record_by_id_lead">
    **Descrição:** Obtenha um registro de Lead pelo seu ID.

* `recordId` (string, obrigatório): ID do registro do Lead
  </Accordion>

<Accordion title="salesforce/get_record_by_id_opportunity">
    **Descrição:** Obtenha um registro de Oportunidade pelo seu ID.

* `recordId` (string, obrigatório): ID do registro da Oportunidade
  </Accordion>

<Accordion title="salesforce/get_record_by_id_task">
    **Descrição:** Obtenha um registro de Tarefa pelo seu ID.

* `recordId` (string, obrigatório): ID do registro da Tarefa
  </Accordion>

<Accordion title="salesforce/get_record_by_id_account">
    **Descrição:** Obtenha um registro de Conta pelo seu ID.

* `recordId` (string, obrigatório): ID do registro da Conta
  </Accordion>

<Accordion title="salesforce/get_record_by_id_any">
    **Descrição:** Obtenha um registro de qualquer tipo de objeto pelo seu ID.

* `recordType` (string, obrigatório): Tipo do registro (ex.: "CustomObject\_\_c")
    * `recordId` (string, obrigatório): ID do registro
  </Accordion>
</AccordionGroup>

### **Busca de Registros**

<AccordionGroup>
  <Accordion title="salesforce/search_records_contact">
    **Descrição:** Pesquise registros de Contato com filtragem avançada.

* `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/search_records_lead">
    **Descrição:** Pesquise registros de Lead com filtragem avançada.

* `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/search_records_opportunity">
    **Descrição:** Pesquise registros de Oportunidade com filtragem avançada.

* `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/search_records_task">
    **Descrição:** Pesquise registros de Tarefa com filtragem avançada.

* `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/search_records_account">
    **Descrição:** Pesquise registros de Conta com filtragem avançada.

* `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/search_records_any">
    **Descrição:** Pesquise registros de qualquer tipo de objeto.

* `recordType` (string, obrigatório): Tipo de registro para buscar
    * `filterFormula` (string, opcional): Critérios de busca por filtro
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>
</AccordionGroup>

### **Recuperação por List View**

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_view_id_contact">
    **Descrição:** Obtenha registros de Contato de um List View específico.

* `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_lead">
    **Descrição:** Obtenha registros de Lead de um List View específico.

* `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_opportunity">
    **Descrição:** Obtenha registros de Oportunidade de um List View específico.

* `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_task">
    **Descrição:** Obtenha registros de Tarefa de um List View específico.

* `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_account">
    **Descrição:** Obtenha registros de Conta de um List View específico.

* `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

<Accordion title="salesforce/get_record_by_view_id_any">
    **Descrição:** Obtenha registros de qualquer tipo de objeto a partir de um List View específico.

* `recordType` (string, obrigatório): Tipo do registro
    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>
</AccordionGroup>

### **Campos Personalizados**

<AccordionGroup>
  <Accordion title="salesforce/create_custom_field_contact">
    **Descrição:** Crie campos personalizados para objetos de Contato.

* `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

<Accordion title="salesforce/create_custom_field_lead">
    **Descrição:** Crie campos personalizados para objetos de Lead.

* `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

<Accordion title="salesforce/create_custom_field_opportunity">
    **Descrição:** Crie campos personalizados para objetos de Oportunidade.

* `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

<Accordion title="salesforce/create_custom_field_task">
    **Descrição:** Crie campos personalizados para objetos de Tarefa.

* `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

<Accordion title="salesforce/create_custom_field_account">
    **Descrição:** Crie campos personalizados para objetos de Conta.

* `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

<Accordion title="salesforce/create_custom_field_any">
    **Descrição:** Crie campos personalizados para qualquer tipo de objeto.

**Nota:** Esta é uma ferramenta flexível para criar campos personalizados para tipos de objetos personalizados ou desconhecidos.
  </Accordion>
</AccordionGroup>

### **Operações Avançadas**

<AccordionGroup>
  <Accordion title="salesforce/write_soql_query">
    **Descrição:** Execute consultas SOQL personalizadas em seus dados do Salesforce.

* `query` (string, obrigatório): Consulta SOQL (ex.: "SELECT Id, Name FROM Account WHERE Name = 'Exemplo'")
  </Accordion>

<Accordion title="salesforce/create_custom_object">
    **Descrição:** Crie um novo objeto personalizado no Salesforce.

* `label` (string, obrigatório): Rótulo do objeto para abas, layouts de página e relatórios
    * `pluralLabel` (string, obrigatório): Rótulo plural (ex.: "Contas")
    * `description` (string, opcional): Uma descrição do Objeto Personalizado
    * `recordName` (string, obrigatório): Nome do registro exibido em layouts e buscas (ex.: "Nome da Conta")
  </Accordion>

<Accordion title="salesforce/describe_action_schema">
    **Descrição:** Obtenha o schema esperado para operações em tipos de objetos específicos.

* `recordType` (string, obrigatório): Tipo de registro a ser detalhado
    * `operation` (string, obrigatório): Tipo de Operação (ex.: "CREATE\_RECORD" ou "UPDATE\_RECORD")

**Nota:** Use esta função primeiro ao trabalhar com objetos personalizados para entender seu schema antes de realizar operações.
  </Accordion>
</AccordionGroup>

### Configuração Básica de um Agente Salesforce

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ferramentas Disponíveis

### **Gerenciamento de Registros**

<AccordionGroup>
  <Accordion title="salesforce/create_record_contact">
    **Descrição:** Crie um novo registro de Contato no Salesforce.

    **Parâmetros:**

    * `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, obrigatório): Sobrenome - Este campo é obrigatório
    * `accountId` (string, opcional): ID da Conta - Conta à qual o contato pertence
    * `Email` (string, opcional): Endereço de e-mail
    * `Title` (string, opcional): Cargo do contato, como CEO ou Vice-presidente
    * `Description` (string, opcional): Descrição do contato
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Contato
  </Accordion>

  <Accordion title="salesforce/create_record_lead">
    **Descrição:** Crie um novo registro de Lead no Salesforce.

    **Parâmetros:**

    * `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, obrigatório): Sobrenome - Este campo é obrigatório
    * `Company` (string, obrigatório): Empresa - Este campo é obrigatório
    * `Email` (string, opcional): Endereço de e-mail
    * `Phone` (string, opcional): Número de telefone
    * `Website` (string, opcional): URL do site
    * `Title` (string, opcional): Cargo do contato, como CEO ou Vice-presidente
    * `Status` (string, opcional): Status do Lead - Use as Configurações de Workflow do Connect Portal para selecionar o status do Lead
    * `Description` (string, opcional): Descrição do lead
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Lead
  </Accordion>

  <Accordion title="salesforce/create_record_opportunity">
    **Descrição:** Crie um novo registro de Oportunidade no Salesforce.

    **Parâmetros:**

    * `Name` (string, obrigatório): Nome da Oportunidade - Este campo é obrigatório
    * `StageName` (string, opcional): Estágio da Oportunidade - Use as Configurações de Workflow do Connect Portal para selecionar o estágio
    * `CloseDate` (string, opcional): Data de fechamento no formato YYYY-MM-DD - Padrão para 30 dias a partir da data atual
    * `AccountId` (string, opcional): Conta à qual a Oportunidade pertence
    * `Amount` (string, opcional): Valor total estimado da venda
    * `Description` (string, opcional): Descrição da oportunidade
    * `OwnerId` (string, opcional): Usuário Salesforce designado para esta Oportunidade
    * `NextStep` (string, opcional): Descrição da próxima tarefa no fechamento da Oportunidade
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Oportunidade
  </Accordion>

  <Accordion title="salesforce/create_record_task">
    **Descrição:** Crie um novo registro de Tarefa no Salesforce.

    **Parâmetros:**

    * `whatId` (string, opcional): Relacionado ao ID - ID da Conta ou Oportunidade relacionada à Tarefa
    * `whoId` (string, opcional): ID do Nome - ID do Contato ou Lead relacionado à Tarefa
    * `subject` (string, obrigatório): Assunto da tarefa
    * `activityDate` (string, opcional): Data da Atividade no formato YYYY-MM-DD
    * `description` (string, opcional): Descrição da tarefa
    * `taskSubtype` (string, obrigatório): Subtipo da Tarefa - Opções: task, email, listEmail, call
    * `Status` (string, opcional): Status - Opções: Not Started, In Progress, Completed
    * `ownerId` (string, opcional): ID do responsável - Usuário Salesforce designado para a Tarefa
    * `callDurationInSeconds` (string, opcional): Duração da chamada em segundos
    * `isReminderSet` (boolean, opcional): Se o lembrete está definido
    * `reminderDateTime` (string, opcional): Data/Hora do lembrete no formato ISO
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Tarefa
  </Accordion>

  <Accordion title="salesforce/create_record_account">
    **Descrição:** Crie um novo registro de Conta no Salesforce.

    **Parâmetros:**

    * `Name` (string, obrigatório): Nome da Conta - Este campo é obrigatório
    * `OwnerId` (string, opcional): Usuário Salesforce responsável por esta Conta
    * `Website` (string, opcional): URL do site
    * `Phone` (string, opcional): Número de telefone
    * `Description` (string, opcional): Descrição da conta
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Conta
  </Accordion>

  <Accordion title="salesforce/create_record_any">
    **Descrição:** Crie um registro de qualquer tipo de objeto no Salesforce.

    **Nota:** Esta é uma ferramenta flexível para criar registros de tipos de objetos personalizados ou desconhecidos.
  </Accordion>
</AccordionGroup>

### **Atualização de Registros**

<AccordionGroup>
  <Accordion title="salesforce/update_record_contact">
    **Descrição:** Atualize um registro de Contato existente no Salesforce.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, opcional): Sobrenome
    * `accountId` (string, opcional): ID da Conta à qual o contato pertence
    * `Email` (string, opcional): Endereço de e-mail
    * `Title` (string, opcional): Cargo do contato
    * `Description` (string, opcional): Descrição do contato
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Contato
  </Accordion>

  <Accordion title="salesforce/update_record_lead">
    **Descrição:** Atualize um registro de Lead existente no Salesforce.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `FirstName` (string, opcional): Primeiro nome
    * `LastName` (string, opcional): Sobrenome
    * `Company` (string, opcional): Nome da empresa
    * `Email` (string, opcional): Endereço de e-mail
    * `Phone` (string, opcional): Número de telefone
    * `Website` (string, opcional): URL do site
    * `Title` (string, opcional): Cargo do contato
    * `Status` (string, opcional): Status do Lead
    * `Description` (string, opcional): Descrição do lead
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Lead
  </Accordion>

  <Accordion title="salesforce/update_record_opportunity">
    **Descrição:** Atualize um registro de Oportunidade existente no Salesforce.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `Name` (string, opcional): Nome da Oportunidade
    * `StageName` (string, opcional): Estágio da oportunidade
    * `CloseDate` (string, opcional): Data de fechamento no formato YYYY-MM-DD
    * `AccountId` (string, opcional): Conta à qual a Oportunidade pertence
    * `Amount` (string, opcional): Valor total estimado da venda
    * `Description` (string, opcional): Descrição da oportunidade
    * `OwnerId` (string, opcional): Usuário Salesforce responsável por esta Oportunidade
    * `NextStep` (string, opcional): Descrição da próxima tarefa no fechamento da Oportunidade
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Oportunidade
  </Accordion>

  <Accordion title="salesforce/update_record_task">
    **Descrição:** Atualize um registro de Tarefa existente no Salesforce.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `whatId` (string, opcional): Relacionado ao ID - ID da Conta ou Oportunidade relacionada
    * `whoId` (string, opcional): ID do Nome - ID do Contato ou Lead relacionado à Tarefa
    * `subject` (string, opcional): Assunto da tarefa
    * `activityDate` (string, opcional): Data da Atividade no formato YYYY-MM-DD
    * `description` (string, opcional): Descrição da tarefa
    * `Status` (string, opcional): Status - Opções: Not Started, In Progress, Completed
    * `ownerId` (string, opcional): ID do responsável - Usuário Salesforce designado para a Tarefa
    * `callDurationInSeconds` (string, opcional): Duração da chamada em segundos
    * `isReminderSet` (boolean, opcional): Se o lembrete está definido
    * `reminderDateTime` (string, opcional): Data/Hora do lembrete em formato ISO
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Tarefa
  </Accordion>

  <Accordion title="salesforce/update_record_account">
    **Descrição:** Atualize um registro de Conta existente no Salesforce.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro a ser atualizado
    * `Name` (string, opcional): Nome da Conta
    * `OwnerId` (string, opcional): Usuário Salesforce responsável por esta Conta
    * `Website` (string, opcional): URL do site
    * `Phone` (string, opcional): Número de telefone
    * `Description` (string, opcional): Descrição da conta
    * `additionalFields` (object, opcional): Campos adicionais no formato JSON para campos personalizados de Conta
  </Accordion>

  <Accordion title="salesforce/update_record_any">
    **Descrição:** Atualize um registro de qualquer tipo de objeto no Salesforce.

    **Nota:** Esta é uma ferramenta flexível para atualizar registros de tipos de objetos personalizados ou desconhecidos.
  </Accordion>
</AccordionGroup>

### **Recuperação de Registros**

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_id_contact">
    **Descrição:** Obtenha um registro de Contato pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro do Contato
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_lead">
    **Descrição:** Obtenha um registro de Lead pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro do Lead
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_opportunity">
    **Descrição:** Obtenha um registro de Oportunidade pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro da Oportunidade
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_task">
    **Descrição:** Obtenha um registro de Tarefa pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro da Tarefa
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_account">
    **Descrição:** Obtenha um registro de Conta pelo seu ID.

    **Parâmetros:**

    * `recordId` (string, obrigatório): ID do registro da Conta
  </Accordion>

  <Accordion title="salesforce/get_record_by_id_any">
    **Descrição:** Obtenha um registro de qualquer tipo de objeto pelo seu ID.

    **Parâmetros:**

    * `recordType` (string, obrigatório): Tipo do registro (ex.: "CustomObject\_\_c")
    * `recordId` (string, obrigatório): ID do registro
  </Accordion>
</AccordionGroup>

### **Busca de Registros**

<AccordionGroup>
  <Accordion title="salesforce/search_records_contact">
    **Descrição:** Pesquise registros de Contato com filtragem avançada.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/search_records_lead">
    **Descrição:** Pesquise registros de Lead com filtragem avançada.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/search_records_opportunity">
    **Descrição:** Pesquise registros de Oportunidade com filtragem avançada.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/search_records_task">
    **Descrição:** Pesquise registros de Tarefa com filtragem avançada.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/search_records_account">
    **Descrição:** Pesquise registros de Conta com filtragem avançada.

    **Parâmetros:**

    * `filterFormula` (object, opcional): Filtro avançado em forma normal disjuntiva com operadores específicos de campo
    * `sortBy` (string, opcional): Campo para ordenação (ex.: "CreatedDate")
    * `sortDirection` (string, opcional): Direção da ordenação - Opções: ASC, DESC
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/search_records_any">
    **Descrição:** Pesquise registros de qualquer tipo de objeto.

    **Parâmetros:**

    * `recordType` (string, obrigatório): Tipo de registro para buscar
    * `filterFormula` (string, opcional): Critérios de busca por filtro
    * `includeAllFields` (boolean, opcional): Incluir todos os campos nos resultados
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>
</AccordionGroup>

### **Recuperação por List View**

<AccordionGroup>
  <Accordion title="salesforce/get_record_by_view_id_contact">
    **Descrição:** Obtenha registros de Contato de um List View específico.

    **Parâmetros:**

    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_lead">
    **Descrição:** Obtenha registros de Lead de um List View específico.

    **Parâmetros:**

    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_opportunity">
    **Descrição:** Obtenha registros de Oportunidade de um List View específico.

    **Parâmetros:**

    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_task">
    **Descrição:** Obtenha registros de Tarefa de um List View específico.

    **Parâmetros:**

    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_account">
    **Descrição:** Obtenha registros de Conta de um List View específico.

    **Parâmetros:**

    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>

  <Accordion title="salesforce/get_record_by_view_id_any">
    **Descrição:** Obtenha registros de qualquer tipo de objeto a partir de um List View específico.

    **Parâmetros:**

    * `recordType` (string, obrigatório): Tipo do registro
    * `listViewId` (string, obrigatório): ID do List View
    * `paginationParameters` (object, opcional): Configurações de paginação com pageCursor
  </Accordion>
</AccordionGroup>

### **Campos Personalizados**

<AccordionGroup>
  <Accordion title="salesforce/create_custom_field_contact">
    **Descrição:** Crie campos personalizados para objetos de Contato.

    **Parâmetros:**

    * `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

  <Accordion title="salesforce/create_custom_field_lead">
    **Descrição:** Crie campos personalizados para objetos de Lead.

    **Parâmetros:**

    * `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

  <Accordion title="salesforce/create_custom_field_opportunity">
    **Descrição:** Crie campos personalizados para objetos de Oportunidade.

    **Parâmetros:**

    * `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

  <Accordion title="salesforce/create_custom_field_task">
    **Descrição:** Crie campos personalizados para objetos de Tarefa.

    **Parâmetros:**

    * `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

  <Accordion title="salesforce/create_custom_field_account">
    **Descrição:** Crie campos personalizados para objetos de Conta.

    **Parâmetros:**

    * `label` (string, obrigatório): Rótulo do campo para exibições e referência interna
    * `type` (string, obrigatório): Tipo do campo - Opções: Checkbox, Currency, Date, Email, Number, Percent, Phone, Picklist, MultiselectPicklist, Text, TextArea, LongTextArea, Html, Time, Url
    * `defaultCheckboxValue` (boolean, opcional): Valor padrão para campos checkbox
    * `length` (string, obrigatório): Comprimento para campos numéricos/texto
    * `decimalPlace` (string, obrigatório): Casas decimais para campos numéricos
    * `pickListValues` (string, obrigatório): Valores para campos picklist (separados por novas linhas)
    * `visibleLines` (string, obrigatório): Linhas visíveis para campos multiseleção/área de texto
    * `description` (string, opcional): Descrição do campo
    * `helperText` (string, opcional): Texto de ajuda exibido ao passar o mouse
    * `defaultFieldValue` (string, opcional): Valor padrão do campo
  </Accordion>

  <Accordion title="salesforce/create_custom_field_any">
    **Descrição:** Crie campos personalizados para qualquer tipo de objeto.

    **Nota:** Esta é uma ferramenta flexível para criar campos personalizados para tipos de objetos personalizados ou desconhecidos.
  </Accordion>
</AccordionGroup>

### **Operações Avançadas**

<AccordionGroup>
  <Accordion title="salesforce/write_soql_query">
    **Descrição:** Execute consultas SOQL personalizadas em seus dados do Salesforce.

    **Parâmetros:**

    * `query` (string, obrigatório): Consulta SOQL (ex.: "SELECT Id, Name FROM Account WHERE Name = 'Exemplo'")
  </Accordion>

  <Accordion title="salesforce/create_custom_object">
    **Descrição:** Crie um novo objeto personalizado no Salesforce.

    **Parâmetros:**

    * `label` (string, obrigatório): Rótulo do objeto para abas, layouts de página e relatórios
    * `pluralLabel` (string, obrigatório): Rótulo plural (ex.: "Contas")
    * `description` (string, opcional): Uma descrição do Objeto Personalizado
    * `recordName` (string, obrigatório): Nome do registro exibido em layouts e buscas (ex.: "Nome da Conta")
  </Accordion>

  <Accordion title="salesforce/describe_action_schema">
    **Descrição:** Obtenha o schema esperado para operações em tipos de objetos específicos.

    **Parâmetros:**

    * `recordType` (string, obrigatório): Tipo de registro a ser detalhado
    * `operation` (string, obrigatório): Tipo de Operação (ex.: "CREATE\_RECORD" ou "UPDATE\_RECORD")

    **Nota:** Use esta função primeiro ao trabalhar com objetos personalizados para entender seu schema antes de realizar operações.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica de um Agente Salesforce
```

---

## Crie um agente para gerenciar grupos de contatos

**URL:** llms-txt#crie-um-agente-para-gerenciar-grupos-de-contatos

group_manager = Agent(
    role="Organizador de Grupos de Contatos",
    goal="Organizar contatos em grupos e gerenciar membros dos grupos",
    backstory="Um assistente IA especializado em criar e gerenciar grupos do Google Contacts.",
    apps=['google_contacts/create_contact_group', 'google_contacts/list_contact_groups']
)

---

## Example task to search and summarize news

**URL:** llms-txt#example-task-to-search-and-summarize-news

browse_task = Task(
    description="Summarize the top 3 trending AI News headlines",
    expected_output="A summary of the top 3 trending AI News headlines",
    agent=browser_agent,
)

---

## To specifically focus your search on a given documentation site

**URL:** llms-txt#to-specifically-focus-your-search-on-a-given-documentation-site

---

## 샘플 태스크 생성

**URL:** llms-txt#샘플-태스크-생성

task = Task(
    description="Analyze the sales data and identify trends",
    expected_output="A detailed analysis with key insights and trends",
    agent=agent
)

---

## Inicializar cliente OpenAI

**URL:** llms-txt#inicializar-cliente-openai

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

---

## 순차 프로세스

**URL:** llms-txt#순차-프로세스

**Contents:**
- 소개
- 순차적 프로세스 개요
  - 주요 기능
- 순차적 프로세스 구현하기

Source: https://docs.crewai.com/ko/learn/sequential-process

CrewAI 프로젝트에서 작업 실행을 위한 순차 프로세스를 활용하는 방법에 대한 종합 가이드입니다.

CrewAI는 순차적 및 계층적 프로세스를 모두 지원하는 구조화된 방식으로 작업을 실행할 수 있는 유연한 프레임워크를 제공합니다.\
이 가이드에서는 효율적인 작업 실행과 프로젝트 완수를 보장하기 위해 이러한 프로세스를 효과적으로 구현하는 방법을 설명합니다.

순차적 프로세스는 작업이 선형적인 진행 방식으로 하나씩 차례로 실행되도록 보장합니다.\
이 접근 방식은 특정 순서로 작업이 완료되어야 하는 프로젝트에 이상적입니다.

* **선형 작업 흐름**: 미리 정해진 순서대로 작업을 처리하여 체계적인 진행을 보장합니다.
* **단순성**: 명확하고 단계별 작업이 있는 프로젝트에 가장 적합합니다.
* **쉬운 모니터링**: 작업 완료 및 프로젝트 진행 상황을 쉽게 추적할 수 있습니다.

순차적 프로세스를 사용하려면 crew를 구성하고 수행되어야 하는 순서대로 작업을 정의하세요.

```python Code theme={null}
from crewai import Crew, Process, Agent, Task, TaskOutput, CrewOutput

---

## Fora do contexto, o handler temporário é removido

**URL:** llms-txt#fora-do-contexto,-o-handler-temporário-é-removido

**Contents:**
- Casos de Uso
- Boas Práticas

Listeners de evento podem ser usados para várias finalidades:

1. **Log e Monitoramento**: Monitore a execução do seu Crew e registre eventos importantes
2. **Analytics**: Colete dados sobre o desempenho e comportamento do seu Crew
3. **Depuração**: Configure listeners temporários para debugar problemas específicos
4. **Integração**: Conecte o CrewAI a sistemas externos como plataformas de monitoramento, bancos de dados ou serviços de notificação
5. **Comportamento Personalizado**: Dispare ações personalizadas com base em eventos específicos

1. **Mantenha Handlers Leves**: Handlers de eventos devem ser leves e evitar operações bloqueantes
2. **Tratamento de Erros**: Implemente tratamento de erros adequado nos event handlers para evitar que exceções afetem a execução principal
3. **Limpeza**: Se seu listener alocar recursos, garanta o devido fechamento/liberação
4. **Escuta Seletiva**: Escute apenas eventos que realmente precisa tratar
5. **Testes**: Teste seus listeners de evento isoladamente para garantir que se comportam conforme esperado

Aproveitando o sistema de eventos do CrewAI, é possível estender a funcionalidade e integrá-lo facilmente à sua infraestrutura existente.

---

## Integração Braintrust

**URL:** llms-txt#integração-braintrust

**Contents:**
- Começar
  - Passo 1: Instalar Dependências
  - Passo 2: Configurar Variáveis de Ambiente

Este guia demonstra como integrar o **Braintrust** com **CrewAI** usando OpenTelemetry para rastreamento e avaliação abrangentes. Ao final deste guia, você poderá rastrear seus agentes CrewAI, monitorar seu desempenho e avaliar suas saídas usando a poderosa plataforma de observabilidade do Braintrust.

> **O que é Braintrust?** [Braintrust](https://www.braintrust.dev) é uma plataforma de avaliação e observabilidade de IA que fornece rastreamento, avaliação e monitoramento abrangentes para aplicações de IA com rastreamento de experimentos e análises de desempenho integrados.

Vamos percorrer um exemplo simples de uso do CrewAI e integração com Braintrust via OpenTelemetry para observabilidade e avaliação abrangentes.

### Passo 1: Instalar Dependências

### Passo 2: Configurar Variáveis de Ambiente

Configure as chaves de API do Braintrust e configure o OpenTelemetry para enviar rastreamentos para o Braintrust. Você precisará de uma chave de API do Braintrust e sua chave de API do OpenAI.

```python  theme={null}
import os
from getpass import getpass

**Examples:**

Example 1 (unknown):
```unknown
### Passo 2: Configurar Variáveis de Ambiente

Configure as chaves de API do Braintrust e configure o OpenTelemetry para enviar rastreamentos para o Braintrust. Você precisará de uma chave de API do Braintrust e sua chave de API do OpenAI.
```

---

## ✅ Use context parameter for task dependencies

**URL:** llms-txt#✅-use-context-parameter-for-task-dependencies

**Contents:**
  - 4. **명확한 작업 설명**

writing_task = Task(
    description="Write article based on research",
    agent=writer,
    context=[research_task],  # Shares research results
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 4. **명확한 작업 설명**
```

---

## Configure LLM with user tracking

**URL:** llms-txt#configure-llm-with-user-tracking

portkey_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
        metadata={
            "_user": "user_123",  # Special _user field for user analytics
            "user_tier": "premium",
            "user_company": "Acme Corp",
            "session_id": "abc-123"
        }
    )
)

---

## Integração DSL MCP

**URL:** llms-txt#integração-dsl-mcp

**Contents:**
- Visão Geral
- Uso Básico

Source: https://docs.crewai.com/pt-BR/mcp/dsl-integration

Aprenda a usar a sintaxe DSL simples do CrewAI para integrar servidores MCP diretamente com seus agentes usando o campo mcps.

A integração DSL (Domain Specific Language) MCP do CrewAI oferece a **forma mais simples** de conectar seus agentes aos servidores MCP (Model Context Protocol). Basta adicionar um campo `mcps` ao seu agente e o CrewAI cuida de toda a complexidade automaticamente.

<Info>
  Esta é a **abordagem recomendada** para a maioria dos casos de uso de MCP. Para cenários avançados que requerem gerenciamento manual de conexão, veja [MCPServerAdapter](/pt-BR/mcp/overview#advanced-mcpserveradapter).
</Info>

Adicione servidores MCP ao seu agente usando o campo `mcps`:

```python  theme={null}
from crewai import Agent

agent = Agent(
    role="Assistente de Pesquisa",
    goal="Ajudar com tarefas de pesquisa e análise",
    backstory="Assistente especialista com acesso a ferramentas avançadas de pesquisa",
    mcps=[
        "https://mcp.exa.ai/mcp?api_key=sua_chave&profile=pesquisa"
    ]
)

---

## UUID string - the unique identifier (auto-generated)

**URL:** llms-txt#uuid-string---the-unique-identifier-(auto-generated)

uuid_str = fingerprint.uuid_str  # e.g., "123e4567-e89b-12d3-a456-426614174000"

---

## 배포 상태 확인

**URL:** llms-txt#배포-상태-확인

---

## MCP connection is made only when a tool is actually executed

**URL:** llms-txt#mcp-connection-is-made-only-when-a-tool-is-actually-executed

---

## O agente é carregado com todas as suas configurações predefinidas

**URL:** llms-txt#o-agente-é-carregado-com-todas-as-suas-configurações-predefinidas

**Contents:**
  - Sobrescrevendo configurações do repositório
  - Exemplo: criando um Crew com agentes do repositório

researcher = Agent(
    from_repository="market-research-agent"
)

python  theme={null}
researcher = Agent(
    from_repository="market-research-agent",
    goal="Pesquisar as tendências mais recentes em desenvolvimento de IA",  # Sobrescreve o goal do repositório
    verbose=True  # Adiciona uma configuração que não está no repositório
)
python  theme={null}
from crewai import Crew, Agent, Task

**Examples:**

Example 1 (unknown):
```unknown
### Sobrescrevendo configurações do repositório

Você pode sobrescrever configurações específicas do repositório informando-as na configuração do agente:
```

Example 2 (unknown):
```unknown
### Exemplo: criando um Crew com agentes do repositório
```

---

## 도구 스키마는 filter_by 및 filter_value를 허용합니다

**URL:** llms-txt#도구-스키마는-filter_by-및-filter_value를-허용합니다

---

## Ferramenta LlamaIndex

**URL:** llms-txt#ferramenta-llamaindex

Source: https://docs.crewai.com/pt-BR/tools/ai-ml/llamaindextool

A `LlamaIndexTool` é um wrapper para ferramentas e mecanismos de consulta do LlamaIndex.

---

## Task to create a new project

**URL:** llms-txt#task-to-create-a-new-project

create_project_task = Task(
    description="Create a new project called 'Q1 Marketing Campaign' in the Marketing workspace",
    agent=asana_agent,
    expected_output="Confirmation that the project was created successfully with project ID"
)

---

## Initialize the tool with a specific YouTube channel handle

**URL:** llms-txt#initialize-the-tool-with-a-specific-youtube-channel-handle

youtube_channel_tool = YoutubeChannelSearchTool(
    youtube_channel_handle='@exampleChannel'
)

---

## Em seu arquivo main.py ou flow.py

**URL:** llms-txt#em-seu-arquivo-main.py-ou-flow.py

from crewai.flow import Flow, listen, start
from my_listeners import MyCustomListener

---

## 에이전트는 작동하는 서버의 도구를 사용하고 실패한 서버에 대한 경고를 로그에 남깁니다

**URL:** llms-txt#에이전트는-작동하는-서버의-도구를-사용하고-실패한-서버에-대한-경고를-로그에-남깁니다

**Contents:**
- 성능 기능
  - 자동 캐싱

**Examples:**

Example 1 (unknown):
```unknown
## 성능 기능

### 자동 캐싱

도구 스키마는 성능 향상을 위해 5분간 캐시됩니다:
```

---

## Example of using kickoff_async

**URL:** llms-txt#example-of-using-kickoff_async

inputs = {'topic': 'AI in healthcare'}
async_result = await my_crew.kickoff_async(inputs=inputs)
print(async_result)

---

## 실행 시 경로가 제공되면 모든 PDF 콘텐츠 검색을 허용하도록 도구를 초기화합니다.

**URL:** llms-txt#실행-시-경로가-제공되면-모든-pdf-콘텐츠-검색을-허용하도록-도구를-초기화합니다.

tool = PDFSearchTool()

---

## Microsoft SharePoint 통합

**URL:** llms-txt#microsoft-sharepoint-통합

**Contents:**
- 개요
- 전제 조건
- Microsoft SharePoint 통합 설정
  - 1. Microsoft 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Microsoft SharePoint 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/microsoft_sharepoint

CrewAI를 위한 Microsoft SharePoint 통합으로 사이트, 목록 및 문서 관리.

에이전트가 SharePoint 사이트, 목록 및 문서 라이브러리에 액세스하고 관리할 수 있도록 합니다. AI 기반 자동화로 사이트 정보를 검색하고, 목록 항목을 관리하고, 파일을 업로드 및 구성하며, SharePoint 워크플로를 간소화합니다.

Microsoft SharePoint 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* SharePoint 액세스 권한이 있는 Microsoft 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Microsoft 계정 연결

## Microsoft SharePoint 통합 설정

### 1. Microsoft 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Microsoft SharePoint** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. SharePoint 사이트 및 파일 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="microsoft_sharepoint/get_sites">
    **설명:** 사용자가 액세스할 수 있는 모든 SharePoint 사이트를 가져옵니다.

* `search` (string, 선택사항): 사이트를 필터링하기 위한 검색 쿼리.
    * `select` (string, 선택사항): 반환할 특정 속성 선택 (예: 'displayName,id,webUrl').
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `skip` (integer, 선택사항): 건너뛸 항목 수 (최소 0).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬 (예: 'displayName desc').
  </Accordion>

<Accordion title="microsoft_sharepoint/get_site">
    **설명:** 특정 SharePoint 사이트에 대한 정보를 가져옵니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `select` (string, 선택사항): 반환할 특정 속성 선택 (예: 'displayName,id,webUrl,drives').
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장 (예: 'drives,lists').
  </Accordion>

<Accordion title="microsoft_sharepoint/get_site_lists">
    **설명:** SharePoint 사이트의 모든 목록을 가져옵니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
  </Accordion>

<Accordion title="microsoft_sharepoint/get_list">
    **설명:** 특정 목록에 대한 정보를 가져옵니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
  </Accordion>

<Accordion title="microsoft_sharepoint/get_list_items">
    **설명:** SharePoint 목록에서 항목을 가져옵니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `expand` (string, 선택사항): 관련 데이터 확장 (예: 'fields').
  </Accordion>

<Accordion title="microsoft_sharepoint/create_list_item">
    **설명:** SharePoint 목록에 새 항목을 만듭니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `fields` (object, 필수): 새 항목의 필드 값.
  </Accordion>

<Accordion title="microsoft_sharepoint/update_list_item">
    **설명:** SharePoint 목록의 항목을 업데이트합니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `item_id` (string, 필수): 업데이트할 항목의 ID.
    * `fields` (object, 필수): 업데이트할 필드 값.
  </Accordion>

<Accordion title="microsoft_sharepoint/delete_list_item">
    **설명:** SharePoint 목록에서 항목을 삭제합니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `item_id` (string, 필수): 삭제할 항목의 ID.
  </Accordion>

<Accordion title="microsoft_sharepoint/upload_file_to_library">
    **설명:** SharePoint 문서 라이브러리에 파일을 업로드합니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `file_path` (string, 필수): 파일을 업로드할 경로 (예: 'folder/fileName.txt').
    * `content` (string, 필수): 업로드할 파일의 내용.
  </Accordion>

<Accordion title="microsoft_sharepoint/get_drive_items">
    **설명:** SharePoint 문서 라이브러리에서 파일과 폴더를 가져옵니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
  </Accordion>

<Accordion title="microsoft_sharepoint/delete_drive_item">
    **설명:** SharePoint 문서 라이브러리에서 파일 또는 폴더를 삭제합니다.

* `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `item_id` (string, 필수): 삭제할 파일 또는 폴더의 ID.
  </Accordion>
</AccordionGroup>

### 기본 Microsoft SharePoint 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="microsoft_sharepoint/get_sites">
    **설명:** 사용자가 액세스할 수 있는 모든 SharePoint 사이트를 가져옵니다.

    **매개변수:**

    * `search` (string, 선택사항): 사이트를 필터링하기 위한 검색 쿼리.
    * `select` (string, 선택사항): 반환할 특정 속성 선택 (예: 'displayName,id,webUrl').
    * `filter` (string, 선택사항): OData 구문을 사용하여 결과 필터링.
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장.
    * `top` (integer, 선택사항): 반환할 항목 수 (최소 1, 최대 999).
    * `skip` (integer, 선택사항): 건너뛸 항목 수 (최소 0).
    * `orderby` (string, 선택사항): 지정된 속성으로 결과 정렬 (예: 'displayName desc').
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_site">
    **설명:** 특정 SharePoint 사이트에 대한 정보를 가져옵니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `select` (string, 선택사항): 반환할 특정 속성 선택 (예: 'displayName,id,webUrl,drives').
    * `expand` (string, 선택사항): 관련 리소스를 인라인으로 확장 (예: 'drives,lists').
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_site_lists">
    **설명:** SharePoint 사이트의 모든 목록을 가져옵니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_list">
    **설명:** 특정 목록에 대한 정보를 가져옵니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_list_items">
    **설명:** SharePoint 목록에서 항목을 가져옵니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `expand` (string, 선택사항): 관련 데이터 확장 (예: 'fields').
  </Accordion>

  <Accordion title="microsoft_sharepoint/create_list_item">
    **설명:** SharePoint 목록에 새 항목을 만듭니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `fields` (object, 필수): 새 항목의 필드 값.
  </Accordion>

  <Accordion title="microsoft_sharepoint/update_list_item">
    **설명:** SharePoint 목록의 항목을 업데이트합니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `item_id` (string, 필수): 업데이트할 항목의 ID.
    * `fields` (object, 필수): 업데이트할 필드 값.
  </Accordion>

  <Accordion title="microsoft_sharepoint/delete_list_item">
    **설명:** SharePoint 목록에서 항목을 삭제합니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `list_id` (string, 필수): 목록의 ID.
    * `item_id` (string, 필수): 삭제할 항목의 ID.
  </Accordion>

  <Accordion title="microsoft_sharepoint/upload_file_to_library">
    **설명:** SharePoint 문서 라이브러리에 파일을 업로드합니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `file_path` (string, 필수): 파일을 업로드할 경로 (예: 'folder/fileName.txt').
    * `content` (string, 필수): 업로드할 파일의 내용.
  </Accordion>

  <Accordion title="microsoft_sharepoint/get_drive_items">
    **설명:** SharePoint 문서 라이브러리에서 파일과 폴더를 가져옵니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
  </Accordion>

  <Accordion title="microsoft_sharepoint/delete_drive_item">
    **설명:** SharePoint 문서 라이브러리에서 파일 또는 폴더를 삭제합니다.

    **매개변수:**

    * `site_id` (string, 필수): SharePoint 사이트의 ID.
    * `item_id` (string, 필수): 삭제할 파일 또는 폴더의 ID.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Microsoft SharePoint 에이전트 설정
```

---

## Acesse os dados estruturados

**URL:** llms-txt#acesse-os-dados-estruturados

**Contents:**
- Boas práticas
- Gerenciamento de organização

print(f"Principais Tendências: {structured_result.pydantic.key_trends}")
print(f"Recomendação: {structured_result.pydantic.recommendation}")
bash  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Boas práticas

1. **Convenção de nomes**: Use nomes claros e descritivos para seus agentes de repositório
2. **Documentação**: Inclua descrições abrangentes para cada agente
3. **Gestão de ferramentas**: Garanta que as ferramentas referenciadas pelos agentes do repositório estejam disponíveis no seu ambiente
4. **Controle de acesso**: Gerencie permissões para que apenas membros autorizados possam modificar agentes do repositório

## Gerenciamento de organização

Para alternar entre organizações ou ver sua organização atual, use o CLI da CrewAI:
```

---

## Wrap it with LlamaIndexTool

**URL:** llms-txt#wrap-it-with-llamaindextool

tool = LlamaIndexTool.from_tool(og_tool)

---

## Always include backup options

**URL:** llms-txt#always-include-backup-options

**Contents:**
  - 4. Use Descriptive Agent Roles
- Troubleshooting
  - Common Issues

mcps=[
    "https://primary-api.com/mcp",       # Primary choice
    "https://backup-api.com/mcp",        # Backup option
    "crewai-amp:reliable-service"        # AMP fallback
]
python  theme={null}
agent = Agent(
    role="Weather-Enhanced Market Analyst",
    goal="Analyze markets considering weather impacts",
    backstory="Financial analyst with access to weather data for agricultural market insights",
    mcps=[
        "https://weather.service.com/mcp#get_forecast",
        "crewai-amp:financial-data#stock_analysis"
    ]
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 4. Use Descriptive Agent Roles
```

Example 2 (unknown):
```unknown
## Troubleshooting

### Common Issues

**No tools discovered:**
```

---

## Microsoft Excel 기능을 가진 에이전트 생성

**URL:** llms-txt#microsoft-excel-기능을-가진-에이전트-생성

excel_agent = Agent(
    role="Excel 데이터 관리자",
    goal="Excel 통합 문서와 데이터를 효율적으로 관리",
    backstory="Microsoft Excel 작업 및 데이터 조작 전문 AI 어시스턴트.",
    apps=['microsoft_excel']  # 모든 Excel 작업을 사용할 수 있습니다
)

---

## Inicialize a ferramenta com a URL de um vídeo específico do YouTube

**URL:** llms-txt#inicialize-a-ferramenta-com-a-url-de-um-vídeo-específico-do-youtube

youtube_search_tool = YoutubeVideoSearchTool(
    youtube_video_url='https://youtube.com/watch?v=example'
)

---

## DOCX RAG Search

**URL:** llms-txt#docx-rag-search

Source: https://docs.crewai.com/en/tools/file-document/docxsearchtool

The `DOCXSearchTool` is a RAG tool designed for semantic searching within DOCX documents.

---

## MongoDB Vector Search Tool

**URL:** llms-txt#mongodb-vector-search-tool

Source: https://docs.crewai.com/pt-BR/tools/database-data/mongodbvectorsearchtool

The `MongoDBVectorSearchTool` performs vector search on MongoDB Atlas with optional indexing helpers.

---

## Create an agent focused on document operations

**URL:** llms-txt#create-an-agent-focused-on-document-operations

document_reader = Agent(
    role="Document Reader",
    goal="Retrieve and analyze document content and properties",
    backstory="An AI assistant skilled in reading and analyzing document content.",
    apps=['microsoft_word/get_documents', 'microsoft_word/get_document_content', 'microsoft_word/get_document_properties']
)

---

## 파일이 있는 디렉터리 추가

**URL:** llms-txt#파일이-있는-디렉터리-추가

**Contents:**
- 에이전트 통합 예시

rag_tool.add(data_type="directory", path="path/to/your/directory")
python Code theme={null}
from crewai import Agent
from crewai.project import agent
from crewai_tools import RagTool

**Examples:**

Example 1 (unknown):
```unknown
## 에이전트 통합 예시

아래는 `RagTool`을 CrewAI 에이전트와 통합하는 방법입니다:
```

---

## Create tool with custom inputs

**URL:** llms-txt#create-tool-with-custom-inputs

market_research_tool = InvokeCrewAIAutomationTool(
    crew_api_url="https://state-of-ai-report-crew-[...].crewai.com",
    crew_bearer_token="your_bearer_token_here",
    crew_name="State of AI Report",
    crew_description="Retrieves a comprehensive report on state of AI for a given year and region",
    crew_inputs=custom_inputs,
    max_polling_time=15 * 60  # 15 minutes timeout
)

---

## Store knowledge in project directory

**URL:** llms-txt#store-knowledge-in-project-directory

project_root = Path(__file__).parent
knowledge_dir = project_root / "knowledge_storage"

os.environ["CREWAI_STORAGE_DIR"] = str(knowledge_dir)

---

## Create an LLM with a temperature of 0 to ensure deterministic outputs

**URL:** llms-txt#create-an-llm-with-a-temperature-of-0-to-ensure-deterministic-outputs

llm = LLM(model="gpt-4o-mini", temperature=0)

---

## Set up LLMs with different providers

**URL:** llms-txt#set-up-llms-with-different-providers

openai_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY"
    )
)

anthropic_llm = LLM(
    model="claude-3-5-sonnet-latest",
    max_tokens=1000,
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_ANTHROPIC_VIRTUAL_KEY"
    )
)

---

## Pesquisa RAG em Sites

**URL:** llms-txt#pesquisa-rag-em-sites

Source: https://docs.crewai.com/pt-BR/tools/search-research/websitesearchtool

O `WebsiteSearchTool` foi projetado para realizar uma busca RAG (Geração Aumentada por Recuperação) dentro do conteúdo de um site.

---

## 모든 도구가 포함된 전체 서비스

**URL:** llms-txt#모든-도구가-포함된-전체-서비스

"crewai-amp:financial-data"

---

## DALL-E Tool

**URL:** llms-txt#dall-e-tool

Source: https://docs.crewai.com/en/tools/ai-ml/dalletool

The `DallETool` is a powerful tool designed for generating images from textual descriptions.

---

## Jira 연동

**URL:** llms-txt#jira-연동

**Contents:**
- 개요
- 사전 준비 사항
- Jira 연동 설정
  - 1. Jira 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 Jira 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/jira

CrewAI를 위한 Jira 연동을 통한 이슈 추적 및 프로젝트 관리.

에이전트가 Jira를 통해 이슈, 프로젝트, 워크플로우를 관리할 수 있도록 합니다. 이슈를 생성 및 업데이트하고, 프로젝트 진행 상황을 추적하며, 할당 작업을 관리하고, AI 기반 자동화로 프로젝트 관리를 효율화하세요.

Jira 통합을 사용하기 전에 다음을 준비하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 프로젝트 권한이 있는 Jira 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Jira 계정 연결

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. **Jira**를 인증 통합 섹션에서 찾습니다.
3. **Connect**를 클릭하고 OAuth 절차를 완료합니다.
4. 이슈 및 프로젝트 관리를 위한 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="jira/create_issue">
    **설명:** Jira에서 이슈를 생성합니다.

* `summary` (string, 필수): 요약 - 이슈에 대한 간단한 한 줄 요약입니다. (예시: "프린터가 작동을 멈췄습니다").
    * `project` (string, 선택): 프로젝트 - 이슈가 속한 프로젝트입니다. 제공되지 않으면 사용자의 첫 번째 프로젝트로 기본 설정됩니다. 사용자가 프로젝트를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `issueType` (string, 선택): 이슈 유형 - 제공되지 않으면 기본값은 Task입니다.
    * `jiraIssueStatus` (string, 선택): 상태 - 제공되지 않으면 프로젝트의 첫 번째 상태가 기본입니다.
    * `assignee` (string, 선택): 담당자 - 제공되지 않으면 인증된 사용자로 기본 설정됩니다.
    * `descriptionType` (string, 선택): 설명 유형 - 설명 유형을 선택하세요.
      * 옵션: `description`, `descriptionJSON`
    * `description` (string, 선택): 설명 - 이슈에 대한 자세한 설명입니다. 이 필드는 'descriptionType'이 'description'일 때만 나타납니다.
    * `additionalFields` (string, 선택): 추가 필드 - 포함해야 하는 다른 필드를 JSON 형식으로 지정하세요. 사용자가 업데이트할 이슈 필드를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
      
  </Accordion>

<Accordion title="jira/update_issue">
    **설명:** Jira에서 이슈를 업데이트합니다.

* `issueKey` (string, 필수): 이슈 키 (예시: "TEST-1234").
    * `summary` (string, 선택): 요약 - 이슈에 대한 간단한 한 줄 요약입니다. (예시: "프린터가 작동을 멈췄습니다").
    * `issueType` (string, 선택): 이슈 유형 - 사용자가 이슈 유형을 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `jiraIssueStatus` (string, 선택): 상태 - 사용자가 상태를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `assignee` (string, 선택): 담당자 - 사용자가 담당자를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `descriptionType` (string, 선택): 설명 유형 - 설명 유형을 선택하세요.
      * 옵션: `description`, `descriptionJSON`
    * `description` (string, 선택): 설명 - 이슈에 대한 자세한 설명입니다. 이 필드는 'descriptionType'이 'description'일 때만 나타납니다.
    * `additionalFields` (string, 선택): 추가 필드 - 포함해야 하는 다른 필드를 JSON 형식으로 지정하세요.
  </Accordion>

<Accordion title="jira/get_issue_by_key">
    **설명:** Jira에서 키로 이슈를 조회합니다.

* `issueKey` (string, 필수): 이슈 키 (예시: "TEST-1234").
  </Accordion>

<Accordion title="jira/filter_issues">
    **설명:** 필터를 사용하여 Jira에서 이슈를 검색합니다.

* `jqlQuery` (object, 선택): 불리언 합정규형(OR의 AND 그룹)으로 구성된 필터.
      
      사용 가능한 연산자: `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringIsIn`, `$stringIsNotIn`, `$stringContains`, `$stringDoesNotContain`, `$stringGreaterThan`, `$stringLessThan`
    * `limit` (string, 선택): 결과 제한 - 반환되는 최대 이슈 수를 제한합니다. 입력하지 않으면 기본값은 10입니다.
  </Accordion>

<Accordion title="jira/search_by_jql">
    **설명:** Jira에서 JQL로 이슈를 검색합니다.

* `jqlQuery` (string, 필수): JQL 쿼리 (예시: "project = PROJECT").
    * `paginationParameters` (object, 선택): 페이지네이션 결과를 위한 파라미터.
      
  </Accordion>

<Accordion title="jira/update_issue_any">
    **설명:** Jira에서 임의의 이슈를 업데이트합니다. 이 기능의 속성 스키마를 얻으려면 DESCRIBE\_ACTION\_SCHEMA를 사용하세요.

**파라미터:** 특정 파라미터 없음 - 예상 스키마를 먼저 확인하려면 JIRA\_DESCRIBE\_ACTION\_SCHEMA를 사용하세요.
  </Accordion>

<Accordion title="jira/describe_action_schema">
    **설명:** 이슈 유형에 대한 예상 스키마를 가져옵니다. 사용하려는 이슈 유형과 일치하는 다른 기능이 없을 경우 먼저 이 기능을 사용하세요.

* `issueTypeId` (string, 필수): 이슈 유형 ID.
    * `projectKey` (string, 필수): 프로젝트 키.
    * `operation` (string, 필수): 작업 유형 값(예: CREATE\_ISSUE 또는 UPDATE\_ISSUE).
  </Accordion>

<Accordion title="jira/get_projects">
    **설명:** Jira에서 프로젝트를 가져옵니다.

* `paginationParameters` (object, 선택): 페이지네이션 파라미터.
      
  </Accordion>

<Accordion title="jira/get_issue_types_by_project">
    **설명:** Jira에서 프로젝트별 이슈 유형을 조회합니다.

* `project` (string, 필수): 프로젝트 키.
  </Accordion>

<Accordion title="jira/get_issue_types">
    **설명:** Jira에서 모든 이슈 유형을 조회합니다.

**파라미터:** 필요 없음.
  </Accordion>

<Accordion title="jira/get_issue_status_by_project">
    **설명:** 주어진 프로젝트의 이슈 상태를 조회합니다.

* `project` (string, 필수): 프로젝트 키.
  </Accordion>

<Accordion title="jira/get_all_assignees_by_project">
    **설명:** 주어진 프로젝트의 담당자 목록을 조회합니다.

* `project` (string, 필수): 프로젝트 키.
  </Accordion>
</AccordionGroup>

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="jira/create_issue">
    **설명:** Jira에서 이슈를 생성합니다.

    **파라미터:**

    * `summary` (string, 필수): 요약 - 이슈에 대한 간단한 한 줄 요약입니다. (예시: "프린터가 작동을 멈췄습니다").
    * `project` (string, 선택): 프로젝트 - 이슈가 속한 프로젝트입니다. 제공되지 않으면 사용자의 첫 번째 프로젝트로 기본 설정됩니다. 사용자가 프로젝트를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `issueType` (string, 선택): 이슈 유형 - 제공되지 않으면 기본값은 Task입니다.
    * `jiraIssueStatus` (string, 선택): 상태 - 제공되지 않으면 프로젝트의 첫 번째 상태가 기본입니다.
    * `assignee` (string, 선택): 담당자 - 제공되지 않으면 인증된 사용자로 기본 설정됩니다.
    * `descriptionType` (string, 선택): 설명 유형 - 설명 유형을 선택하세요.
      * 옵션: `description`, `descriptionJSON`
    * `description` (string, 선택): 설명 - 이슈에 대한 자세한 설명입니다. 이 필드는 'descriptionType'이 'description'일 때만 나타납니다.
    * `additionalFields` (string, 선택): 추가 필드 - 포함해야 하는 다른 필드를 JSON 형식으로 지정하세요. 사용자가 업데이트할 이슈 필드를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="jira/update_issue">
    **설명:** Jira에서 이슈를 업데이트합니다.

    **파라미터:**

    * `issueKey` (string, 필수): 이슈 키 (예시: "TEST-1234").
    * `summary` (string, 선택): 요약 - 이슈에 대한 간단한 한 줄 요약입니다. (예시: "프린터가 작동을 멈췄습니다").
    * `issueType` (string, 선택): 이슈 유형 - 사용자가 이슈 유형을 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `jiraIssueStatus` (string, 선택): 상태 - 사용자가 상태를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `assignee` (string, 선택): 담당자 - 사용자가 담당자를 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요.
    * `descriptionType` (string, 선택): 설명 유형 - 설명 유형을 선택하세요.
      * 옵션: `description`, `descriptionJSON`
    * `description` (string, 선택): 설명 - 이슈에 대한 자세한 설명입니다. 이 필드는 'descriptionType'이 'description'일 때만 나타납니다.
    * `additionalFields` (string, 선택): 추가 필드 - 포함해야 하는 다른 필드를 JSON 형식으로 지정하세요.
  </Accordion>

  <Accordion title="jira/get_issue_by_key">
    **설명:** Jira에서 키로 이슈를 조회합니다.

    **파라미터:**

    * `issueKey` (string, 필수): 이슈 키 (예시: "TEST-1234").
  </Accordion>

  <Accordion title="jira/filter_issues">
    **설명:** 필터를 사용하여 Jira에서 이슈를 검색합니다.

    **파라미터:**

    * `jqlQuery` (object, 선택): 불리언 합정규형(OR의 AND 그룹)으로 구성된 필터.
```

---

## ├── Technical Specialist/    # Agent knowledge collection

**URL:** llms-txt#├──-technical-specialist/----#-agent-knowledge-collection

---

## 실행 중에 찾은 모든 웹사이트를 스크랩할 수 있도록 활성화

**URL:** llms-txt#실행-중에-찾은-모든-웹사이트를-스크랩할-수-있도록-활성화

tool = ScrapeWebsiteTool()

---

## 덜 효율적 - 서버의 모든 도구 가져오기

**URL:** llms-txt#덜-효율적---서버의-모든-도구-가져오기

**Contents:**
  - 2. 인증을 안전하게 처리

mcps=["https://weather.api.com/mcp"]
python  theme={null}
import os

**Examples:**

Example 1 (unknown):
```unknown
### 2. 인증을 안전하게 처리
```

---

## Check server status or try backup servers

**URL:** llms-txt#check-server-status-or-try-backup-servers

**Examples:**

Example 1 (unknown):
```unknown
**Authentication failures:**
```

---

## Qdrant 벡터 검색 도구

**URL:** llms-txt#qdrant-벡터-검색-도구

**Contents:**
- 개요
- 설치
- 기본 사용법

Source: https://docs.crewai.com/ko/tools/database-data/qdrantvectorsearchtool

Qdrant 벡터 데이터베이스를 활용한 CrewAI 에이전트의 시맨틱 검색 기능

Qdrant Vector Search Tool은 [Qdrant](https://qdrant.tech/) 벡터 유사성 검색 엔진을 활용하여 CrewAI 에이전트에 시맨틱 검색 기능을 제공합니다. 이 도구를 사용하면 에이전트가 Qdrant 컬렉션에 저장된 문서를 시맨틱 유사성을 기반으로 검색할 수 있습니다.

아래는 도구를 사용하는 최소한의 예시입니다:

```python  theme={null}
from crewai import Agent
from crewai_tools import QdrantVectorSearchTool, QdrantConfig

**Examples:**

Example 1 (unknown):
```unknown
## 기본 사용법

아래는 도구를 사용하는 최소한의 예시입니다:
```

---

## Com contexto de referência explícito

**URL:** llms-txt#com-contexto-de-referência-explícito

**Contents:**
  - Adicionando às Tarefas

protecao_com_contexto = HallucinationGuardrail(
    context="IA ajuda em várias tarefas, incluindo análise e geração.",
    llm=LLM(model="gpt-4o-mini")
)
python  theme={null}
from crewai import Task

**Examples:**

Example 1 (unknown):
```unknown
### Adicionando às Tarefas
```

---

## 에이전트가 지정된 웹사이트의 콘텐츠만 스크랩할 수 있도록 합니다

**URL:** llms-txt#에이전트가-지정된-웹사이트의-콘텐츠만-스크랩할-수-있도록-합니다

tool = ScrapeWebsiteTool(website_url='https://www.example.com')

---

## Timestamp de criação (gerado automaticamente)

**URL:** llms-txt#timestamp-de-criação-(gerado-automaticamente)

created_at = fingerprint.created_at  # Um objeto datetime

---

## Integração com Zendesk

**URL:** llms-txt#integração-com-zendesk

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Zendesk
  - 1. Conecte sua Conta Zendesk
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ferramentas Disponíveis
  - **Gerenciamento de Tickets**
  - **Gerenciamento de Usuários**
  - **Ferramentas Administrativas**

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/zendesk

Gestão de suporte ao cliente e helpdesk com integração Zendesk para CrewAI.

Permita que seus agentes gerenciem operações de suporte ao cliente através do Zendesk. Crie e atualize tickets, gerencie usuários, monitore métricas de suporte e otimize seus fluxos de atendimento ao cliente com automação impulsionada por IA.

Antes de usar a integração com o Zendesk, certifique-se de que você possui:

* Uma conta [CrewAI AMP](https://app.crewai.com) com uma assinatura ativa
* Uma conta Zendesk com permissões apropriadas de API
* Sua conta Zendesk conectada através da [página de Integrações](https://app.crewai.com/integrations)

## Configurando a Integração Zendesk

### 1. Conecte sua Conta Zendesk

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Zendesk** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de tickets e usuários
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

## Ferramentas Disponíveis

### **Gerenciamento de Tickets**

<AccordionGroup>
  <Accordion title="zendesk/create_ticket">
    **Descrição:** Crie um novo ticket de suporte no Zendesk.

* `ticketSubject` (string, obrigatório): Assunto do ticket (ex.: "Socorro, minha impressora está pegando fogo!")
    * `ticketDescription` (string, obrigatório): Primeiro comentário que aparece no ticket (ex.: "A fumaça é muito colorida.")
    * `requesterName` (string, obrigatório): Nome do usuário solicitando suporte (ex.: "Jane Cliente")
    * `requesterEmail` (string, obrigatório): E-mail do solicitante do suporte (ex.: "[jane@example.com](mailto:jane@example.com)")
    * `assigneeId` (string, opcional): ID do agente Zendesk atribuído ao ticket - Use as Configurações de Fluxo de Trabalho do Portal Connect para permitir a seleção do responsável
    * `ticketType` (string, opcional): Tipo de ticket - Opções: problem, incident, question, task
    * `ticketPriority` (string, opcional): Nível de prioridade - Opções: urgent, high, normal, low
    * `ticketStatus` (string, opcional): Status do ticket - Opções: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, opcional): Data de vencimento para tickets do tipo tarefa (timestamp ISO 8601)
    * `ticketTags` (string, opcional): Array de tags a aplicar (ex.: `["enterprise", "outra_tag"]`)
    * `ticketExternalId` (string, opcional): ID externo para vincular tickets a registros locais
    * `ticketCustomFields` (object, opcional): Valores de campos personalizados em formato JSON
  </Accordion>

<Accordion title="zendesk/update_ticket">
    **Descrição:** Atualize um ticket de suporte existente no Zendesk.

* `ticketId` (string, obrigatório): ID do ticket a ser atualizado (ex.: "35436")
    * `ticketSubject` (string, opcional): Assunto atualizado do ticket
    * `requesterName` (string, obrigatório): Nome do solicitante deste ticket
    * `requesterEmail` (string, obrigatório): E-mail do solicitante deste ticket
    * `assigneeId` (string, opcional): ID atualizado do responsável - Use as Configurações de Fluxo de Trabalho do Portal Connect
    * `ticketType` (string, opcional): Tipo atualizado - Opções: problem, incident, question, task
    * `ticketPriority` (string, opcional): Prioridade atualizada - Opções: urgent, high, normal, low
    * `ticketStatus` (string, opcional): Status atualizado - Opções: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, opcional): Nova data de vencimento (timestamp ISO 8601)
    * `ticketTags` (string, opcional): Array de tags atualizadas
    * `ticketExternalId` (string, opcional): Novo ID externo
    * `ticketCustomFields` (object, opcional): Valores atualizados dos campos personalizados
  </Accordion>

<Accordion title="zendesk/get_ticket_by_id">
    **Descrição:** Recupere um ticket específico pelo ID.

* `ticketId` (string, obrigatório): ID do ticket a ser recuperado (ex.: "35436")
  </Accordion>

<Accordion title="zendesk/add_comment_to_ticket">
    **Descrição:** Adicione um comentário ou nota interna a um ticket existente.

* `ticketId` (string, obrigatório): ID do ticket para adicionar o comentário (ex.: "35436")
    * `commentBody` (string, obrigatório): Mensagem do comentário (aceita texto simples ou HTML, ex.: "Obrigado pela sua ajuda!")
    * `isInternalNote` (boolean, opcional): Defina como verdadeiro para notas internas ao invés de respostas públicas (padrão é falso)
    * `isPublic` (boolean, opcional): Verdadeiro para comentários públicos, falso para notas internas
  </Accordion>

<Accordion title="zendesk/search_tickets">
    **Descrição:** Busque tickets usando diversos filtros e critérios.

* `ticketSubject` (string, opcional): Filtrar pelo texto no assunto do ticket
    * `ticketDescription` (string, opcional): Filtrar por texto na descrição e comentários do ticket
    * `ticketStatus` (string, opcional): Filtrar por status - Opções: new, open, pending, hold, solved, closed
    * `ticketType` (string, opcional): Filtrar por tipo - Opções: problem, incident, question, task, no\_type
    * `ticketPriority` (string, opcional): Filtrar por prioridade - Opções: urgent, high, normal, low, no\_priority
    * `requesterId` (string, opcional): Filtrar por ID do solicitante
    * `assigneeId` (string, opcional): Filtrar pelo ID do agente responsável
    * `recipientEmail` (string, opcional): Filtrar pelo e-mail do destinatário original
    * `ticketTags` (string, opcional): Filtrar por tags do ticket
    * `ticketExternalId` (string, opcional): Filtrar por ID externo
    * `createdDate` (object, opcional): Filtrar por data de criação com operador (EQUALS, LESS\_THAN\_EQUALS, GREATER\_THAN\_EQUALS) e valor
    * `updatedDate` (object, opcional): Filtrar por data de atualização com operador e valor
    * `dueDate` (object, opcional): Filtrar por data de vencimento com operador e valor
    * `sort_by` (string, opcional): Campo de ordenação - Opções: created\_at, updated\_at, priority, status, ticket\_type
    * `sort_order` (string, opcional): Direção da ordenação - Opções: asc, desc
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Usuários**

<AccordionGroup>
  <Accordion title="zendesk/create_user">
    **Descrição:** Crie um novo usuário no Zendesk.

* `name` (string, obrigatório): Nome completo do usuário
    * `email` (string, opcional): E-mail do usuário (ex.: "[jane@example.com](mailto:jane@example.com)")
    * `phone` (string, opcional): Telefone do usuário
    * `role` (string, opcional): Papel do usuário - Opções: admin, agent, end-user
    * `externalId` (string, opcional): Identificador único de outro sistema
    * `details` (string, opcional): Detalhes adicionais do usuário
    * `notes` (string, opcional): Notas internas sobre o usuário
  </Accordion>

<Accordion title="zendesk/update_user">
    **Descrição:** Atualize informações de um usuário existente.

* `userId` (string, obrigatório): ID do usuário a ser atualizado
    * `name` (string, opcional): Nome atualizado do usuário
    * `email` (string, opcional): Novo e-mail (adicionado como e-mail secundário na atualização)
    * `phone` (string, opcional): Novo telefone
    * `role` (string, opcional): Novo papel - Opções: admin, agent, end-user
    * `externalId` (string, opcional): Novo ID externo
    * `details` (string, opcional): Novos detalhes do usuário
    * `notes` (string, opcional): Novas notas internas
  </Accordion>

<Accordion title="zendesk/get_user_by_id">
    **Descrição:** Recupere um usuário específico pelo ID.

* `userId` (string, obrigatório): ID do usuário a ser recuperado
  </Accordion>

<Accordion title="zendesk/search_users">
    **Descrição:** Busque usuários utilizando vários critérios.

* `name` (string, opcional): Filtrar por nome do usuário
    * `email` (string, opcional): Filtrar por e-mail do usuário (ex.: "[jane@example.com](mailto:jane@example.com)")
    * `role` (string, opcional): Filtrar por papel - Opções: admin, agent, end-user
    * `externalId` (string, opcional): Filtrar por ID externo
    * `sort_by` (string, opcional): Campo de ordenação - Opções: created\_at, updated\_at
    * `sort_order` (string, opcional): Direção de ordenação - Opções: asc, desc
  </Accordion>
</AccordionGroup>

### **Ferramentas Administrativas**

<AccordionGroup>
  <Accordion title="zendesk/get_ticket_fields">
    **Descrição:** Recupere todos os campos padrão e personalizados disponíveis para tickets.

* `paginationParameters` (object, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor de página para paginação
  </Accordion>

<Accordion title="zendesk/get_ticket_audits">
    **Descrição:** Obtenha registros de auditoria (histórico somente leitura) dos tickets.

* `ticketId` (string, opcional): Obtenha auditorias para um ticket específico (se vazio, recupera auditorias de todos os tickets não arquivados, ex.: "1234")
    * `paginationParameters` (object, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor de página para paginação
  </Accordion>
</AccordionGroup>

## Campos Personalizados

Campos personalizados permitem armazenar informações adicionais específicas para sua organização:

## Níveis de Prioridade dos Tickets

Compreendendo os níveis de prioridade:

* **urgent** - Questões críticas que exigem atenção imediata
* **high** - Questões importantes que devem ser tratadas rapidamente
* **normal** - Prioridade padrão para a maioria dos tickets
* **low** - Questões menores que podem ser tratadas quando conveniente

## Fluxo de Status dos Tickets

Progresso padrão de status dos tickets:

* **new** - Recém-criado, ainda não atribuído
* **open** - Em andamento
* **pending** - Aguardando resposta do cliente ou ação externa
* **hold** - Pausa temporária
* **solved** - Problema resolvido, aguardando confirmação do cliente
* **closed** - Ticket finalizado e fechado

### Configuração Básica de Agente Zendesk

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ferramentas Disponíveis

### **Gerenciamento de Tickets**

<AccordionGroup>
  <Accordion title="zendesk/create_ticket">
    **Descrição:** Crie um novo ticket de suporte no Zendesk.

    **Parâmetros:**

    * `ticketSubject` (string, obrigatório): Assunto do ticket (ex.: "Socorro, minha impressora está pegando fogo!")
    * `ticketDescription` (string, obrigatório): Primeiro comentário que aparece no ticket (ex.: "A fumaça é muito colorida.")
    * `requesterName` (string, obrigatório): Nome do usuário solicitando suporte (ex.: "Jane Cliente")
    * `requesterEmail` (string, obrigatório): E-mail do solicitante do suporte (ex.: "[jane@example.com](mailto:jane@example.com)")
    * `assigneeId` (string, opcional): ID do agente Zendesk atribuído ao ticket - Use as Configurações de Fluxo de Trabalho do Portal Connect para permitir a seleção do responsável
    * `ticketType` (string, opcional): Tipo de ticket - Opções: problem, incident, question, task
    * `ticketPriority` (string, opcional): Nível de prioridade - Opções: urgent, high, normal, low
    * `ticketStatus` (string, opcional): Status do ticket - Opções: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, opcional): Data de vencimento para tickets do tipo tarefa (timestamp ISO 8601)
    * `ticketTags` (string, opcional): Array de tags a aplicar (ex.: `["enterprise", "outra_tag"]`)
    * `ticketExternalId` (string, opcional): ID externo para vincular tickets a registros locais
    * `ticketCustomFields` (object, opcional): Valores de campos personalizados em formato JSON
  </Accordion>

  <Accordion title="zendesk/update_ticket">
    **Descrição:** Atualize um ticket de suporte existente no Zendesk.

    **Parâmetros:**

    * `ticketId` (string, obrigatório): ID do ticket a ser atualizado (ex.: "35436")
    * `ticketSubject` (string, opcional): Assunto atualizado do ticket
    * `requesterName` (string, obrigatório): Nome do solicitante deste ticket
    * `requesterEmail` (string, obrigatório): E-mail do solicitante deste ticket
    * `assigneeId` (string, opcional): ID atualizado do responsável - Use as Configurações de Fluxo de Trabalho do Portal Connect
    * `ticketType` (string, opcional): Tipo atualizado - Opções: problem, incident, question, task
    * `ticketPriority` (string, opcional): Prioridade atualizada - Opções: urgent, high, normal, low
    * `ticketStatus` (string, opcional): Status atualizado - Opções: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, opcional): Nova data de vencimento (timestamp ISO 8601)
    * `ticketTags` (string, opcional): Array de tags atualizadas
    * `ticketExternalId` (string, opcional): Novo ID externo
    * `ticketCustomFields` (object, opcional): Valores atualizados dos campos personalizados
  </Accordion>

  <Accordion title="zendesk/get_ticket_by_id">
    **Descrição:** Recupere um ticket específico pelo ID.

    **Parâmetros:**

    * `ticketId` (string, obrigatório): ID do ticket a ser recuperado (ex.: "35436")
  </Accordion>

  <Accordion title="zendesk/add_comment_to_ticket">
    **Descrição:** Adicione um comentário ou nota interna a um ticket existente.

    **Parâmetros:**

    * `ticketId` (string, obrigatório): ID do ticket para adicionar o comentário (ex.: "35436")
    * `commentBody` (string, obrigatório): Mensagem do comentário (aceita texto simples ou HTML, ex.: "Obrigado pela sua ajuda!")
    * `isInternalNote` (boolean, opcional): Defina como verdadeiro para notas internas ao invés de respostas públicas (padrão é falso)
    * `isPublic` (boolean, opcional): Verdadeiro para comentários públicos, falso para notas internas
  </Accordion>

  <Accordion title="zendesk/search_tickets">
    **Descrição:** Busque tickets usando diversos filtros e critérios.

    **Parâmetros:**

    * `ticketSubject` (string, opcional): Filtrar pelo texto no assunto do ticket
    * `ticketDescription` (string, opcional): Filtrar por texto na descrição e comentários do ticket
    * `ticketStatus` (string, opcional): Filtrar por status - Opções: new, open, pending, hold, solved, closed
    * `ticketType` (string, opcional): Filtrar por tipo - Opções: problem, incident, question, task, no\_type
    * `ticketPriority` (string, opcional): Filtrar por prioridade - Opções: urgent, high, normal, low, no\_priority
    * `requesterId` (string, opcional): Filtrar por ID do solicitante
    * `assigneeId` (string, opcional): Filtrar pelo ID do agente responsável
    * `recipientEmail` (string, opcional): Filtrar pelo e-mail do destinatário original
    * `ticketTags` (string, opcional): Filtrar por tags do ticket
    * `ticketExternalId` (string, opcional): Filtrar por ID externo
    * `createdDate` (object, opcional): Filtrar por data de criação com operador (EQUALS, LESS\_THAN\_EQUALS, GREATER\_THAN\_EQUALS) e valor
    * `updatedDate` (object, opcional): Filtrar por data de atualização com operador e valor
    * `dueDate` (object, opcional): Filtrar por data de vencimento com operador e valor
    * `sort_by` (string, opcional): Campo de ordenação - Opções: created\_at, updated\_at, priority, status, ticket\_type
    * `sort_order` (string, opcional): Direção da ordenação - Opções: asc, desc
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Usuários**

<AccordionGroup>
  <Accordion title="zendesk/create_user">
    **Descrição:** Crie um novo usuário no Zendesk.

    **Parâmetros:**

    * `name` (string, obrigatório): Nome completo do usuário
    * `email` (string, opcional): E-mail do usuário (ex.: "[jane@example.com](mailto:jane@example.com)")
    * `phone` (string, opcional): Telefone do usuário
    * `role` (string, opcional): Papel do usuário - Opções: admin, agent, end-user
    * `externalId` (string, opcional): Identificador único de outro sistema
    * `details` (string, opcional): Detalhes adicionais do usuário
    * `notes` (string, opcional): Notas internas sobre o usuário
  </Accordion>

  <Accordion title="zendesk/update_user">
    **Descrição:** Atualize informações de um usuário existente.

    **Parâmetros:**

    * `userId` (string, obrigatório): ID do usuário a ser atualizado
    * `name` (string, opcional): Nome atualizado do usuário
    * `email` (string, opcional): Novo e-mail (adicionado como e-mail secundário na atualização)
    * `phone` (string, opcional): Novo telefone
    * `role` (string, opcional): Novo papel - Opções: admin, agent, end-user
    * `externalId` (string, opcional): Novo ID externo
    * `details` (string, opcional): Novos detalhes do usuário
    * `notes` (string, opcional): Novas notas internas
  </Accordion>

  <Accordion title="zendesk/get_user_by_id">
    **Descrição:** Recupere um usuário específico pelo ID.

    **Parâmetros:**

    * `userId` (string, obrigatório): ID do usuário a ser recuperado
  </Accordion>

  <Accordion title="zendesk/search_users">
    **Descrição:** Busque usuários utilizando vários critérios.

    **Parâmetros:**

    * `name` (string, opcional): Filtrar por nome do usuário
    * `email` (string, opcional): Filtrar por e-mail do usuário (ex.: "[jane@example.com](mailto:jane@example.com)")
    * `role` (string, opcional): Filtrar por papel - Opções: admin, agent, end-user
    * `externalId` (string, opcional): Filtrar por ID externo
    * `sort_by` (string, opcional): Campo de ordenação - Opções: created\_at, updated\_at
    * `sort_order` (string, opcional): Direção de ordenação - Opções: asc, desc
  </Accordion>
</AccordionGroup>

### **Ferramentas Administrativas**

<AccordionGroup>
  <Accordion title="zendesk/get_ticket_fields">
    **Descrição:** Recupere todos os campos padrão e personalizados disponíveis para tickets.

    **Parâmetros:**

    * `paginationParameters` (object, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor de página para paginação
  </Accordion>

  <Accordion title="zendesk/get_ticket_audits">
    **Descrição:** Obtenha registros de auditoria (histórico somente leitura) dos tickets.

    **Parâmetros:**

    * `ticketId` (string, opcional): Obtenha auditorias para um ticket específico (se vazio, recupera auditorias de todos os tickets não arquivados, ex.: "1234")
    * `paginationParameters` (object, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor de página para paginação
  </Accordion>
</AccordionGroup>

## Campos Personalizados

Campos personalizados permitem armazenar informações adicionais específicas para sua organização:
```

Example 4 (unknown):
```unknown
## Níveis de Prioridade dos Tickets

Compreendendo os níveis de prioridade:

* **urgent** - Questões críticas que exigem atenção imediata
* **high** - Questões importantes que devem ser tratadas rapidamente
* **normal** - Prioridade padrão para a maioria dos tickets
* **low** - Questões menores que podem ser tratadas quando conveniente

## Fluxo de Status dos Tickets

Progresso padrão de status dos tickets:

* **new** - Recém-criado, ainda não atribuído
* **open** - Em andamento
* **pending** - Aguardando resposta do cliente ou ação externa
* **hold** - Pausa temporária
* **solved** - Problema resolvido, aguardando confirmação do cliente
* **closed** - Ticket finalizado e fechado

## Exemplos de Uso

### Configuração Básica de Agente Zendesk
```

---

## Handle result based on its type

**URL:** llms-txt#handle-result-based-on-its-type

if hasattr(result, "json_dict") and result.json_dict:
    json_result = result.json_dict
    print("\nStructured JSON result:")
    print(f"{json.dumps(json_result, indent=2)}")

# Access fields safely
    if isinstance(json_result, dict):
        if "code" in json_result:
            print("\nCode:")
            print(
                json_result["code"][:200] + "..."
                if len(json_result["code"]) > 200
                else json_result["code"]
            )

if "links" in json_result:
            print("\nLinks:")
            for link in json_result["links"][:5]:  # Print first 5 links
                print(f"- {link}")
            if len(json_result["links"]) > 5:
                print(f"...and {len(json_result['links']) - 5} more links")
elif hasattr(result, "pydantic") and result.pydantic:
    print("\nPydantic model result:")
    print(result.pydantic.model_dump_json(indent=2))
else:
    # Fallback to raw output
    print("\nNo structured result available, using raw output:")
    print(result.raw[:500] + "..." if len(result.raw) > 500 else result.raw)

---

## Task to retrieve and organize contacts

**URL:** llms-txt#task-to-retrieve-and-organize-contacts

contact_management_task = Task(
    description="Retrieve all contacts and organize them by company affiliation",
    agent=contacts_agent,
    expected_output="Contacts retrieved and organized by company with summary report"
)

---

## Scrapfly 웹사이트 스크레이핑 도구

**URL:** llms-txt#scrapfly-웹사이트-스크레이핑-도구

Source: https://docs.crewai.com/ko/tools/web-scraping/scrapflyscrapetool

ScrapflyScrapeWebsiteTool은 Scrapfly의 웹 스크레이핑 API를 활용하여 다양한 형식으로 웹사이트의 콘텐츠를 추출합니다.

---

## Limpar tipos específicos de memória

**URL:** llms-txt#limpar-tipos-específicos-de-memória

**Contents:**
  - Melhores Práticas para Produção
  - Problemas Comuns de Armazenamento

crew.reset_memories(command_type='short')     # Memória de curto prazo
crew.reset_memories(command_type='long')      # Memória de longo prazo  
crew.reset_memories(command_type='entity')    # Memória de entidades
crew.reset_memories(command_type='knowledge') # Armazenamento de conhecimento
bash  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Melhores Práticas para Produção

1. **Defina o `CREWAI_STORAGE_DIR`** para um local conhecido em produção para maior controle
2. **Escolha explicitamente provedores de embeddings** para coincidir com seu setup de LLM
3. **Monitore o tamanho do diretório de armazenamento** em casos de grande escala
4. **Inclua diretórios de armazenamento** em sua política de backup
5. **Defina permissões apropriadas de arquivo** (0o755 para diretórios, 0o644 para arquivos)
6. **Use caminhos relativos ao projeto** para implantações containerizadas

### Problemas Comuns de Armazenamento

**Erros "ChromaDB permission denied":**
```

---

## Pesquisa MDX RAG

**URL:** llms-txt#pesquisa-mdx-rag

Source: https://docs.crewai.com/pt-BR/tools/file-document/mdxsearchtool

O `MDXSearchTool` foi projetado para pesquisar arquivos MDX e retornar os resultados mais relevantes.

---

## Envolvendo com a LlamaIndexTool

**URL:** llms-txt#envolvendo-com-a-llamaindextool

tool = LlamaIndexTool.from_tool(og_tool)

---

## TXT RAG Search

**URL:** llms-txt#txt-rag-search

**Contents:**
- Overview
- Installation
- Example

Source: https://docs.crewai.com/en/tools/file-document/txtsearchtool

The `TXTSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.

<Note>
  We are still working on improving tools, so there might be unexpected behavior or changes in the future.
</Note>

This tool is used to perform a RAG (Retrieval-Augmented Generation) search within the content of a text file.
It allows for semantic searching of a query within a specified text file's content,
making it an invaluable resource for quickly extracting information or finding specific sections of text based on the query provided.

To use the `TXTSearchTool`, you first need to install the `crewai_tools` package.
This can be done using pip, a package manager for Python.
Open your terminal or command prompt and enter the following command:

This command will download and install the TXTSearchTool along with any necessary dependencies.

The following example demonstrates how to use the TXTSearchTool to search within a text file.
This example shows both the initialization of the tool with a specific text file and the subsequent search within that file's content.

```python Code theme={null}
from crewai_tools import TXTSearchTool

**Examples:**

Example 1 (unknown):
```unknown
This command will download and install the TXTSearchTool along with any necessary dependencies.

## Example

The following example demonstrates how to use the TXTSearchTool to search within a text file.
This example shows both the initialization of the tool with a specific text file and the subsequent search within that file's content.
```

---

## 디렉터리 RAG 검색

**URL:** llms-txt#디렉터리-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/directorysearchtool

DirectorySearchTool은 디렉터리의 콘텐츠 내에서 의미 기반 검색을 수행하도록 설계된 강력한 RAG(Retrieval-Augmented Generation) 도구입니다.

---

## Fix permissions

**URL:** llms-txt#fix-permissions

chmod -R 755 ~/.local/share/CrewAI/
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**"Database is locked" 오류:**
```

---

## Create a RAG tool with custom configuration

**URL:** llms-txt#create-a-rag-tool-with-custom-configuration

**Contents:**
- Conclusão

config = {
    "app": {
        "name": "custom_app",
    },
    "llm": {
        "provider": "openai",
        "config": {
            "model": "gpt-4",
        }
    },
    "embedding_model": {
        "provider": "openai",
        "config": {
            "model": "text-embedding-ada-002"
        }
    },
    "vectordb": {
        "provider": "elasticsearch",
        "config": {
            "collection_name": "my-collection",
            "cloud_id": "deployment-name:xxxx",
            "api_key": "your-key",
            "verify_certs": False
        }
    },
    "chunker": {
        "chunk_size": 400,
        "chunk_overlap": 100,
        "length_function": "len",
        "min_chunk_size": 0
    }
}

rag_tool = RagTool(config=config, summarize=True)
```

A ferramenta RAG interna utiliza o adaptador Embedchain, possibilitando que você forneça quaisquer opções de configuração suportadas pelo Embedchain.
Você pode consultar a [documentação do Embedchain](https://docs.embedchain.ai/components/introduction) para mais detalhes.
Certifique-se de revisar as opções de configuração disponíveis no arquivo .yaml.

O `RagTool` oferece uma maneira poderosa de criar e consultar bases de conhecimento a partir de diversas fontes de dados. Ao explorar a Geração Aumentada por Recuperação, ele permite que agentes acessem e recuperem informações relevantes de forma eficiente, ampliando a capacidade de fornecer respostas precisas e contextualmente apropriadas.

---

## Define flow state

**URL:** llms-txt#define-flow-state

class MarketResearchState(BaseModel):
    product: str = ""
    analysis: MarketAnalysis | None = None

---

## Use fontes de conhecimento ao invés de prompts grandes

**URL:** llms-txt#use-fontes-de-conhecimento-ao-invés-de-prompts-grandes

**Contents:**
  - Boas Práticas para Janela de Contexto
  - Solucionando Problemas de Contexto

knowledge_agent = Agent(
    role="Knowledge Expert",
    goal="Answer questions using curated knowledge",
    backstory="Expert at leveraging structured knowledge sources",
    knowledge_sources=[your_knowledge_sources],  # Conhecimento pré-processado
    respect_context_window=True,
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Boas Práticas para Janela de Contexto

1. **Monitore o uso de contexto**: Ative `verbose=True` para visualizar o gerenciamento de contexto em ação
2. **Otimize para eficiência**: Estruture tarefas para minimizar o acúmulo de contexto
3. **Use modelos apropriados**: Escolha LLMs com janelas de contexto adequadas à sua tarefa
4. **Teste ambos os modos**: Experimente `True` e `False` para descobrir o que funciona melhor para seu caso
5. **Combine com RAG**: Utilize ferramentas RAG para grandes conjuntos de dados ao invés de depender apenas da janela de contexto

### Solucionando Problemas de Contexto

**Se você receber erros de limite de contexto:**
```

---

## Title: Billetterie Officielle de Paris 2024 - Jeux Olympiques et Paralympiques

**URL:** llms-txt#title:-billetterie-officielle-de-paris-2024---jeux-olympiques-et-paralympiques

---

## Define an agent that uses the tool

**URL:** llms-txt#define-an-agent-that-uses-the-tool

web_scraper_agent = Agent(
    role="Web Scraper",
    goal="Extract information from websites",
    backstory="An expert in web scraping who can extract content from any website.",
    tools=[scrape_tool],
    verbose=True,
)

---

## Option 4: Printing the Entire Blog Object

**URL:** llms-txt#option-4:-printing-the-entire-blog-object

**Contents:**
  - `output_json` 사용하기

print("Accessing Properties - Option 5")
print("Blog:", result)

python Code theme={null}
import json

from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

**Examples:**

Example 1 (unknown):
```unknown
이 예제에서:

* title과 content 필드를 가진 Pydantic 모델 Blog가 정의되어 있습니다.
* 작업 task1은 output\_pydantic 속성을 사용하여 출력이 Blog 모델을 준수해야 함을 명시합니다.
* crew를 실행한 후, 위와 같이 다양한 방법으로 구조화된 출력을 확인할 수 있습니다.

#### 출력 접근 방법 설명

1. 딕셔너리 스타일 인덱싱: `result["field_name"]`을 사용하여 필드를 직접 접근할 수 있습니다. 이는 CrewOutput 클래스가 `__getitem__` 메서드를 구현하고 있기 때문에 가능합니다.
2. Pydantic 모델에서 직접 접근: `result.pydantic` 객체에서 속성에 직접 접근할 수 있습니다.
3. to\_dict() 메서드 사용: 출력을 딕셔너리로 변환한 후 필드에 접근합니다.
4. 전체 객체 출력: 단순히 result 객체를 출력하여 구조화된 출력을 확인할 수 있습니다.

### `output_json` 사용하기

`output_json` 속성을 사용하면 예상되는 출력을 JSON 형식으로 정의할 수 있습니다. 이를 통해 태스크의 출력이 쉽게 파싱되고, 애플리케이션에서 사용할 수 있는 유효한 JSON 구조임을 보장합니다.

다음은 `output_json` 사용 방법을 보여주는 예시입니다:
```

---

## so the agent can only search the content of the specified DOCX file

**URL:** llms-txt#so-the-agent-can-only-search-the-content-of-the-specified-docx-file

**Contents:**
- 인자
- 커스텀 모델과 임베딩

tool = DOCXSearchTool(docx='path/to/your/document.docx')
python Code theme={null}
from chromadb.config import Settings

tool = DOCXSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

다음 매개변수를 사용하여 `DOCXSearchTool`의 동작을 사용자 정의할 수 있습니다:

| 인자       | 타입       | 설명                                                                                                        |
| :------- | :------- | :-------------------------------------------------------------------------------------------------------- |
| **docx** | `string` | *선택 사항*. 검색하려는 DOCX 파일의 경로를 지정하는 인자입니다. 초기화 시 제공하지 않은 경우, 도구는 이후에 검색을 위한 DOCX 파일의 내용 경로를 지정할 수 있도록 허용합니다. |

## 커스텀 모델과 임베딩

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 커스터마이즈하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다:
```

---

## PDF RAG 검색

**URL:** llms-txt#pdf-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/pdfsearchtool

PDFSearchTool은 PDF 파일을 검색하고 가장 관련성 높은 결과를 반환하도록 설계되었습니다.

---

## Initialize the tool with the website URL,

**URL:** llms-txt#initialize-the-tool-with-the-website-url,

---

## Create a flow with typed state

**URL:** llms-txt#create-a-flow-with-typed-state

class StructuredStateFlow(Flow[AppState]):
    @start()
    def initialize_data(self):
        print("Initializing flow data")
        # Set state values (type-checked)
        self.state.user_name = "Taylor"
        self.state.preferences.theme = "dark"

# The ID field is automatically available
        print(f"Flow ID: {self.state.id}")

@listen(initialize_data)
    def process_data(self, previous_result):
        print(f"Processing data for {self.state.user_name}")

# Modify state (with type checking)
        self.state.items.append("item1")
        self.state.items.append("item2")
        self.state.processed = True
        self.state.completion_percentage = 50.0

@listen(process_data)
    def generate_summary(self, previous_result):
        # Access state (with autocompletion)
        summary = f"User {self.state.user_name} has {len(self.state.items)} items "
        summary += f"with {self.state.preferences.theme} theme. "
        summary += "Data is processed." if self.state.processed else "Data is not processed."
        summary += f" Completion: {self.state.completion_percentage}%"

---

## PDF RAG Search

**URL:** llms-txt#pdf-rag-search

Source: https://docs.crewai.com/en/tools/file-document/pdfsearchtool

The `PDFSearchTool` is designed to search PDF files and return the most relevant results.

---

## Leitura de Diretório

**URL:** llms-txt#leitura-de-diretório

Source: https://docs.crewai.com/pt-BR/tools/file-document/directoryreadtool

O `DirectoryReadTool` é uma poderosa utilidade projetada para fornecer uma listagem abrangente do conteúdo de diretórios.

---

## 웹사이트 요소 스크랩 도구

**URL:** llms-txt#웹사이트-요소-스크랩-도구

Source: https://docs.crewai.com/ko/tools/web-scraping/scrapeelementfromwebsitetool

ScrapeElementFromWebsiteTool은 CrewAI 에이전트가 CSS 셀렉터를 사용하여 웹사이트에서 특정 요소를 추출할 수 있도록 합니다.

---

## Leitura de Arquivo

**URL:** llms-txt#leitura-de-arquivo

**Contents:**
- Visão Geral
- Instalação
- Exemplo de Uso

Source: https://docs.crewai.com/pt-BR/tools/file-document/filereadtool

O `FileReadTool` foi desenvolvido para ler arquivos do sistema de arquivos local.

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, portanto pode haver comportamentos inesperados ou alterações no futuro.
</Note>

O FileReadTool representa conceitualmente um conjunto de funcionalidades dentro do pacote crewai\_tools voltadas para facilitar a leitura e a recuperação de conteúdo de arquivos.
Esse conjunto inclui ferramentas para processar arquivos de texto em lote, ler arquivos de configuração em tempo de execução e importar dados para análise.
Ele suporta uma variedade de formatos de arquivo baseados em texto, como `.txt`, `.csv`, `.json` e outros. Dependendo do tipo de arquivo, o conjunto oferece funcionalidades especializadas,
como converter conteúdo JSON em um dicionário Python para facilitar o uso.

Para utilizar as funcionalidades anteriormente atribuídas ao FileReadTool, instale o pacote crewai\_tools:

Para começar a usar o FileReadTool:

```python Code theme={null}
from crewai_tools import FileReadTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo de Uso

Para começar a usar o FileReadTool:
```

---

## Controle de Acesso Baseado em Funções (RBAC)

**URL:** llms-txt#controle-de-acesso-baseado-em-funções-(rbac)

**Contents:**
- Visão Geral
- Usuários e Funções
  - Resumo de configuração
- Controle de Acesso em Nível de Automação
  - Resultado de acesso no modo Private

Source: https://docs.crewai.com/pt-BR/enterprise/features/rbac

Controle o acesso a crews, ferramentas e dados com funções e visibilidade por automação.

O RBAC no CrewAI AMP permite gerenciar acesso de forma segura e escalável combinando **funções em nível de organização** com **controles de visibilidade em nível de automação**.

<Frame>
  <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=31b2661025e9813f32938f9d583228b5" alt="Visão geral de RBAC no CrewAI AMP" data-og-width="1365" width="1365" data-og-height="1044" height="1044" data-path="images/enterprise/users_and_roles.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c3863373e71e9e7190b4e68024e82ad6 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e9bfbec405004555d4a862a97e29945e 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8b3c5a5d5a1ba5417537c6ae6cae8f1c 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=50ba9cfdd73790c67ed3a7cce74d4f39 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=aed9da1d5c9044e026f1674463f9adc2 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/users_and_roles.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=64a041f4e9ee05456c86d7259cef7e61 2500w" />
</Frame>

## Usuários e Funções

Cada membro da sua workspace possui uma função, que determina o acesso aos recursos.

* Usar funções pré-definidas (Owner, Member)
* Criar funções personalizadas com permissões específicas
* Atribuir funções a qualquer momento no painel de configurações

A configuração de usuários e funções é feita em Settings → Roles.

<Steps>
  <Step title="Abrir Roles">
    Vá em <b>Settings → Roles</b> no CrewAI AMP.
  </Step>

<Step title="Escolher a função">
    Use <b>Owner</b> ou <b>Member</b>, ou clique em <b>Create role</b> para criar uma função personalizada.
  </Step>

<Step title="Atribuir aos membros">
    Selecione os usuários e atribua a função. Você pode alterar depois.
  </Step>
</Steps>

### Resumo de configuração

| Área                      | Onde configurar                    | Opções                                               |
| :------------------------ | :--------------------------------- | :--------------------------------------------------- |
| Usuários & Funções        | Settings → Roles                   | Pré-definidas: Owner, Member; Funções personalizadas |
| Visibilidade da automação | Automation → Settings → Visibility | Private; Lista de usuários/funções                   |

## Controle de Acesso em Nível de Automação

Além das funções na organização, as **Automations** suportam visibilidade refinada para restringir acesso por usuário ou função.

* Manter automações sensíveis/experimentais privadas
* Gerenciar visibilidade em equipes grandes ou colaboradores externos
* Testar automações em contexto isolado

Em modo privado, somente usuários/funções na whitelist poderão:

* Ver a automação
* Executar/usar a API
* Acessar logs, métricas e configurações

O owner da organização sempre tem acesso, independente da visibilidade.

Configure em Automation → Settings → Visibility.

<Steps>
  <Step title="Abrir a aba Visibility">
    Acesse <b>Automation → Settings → Visibility</b>.
  </Step>

<Step title="Definir visibilidade">
    Selecione <b>Private</b> para restringir o acesso. O owner mantém acesso.
  </Step>

<Step title="Permitir acesso">
    Adicione usuários e funções que poderão ver/executar e acessar logs/métricas/configurações.
  </Step>

<Step title="Salvar e verificar">
    Salve e confirme que não listados não conseguem ver ou executar a automação.
  </Step>
</Steps>

### Resultado de acesso no modo Private

| Ação                        | Owner | Usuário/função na whitelist | Não listado |
| :-------------------------- | :---- | :-------------------------- | :---------- |
| Ver automação               | ✓     | ✓                           | ✗           |
| Executar/API                | ✓     | ✓                           | ✗           |
| Logs/métricas/configurações | ✓     | ✓                           | ✗           |

<Tip>
  O owner sempre possui acesso. Em modo privado, somente usuários/funções na whitelist têm permissão.
</Tip>

<Frame>
  <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=48e3dd12b9d55da6f7adc82ea80be56d" alt="Configuração de visibilidade no CrewAI AMP" data-og-width="2028" width="2028" data-og-height="1498" height="1498" data-path="images/enterprise/visibility.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=382d272d44871f509846140dc972592e 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6d6ba4cf2fcc360c7ce05266f5cc27e9 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b9fff488a36423a05ccb3f8e592ffd07 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=00471ecc85192b53abbcd64416e2b624 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9008ee6b24abd22593938021d2093174 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/visibility.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=27fde319cbc6fae3e4c1e0a9044c264f 2500w" />
</Frame>

<Card title="Precisa de Ajuda?" icon="headset" href="mailto:support@crewai.com">
  Fale com o nosso time para suporte em configuração e auditoria de RBAC.
</Card>

---

## Weave 개요

**URL:** llms-txt#weave-개요

**Contents:**
- 설치 안내
- 특징
- 자료

[Weights & Biases (W\&B) Weave](https://weave-docs.wandb.ai/)는 LLM 기반 애플리케이션을 추적, 실험, 평가, 배포 및 개선하기 위한 프레임워크입니다.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.gif?s=4a933830e3e3cf146c4c87cb44d46475" alt="W&B Weave CrewAI 트레이싱 사용 개요" data-og-width="852" width="852" data-og-height="480" height="480" data-path="images/weave-tracing.gif" data-optimize="true" data-opv="3" />

Weave는 CrewAI 애플리케이션 개발의 모든 단계에서 포괄적인 지원을 제공합니다:

* **트레이싱 및 모니터링**: LLM 호출과 애플리케이션 로직을 자동으로 추적하여 프로덕션 시스템을 디버그하고 분석
* **체계적인 반복**: prompt, 데이터셋, 모델을 개선하고 반복
* **평가**: 맞춤형 또는 사전 구축된 스코어러를 사용하여 agent 성능을 체계적으로 평가하고 향상
* **가드레일**: 콘텐츠 모더레이션과 prompt 안전성을 위한 사전 및 사후 보호조치로 agent를 보호

Weave는 CrewAI 애플리케이션의 트레이스를 자동으로 캡처하여 agent의 성능, 상호 작용 및 실행 흐름을 모니터링하고 분석할 수 있게 해줍니다. 이를 통해 더 나은 평가 데이터셋을 구축하고 agent 워크플로우를 최적화할 수 있습니다.

<Steps>
  <Step title="필수 패키지 설치">
    
  </Step>

<Step title="W&B 계정 설정">
    [Weights & Biases 계정](https://wandb.ai)에 가입하세요. 아직 계정이 없다면 가입이 필요합니다. 트레이스와 메트릭을 확인하려면 계정이 필요합니다.
  </Step>

<Step title="애플리케이션에서 Weave 초기화">
    다음 코드를 애플리케이션에 추가하세요:

초기화 후, Weave는 트레이스와 메트릭을 확인할 수 있는 URL을 제공합니다.
  </Step>

<Step title="Crews/Flows 생성">
    
  </Step>

<Step title="Weave에서 트레이스 보기">
    CrewAI 애플리케이션 실행 후, 초기화 시 제공된 Weave URL에 방문하여 다음 항목을 확인할 수 있습니다:

* LLM 호출 및 그 메타데이터
    * 에이전트 상호작용 및 작업 실행 흐름
    * 대기 시간 및 토큰 사용량과 같은 성능 메트릭
    * 실행 중 발생한 오류 또는 이슈

<Frame caption="Weave 트레이싱 대시보드">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f59e556fcc0ac8fcca8eaeef4c0551ae" alt="Weave tracing example with CrewAI" data-og-width="3456" width="3456" data-og-height="1986" height="1986" data-path="images/weave-tracing.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=42efb320cedff3209765027d4f47e187 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=85318181f2afd6237c71cecedfda8104 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6124c3113060320d39847c47faa02ac4 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=e04300ff38ddf3624acc078bacf6712e 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c0ba473c3fa41c2939df4e28bc1098b5 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6d860d735bc5a42fb68085fc4ef01b2c 2500w" />
    </Frame>
  </Step>
</Steps>

* Weave는 모든 CrewAI 작업을 자동으로 캡처합니다: agent 상호작용 및 태스크 실행; 메타데이터와 토큰 사용량을 포함한 LLM 호출; 도구 사용 및 결과.
* 이 통합은 모든 CrewAI 실행 메서드를 지원합니다: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, 그리고 `kickoff_for_each_async()`.
* 모든 [crewAI-tools](https://github.com/crewAIInc/crewAI-tools) 작업의 자동 추적.
* 데코레이터 패칭(`@start`, `@listen`, `@router`, `@or_`, `@and_`)을 통한 flow 기능 지원.
* `@weave.op()`과 함께 CrewAI `Task`에 전달된 커스텀 guardrails 추적.

지원되는 항목에 대한 자세한 정보는 [Weave CrewAI 문서](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow)를 참조하세요.

* [📘 Weave 문서](https://weave-docs.wandb.ai)
* [📊 예시 Weave x CrewAI 대시보드](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89)
* [🐦 X](https://x.com/weave_wb)

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="W&B 계정 설정">
    [Weights & Biases 계정](https://wandb.ai)에 가입하세요. 아직 계정이 없다면 가입이 필요합니다. 트레이스와 메트릭을 확인하려면 계정이 필요합니다.
  </Step>

  <Step title="애플리케이션에서 Weave 초기화">
    다음 코드를 애플리케이션에 추가하세요:
```

Example 2 (unknown):
```unknown
초기화 후, Weave는 트레이스와 메트릭을 확인할 수 있는 URL을 제공합니다.
  </Step>

  <Step title="Crews/Flows 생성">
```

---

## Create a task with specific analysis requirements

**URL:** llms-txt#create-a-task-with-specific-analysis-requirements

inspection_task = Task(
    description="""
    Analyze the product image at https://example.com/product.jpg with focus on:
    1. Quality of materials
    2. Manufacturing defects
    3. Compliance with standards
    Provide a detailed report highlighting any issues found.
    """,
    expected_output="A detailed report highlighting any issues found",
    agent=expert_analyst
)

---

## 특정 조건에 대한 필터 생성

**URL:** llms-txt#특정-조건에-대한-필터-생성

preset_filter = qmodels.Filter(
    must=[
        qmodels.FieldCondition(
            key="category",
            match=qmodels.MatchValue(value="research")
        ),
        qmodels.FieldCondition(
            key="year",
            match=qmodels.MatchValue(value=2024)
        )
    ]
)

---

## Google Contacts 기능을 가진 에이전트 생성

**URL:** llms-txt#google-contacts-기능을-가진-에이전트-생성

contacts_agent = Agent(
    role="연락처 관리자",
    goal="Google Contacts를 효율적으로 관리",
    backstory="연락처 관리 및 조직 전문 AI 어시스턴트.",
    apps=['google_contacts']  # 모든 Google Contacts 작업을 사용할 수 있습니다
)

---

## Restricting search to a specific JSON file

**URL:** llms-txt#restricting-search-to-a-specific-json-file

---

## Tarefa para criar um novo documento

**URL:** llms-txt#tarefa-para-criar-um-novo-documento

create_doc_task = Task(
    description="Criar um novo documento do Google intitulado 'Relatório de Status do Projeto'",
    agent=docs_agent,
    expected_output="Novo documento do Google 'Relatório de Status do Projeto' criado com sucesso"
)

---

## Example task to read a configuration file

**URL:** llms-txt#example-task-to-read-a-configuration-file

read_task = Task(
    description="Read the configuration file from {my_bucket} and summarize its contents.",
    expected_output="A summary of the configuration file contents.",
    agent=file_reader_agent,
)

---

## 이메일 보내기 작업

**URL:** llms-txt#이메일-보내기-작업

send_email_task = Task(
    description="'colleague@example.com'에게 제목 '프로젝트 업데이트'와 본문 '안녕하세요, 프로젝트의 최신 업데이트입니다. 감사합니다.'로 이메일을 보내세요",
    agent=outlook_agent,
    expected_output="colleague@example.com에게 이메일이 성공적으로 전송됨"
)

---

## As ferramentas MCP agora estão automaticamente disponíveis!

**URL:** llms-txt#as-ferramentas-mcp-agora-estão-automaticamente-disponíveis!

---

## 자유 형식 응답 받기

**URL:** llms-txt#자유-형식-응답-받기

result = analyst.kickoff("Analyze the AI market in 2025")
print(result.raw)  # 원시 응답 접근

---

## The tool schema accepts filter_by and filter_value

**URL:** llms-txt#the-tool-schema-accepts-filter_by-and-filter_value

---

## Transporte SSE

**URL:** llms-txt#transporte-sse

**Contents:**
- Visão Geral
- Conceitos-Chave
- Conectando via SSE
  - 1. Conexão Totalmente Gerenciada (Recomendado)

Source: https://docs.crewai.com/pt-BR/mcp/sse

Saiba como conectar o CrewAI a servidores MCP remotos usando Server-Sent Events (SSE) para comunicação em tempo real.

Server-Sent Events (SSE) fornecem uma forma padrão para um servidor web enviar atualizações a um cliente através de uma única conexão HTTP de longa duração. No contexto do MCP, SSE é utilizado para que servidores remotos transmitam dados (como respostas de ferramentas) para sua aplicação CrewAI em tempo real.

* **Servidores Remotos**: SSE é adequado para servidores MCP hospedados remotamente.
* **Fluxo Unidirecional**: Normalmente, SSE é um canal de comunicação de mão única, do servidor para o cliente.
* **Configuração do `MCPServerAdapter`**: Para SSE, você fornecerá a URL do servidor e especificará o tipo de transporte.

## Conectando via SSE

Você pode se conectar a um servidor MCP baseado em SSE usando duas abordagens principais para gerenciar o ciclo de vida da conexão:

### 1. Conexão Totalmente Gerenciada (Recomendado)

Utilizar um gerenciador de contexto Python (`with` statement) é a abordagem recomendada. Ele lida automaticamente com o estabelecimento e o encerramento da conexão com o servidor MCP SSE.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter

server_params = {
    "url": "http://localhost:8000/sse", # Replace with your actual SSE server URL
    "transport": "sse" 
}

---

## 모든 LLM에 연결하기

**URL:** llms-txt#모든-llm에-연결하기

**Contents:**
- CrewAI를 LLM에 연결하기
- 지원되는 프로바이더
- LLM 변경하기
- 구성 옵션
- OpenAI 호환 LLM에 연결하기
- Ollama와 함께 로컬 모델 사용하기
- 기본 API URL 변경하기
- 결론

Source: https://docs.crewai.com/ko/learn/llm-connections

LiteLLM을 사용하여 CrewAI를 다양한 대형 언어 모델(LLM)과 통합하는 방법에 대한 종합적인 가이드로, 지원되는 제공자와 구성 옵션을 포함합니다.

CrewAI는 LiteLLM을 사용하여 다양한 언어 모델(LLM)에 연결합니다. 이 통합은 높은 다양성을 제공하여, 여러 공급자의 모델을 간단하고 통합된 인터페이스로 사용할 수 있게 해줍니다.

<Note>
  기본적으로 CrewAI는 `gpt-4o-mini` 모델을 사용합니다. 이는 `OPENAI_MODEL_NAME` 환경 변수에 의해 결정되며, 설정되지 않은 경우 기본값은 "gpt-4o-mini"입니다.
  본 가이드에 설명된 대로 다른 모델이나 공급자를 사용하도록 에이전트를 쉽게 설정할 수 있습니다.
</Note>

LiteLLM은 다음을 포함하되 이에 국한되지 않는 다양한 프로바이더를 지원합니다:

* OpenAI
* Anthropic
* Google (Vertex AI, Gemini)
* Azure OpenAI
* AWS (Bedrock, SageMaker)
* Cohere
* VoyageAI
* Hugging Face
* Ollama
* Mistral AI
* Replicate
* Together AI
* AI21
* Cloudflare Workers AI
* DeepInfra
* Groq
* SambaNova
* Nebius AI Studio
* [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1)
* 그리고 더 많은 프로바이더!

지원되는 프로바이더의 전체 및 최신 목록은 [LiteLLM 프로바이더 문서](https://docs.litellm.ai/docs/providers)를 참조하세요.

CrewAI agent에서 다른 LLM을 사용하려면 여러 가지 방법이 있습니다:

<Tabs>
  <Tab title="문자열 식별자 사용">
    agent를 초기화할 때 모델 이름을 문자열로 전달하세요:

<CodeGroup>
      
    </CodeGroup>
  </Tab>

<Tab title="LLM 클래스 사용">
    더 자세한 설정을 위해 LLM 클래스를 사용하세요:

<CodeGroup>
      
    </CodeGroup>
  </Tab>
</Tabs>

에이전트를 위해 LLM을 구성할 때 다양한 매개변수를 사용할 수 있습니다:

| 매개변수                   |         유형         | 설명                                     |
| :--------------------- | :----------------: | :------------------------------------- |
| **model**              |        `str`       | 사용할 모델의 이름 (예: "gpt-4", "claude-2")    |
| **temperature**        |       `float`      | 출력의 무작위성 제어 (0.0 \~ 1.0)               |
| **max\_tokens**        |        `int`       | 생성할 최대 토큰 수                            |
| **top\_p**             |       `float`      | 출력 다양성 제어 (0.0 \~ 1.0)                 |
| **frequency\_penalty** |       `float`      | 지금까지의 텍스트에서 빈도에 따라 새로운 토큰에 패널티 부여      |
| **presence\_penalty**  |       `float`      | 지금까지의 텍스트에 이미 존재하는지에 따라 새로운 토큰에 패널티 부여 |
| **stop**               | `str`, `List[str]` | 생성을 중단할 시퀀스(들)                         |
| **base\_url**          |        `str`       | API 엔드포인트의 기본 URL                      |
| **api\_key**           |        `str`       | 인증용 API 키                              |

매개변수와 그 설명의 전체 목록은 LLM 클래스 문서를 참고하십시오.

## OpenAI 호환 LLM에 연결하기

OpenAI 호환 LLM에 연결하려면 환경 변수를 사용하거나 LLM 클래스에서 특정 속성을 설정할 수 있습니다:

<Tabs>
  <Tab title="환경 변수 사용하기">
    <CodeGroup>

</CodeGroup>
  </Tab>

<Tab title="LLM 클래스 속성 사용하기">
    <CodeGroup>

</CodeGroup>
  </Tab>
</Tabs>

## Ollama와 함께 로컬 모델 사용하기

Ollama에서 제공하는 로컬 모델의 경우:

<Steps>
  <Step title="Ollama 다운로드 및 설치">
    [여기를 클릭하여 Ollama를 다운로드 및 설치하세요](https://ollama.com/download)
  </Step>

<Step title="원하는 모델 가져오기">
    예를 들어, `ollama pull llama3.2`를 실행하여 모델을 다운로드합니다.
  </Step>

<Step title="에이전트 구성">
    <CodeGroup>
      
    </CodeGroup>
  </Step>
</Steps>

어떤 LLM provider든 `base_url` 파라미터를 설정하여 기본 API URL을 변경할 수 있습니다:

이 기능은 OpenAI 호환 API를 사용할 때나 선택한 provider에 대해 다른 endpoint를 지정해야 할 때 특히 유용합니다.

LiteLLM을 활용함으로써 CrewAI는 다양한 LLM과의 원활한 통합을 제공합니다. 이러한 유연성 덕분에 성능, 비용 효율성 또는 로컬 배포 등 귀하의 특정 요구 사항에 가장 적합한 모델을 선택할 수 있습니다. 지원되는 모델과 구성 옵션에 대한 최신 정보는 반드시 [LiteLLM 문서](https://docs.litellm.ai/docs/)를 참고하시기 바랍니다.

**Examples:**

Example 1 (unknown):
```unknown
</CodeGroup>
  </Tab>

  <Tab title="LLM 클래스 사용">
    더 자세한 설정을 위해 LLM 클래스를 사용하세요:

    <CodeGroup>
```

Example 2 (unknown):
```unknown
</CodeGroup>
  </Tab>
</Tabs>

## 구성 옵션

에이전트를 위해 LLM을 구성할 때 다양한 매개변수를 사용할 수 있습니다:

| 매개변수                   |         유형         | 설명                                     |
| :--------------------- | :----------------: | :------------------------------------- |
| **model**              |        `str`       | 사용할 모델의 이름 (예: "gpt-4", "claude-2")    |
| **temperature**        |       `float`      | 출력의 무작위성 제어 (0.0 \~ 1.0)               |
| **max\_tokens**        |        `int`       | 생성할 최대 토큰 수                            |
| **top\_p**             |       `float`      | 출력 다양성 제어 (0.0 \~ 1.0)                 |
| **frequency\_penalty** |       `float`      | 지금까지의 텍스트에서 빈도에 따라 새로운 토큰에 패널티 부여      |
| **presence\_penalty**  |       `float`      | 지금까지의 텍스트에 이미 존재하는지에 따라 새로운 토큰에 패널티 부여 |
| **stop**               | `str`, `List[str]` | 생성을 중단할 시퀀스(들)                         |
| **base\_url**          |        `str`       | API 엔드포인트의 기본 URL                      |
| **api\_key**           |        `str`       | 인증용 API 키                              |

매개변수와 그 설명의 전체 목록은 LLM 클래스 문서를 참고하십시오.

## OpenAI 호환 LLM에 연결하기

OpenAI 호환 LLM에 연결하려면 환경 변수를 사용하거나 LLM 클래스에서 특정 속성을 설정할 수 있습니다:

<Tabs>
  <Tab title="환경 변수 사용하기">
    <CodeGroup>
```

Example 3 (unknown):
```unknown

```

Example 4 (unknown):
```unknown
</CodeGroup>
  </Tab>

  <Tab title="LLM 클래스 속성 사용하기">
    <CodeGroup>
```

---

## Print the UUID strings

**URL:** llms-txt#print-the-uuid-strings

**Contents:**
  - 지문 메타데이터 작업

print(f"Agent fingerprint: {agent_fingerprint.uuid_str}")
print(f"Crew fingerprint: {crew_fingerprint.uuid_str}")
print(f"Task fingerprint: {task_fingerprint.uuid_str}")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 지문 메타데이터 작업

지문에 추가적인 맥락 정보를 제공하기 위해 메타데이터를 추가할 수 있습니다:
```

---

## This approach is suitable when the JSON path is either known beforehand or can be dynamically identified.

**URL:** llms-txt#this-approach-is-suitable-when-the-json-path-is-either-known-beforehand-or-can-be-dynamically-identified.

tool = JSONSearchTool()

---

## Crie um agente com capacidades do Google Slides

**URL:** llms-txt#crie-um-agente-com-capacidades-do-google-slides

slides_agent = Agent(
    role="Criador de Apresentações",
    goal="Criar e gerenciar apresentações do Google Slides de forma eficiente",
    backstory="Um assistente IA especializado em design de apresentações e gerenciamento de conteúdo.",
    apps=['google_slides']  # Todas as ações do Google Slides estarão disponíveis
)

---

## Defina um formato de saída estruturado

**URL:** llms-txt#defina-um-formato-de-saída-estruturado

class MarketAnalysis(BaseModel):
    key_trends: List[str]
    opportunities: List[str]
    recommendation: str

---

## `BrowserbaseLoadTool`

**URL:** llms-txt#`browserbaseloadtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

[Browserbase](https://browserbase.com) é uma plataforma para desenvolvedores que permite executar, gerenciar e monitorar navegadores headless de forma confiável.

Potencialize suas buscas de dados para IA com:

* [Infraestrutura Serverless](https://docs.browserbase.com/under-the-hood) fornecendo navegadores confiáveis para extrair dados de interfaces complexas
* [Modo Stealth](https://docs.browserbase.com/features/stealth-mode) com táticas de fingerprinting e resolução automática de captcha incluídas
* [Depurador de Sessão](https://docs.browserbase.com/features/sessions) para inspecionar sua Sessão do Navegador com linha do tempo de rede e logs
* [Depuração Ao Vivo](https://docs.browserbase.com/guides/session-debug-connection/browser-remote-control) para depurar rapidamente sua automação

* Obtenha uma chave de API e o Project ID em [browserbase.com](https://browserbase.com) e defina-os nas variáveis de ambiente (`BROWSERBASE_API_KEY`, `BROWSERBASE_PROJECT_ID`).
* Instale o [SDK do Browserbase](http://github.com/browserbase/python-sdk) juntamente com o pacote `crewai[tools]`:

Utilize o BrowserbaseLoadTool conforme abaixo para permitir que seu agente carregue sites:

```python Code theme={null}
from crewai_tools import BrowserbaseLoadTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Utilize o BrowserbaseLoadTool conforme abaixo para permitir que seu agente carregue sites:
```

---

## Initialize with custom configuration

**URL:** llms-txt#initialize-with-custom-configuration

**Contents:**
- Features
- Response Format
- Use Cases

extractor_tool = TavilyExtractorTool(
    extract_depth='advanced',  # More comprehensive extraction
    include_images=True,       # Include image results
    timeout=90                 # Custom timeout
)
```

* **Single or Multiple URLs**: Extract content from one URL or process multiple URLs in a single request
* **Configurable Depth**: Choose between basic (fast) and advanced (comprehensive) extraction modes
* **Image Support**: Optionally include images in the extraction results
* **Structured Output**: Returns well-formatted JSON containing the extracted content
* **Error Handling**: Robust handling of network timeouts and extraction errors

The tool returns a JSON string representing the structured data extracted from the provided URL(s). The exact structure depends on the content of the pages and the `extract_depth` used.

Common response elements include:

* **Title**: The page title
* **Content**: Main text content of the page
* **Images**: Image URLs and metadata (when `include_images=True`)
* **Metadata**: Additional page information like author, description, etc.

* **Content Analysis**: Extract and analyze content from competitor websites
* **Research**: Gather structured data from multiple sources for analysis
* **Content Migration**: Extract content from existing websites for migration
* **Monitoring**: Regular extraction of content for change detection
* **Data Collection**: Systematic extraction of information from web sources

Refer to the [Tavily API documentation](https://docs.tavily.com/docs/tavily-api/python-sdk#extract) for detailed information about the response structure and available options.

---

## Carregue agentes dos repositórios

**URL:** llms-txt#carregue-agentes-dos-repositórios

researcher = Agent(
    from_repository="market-research-agent"
)

writer = Agent(
    from_repository="content-writer-agent"
)

---

## assim o agente só poderá buscar dentro do conteúdo do arquivo DOCX especificado

**URL:** llms-txt#assim-o-agente-só-poderá-buscar-dentro-do-conteúdo-do-arquivo-docx-especificado

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = DOCXSearchTool(docx='path/to/your/document.docx')
python Code theme={null}
from chromadb.config import Settings

tool = DOCXSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # ou "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

Os seguintes parâmetros podem ser usados para customizar o comportamento da `DOCXSearchTool`:

| Argumento | Tipo     | Descrição                                                                                                                                                                                                                                     |
| :-------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **docx**  | `string` | *Opcional*. Um argumento que especifica o caminho para o arquivo DOCX que você deseja pesquisar. Se não for fornecido durante a inicialização, a ferramenta permite a especificação posterior do caminho de qualquer arquivo DOCX para busca. |

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza o OpenAI tanto para embeddings quanto para sumarização. Para customizar o modelo, você pode usar um dicionário de configuração como no exemplo:
```

---

## it learns about during execution

**URL:** llms-txt#it-learns-about-during-execution

tool = DirectoryReadTool()

---

## Task to create a new lead

**URL:** llms-txt#task-to-create-a-new-lead

create_lead_task = Task(
    description="Create a new lead for John Doe from Example Corp with email john.doe@example.com",
    agent=salesforce_agent,
    expected_output="Lead created successfully with lead ID"
)

---

## ❌ Wrong - missing required parameters

**URL:** llms-txt#❌-wrong---missing-required-parameters

def __init__(self, api_key: str):
    super().__init__()

---

## Github Search

**URL:** llms-txt#github-search

Source: https://docs.crewai.com/pt-BR/tools/search-research/githubsearchtool

O `GithubSearchTool` foi desenvolvido para pesquisar sites e convertê-los em markdown limpo ou dados estruturados.

---

## Run the async function

**URL:** llms-txt#run-the-async-function

asyncio.run(async_multiple_crews())
```

---

## Now all storage will be in your project directory

**URL:** llms-txt#now-all-storage-will-be-in-your-project-directory

**Contents:**
  - 임베딩 제공자 기본값

**Examples:**

Example 1 (unknown):
```unknown
### 임베딩 제공자 기본값

<Info>
  **기본 임베딩 제공자**: CrewAI는 일관성과 신뢰성을 위해 기본적으로 OpenAI 임베딩을 사용합니다. 이를 쉽게 사용자 맞춤화하여 LLM 제공자에 맞추거나 로컬 임베딩을 사용할 수 있습니다.
</Info>

#### 기본 동작 이해하기
```

---

## Modificar o agente

**URL:** llms-txt#modificar-o-agente

agent.goal = "New goal for analysis"

---

## SSE Transport

**URL:** llms-txt#sse-transport

**Contents:**
- Overview
- Key Concepts
- Connecting via SSE
  - 1. Fully Managed Connection (Recommended)

Source: https://docs.crewai.com/en/mcp/sse

Learn how to connect CrewAI to remote MCP servers using Server-Sent Events (SSE) for real-time communication.

Server-Sent Events (SSE) provide a standard way for a web server to send updates to a client over a single, long-lived HTTP connection. In the context of MCP, SSE is used for remote servers to stream data (like tool responses) to your CrewAI application in real-time.

* **Remote Servers**: SSE is suitable for MCP servers hosted remotely.
* **Unidirectional Stream**: Typically, SSE is a one-way communication channel from server to client.
* **`MCPServerAdapter` Configuration**: For SSE, you'll provide the server's URL and specify the transport type.

## Connecting via SSE

You can connect to an SSE-based MCP server using two main approaches for managing the connection lifecycle:

### 1. Fully Managed Connection (Recommended)

Using a Python context manager (`with` statement) is the recommended approach. It automatically handles establishing and closing the connection to the SSE MCP server.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter

server_params = {
    "url": "http://localhost:8000/sse", # Replace with your actual SSE server URL
    "transport": "sse" 
}

---

## Linkup 검색 도구

**URL:** llms-txt#linkup-검색-도구

Source: https://docs.crewai.com/ko/tools/search-research/linkupsearchtool

LinkupSearchTool은 Linkup API를 통해 컨텍스트 정보를 질의할 수 있도록 합니다.

---

## Initialize the tool with a specific text file,

**URL:** llms-txt#initialize-the-tool-with-a-specific-text-file,

---

## React 컴포넌트 내보내기

**URL:** llms-txt#react-컴포넌트-내보내기

**Contents:**
- React 컴포넌트 내보내기
- 리액트 환경 설정
- 커스터마이징
- 다음 단계

Source: https://docs.crewai.com/ko/enterprise/guides/react-component-export

CrewAI AMP React 컴포넌트를 애플리케이션에 내보내고 통합하는 방법을 알아보세요

이 가이드는 CrewAI AMP crew를 React 컴포넌트로 내보내고 이를 여러분의 애플리케이션에 통합하는 방법을 설명합니다.

<Steps>
  <Step title="컴포넌트 내보내기">
    배포된 crew 오른쪽에 있는 줄임표(세 개의 점)를 클릭한 다음 내보내기 옵션을 선택하고 파일을 로컬에 저장하세요. 본 예시에서는 `CrewLead.jsx`를 사용합니다.

<Frame>
      <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e0c72184b57eeae414674023197fca1b" alt="React 컴포넌트 내보내기" data-og-width="493" width="493" data-og-height="359" height="359" data-path="images/enterprise/export-react-component.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8493fbf39305d5f66dea0f19af860363 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=77698a5cf65d840dc81de4bd72bb4db1 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=fe2f4ee4cf620354f6413726983a33fb 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c817314a4164f7c55ecd424ab5de61cf 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6d982c3772ec31c866bcdcabaa8a6b5e 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/export-react-component.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=0b9e48143a23435526cf924906aac876 2500w" />
    </Frame>
  </Step>
</Steps>

이 리액트 컴포넌트를 로컬에서 실행하려면 리액트 개발 환경을 설정하고 이 컴포넌트를 리액트 프로젝트에 통합해야 합니다.

<Steps>
  <Step title="Node.js 설치">
    * 공식 웹사이트([https://nodejs.org/)에서](https://nodejs.org/\)에서) Node.js를 다운로드하고 설치하세요.
    * 안정성을 위해 LTS(장기 지원) 버전을 선택하세요.
  </Step>

<Step title="새 리액트 프로젝트 생성">
    * 명령 프롬프트 또는 PowerShell을 엽니다.
    * 프로젝트를 생성하고자 하는 디렉터리로 이동하세요.
    * 다음 명령어를 실행하여 새로운 리액트 프로젝트를 생성합니다:

<Step title="필요한 의존성 설치">
    
  </Step>

<Step title="CrewLead 컴포넌트 생성">
    * 다운로드한 파일 `CrewLead.jsx`를 프로젝트의 `src` 폴더로 이동하세요.
  </Step>

<Step title="App.js를 수정하여 CrewLead 컴포넌트 사용">
    * `src/App.js`를 엽니다.
    * 내용물을 아래와 같이 교체하세요:

* `YOUR_API_BASE_URL` 및 `YOUR_BEARER_TOKEN` 부분을 실제 API 값으로 바꿔주세요.
  </Step>

<Step title="개발 서버 시작">
    * 프로젝트 디렉터리에서 다음 명령어를 실행하세요:

* 개발 서버가 시작되며, 기본 웹 브라우저가 자동으로 [http://localhost:3000](http://localhost:3000) 을 열고 리액트 앱이 실행되는 것을 확인할 수 있습니다.
  </Step>
</Steps>

그런 다음 `CrewLead.jsx`를 커스터마이즈하여 색상, 제목 등을 추가할 수 있습니다.

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4673fd3ac9eedc1c83b777afb8cf09c9" alt="React 컴포넌트 커스터마이즈" data-og-width="1119" width="1119" data-og-height="939" height="939" data-path="images/enterprise/customise-react-component.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=551606e5340b4eb48fa2ca617486ab17 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4861d2caa401af697527bbafe3cfdb8a 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=ce6d2304d336e487c9bfbd8e1fde5eaf 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1b2d7f443f10ff21f73e14ef42f91063 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=af6ddc00aa79e8b1606d74b587336a5d 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=997057d8f5ed2b15166ea3cec704a4f3 2500w" />
</Frame>

<Frame>
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=714c15d129b3db4bd96cdc55e80916dd" alt="React 컴포넌트 커스터마이즈" data-og-width="1058" width="1058" data-og-height="427" height="427" data-path="images/enterprise/customise-react-component-2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=5c589ec079cd09f29551136ee607d0a5 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=059851daaaf939d0a5bb2aa1598940cf 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3bad7a6f0f18aff57419ded53c398f15 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6753c201e535c8fcebd1d949436003c7 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=352df6d7283212880ef271a8fb673098 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/customise-react-component-2.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=725cfe8688b8135dd25290296d787dbf 2500w" />
</Frame>

* 구성 요소 스타일을 애플리케이션 디자인에 맞게 맞춤화하세요
* 추가 구성을 위한 props를 추가하세요
* 애플리케이션의 상태 관리와 통합하세요
* 오류 처리 및 로딩 상태를 추가하세요

**Examples:**

Example 1 (unknown):
```unknown
* 프로젝트 디렉터리로 이동합니다:
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="필요한 의존성 설치">
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="CrewLead 컴포넌트 생성">
    * 다운로드한 파일 `CrewLead.jsx`를 프로젝트의 `src` 폴더로 이동하세요.
  </Step>

  <Step title="App.js를 수정하여 CrewLead 컴포넌트 사용">
    * `src/App.js`를 엽니다.
    * 내용물을 아래와 같이 교체하세요:
```

Example 4 (unknown):
```unknown
* `YOUR_API_BASE_URL` 및 `YOUR_BEARER_TOKEN` 부분을 실제 API 값으로 바꿔주세요.
  </Step>

  <Step title="개발 서버 시작">
    * 프로젝트 디렉터리에서 다음 명령어를 실행하세요:
```

---

## Example task with markdown formatting enabled

**URL:** llms-txt#example-task-with-markdown-formatting-enabled

**Contents:**
  - 마크다운을 활용한 YAML 구성
  - 마크다운 출력의 이점
- 작업 종속성 및 컨텍스트
- 작업 가드레일
  - 함수 기반 가드레일
  - Guardrail 함수 요구사항
  - 오류 처리 모범 사례
  - 가드레일 결과 처리
- 작업에서 구조화된 일관된 출력 얻기
  - `output_pydantic` 사용하기

formatted_task = Task(
    description="Create a comprehensive report on AI trends",
    expected_output="A well-structured report with headers, sections, and bullet points",
    agent=reporter_agent,
    markdown=True  # Enable automatic markdown formatting
)
yaml tasks.yaml theme={null}
analysis_task:
  description: >
    Analyze the market data and create a detailed report
  expected_output: >
    A comprehensive analysis with charts and key findings
  agent: analyst
  markdown: true  # Enable markdown formatting
  output_file: analysis.md
python Code theme={null}
research_task = Task(
    description="Research the latest developments in AI",
    expected_output="A list of recent AI developments",
    agent=researcher
)

analysis_task = Task(
    description="Analyze the research findings and identify key trends",
    expected_output="Analysis report of AI trends",
    agent=analyst,
    context=[research_task]  # This task will wait for research_task to complete
)
python Code theme={null}
from typing import Tuple, Union, Dict, Any
from crewai import TaskOutput

def validate_blog_content(result: TaskOutput) -> Tuple[bool, Any]:
    """Validate blog content meets requirements."""
    try:
        # Check word count
        word_count = len(result.split())
        if word_count > 200:
            return (False, "Blog content exceeds 200 words")

# Additional validation logic here
        return (True, result.strip())
    except Exception as e:
        return (False, "Unexpected error during validation")

blog_task = Task(
    description="Write a blog post about AI",
    expected_output="A blog post under 200 words",
    agent=blog_agent,
    guardrail=validate_blog_content  # Add the guardrail function
)
python Code theme={null}
from crewai import TaskOutput, LLMGuardrail

def validate_with_context(result: TaskOutput) -> Tuple[bool, Any]:
    try:
        # Main validation logic
        validated_data = perform_validation(result)
        return (True, validated_data)
    except ValidationError as e:
        return (False, f"VALIDATION_ERROR: {str(e)}")
    except Exception as e:
        return (False, str(e))
python Code theme={null}
from typing import Any, Dict, List, Tuple, Union
from crewai import TaskOutput

def complex_validation(result: TaskOutput) -> Tuple[bool, Any]:
    """Chain multiple validation steps."""
    # Step 1: Basic validation
    if not result:
        return (False, "Empty result")

# Step 2: Content validation
    try:
        validated = validate_content(result)
        if not validated:
            return (False, "Invalid content")

# Step 3: Format validation
        formatted = format_output(validated)
        return (True, formatted)
    except Exception as e:
        return (False, str(e))
python Code theme={null}
from typing import Optional, Tuple, Union
from crewai import TaskOutput, Task

def validate_json_output(result: TaskOutput) -> Tuple[bool, Any]:
    """Validate and parse JSON output."""
    try:
        # Try to parse as JSON
        data = json.loads(result)
        return (True, data)
    except json.JSONDecodeError as e:
        return (False, "Invalid JSON format")

task = Task(
    description="Generate a JSON report",
    expected_output="A valid JSON object",
    agent=analyst,
    guardrail=validate_json_output,
    guardrail_max_retries=3  # 재시도 횟수 제한
)
python Code theme={null}
import json

from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

class Blog(BaseModel):
    title: str
    content: str

blog_agent = Agent(
    role="Blog Content Generator Agent",
    goal="Generate a blog title and content",
    backstory="""You are an expert content creator, skilled in crafting engaging and informative blog posts.""",
    verbose=False,
    allow_delegation=False,
    llm="gpt-4o",
)

task1 = Task(
    description="""Create a blog title and content on a given topic. Make sure the content is under 200 words.""",
    expected_output="A compelling blog title and well-written content.",
    agent=blog_agent,
    output_pydantic=Blog,
)

**Examples:**

Example 1 (unknown):
```unknown
`markdown=True`일 때, 에이전트는 다음과 같이 출력을 포매팅하라는 추가 지시를 받게 됩니다:

* 헤더에는 `#` 사용
* 볼드체는 `**텍스트**` 사용
* 이탤릭체는 `*텍스트*` 사용
* 불릿 포인트에는 `-` 또는 `*` 사용
* 인라인 코드는 `` `코드` `` 사용
* 코드 블록은 ` `언어 \`\`\` 사용

### 마크다운을 활용한 YAML 구성
```

Example 2 (unknown):
```unknown
### 마크다운 출력의 이점

* **일관된 포맷팅**: 모든 출력이 올바른 마크다운 규칙을 따르도록 보장합니다
* **향상된 가독성**: 헤더, 목록, 강조 등으로 구조화된 콘텐츠
* **문서화에 적합**: 출력을 문서 시스템에서 바로 사용할 수 있습니다
* **크로스 플랫폼 호환성**: 마크다운은 보편적으로 지원됩니다

<Note>
  마크다운 포맷팅 지침은 `markdown=True`일 때 작업 프롬프트에 자동으로 추가되므로, 작업 설명에 포맷팅 요구사항을 따로 명시할 필요가 없습니다.
</Note>

## 작업 종속성 및 컨텍스트

작업은 `context` 속성을 사용하여 다른 작업의 출력에 의존할 수 있습니다. 예를 들어:
```

Example 3 (unknown):
```unknown
## 작업 가드레일

작업 가드레일은 작업 출력물을 다음 작업에 전달하기 전에 유효성을 검사하고 변환할 수 있는 방식을 제공합니다. 이 기능은 데이터 품질을 보장하고 에이전트의 출력이 특정 기준을 충족하지 않을 때 피드백을 제공하는 데 도움이 됩니다.

가드레일은 사용자 지정 유효성 검사 로직을 포함하는 Python 함수로 구현되며, 유효성 검사 프로세스를 완전히 제어할 수 있어 신뢰할 수 있고 결정적인 결과를 보장합니다.

### 함수 기반 가드레일

함수 기반 가드레일을 태스크에 추가하려면 `guardrail` 파라미터를 통해 검증 함수를 제공하세요:
```

Example 4 (unknown):
```unknown
### Guardrail 함수 요구사항

1. **함수 시그니처**:
   * 정확히 하나의 매개변수(태스크 출력)를 받아야 함
   * `(bool, Any)` 형태의 튜플을 반환해야 함
   * 타입 힌트는 권장하지만 필수는 아님

2. **반환 값**:
   * 성공 시: `(bool, Any)` 형태의 튜플을 반환. 예: `(True, validated_result)`
   * 실패 시: `(bool, str)` 형태의 튜플을 반환. 예: `(False, "Error message explain the failure")`

### 오류 처리 모범 사례

1. **구조화된 오류 응답**:
```

---

## 검색 범위를 특정 JSON 파일로 제한하고 싶을 때 이 초기화 방법을 사용하세요.

**URL:** llms-txt#검색-범위를-특정-json-파일로-제한하고-싶을-때-이-초기화-방법을-사용하세요.

**Contents:**
- 인자
- 구성 옵션

tool = JSONSearchTool(json_path='./path/to/your/file.json')
python Code theme={null}
tool = JSONSearchTool(
    config={
        "llm": {
            "provider": "ollama",  # Other options include google, openai, anthropic, llama2, etc.
            "config": {
                "model": "llama2",
                # Additional optional configurations can be specified here.
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            },
        },
        "embedding_model": {
            "provider": "google", # or openai, ollama, ...
            "config": {
                "model": "models/embedding-001",
                "task_type": "retrieval_document",
                # Further customization options can be added here.
            },
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

* `json_path` (str, 선택적): 검색할 JSON 파일의 경로를 지정합니다. 이 인자는 도구가 일반 검색을 위해 초기화된 경우 필수가 아닙니다. 제공될 경우, 지정된 JSON 파일로 검색이 제한됩니다.

## 구성 옵션

JSONSearchTool은 구성 딕셔너리를 통해 광범위한 커스터마이징을 지원합니다. 이를 통해 사용자는 임베딩 및 요약을 위한 다양한 모델을 요구 사항에 따라 선택할 수 있습니다.
```

---

## 로컬 Mem0 구성으로 외부 메모리 인스턴스 생성

**URL:** llms-txt#로컬-mem0-구성으로-외부-메모리-인스턴스-생성

**Contents:**
  - Mem0 클라이언트를 활용한 고급 외부 메모리

external_memory = ExternalMemory(
    embedder_config={
        "provider": "mem0",
        "config": {
            "user_id": "john",
            "local_mem0_config": {
                "vector_store": {
                    "provider": "qdrant",
                    "config": {"host": "localhost", "port": 6333}
                },
                "llm": {
                    "provider": "openai",
                    "config": {"api_key": "your-api-key", "model": "gpt-4"}
                },
                "embedder": {
                    "provider": "openai",
                    "config": {"api_key": "your-api-key", "model": "text-embedding-3-small"}
                }
            },
            "infer": True # Optional defaults to True
        },
    }
)

crew = Crew(
    agents=[...],
    tasks=[...],
    external_memory=external_memory, # 기본 메모리와 분리됨
    process=Process.sequential,
    verbose=True
)
python  theme={null}
import os
from crewai import Agent, Crew, Process, Task
from crewai.memory.external.external_memory import ExternalMemory

new_categories = [
    {"lifestyle_management_concerns": "Tracks daily routines, habits, hobbies and interests including cooking, time management and work-life balance"},
    {"seeking_structure": "Documents goals around creating routines, schedules, and organized systems in various life areas"},
    {"personal_information": "Basic information about the user including name, preferences, and personality traits"}
]

os.environ["MEM0_API_KEY"] = "your-api-key"

**Examples:**

Example 1 (unknown):
```unknown
### Mem0 클라이언트를 활용한 고급 외부 메모리

Mem0 클라이언트를 사용할 때, 'includes', 'excludes', 'custom\_categories', 'infer', 'run\_id'(이것은 단기 메모리에만 해당)와 같은 파라미터를 사용하여 메모리 구성을 더욱 세밀하게 커스터마이즈할 수 있습니다.\
더 자세한 내용은 [Mem0 문서](https://docs.mem0.ai/)에서 확인할 수 있습니다.
```

---

## Output:

**URL:** llms-txt#output:

---

## Extract the text from the site

**URL:** llms-txt#extract-the-text-from-the-site

**Contents:**
- Arguments

text = tool.run()
print(text)
```

| Argument         | Type     | Description                                                                                                                                        |
| :--------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |
| **website\_url** | `string` | **Mandatory** website URL to read the file. This is the primary input for the tool, specifying which website's content should be scraped and read. |

---

## Visão Geral do Weave

**URL:** llms-txt#visão-geral-do-weave

**Contents:**
- Instruções de Configuração
- Funcionalidades
- Recursos

[Weights & Biases (W\&B) Weave](https://weave-docs.wandb.ai/) é um framework para rastreamento, experimentação, avaliação, implementação e aprimoramento de aplicações baseadas em LLM.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.gif?s=4a933830e3e3cf146c4c87cb44d46475" alt="Visão geral do uso do tracing do W&B Weave com CrewAI" data-og-width="852" width="852" data-og-height="480" height="480" data-path="images/weave-tracing.gif" data-optimize="true" data-opv="3" />

O Weave oferece suporte completo para todas as etapas do desenvolvimento da sua aplicação CrewAI:

* **Rastreamento e Monitoramento**: Acompanhe automaticamente chamadas LLM e a lógica da aplicação para depuração e análise de sistemas em produção
* **Iteração Sistemática**: Aperfeiçoe e itere em prompts, conjuntos de dados e modelos
* **Avaliação**: Utilize avaliadores personalizados ou pré-construídos para avaliar e aprimorar sistematicamente o desempenho dos agentes
* **Guardrails**: Proteja seus agentes com salvaguardas pré e pós-execução para moderação de conteúdo e segurança de prompts

O Weave captura automaticamente rastreamentos (traces) de suas aplicações CrewAI, permitindo monitorar e analisar o desempenho, as interações e o fluxo de execução dos seus agentes. Isso te ajuda a construir melhores conjuntos de dados para avaliação e a otimizar os fluxos de trabalho dos agentes.

## Instruções de Configuração

<Steps>
  <Step title="Instale os pacotes necessários">
    
  </Step>

<Step title="Crie uma conta no W&B">
    Cadastre-se em uma [conta Weights & Biases](https://wandb.ai) caso ainda não tenha uma. Você precisará dela para visualizar rastreamentos e métricas.
  </Step>

<Step title="Inicialize o Weave na sua aplicação">
    Adicione o seguinte código à sua aplicação:

Após a inicialização, o Weave fornecerá uma URL onde você poderá visualizar seus rastreamentos e métricas.
  </Step>

<Step title="Crie seus Crews/Flows">
    
  </Step>

<Step title="Visualize rastreamentos no Weave">
    Após executar sua aplicação CrewAI, acesse a URL do Weave fornecida durante a inicialização para visualizar:

* Chamadas LLM e seus metadados
    * Interações dos agentes e fluxo de execução das tarefas
    * Métricas de desempenho como latência e uso de tokens
    * Quaisquer erros ou problemas ocorridos durante a execução

<Frame caption="Painel de Rastreamento do Weave">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f59e556fcc0ac8fcca8eaeef4c0551ae" alt="Exemplo de rastreamento do Weave com CrewAI" data-og-width="3456" width="3456" data-og-height="1986" height="1986" data-path="images/weave-tracing.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=42efb320cedff3209765027d4f47e187 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=85318181f2afd6237c71cecedfda8104 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6124c3113060320d39847c47faa02ac4 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=e04300ff38ddf3624acc078bacf6712e 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c0ba473c3fa41c2939df4e28bc1098b5 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6d860d735bc5a42fb68085fc4ef01b2c 2500w" />
    </Frame>
  </Step>
</Steps>

* O Weave captura automaticamente todas as operações do CrewAI: interações dos agentes e execuções das tarefas; chamadas LLM com metadados e uso de tokens; uso de ferramentas e resultados.
* A integração suporta todos os métodos de execução do CrewAI: `kickoff()`, `kickoff_for_each()`, `kickoff_async()` e `kickoff_for_each_async()`.
* Rastreamento automático de todas as [crewAI-tools](https://github.com/crewAIInc/crewAI-tools).
* Suporte ao recurso flow com patching por decorador (`@start`, `@listen`, `@router`, `@or_`, `@and_`).
* Rastreie guardrails personalizados passados para o `Task` do CrewAI com `@weave.op()`.

Para informações detalhadas sobre o que é suportado, acesse a [documentação do Weave CrewAI](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow).

* [📘 Documentação do Weave](https://weave-docs.wandb.ai)
* [📊 Exemplo de dashboard Weave x CrewAI](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89)
* [🐦 X](https://x.com/weave_wb)

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Crie uma conta no W&B">
    Cadastre-se em uma [conta Weights & Biases](https://wandb.ai) caso ainda não tenha uma. Você precisará dela para visualizar rastreamentos e métricas.
  </Step>

  <Step title="Inicialize o Weave na sua aplicação">
    Adicione o seguinte código à sua aplicação:
```

Example 2 (unknown):
```unknown
Após a inicialização, o Weave fornecerá uma URL onde você poderá visualizar seus rastreamentos e métricas.
  </Step>

  <Step title="Crie seus Crews/Flows">
```

---

## ✅ Solution: Ensure delegation is enabled

**URL:** llms-txt#✅-solution:-ensure-delegation-is-enabled

**Contents:**
  - 문제: 지나친 이중 확인

agent = Agent(
    role="...",
    allow_delegation=True,  # This is required!
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 문제: 지나친 이중 확인

**증상:** 에이전트가 과도하게 질문을 하여 진행이 느려짐
```

---

## Usage example

**URL:** llms-txt#usage-example

async def run_flow():
    flow = MarketResearchFlow()
    flow.plot("MarketResearchFlowPlot")
    result = await flow.kickoff_async(inputs={"product": "AI-powered chatbots"})
    return result

---

## 커스텀 도구 생성

**URL:** llms-txt#커스텀-도구-생성

**Contents:**
- CrewAI에서 툴 생성 및 활용
  - `BaseTool` 서브클래싱
  - `tool` 데코레이터 사용하기
  - 도구를 위한 캐시 함수 정의하기

Source: https://docs.crewai.com/ko/learn/create-custom-tools

CrewAI 프레임워크 내에서 커스텀 도구를 제작, 사용 및 관리하는 종합 가이드로, 신규 기능과 오류 처리를 포함합니다.

## CrewAI에서 툴 생성 및 활용

이 가이드는 CrewAI 프레임워크를 위한 커스텀 툴을 생성하는 방법과 최신 기능(툴 위임, 오류 처리, 동적 툴 호출 등)을 통합하여 이러한 툴을 효율적으로 관리하고 활용하는 방법에 대해 자세히 안내합니다. 또한 협업 툴의 중요성을 강조하며, 에이전트가 다양한 작업을 수행할 수 있도록 지원합니다.

개인화된 툴을 생성하려면 `BaseTool`을 상속받고, 입력 검증을 위한 `args_schema`와 `_run` 메서드를 포함한 필요한 속성들을 정의해야 합니다.

### `tool` 데코레이터 사용하기

또는 tool 데코레이터 `@tool`을 사용할 수 있습니다. 이 방법은 함수 내에서 도구의 속성과 기능을 직접 정의할 수 있도록 하며, 귀하의 필요에 맞춘 특화된 도구를 간결하고 효율적으로 생성할 수 있는 방법을 제공합니다.

### 도구를 위한 캐시 함수 정의하기

도구의 성능을 캐싱으로 최적화하려면, `cache_function` 속성을 사용하여 사용자 맞춤 캐싱 전략을 정의할 수 있습니다.

이 가이드라인을 준수하고 새로운 기능과 협업 도구를 도구 생성 및 관리 프로세스에 통합함으로써,
CrewAI 프레임워크의 모든 기능을 활용할 수 있으며, AI agent의 개발 경험과 효율성을 모두 높일 수 있습니다.

**Examples:**

Example 1 (unknown):
```unknown
### `tool` 데코레이터 사용하기

또는 tool 데코레이터 `@tool`을 사용할 수 있습니다. 이 방법은 함수 내에서 도구의 속성과 기능을 직접 정의할 수 있도록 하며, 귀하의 필요에 맞춘 특화된 도구를 간결하고 효율적으로 생성할 수 있는 방법을 제공합니다.
```

Example 2 (unknown):
```unknown
### 도구를 위한 캐시 함수 정의하기

도구의 성능을 캐싱으로 최적화하려면, `cache_function` 속성을 사용하여 사용자 맞춤 캐싱 전략을 정의할 수 있습니다.
```

---

## Option 2: Accessing Properties Directly from the Pydantic Model

**URL:** llms-txt#option-2:-accessing-properties-directly-from-the-pydantic-model

print("Accessing Properties - Option 2")
title = result.pydantic.title
content = result.pydantic.content
print("Title:", title)
print("Content:", content)

---

## ❌ 협업에 도움이 되지 않는 모호한 설명

**URL:** llms-txt#❌-협업에-도움이-되지-않는-모호한-설명

**Contents:**
- 협업 문제 해결
  - 문제: 에이전트들이 협업하지 않음

Task(description="Do some research about chatbots", ...)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 협업 문제 해결

### 문제: 에이전트들이 협업하지 않음

**증상:** 에이전트들이 각자 작업하며, 위임이 이루어지지 않음
```

---

## 웹사이트 URL로 도구를 초기화하여,

**URL:** llms-txt#웹사이트-url로-도구를-초기화하여,

---

## Search results: Title: Role of chat gpt in public health

**URL:** llms-txt#search-results:-title:-role-of-chat-gpt-in-public-health

---

## 더 나은 솔루션: 대용량 데이터에는 RAG 도구 사용

**URL:** llms-txt#더-나은-솔루션:-대용량-데이터에는-rag-도구-사용

from crewai_tools import RagTool
agent.tools = [RagTool()]

---

## Integração Datadog

**URL:** llms-txt#integração-datadog

Source: https://docs.crewai.com/pt-BR/observability/datadog

Saiba como integrar o Datadog com o CrewAI para enviar os rastros de observabilidade do LLM para o Datadog.

---

## 3. Streamable HTTP Server:

**URL:** llms-txt#3.-streamable-http-server:

server_params = {
    "url": "http://localhost:8001/mcp",
    "transport": "streamable-http"
}

---

## Conecte-se a qualquer LLM

**URL:** llms-txt#conecte-se-a-qualquer-llm

**Contents:**
- Conecte o CrewAI a LLMs
- Provedores Compatíveis
- Alterando a LLM
- Opções de Configuração
- Conectando-se a LLMs Compatíveis com OpenAI
- Utilizando Modelos Locais com Ollama
- Alterando a URL Base da API
- Conclusão

Source: https://docs.crewai.com/pt-BR/learn/llm-connections

Guia abrangente sobre como integrar o CrewAI a diversos Large Language Models (LLMs) usando o LiteLLM, incluindo provedores compatíveis e opções de configuração.

## Conecte o CrewAI a LLMs

O CrewAI utiliza o LiteLLM para conectar-se a uma grande variedade de Modelos de Linguagem (LLMs). Essa integração proporciona grande versatilidade, permitindo que você utilize modelos de inúmeros provedores por meio de uma interface simples e unificada.

<Note>
  Por padrão, o CrewAI usa o modelo `gpt-4o-mini`. Isso é determinado pela variável de ambiente `OPENAI_MODEL_NAME`, que tem como padrão "gpt-4o-mini" se não for definida.
  Você pode facilmente configurar seus agentes para usar um modelo ou provedor diferente, conforme descrito neste guia.
</Note>

## Provedores Compatíveis

O LiteLLM oferece suporte a uma ampla gama de provedores, incluindo, mas não se limitando a:

* OpenAI
* Anthropic
* Google (Vertex AI, Gemini)
* Azure OpenAI
* AWS (Bedrock, SageMaker)
* Cohere
* VoyageAI
* Hugging Face
* Ollama
* Mistral AI
* Replicate
* Together AI
* AI21
* Cloudflare Workers AI
* DeepInfra
* Groq
* SambaNova
* [NVIDIA NIMs](https://docs.api.nvidia.com/nim/reference/models-1)
* E muitos outros!

Para uma lista completa e sempre atualizada dos provedores suportados, consulte a [documentação de Provedores do LiteLLM](https://docs.litellm.ai/docs/providers).

Para utilizar uma LLM diferente com seus agentes CrewAI, você tem várias opções:

<Tabs>
  <Tab title="Usando um Identificador de String">
    Passe o nome do modelo como uma string ao inicializar o agente:

<CodeGroup>
      
    </CodeGroup>
  </Tab>

<Tab title="Usando a Classe LLM">
    Para uma configuração mais detalhada, utilize a classe LLM:

<CodeGroup>
      
    </CodeGroup>
  </Tab>
</Tabs>

## Opções de Configuração

Ao configurar uma LLM para o seu agente, você tem acesso a uma variedade de parâmetros:

| Parâmetro              |        Tipo        | Descrição                                                                  |
| :--------------------- | :----------------: | :------------------------------------------------------------------------- |
| **model**              |        `str`       | O nome do modelo a ser utilizado (ex.: "gpt-4", "claude-2")                |
| **temperature**        |       `float`      | Controla o grau de aleatoriedade nas respostas (0.0 a 1.0)                 |
| **max\_tokens**        |        `int`       | Número máximo de tokens a serem gerados                                    |
| **top\_p**             |       `float`      | Controla a diversidade das respostas (0.0 a 1.0)                           |
| **frequency\_penalty** |       `float`      | Penaliza novos tokens com base na frequência em que já apareceram no texto |
| **presence\_penalty**  |       `float`      | Penaliza novos tokens com base na presença deles no texto até o momento    |
| **stop**               | `str`, `List[str]` | Sequência(s) que interrompem a geração do texto                            |
| **base\_url**          |        `str`       | URL base do endpoint da API                                                |
| **api\_key**           |        `str`       | Sua chave de API para autenticação                                         |

Para uma lista completa de parâmetros e suas respectivas descrições, consulte a documentação da classe LLM.

## Conectando-se a LLMs Compatíveis com OpenAI

Você pode se conectar a LLMs compatíveis com a OpenAI usando variáveis de ambiente ou definindo atributos específicos na classe LLM:

<Tabs>
  <Tab title="Usando Variáveis de Ambiente">
    <CodeGroup>

</CodeGroup>
  </Tab>

<Tab title="Usando Atributos da Classe LLM">
    <CodeGroup>

</CodeGroup>
  </Tab>
</Tabs>

## Utilizando Modelos Locais com Ollama

Para modelos locais como os oferecidos pelo Ollama:

<Steps>
  <Step title="Baixe e instale o Ollama">
    [Clique aqui para baixar e instalar o Ollama](https://ollama.com/download)
  </Step>

<Step title="Puxe o modelo desejado">
    Por exemplo, execute `ollama pull llama3.2` para baixar o modelo.
  </Step>

<Step title="Configure seu agente">
    <CodeGroup>
      
    </CodeGroup>
  </Step>
</Steps>

## Alterando a URL Base da API

Você pode alterar a URL base da API para qualquer provedor de LLM definindo o parâmetro `base_url`:

Isso é particularmente útil ao trabalhar com APIs compatíveis com a OpenAI ou quando você precisa especificar um endpoint diferente para o provedor escolhido.

Ao utilizar o LiteLLM, o CrewAI oferece integração transparente com uma vasta gama de LLMs. Essa flexibilidade permite que você escolha o modelo mais adequado para sua necessidade específica, seja priorizando desempenho, custo-benefício ou implantação local. Lembre-se de consultar a [documentação do LiteLLM](https://docs.litellm.ai/docs/) para obter as informações mais atualizadas sobre modelos suportados e opções de configuração.

**Examples:**

Example 1 (unknown):
```unknown
</CodeGroup>
  </Tab>

  <Tab title="Usando a Classe LLM">
    Para uma configuração mais detalhada, utilize a classe LLM:

    <CodeGroup>
```

Example 2 (unknown):
```unknown
</CodeGroup>
  </Tab>
</Tabs>

## Opções de Configuração

Ao configurar uma LLM para o seu agente, você tem acesso a uma variedade de parâmetros:

| Parâmetro              |        Tipo        | Descrição                                                                  |
| :--------------------- | :----------------: | :------------------------------------------------------------------------- |
| **model**              |        `str`       | O nome do modelo a ser utilizado (ex.: "gpt-4", "claude-2")                |
| **temperature**        |       `float`      | Controla o grau de aleatoriedade nas respostas (0.0 a 1.0)                 |
| **max\_tokens**        |        `int`       | Número máximo de tokens a serem gerados                                    |
| **top\_p**             |       `float`      | Controla a diversidade das respostas (0.0 a 1.0)                           |
| **frequency\_penalty** |       `float`      | Penaliza novos tokens com base na frequência em que já apareceram no texto |
| **presence\_penalty**  |       `float`      | Penaliza novos tokens com base na presença deles no texto até o momento    |
| **stop**               | `str`, `List[str]` | Sequência(s) que interrompem a geração do texto                            |
| **base\_url**          |        `str`       | URL base do endpoint da API                                                |
| **api\_key**           |        `str`       | Sua chave de API para autenticação                                         |

Para uma lista completa de parâmetros e suas respectivas descrições, consulte a documentação da classe LLM.

## Conectando-se a LLMs Compatíveis com OpenAI

Você pode se conectar a LLMs compatíveis com a OpenAI usando variáveis de ambiente ou definindo atributos específicos na classe LLM:

<Tabs>
  <Tab title="Usando Variáveis de Ambiente">
    <CodeGroup>
```

Example 3 (unknown):
```unknown

```

Example 4 (unknown):
```unknown
</CodeGroup>
  </Tab>

  <Tab title="Usando Atributos da Classe LLM">
    <CodeGroup>
```

---

## TXT RAG 검색

**URL:** llms-txt#txt-rag-검색

**Contents:**
- 개요
- 설치
- 예시

Source: https://docs.crewai.com/ko/tools/file-document/txtsearchtool

TXTSearchTool은 텍스트 파일의 내용 내에서 RAG(Retrieval-Augmented Generation) 검색을 수행하도록 설계되었습니다.

<Note>
  저희는 도구를 계속 개선하고 있으므로, 추후에 예기치 않은 동작이나 변경이 발생할 수 있습니다.
</Note>

이 도구는 텍스트 파일의 콘텐츠 내에서 RAG(Retrieval-Augmented Generation) 검색을 수행하는 데 사용됩니다.
지정된 텍스트 파일의 콘텐츠에서 쿼리를 의미적으로 검색할 수 있어,
제공된 쿼리를 기반으로 정보를 신속하게 추출하거나 특정 텍스트 섹션을 찾는 데 매우 유용한 리소스입니다.

`TXTSearchTool`을 사용하려면 먼저 `crewai_tools` 패키지를 설치해야 합니다.
이 작업은 Python용 패키지 관리자 pip를 사용하여 수행할 수 있습니다.
터미널 또는 명령 프롬프트를 열고 다음 명령어를 입력하세요:

이 명령어는 TXTSearchTool과 필요한 모든 종속성을 다운로드하고 설치합니다.

다음 예시는 TXTSearchTool을 사용하여 텍스트 파일 내에서 검색하는 방법을 보여줍니다.
이 예시는 특정 텍스트 파일로 도구를 초기화하는 방법과, 해당 파일의 내용에서 검색을 수행하는 방법을 모두 포함하고 있습니다.

```python Code theme={null}
from crewai_tools import TXTSearchTool

**Examples:**

Example 1 (unknown):
```unknown
이 명령어는 TXTSearchTool과 필요한 모든 종속성을 다운로드하고 설치합니다.

## 예시

다음 예시는 TXTSearchTool을 사용하여 텍스트 파일 내에서 검색하는 방법을 보여줍니다.
이 예시는 특정 텍스트 파일로 도구를 초기화하는 방법과, 해당 파일의 내용에서 검색을 수행하는 방법을 모두 포함하고 있습니다.
```

---

## Define a task for the agent

**URL:** llms-txt#define-a-task-for-the-agent

extract_task = Task(
    description='Extract the main content from the URL https://example.com using basic extraction depth.',
    expected_output='A JSON string containing the extracted content from the URL.',
    agent=extractor_agent
)

---

## Bedrock 지식 베이스 검색기

**URL:** llms-txt#bedrock-지식-베이스-검색기

Source: https://docs.crewai.com/ko/tools/cloud-storage/bedrockkbretriever

자연어 쿼리를 사용하여 Amazon Bedrock 지식 베이스에서 정보를 검색합니다

---

## Google Sheets 연동

**URL:** llms-txt#google-sheets-연동

**Contents:**
- 개요
- 사전 준비 사항
- Google Sheets 통합 설정
  - 1. Google 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 Google Sheets 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/google_sheets

CrewAI를 위한 Google Sheets 연동을 통해 스프레드시트 데이터 동기화.

에이전트가 Google Sheets를 통해 스프레드시트 데이터를 관리할 수 있도록 합니다. 행을 읽고, 새 항목을 생성하며, 기존 데이터를 업데이트하고, AI 기반 자동화를 통해 데이터 관리 워크플로우를 간소화하세요. 데이터 추적, 보고, 협업 데이터 관리에 최적화되어 있습니다.

Google Sheets 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 되어 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Google Sheets에 액세스할 수 있는 Google 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Google 계정 연결
* 데이터 작업을 위한 올바른 열 헤더가 있는 스프레드시트

## Google Sheets 통합 설정

### 1. Google 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **Google Sheets**를 찾습니다.
3. **Connect**를 클릭하고 OAuth 흐름을 완료합니다.
4. 스프레드시트 접근에 필요한 권한을 허용합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="google_sheets/get_values">
    **설명:** Google Sheets 스프레드시트에서 행을 가져옵니다.

* `spreadsheetId` (string, 필수): 스프레드시트 - Connect Portal Workflow Settings를 사용하여 사용자가 스프레드시트를 선택할 수 있도록 합니다. 선택한 스프레드시트의 첫 번째 워크시트를 기본값으로 사용합니다.
    * `limit` (string, 선택): 행 제한 - 반환할 최대 행 수를 제한합니다.
  </Accordion>

<Accordion title="google_sheets/append_values">
    **설명:** Google Sheets 스프레드시트에 새로운 행을 만듭니다.

* `spreadsheetId` (string, 필수): 스프레드시트 - Connect Portal Workflow Settings를 사용하여 사용자가 스프레드시트를 선택할 수 있도록 합니다. 선택한 스프레드시트의 첫 번째 워크시트를 기본값으로 사용합니다.
    * `worksheet` (string, 필수): 워크시트 - 워크시트에는 반드시 열 헤더가 있어야 합니다.
    * `additionalFields` (object, 필수): 필드 - 추가할 행의 필드를 열 이름을 key로 하는 객체로 포함합니다. Connect Portal Workflow Settings를 사용하여 사용자가 열 매핑을 선택할 수 있도록 합니다.
      
  </Accordion>

<Accordion title="google_sheets/update_values">
    **설명:** Google Sheets 스프레드시트의 기존 행을 업데이트합니다.

* `spreadsheetId` (string, 필수): 스프레드시트 - Connect Portal Workflow Settings를 사용하여 사용자가 스프레드시트를 선택할 수 있도록 합니다. 선택한 스프레드시트의 첫 번째 워크시트를 기본값으로 사용합니다.
    * `worksheet` (string, 필수): 워크시트 - 워크시트에는 반드시 열 헤더가 있어야 합니다.
    * `filterFormula` (object, 선택): 필터 - 업데이트할 행을 식별하기 위한 단일 조건의 AND 그룹으로 이루어진 OR의 형태(분리 정규형)로 작성합니다.
      
      사용 가능한 연산자: `$stringContains`, `$stringDoesNotContain`, `$stringExactlyMatches`, `$stringDoesNotExactlyMatch`, `$stringStartsWith`, `$stringDoesNotStartWith`, `$stringEndsWith`, `$stringDoesNotEndWith`, `$numberGreaterThan`, `$numberLessThan`, `$numberEquals`, `$numberDoesNotEqual`, `$dateTimeAfter`, `$dateTimeBefore`, `$dateTimeEquals`, `$booleanTrue`, `$booleanFalse`, `$exists`, `$doesNotExist`
    * `additionalFields` (object, 필수): 필드 - 업데이트할 필드를 열 이름을 key로 하는 객체로 포함합니다. Connect Portal Workflow Settings를 사용하여 사용자가 열 매핑을 선택할 수 있도록 합니다.
      
  </Accordion>
</AccordionGroup>

### 기본 Google Sheets 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="google_sheets/get_values">
    **설명:** Google Sheets 스프레드시트에서 행을 가져옵니다.

    **매개변수:**

    * `spreadsheetId` (string, 필수): 스프레드시트 - Connect Portal Workflow Settings를 사용하여 사용자가 스프레드시트를 선택할 수 있도록 합니다. 선택한 스프레드시트의 첫 번째 워크시트를 기본값으로 사용합니다.
    * `limit` (string, 선택): 행 제한 - 반환할 최대 행 수를 제한합니다.
  </Accordion>

  <Accordion title="google_sheets/append_values">
    **설명:** Google Sheets 스프레드시트에 새로운 행을 만듭니다.

    **매개변수:**

    * `spreadsheetId` (string, 필수): 스프레드시트 - Connect Portal Workflow Settings를 사용하여 사용자가 스프레드시트를 선택할 수 있도록 합니다. 선택한 스프레드시트의 첫 번째 워크시트를 기본값으로 사용합니다.
    * `worksheet` (string, 필수): 워크시트 - 워크시트에는 반드시 열 헤더가 있어야 합니다.
    * `additionalFields` (object, 필수): 필드 - 추가할 행의 필드를 열 이름을 key로 하는 객체로 포함합니다. Connect Portal Workflow Settings를 사용하여 사용자가 열 매핑을 선택할 수 있도록 합니다.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="google_sheets/update_values">
    **설명:** Google Sheets 스프레드시트의 기존 행을 업데이트합니다.

    **매개변수:**

    * `spreadsheetId` (string, 필수): 스프레드시트 - Connect Portal Workflow Settings를 사용하여 사용자가 스프레드시트를 선택할 수 있도록 합니다. 선택한 스프레드시트의 첫 번째 워크시트를 기본값으로 사용합니다.
    * `worksheet` (string, 필수): 워크시트 - 워크시트에는 반드시 열 헤더가 있어야 합니다.
    * `filterFormula` (object, 선택): 필터 - 업데이트할 행을 식별하기 위한 단일 조건의 AND 그룹으로 이루어진 OR의 형태(분리 정규형)로 작성합니다.
```

---

## 현재 조직 보기

**URL:** llms-txt#현재-조직-보기

---

## Use este método de inicialização quando desejar limitar o escopo de busca a um arquivo específico.

**URL:** llms-txt#use-este-método-de-inicialização-quando-desejar-limitar-o-escopo-de-busca-a-um-arquivo-específico.

**Contents:**
- Argumentos
- Opções de Configuração

tool = JSONSearchTool(json_path='./path/to/your/file.json')
python Code theme={null}
tool = JSONSearchTool(
    config={
        "llm": {
            "provider": "ollama",  # Outras opções incluem google, openai, anthropic, llama2, etc.
            "config": {
                "model": "llama2",
                # Configurações opcionais adicionais podem ser especificadas aqui.
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            },
        },
        "embedding_model": {
            "provider": "google", # ou openai, ollama, ...
            "config": {
                "model": "models/embedding-001",
                "task_type": "retrieval_document",
                # Mais opções de personalização podem ser adicionadas aqui.
            },
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

* `json_path` (str, opcional): Especifica o caminho para o arquivo JSON a ser buscado. Este argumento não é obrigatório se a ferramenta for inicializada para uma busca geral. Quando fornecido, limita a busca ao arquivo JSON especificado.

## Opções de Configuração

O JSONSearchTool oferece ampla personalização através de um dicionário de configuração. Isso permite que os usuários selecionem diferentes modelos para embeddings e sumarização conforme suas necessidades.
```

---

## 구조화된 출력 받기

**URL:** llms-txt#구조화된-출력-받기

structured_result = analyst.kickoff(
    "Provide a structured analysis of the AI market in 2025",
    response_format=MarketAnalysis
)

---

## Create a query engine

**URL:** llms-txt#create-a-query-engine

query_engine = index.as_query_engine()

---

## Option 3: 에이전트 수준의 임베딩 사용자 정의

**URL:** llms-txt#option-3:-에이전트-수준의-임베딩-사용자-정의

**Contents:**
- 고급 기능
  - 쿼리 리라이팅

agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "google",
        "config": {
            "model": "models/text-embedding-004",
            "api_key": "your-google-key"
        }
    }
)
python  theme={null}
agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "azure",
        "config": {
            "api_key": "your-azure-api-key",
            "model": "text-embedding-ada-002", # change to the model you are using and is deployed in Azure
            "api_base": "https://your-azure-endpoint.openai.azure.com/",
            "api_version": "2024-02-01"
        }
    }
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### Azure OpenAI 임베딩 구성

Azure OpenAI 임베딩을 사용할 때:

1. 먼저 Azure 플랫폼에 임베딩 모델을 배포했는지 확인하세요.
2. 그런 다음 다음과 같은 구성을 사용해야 합니다:
```

Example 2 (unknown):
```unknown
## 고급 기능

### 쿼리 리라이팅

CrewAI는 지식 검색을 최적화하기 위해 지능형 쿼리 리라이팅 메커니즘을 구현합니다. 에이전트가 지식 소스를 검색해야 할 때, 원시 태스크 프롬프트는 자동으로 더 효과적인 검색 쿼리로 변환됩니다.

#### 쿼리 재작성 방식

1. 에이전트가 knowledge 소스를 사용할 수 있을 때 작업을 실행하면 `_get_knowledge_search_query` 메서드가 트리거됩니다.
2. 에이전트의 LLM을 사용하여 원래 작업 프롬프트를 최적화된 검색 쿼리로 변환합니다.
3. 이 최적화된 쿼리는 knowledge 소스에서 관련 정보를 검색하는 데 사용됩니다.

#### 쿼리 리라이트(Query Rewriting)의 이점

<CardGroup cols={2}>
  <Card title="향상된 검색 정확도" icon="bullseye-arrow">
    주요 개념에 집중하고 불필요한 내용을 제거함으로써, 쿼리 리라이트는 보다 관련성 높은 정보를 검색할 수 있게 도와줍니다.
  </Card>

  <Card title="컨텍스트 인식" icon="brain">
    리라이트된 쿼리는 벡터 데이터베이스 검색을 위해 더욱 구체적이고 컨텍스트를 인식할 수 있도록 설계되어 있습니다.
  </Card>
</CardGroup>

#### 예시
```

---

## This happens when switching embedding providers

**URL:** llms-txt#this-happens-when-switching-embedding-providers

---

## Weaviate Vector Search

**URL:** llms-txt#weaviate-vector-search

**Contents:**
- Overview
- Installation
- Steps to Get Started
- Example

Source: https://docs.crewai.com/en/tools/database-data/weaviatevectorsearchtool

The `WeaviateVectorSearchTool` is designed to search a Weaviate vector database for semantically similar documents using hybrid search.

The `WeaviateVectorSearchTool` is specifically crafted for conducting semantic searches within documents stored in a Weaviate vector database. This tool allows you to find semantically similar documents to a given query, leveraging the power of vector and keyword search for more accurate and contextually relevant search results.

[Weaviate](https://weaviate.io/) is a vector database that stores and queries vector embeddings, enabling semantic search capabilities.

To incorporate this tool into your project, you need to install the Weaviate client:

## Steps to Get Started

To effectively use the `WeaviateVectorSearchTool`, follow these steps:

1. **Package Installation**: Confirm that the `crewai[tools]` and `weaviate-client` packages are installed in your Python environment.
2. **Weaviate Setup**: Set up a Weaviate cluster. You can follow the [Weaviate documentation](https://weaviate.io/developers/wcs/manage-clusters/connect) for instructions.
3. **API Keys**: Obtain your Weaviate cluster URL and API key.
4. **OpenAI API Key**: Ensure you have an OpenAI API key set in your environment variables as `OPENAI_API_KEY`.

The following example demonstrates how to initialize the tool and execute a search:

```python Code theme={null}
from crewai_tools import WeaviateVectorSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Steps to Get Started

To effectively use the `WeaviateVectorSearchTool`, follow these steps:

1. **Package Installation**: Confirm that the `crewai[tools]` and `weaviate-client` packages are installed in your Python environment.
2. **Weaviate Setup**: Set up a Weaviate cluster. You can follow the [Weaviate documentation](https://weaviate.io/developers/wcs/manage-clusters/connect) for instructions.
3. **API Keys**: Obtain your Weaviate cluster URL and API key.
4. **OpenAI API Key**: Ensure you have an OpenAI API key set in your environment variables as `OPENAI_API_KEY`.

## Example

The following example demonstrates how to initialize the tool and execute a search:
```

---

## 첫 번째 크루 만들기

**URL:** llms-txt#첫-번째-크루-만들기

**Contents:**
- 협업 AI의 힘을 발휘하기
  - 무엇을 만들고 배우게 될까요
  - 필수 조건
- 1단계: 새로운 CrewAI 프로젝트 생성
- 2단계: 프로젝트 구조 살펴보기
- 3단계: 에이전트 구성하기

Source: https://docs.crewai.com/ko/guides/crews/first-crew

복잡한 문제를 함께 해결할 수 있는 협업 AI 팀을 만드는 단계별 튜토리얼입니다.

여러 AI 에이전트가 각자의 전문성을 바탕으로 원활하게 협력하며 복잡한 문제를 해결한다고 상상해 보세요. 각자 고유한 기술을 발휘해 공동의 목표를 달성합니다. 이것이 바로 CrewAI의 힘입니다. CrewAI 프레임워크를 통해 단일 AI로는 달성할 수 없는 과업을 협업 AI 시스템으로 실현할 수 있습니다.

이 가이드에서는 연구 크루를 만들어 주제를 조사 및 분석하고, 종합적인 보고서를 작성하는 과정을 안내합니다. 이 실용적인 예시는 AI 에이전트들이 어떻게 협력하여 복잡한 작업을 수행할 수 있는지 보여 주지만, CrewAI로 실현할 수 있는 가능성의 시작에 불과합니다.

이 가이드를 마치면 다음을 할 수 있게 됩니다:

1. **특화된 AI 연구팀 조직**: 각기 다른 역할과 책임을 가진 연구팀을 만듭니다
2. **여러 AI 에이전트 간의 협업 조율**
3. **정보 수집, 분석, 보고서 생성을 포함한 복잡한 workflow 자동화**
4. **더 야심찬 프로젝트에도 적용할 수 있는 기초 역량 구축**

이 가이드에서는 간단한 research crew를 만들지만, 동일한 패턴과 기법을 활용하여 다음과 같은 훨씬 더 정교한 팀도 만들 수 있습니다:

* 전문 writer, editor, fact-checker가 참여하는 다단계 콘텐츠 생성
* 단계별 지원 에이전트가 있는 복잡한 고객 서비스 시스템
* 데이터 수집, 시각화, 인사이트 생성까지 하는 자율 business analyst
* 아이디어 구상, 디자인, 구현 계획까지 진행하는 product development 팀

이제 여러분의 첫 crew를 만들어 봅시다!

1. [설치 가이드](/ko/installation)를 참고하여 CrewAI를 설치했는지 확인하세요.
2. [LLM 설정 가이드](/ko/concepts/llms#setting-up-your-llm)를 참고하여 환경에 LLM API 키를 설정했는지 확인하세요.
3. Python에 대한 기본적인 이해

## 1단계: 새로운 CrewAI 프로젝트 생성

먼저, CLI를 사용하여 새로운 CrewAI 프로젝트를 생성해봅시다. 이 명령어는 필요한 모든 파일을 포함한 전체 프로젝트 구조를 설정해 주어, 보일러플레이트 코드를 설정하는 대신 에이전트와 그들의 작업 정의에 집중할 수 있습니다.

이렇게 하면 crew에 필요한 기본 구조를 갖춘 프로젝트가 생성됩니다. CLI는 다음을 자동으로 생성합니다:

* 필요한 파일이 포함된 프로젝트 디렉터리
* 에이전트와 작업에 대한 구성 파일
* 기본 crew 구현
* crew를 실행하는 메인 스크립트

<Frame caption="CrewAI 프레임워크 개요">
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=514fd0b06e4128e62f10728d44601975" alt="CrewAI Framework Overview" data-og-width="634" width="634" data-og-height="473" height="473" data-path="images/crews.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=279c5c26c77fc9acc8411677716fa5ee 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=92b76be34b84b36771e0a8eed8976966 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3ef573e6215967af1bb2975a58d0d859 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1af6e6a337b70ca2ce238d8e40f49218 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c5da01705f1373446f8582ac582ff244 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=96464aab7bb5efe4213a7b80f58038aa 2500w" />
</Frame>

CLI가 생성한 프로젝트 구조를 이해하는 시간을 가져봅시다. CrewAI는 Python 프로젝트의 모범 사례를 따르므로, crew가 더 복잡해질수록 코드를 쉽게 유지 관리하고 확장할 수 있습니다.

이 구조는 Python 프로젝트의 모범 사례를 따르며, 코드를 체계적으로 구성할 수 있도록 해줍니다. 설정 파일(YAML)과 구현 코드(Python)의 분리로 인해, 기본 코드를 변경하지 않고도 crew의 동작을 쉽게 수정할 수 있습니다.

이제 재미있는 단계가 시작됩니다 - 여러분의 AI 에이전트를 정의하는 것입니다! CrewAI에서 에이전트는 특정 역할, 목표 및 배경을 가진 전문화된 엔터티로, 이들이 어떻게 행동할지를 결정합니다. 각각 고유한 성격과 목적을 지닌 연극의 등장인물로 생각하면 됩니다.

우리의 리서치 crew를 위해 두 명의 에이전트를 만들겠습니다:

1. 정보를 찾아 정리하는 데 뛰어난 **리서처**
2. 연구 결과를 해석하고 통찰력 있는 보고서를 작성할 수 있는 **애널리스트**

이러한 전문화된 에이전트를 정의하기 위해 `agents.yaml` 파일을 수정해봅시다. `llm` 항목은 사용 중인 제공업체에 맞게 설정하세요.

```yaml  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
이렇게 하면 crew에 필요한 기본 구조를 갖춘 프로젝트가 생성됩니다. CLI는 다음을 자동으로 생성합니다:

* 필요한 파일이 포함된 프로젝트 디렉터리
* 에이전트와 작업에 대한 구성 파일
* 기본 crew 구현
* crew를 실행하는 메인 스크립트

<Frame caption="CrewAI 프레임워크 개요">
  <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=514fd0b06e4128e62f10728d44601975" alt="CrewAI Framework Overview" data-og-width="634" width="634" data-og-height="473" height="473" data-path="images/crews.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=279c5c26c77fc9acc8411677716fa5ee 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=92b76be34b84b36771e0a8eed8976966 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3ef573e6215967af1bb2975a58d0d859 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1af6e6a337b70ca2ce238d8e40f49218 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=c5da01705f1373446f8582ac582ff244 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/crews.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=96464aab7bb5efe4213a7b80f58038aa 2500w" />
</Frame>

## 2단계: 프로젝트 구조 살펴보기

CLI가 생성한 프로젝트 구조를 이해하는 시간을 가져봅시다. CrewAI는 Python 프로젝트의 모범 사례를 따르므로, crew가 더 복잡해질수록 코드를 쉽게 유지 관리하고 확장할 수 있습니다.
```

Example 2 (unknown):
```unknown
이 구조는 Python 프로젝트의 모범 사례를 따르며, 코드를 체계적으로 구성할 수 있도록 해줍니다. 설정 파일(YAML)과 구현 코드(Python)의 분리로 인해, 기본 코드를 변경하지 않고도 crew의 동작을 쉽게 수정할 수 있습니다.

## 3단계: 에이전트 구성하기

이제 재미있는 단계가 시작됩니다 - 여러분의 AI 에이전트를 정의하는 것입니다! CrewAI에서 에이전트는 특정 역할, 목표 및 배경을 가진 전문화된 엔터티로, 이들이 어떻게 행동할지를 결정합니다. 각각 고유한 성격과 목적을 지닌 연극의 등장인물로 생각하면 됩니다.

우리의 리서치 crew를 위해 두 명의 에이전트를 만들겠습니다:

1. 정보를 찾아 정리하는 데 뛰어난 **리서처**
2. 연구 결과를 해석하고 통찰력 있는 보고서를 작성할 수 있는 **애널리스트**

이러한 전문화된 에이전트를 정의하기 위해 `agents.yaml` 파일을 수정해봅시다. `llm` 항목은 사용 중인 제공업체에 맞게 설정하세요.
```

---

## Task to organize content structure

**URL:** llms-txt#task-to-organize-content-structure

**Contents:**
  - Fluxos de Trabalho de Documentação Automatizados

organization_task = Task(
    description="""
    1. Get content from existing project pages
    2. Analyze the structure and identify improvement opportunities
    3. Update content blocks to use proper headings, tables, and formatting
    4. Add table of contents and improve navigation between related pages
    5. Create templates for future documentation consistency
    """,
    agent=content_organizer,
    expected_output="Content reorganized with improved structure and navigation"
)

crew = Crew(
    agents=[content_organizer],
    tasks=[organization_task]
)

crew.kickoff()
python  theme={null}
from crewai import Agent, Task, Crew

doc_automator = Agent(
    role="Documentation Automator",
    goal="Automate documentation workflows and maintenance",
    backstory="An AI assistant that automates repetitive documentation tasks.",
    apps=['notion']
)

**Examples:**

Example 1 (unknown):
```unknown
### Fluxos de Trabalho de Documentação Automatizados
```

---

## ❌ 이러한 이름은 배포 실패를 초래합니다

**URL:** llms-txt#❌-이러한-이름은-배포-실패를-초래합니다

OPENAI_TOKEN=sk-...
DATABASE_PASSWORD=mypassword
API_SECRET=secret123

---

## O agente usará esses parâmetros ao chamar a ferramenta

**URL:** llms-txt#o-agente-usará-esses-parâmetros-ao-chamar-a-ferramenta

---

## Manager agent coordinates the team

**URL:** llms-txt#manager-agent-coordinates-the-team

manager = Agent(
    role="Gerente de Projetos",
    goal="Coordenar esforços da equipe e garantir o sucesso do projeto",
    backstory="Gerente de projetos experiente, habilidoso em delegação e controle de qualidade",
    allow_delegation=True,
    verbose=True
)

---

## YouTube 동영상 RAG 검색

**URL:** llms-txt#youtube-동영상-rag-검색

Source: https://docs.crewai.com/ko/tools/search-research/youtubevideosearchtool

YoutubeVideoSearchTool은 YouTube 동영상의 콘텐츠 내에서 RAG(Retrieval-Augmented Generation) 검색을 수행하도록 설계되었습니다.

---

## Inicialize a ferramenta com um caminho específico para o arquivo MDX, realizando buscas exclusivamente neste documento

**URL:** llms-txt#inicialize-a-ferramenta-com-um-caminho-específico-para-o-arquivo-mdx,-realizando-buscas-exclusivamente-neste-documento

**Contents:**
- Parâmetros
- Personalização do Modelo e Embeddings

tool = MDXSearchTool(mdx='path/to/your/document.mdx')
python Code theme={null}
from chromadb.config import Settings

tool = MDXSearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # ou "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Parâmetros

* mdx: **Opcional**. Especifica o caminho do arquivo MDX para pesquisa. Pode ser informado durante a inicialização.

## Personalização do Modelo e Embeddings

A ferramenta utiliza, por padrão, o OpenAI para embeddings e sumarização. Para personalizar, utilize um dicionário de configuração conforme exemplo abaixo:
```

---

## 사용 가능한 모든 파라미터로 agent 생성

**URL:** llms-txt#사용-가능한-모든-파라미터로-agent-생성

**Contents:**
  - 매개변수 세부 정보
- 에이전트 도구

agent = Agent(
    role="Senior Data Scientist",
    goal="Analyze and interpret complex datasets to provide actionable insights",
    backstory="With over 10 years of experience in data science and machine learning, "
              "you excel at finding patterns in complex datasets.",
    llm="gpt-4",  # 기본값: OPENAI_MODEL_NAME 또는 "gpt-4"
    function_calling_llm=None,  # 옵션: 도구 호출을 위한 별도의 LLM
    verbose=False,  # 기본값: False
    allow_delegation=False,  # 기본값: False
    max_iter=20,  # 기본값: 20번 반복
    max_rpm=None,  # 옵션: API 호출에 대한 속도 제한
    max_execution_time=None,  # 옵션: 최대 실행 시간(초 단위)
    max_retry_limit=2,  # 기본값: 오류 시 2번 재시도
    allow_code_execution=False,  # 기본값: False
    code_execution_mode="safe",  # 기본값: "safe" (옵션: "safe", "unsafe")
    respect_context_window=True,  # 기본값: True
    use_system_prompt=True,  # 기본값: True
    multimodal=False,  # 기본값: False
    inject_date=False,  # 기본값: False
    date_format="%Y-%m-%d",  # 기본값: ISO 형식
    reasoning=False,  # 기본값: False
    max_reasoning_attempts=None,  # 기본값: None
    tools=[SerperDevTool()],  # 옵션: 도구 리스트
    knowledge_sources=None,  # 옵션: 지식 소스 리스트
    embedder=None,  # 옵션: 커스텀 임베더 구성
    system_template=None,  # 옵션: 커스텀 시스템 프롬프트 템플릿
    prompt_template=None,  # 옵션: 커스텀 프롬프트 템플릿
    response_template=None,  # 옵션: 커스텀 응답 템플릿
    step_callback=None,  # 옵션: 모니터링용 콜백 함수
)
python Code theme={null}
research_agent = Agent(
    role="Research Analyst",
    goal="Find and summarize information about specific topics",
    backstory="You are an experienced researcher with attention to detail",
    tools=[SerperDevTool()],
    verbose=True  # Enable logging for debugging
)
python Code theme={null}
dev_agent = Agent(
    role="Senior Python Developer",
    goal="Write and debug Python code",
    backstory="Expert Python developer with 10 years of experience",
    allow_code_execution=True,
    code_execution_mode="safe",  # Uses Docker for safety
    max_execution_time=300,  # 5-minute timeout
    max_retry_limit=3  # More retries for complex code tasks
)
python Code theme={null}
analysis_agent = Agent(
    role="Data Analyst",
    goal="Perform deep analysis of large datasets",
    backstory="Specialized in big data analysis and pattern recognition",
    memory=True,
    respect_context_window=True,
    max_rpm=10,  # Limit API calls
    function_calling_llm="gpt-4o-mini"  # Cheaper model for tool calls
)
python Code theme={null}
custom_agent = Agent(
    role="Customer Service Representative",
    goal="Assist customers with their inquiries",
    backstory="Experienced in customer support with a focus on satisfaction",
    system_template="""<|start_header_id|>system<|end_header_id|>
                        {{ .System }}<|eot_id|>""",
    prompt_template="""<|start_header_id|>user<|end_header_id|>
                        {{ .Prompt }}<|eot_id|>""",
    response_template="""<|start_header_id|>assistant<|end_header_id|>
                        {{ .Response }}<|eot_id|>""",
)
python Code theme={null}
strategic_agent = Agent(
    role="Market Analyst",
    goal="Track market movements with precise date references and strategic planning",
    backstory="Expert in time-sensitive financial analysis and strategic reporting",
    inject_date=True,  # Automatically inject current date into tasks
    date_format="%B %d, %Y",  # Format as "May 21, 2025"
    reasoning=True,  # Enable strategic planning
    max_reasoning_attempts=2,  # Limit planning iterations
    verbose=True
)
python Code theme={null}
reasoning_agent = Agent(
    role="Strategic Planner",
    goal="Analyze complex problems and create detailed execution plans",
    backstory="Expert strategic planner who methodically breaks down complex challenges",
    reasoning=True,  # Enable reasoning and planning
    max_reasoning_attempts=3,  # Limit reasoning attempts
    max_iter=30,  # Allow more iterations for complex planning
    verbose=True
)
python Code theme={null}
multimodal_agent = Agent(
    role="Visual Content Analyst",
    goal="Analyze and process both text and visual content",
    backstory="Specialized in multimodal analysis combining text and image understanding",
    multimodal=True,  # Enable multimodal capabilities
    verbose=True
)
python Code theme={null}
from crewai import Agent
from crewai_tools import SerperDevTool, WikipediaTools

**Examples:**

Example 1 (unknown):
```unknown
일반적인 사용 사례를 위한 주요 파라미터 조합을 살펴보겠습니다:

#### 기본 연구 에이전트
```

Example 2 (unknown):
```unknown
#### 코드 개발 에이전트
```

Example 3 (unknown):
```unknown
#### 장기 실행 분석 에이전트
```

Example 4 (unknown):
```unknown
#### 커스텀 템플릿 에이전트
```

---

## Better: Focused state

**URL:** llms-txt#better:-focused-state

**Contents:**
  - 2. 복잡한 플로우를 위한 구조화된 상태 사용

class FocusedState(BaseModel):
    user_id: str
    preferences: Dict[str, str]
    completion_status: Dict[str, bool]
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 2. 복잡한 플로우를 위한 구조화된 상태 사용

플로우의 복잡도가 증가할수록 구조화된 상태의 가치는 점점 커집니다:
```

---

## LLM에 전달될 전체 시스템 프롬프트 출력

**URL:** llms-txt#llm에-전달될-전체-시스템-프롬프트-출력

if "system" in generated_prompt:
    print("=== SYSTEM PROMPT ===")
    print(generated_prompt["system"])
    print("\n=== USER PROMPT ===")
    print(generated_prompt["user"])
else:
    print("=== COMPLETE PROMPT ===")
    print(generated_prompt["prompt"])

---

## 고정된 디렉토리에서 검색할 때

**URL:** llms-txt#고정된-디렉토리에서-검색할-때

**Contents:**
- 인수
- 커스텀 모델과 임베딩

tool = DirectorySearchTool(directory='/path/to/directory')
python Code theme={null}
from chromadb.config import Settings

tool = DirectorySearchTool(
    config={
        "embedding_model": {
            "provider": "openai",
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",
            },
        },
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인수

* `directory`: 검색 디렉토리를 지정하는 문자열 인수입니다. 이 인수는 초기화 시 선택 사항이지만, 처음에 설정되지 않은 경우 검색 시 필수입니다.

## 커스텀 모델과 임베딩

DirectorySearchTool은 기본적으로 OpenAI를 사용하여 임베딩 및 요약을 수행합니다. 이 설정의 커스터마이즈 옵션에는 모델 공급자 및 구성을 변경하는 것이 포함되어 있어, 고급 사용자를 위한 유연성을 향상시킵니다.
```

---

## 비전 도구

**URL:** llms-txt#비전-도구

Source: https://docs.crewai.com/ko/tools/ai-ml/visiontool

VisionTool은 이미지에서 텍스트를 추출하도록 설계되었습니다.

---

## Repositórios de Agentes

**URL:** llms-txt#repositórios-de-agentes

**Contents:**
- Benefícios dos Repositórios de Agentes
- Usando Repositórios de Agentes
  - Pré-requisitos
  - Criando e gerenciando agentes em repositórios
  - Carregando agentes de repositórios

Source: https://docs.crewai.com/pt-BR/enterprise/features/agent-repositories

Aprenda a usar Repositórios de Agentes para compartilhar e reutilizar seus agentes entre equipes e projetos

Repositórios de Agentes permitem que usuários do enterprise armazenem, compartilhem e reutilizem definições de agentes entre equipes e projetos. Esse recurso possibilita manter uma biblioteca centralizada de agentes padronizados, promovendo consistência e reduzindo a duplicidade de esforços.

## Benefícios dos Repositórios de Agentes

* **Padronização**: Mantenha definições de agentes consistentes em toda a sua organização
* **Reutilização**: Crie um agente uma vez e use-o em vários crews e projetos
* **Governança**: Implemente políticas organizacionais para configurações de agentes
* **Colaboração**: Permita que equipes compartilhem e evoluam o trabalho umas das outras

## Usando Repositórios de Agentes

1. Você deve ter uma conta na CrewAI, experimente o [plano gratuito](https://app.crewai.com).
2. Você precisa estar autenticado usando o CLI da CrewAI.
3. Se você tiver mais de uma organização, garanta que alternou para a organização correta usando o comando do CLI:

### Criando e gerenciando agentes em repositórios

Para criar e gerenciar agentes em repositórios, utilize o Painel do Enterprise.

### Carregando agentes de repositórios

Você pode carregar agentes de repositórios no seu código usando o parâmetro `from_repository`:

```python  theme={null}
from crewai import Agent

**Examples:**

Example 1 (unknown):
```unknown
### Criando e gerenciando agentes em repositórios

Para criar e gerenciar agentes em repositórios, utilize o Painel do Enterprise.

### Carregando agentes de repositórios

Você pode carregar agentes de repositórios no seu código usando o parâmetro `from_repository`:
```

---

## Initialize Qdrant client and load data

**URL:** llms-txt#initialize-qdrant-client-and-load-data

qdrant = QdrantClient(
    url=os.getenv("QDRANT_URL"),
    api_key=os.getenv("QDRANT_API_KEY")
)
collection_name = "example_collection"
pdf_path = "path/to/your/document.pdf"
load_pdf_to_qdrant(pdf_path, qdrant, collection_name)

---

## Example of limiting the search to the content of a specific website,

**URL:** llms-txt#example-of-limiting-the-search-to-the-content-of-a-specific-website,

---

## Create Snowflake configuration

**URL:** llms-txt#create-snowflake-configuration

config = SnowflakeConfig(
    account="your_account",
    user="your_username",
    password="your_password",
    warehouse="COMPUTE_WH",
    database="your_database",
    snowflake_schema="your_schema"
)

---

## Google 캘린더 연동

**URL:** llms-txt#google-캘린더-연동

**Contents:**
- 개요
- 필수 조건
- Google Calendar 연동 설정
  - 1. Google 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예시
  - 기본 캘린더 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/google_calendar

CrewAI를 위한 Google 캘린더 연동을 통한 이벤트 및 일정 관리.

에이전트가 Google Calendar를 통해 캘린더 이벤트, 일정, 가용 시간을 관리할 수 있도록 지원합니다. 이벤트를 생성 및 업데이트하고 참석자를 관리하며, 가용성을 확인하고 AI 기반 자동화로 일정 관리 워크플로우를 효율적으로 운영하세요.

Google Calendar 통합을 사용하기 전에 다음을 준비해야 합니다:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Google Calendar에 접근 가능한 Google 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Google 계정을 연결 완료

## Google Calendar 연동 설정

### 1. Google 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합 섹션에서 **Google Calendar**를 찾습니다.
3. **Connect**를 클릭하고 OAuth 과정을 완료합니다.
4. 캘린더 및 연락처 접근 권한을 허용합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="google_calendar/create_event">
    **설명:** Google 캘린더에 이벤트를 생성합니다.

* `eventName` (string, 필수): 이벤트 이름.
    * `startTime` (string, 필수): 시작 시간 - Unix 타임스탬프 또는 ISO8601 날짜 형식 허용.
    * `endTime` (string, 선택): 종료 시간 - 비워두면 시작 시간 기준 1시간 후로 기본 설정됩니다.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
    * `attendees` (string, 선택): 참석자 - 이메일 주소 배열 또는 쉼표로 구분된 이메일 주소 허용.
    * `eventLocation` (string, 선택): 이벤트 위치.
    * `eventDescription` (string, 선택): 이벤트 설명.
    * `eventId` (string, 선택): 이벤트 ID - 이 이벤트와 연결할 애플리케이션의 ID입니다. 이후 이 ID를 사용하여 이벤트를 동기화할 수 있습니다.
    * `includeMeetLink` (boolean, 선택): Google Meet 링크 포함 여부? - 이 이벤트에 대해 Google Meet 컨퍼런스 링크를 자동으로 생성합니다.
  </Accordion>

<Accordion title="google_calendar/update_event">
    **설명:** Google 캘린더에서 기존 이벤트를 업데이트합니다.

* `eventId` (string, 필수): 이벤트 ID - 업데이트할 이벤트의 ID입니다.
    * `eventName` (string, 선택): 이벤트 이름.
    * `startTime` (string, 선택): 시작 시간 - Unix 타임스탬프 또는 ISO8601 날짜 형식 허용.
    * `endTime` (string, 선택): 종료 시간 - 비워두면 시작 시간 기준 1시간 후로 기본 설정됩니다.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
    * `attendees` (string, 선택): 참석자 - 이메일 주소 배열 또는 쉼표로 구분된 이메일 주소 허용.
    * `eventLocation` (string, 선택): 이벤트 위치.
    * `eventDescription` (string, 선택): 이벤트 설명.
  </Accordion>

<Accordion title="google_calendar/view_events">
    **설명:** Google 캘린더에서 이벤트 목록을 가져옵니다.

* `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
    * `after` (string, 선택): 이후 - 제공된 날짜 이후에 시작하는 이벤트를 필터링합니다 (밀리초 단위의 Unix 또는 ISO 타임스탬프). (예시: "2025-04-12T10:00:00Z 또는 1712908800000").
    * `before` (string, 선택): 이전 - 제공된 날짜 이전에 종료되는 이벤트를 필터링합니다 (밀리초 단위의 Unix 또는 ISO 타임스탬프). (예시: "2025-04-12T10:00:00Z 또는 1712908800000").
  </Accordion>

<Accordion title="google_calendar/get_event_by_id">
    **설명:** Google 캘린더에서 ID로 특정 이벤트를 가져옵니다.

* `eventId` (string, 필수): 이벤트 ID.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
  </Accordion>

<Accordion title="google_calendar/delete_event">
    **설명:** Google 캘린더에서 이벤트를 삭제합니다.

* `eventId` (string, 필수): 이벤트 ID - 삭제할 캘린더 이벤트의 ID입니다.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
  </Accordion>

<Accordion title="google_calendar/get_contacts">
    **설명:** Google 캘린더에서 연락처를 가져옵니다.

* `paginationParameters` (object, 선택): 페이지네이션 파라미터.
      
  </Accordion>

<Accordion title="google_calendar/search_contacts">
    **설명:** Google 캘린더에서 연락처를 검색합니다.

* `query` (string, 선택): 연락처를 검색할 검색 쿼리.
  </Accordion>

<Accordion title="google_calendar/list_directory_people">
    **설명:** 디렉토리 구성원 목록을 가져옵니다.

* `paginationParameters` (object, 선택): 페이지네이션 파라미터.
      
  </Accordion>

<Accordion title="google_calendar/search_directory_people">
    **설명:** 디렉토리 구성원을 검색합니다.

* `query` (string, 필수): 연락처를 검색할 검색 쿼리.
    * `paginationParameters` (object, 선택): 페이지네이션 파라미터.
      
  </Accordion>

<Accordion title="google_calendar/list_other_contacts">
    **설명:** 기타 연락처 목록을 가져옵니다.

* `paginationParameters` (object, 선택): 페이지네이션 파라미터.
      
  </Accordion>

<Accordion title="google_calendar/search_other_contacts">
    **설명:** 기타 연락처를 검색합니다.

* `query` (string, 선택): 연락처를 검색할 검색 쿼리.
  </Accordion>

<Accordion title="google_calendar/get_availability">
    **설명:** 캘린더의 가용성 정보를 가져옵니다.

* `timeMin` (string, 필수): 기간의 시작. ISO 형식.
    * `timeMax` (string, 필수): 기간의 끝. ISO 형식.
    * `timeZone` (string, 선택): 응답에 사용되는 시간대. 선택 사항입니다. 기본값은 UTC입니다.
    * `items` (array, 선택): 조회할 캘린더 및/또는 그룹 목록. 비워두면 사용자 기본 캘린더가 기본값입니다.
      
  </Accordion>
</AccordionGroup>

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="google_calendar/create_event">
    **설명:** Google 캘린더에 이벤트를 생성합니다.

    **파라미터:**

    * `eventName` (string, 필수): 이벤트 이름.
    * `startTime` (string, 필수): 시작 시간 - Unix 타임스탬프 또는 ISO8601 날짜 형식 허용.
    * `endTime` (string, 선택): 종료 시간 - 비워두면 시작 시간 기준 1시간 후로 기본 설정됩니다.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
    * `attendees` (string, 선택): 참석자 - 이메일 주소 배열 또는 쉼표로 구분된 이메일 주소 허용.
    * `eventLocation` (string, 선택): 이벤트 위치.
    * `eventDescription` (string, 선택): 이벤트 설명.
    * `eventId` (string, 선택): 이벤트 ID - 이 이벤트와 연결할 애플리케이션의 ID입니다. 이후 이 ID를 사용하여 이벤트를 동기화할 수 있습니다.
    * `includeMeetLink` (boolean, 선택): Google Meet 링크 포함 여부? - 이 이벤트에 대해 Google Meet 컨퍼런스 링크를 자동으로 생성합니다.
  </Accordion>

  <Accordion title="google_calendar/update_event">
    **설명:** Google 캘린더에서 기존 이벤트를 업데이트합니다.

    **파라미터:**

    * `eventId` (string, 필수): 이벤트 ID - 업데이트할 이벤트의 ID입니다.
    * `eventName` (string, 선택): 이벤트 이름.
    * `startTime` (string, 선택): 시작 시간 - Unix 타임스탬프 또는 ISO8601 날짜 형식 허용.
    * `endTime` (string, 선택): 종료 시간 - 비워두면 시작 시간 기준 1시간 후로 기본 설정됩니다.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
    * `attendees` (string, 선택): 참석자 - 이메일 주소 배열 또는 쉼표로 구분된 이메일 주소 허용.
    * `eventLocation` (string, 선택): 이벤트 위치.
    * `eventDescription` (string, 선택): 이벤트 설명.
  </Accordion>

  <Accordion title="google_calendar/view_events">
    **설명:** Google 캘린더에서 이벤트 목록을 가져옵니다.

    **파라미터:**

    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
    * `after` (string, 선택): 이후 - 제공된 날짜 이후에 시작하는 이벤트를 필터링합니다 (밀리초 단위의 Unix 또는 ISO 타임스탬프). (예시: "2025-04-12T10:00:00Z 또는 1712908800000").
    * `before` (string, 선택): 이전 - 제공된 날짜 이전에 종료되는 이벤트를 필터링합니다 (밀리초 단위의 Unix 또는 ISO 타임스탬프). (예시: "2025-04-12T10:00:00Z 또는 1712908800000").
  </Accordion>

  <Accordion title="google_calendar/get_event_by_id">
    **설명:** Google 캘린더에서 ID로 특정 이벤트를 가져옵니다.

    **파라미터:**

    * `eventId` (string, 필수): 이벤트 ID.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
  </Accordion>

  <Accordion title="google_calendar/delete_event">
    **설명:** Google 캘린더에서 이벤트를 삭제합니다.

    **파라미터:**

    * `eventId` (string, 필수): 이벤트 ID - 삭제할 캘린더 이벤트의 ID입니다.
    * `calendar` (string, 선택): 캘린더 - Connect Portal Workflow Settings를 사용하여 사용자가 이벤트를 추가할 캘린더를 선택할 수 있도록 합니다. 비워두면 사용자의 기본 캘린더로 기본 설정됩니다.
  </Accordion>

  <Accordion title="google_calendar/get_contacts">
    **설명:** Google 캘린더에서 연락처를 가져옵니다.

    **파라미터:**

    * `paginationParameters` (object, 선택): 페이지네이션 파라미터.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="google_calendar/search_contacts">
    **설명:** Google 캘린더에서 연락처를 검색합니다.

    **파라미터:**

    * `query` (string, 선택): 연락처를 검색할 검색 쿼리.
  </Accordion>

  <Accordion title="google_calendar/list_directory_people">
    **설명:** 디렉토리 구성원 목록을 가져옵니다.

    **파라미터:**

    * `paginationParameters` (object, 선택): 페이지네이션 파라미터.
```

---

## Example of using the tool with an agent

**URL:** llms-txt#example-of-using-the-tool-with-an-agent

web_scraper_agent = Agent(
    role="Web Scraper",
    goal="Extract information from websites",
    backstory="An expert in web scraping who can extract content from any website.",
    tools=[scrape_tool],
    verbose=True,
)

---

## Initialize the tool with predefined criteria

**URL:** llms-txt#initialize-the-tool-with-predefined-criteria

patronus_eval_tool = PatronusPredefinedCriteriaEvalTool(
    evaluators=[{"evaluator": "judge", "criteria": "contains-code"}]
)

---

## Server may be slow or overloaded

**URL:** llms-txt#server-may-be-slow-or-overloaded

---

## Notion 연동

**URL:** llms-txt#notion-연동

**Contents:**
- 개요
- 필수 조건
- Notion 연동 설정
  - 1. Notion 계정 연결하기
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 액션
- 사용 예시
  - 기본 Notion Agent 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/notion

CrewAI를 위한 Notion 연동을 통한 페이지 및 데이터베이스 관리.

에이전트가 Notion을 통해 페이지, 데이터베이스, 콘텐츠를 관리할 수 있도록 지원합니다. 페이지 생성 및 업데이트, 콘텐츠 블록 관리, 지식 베이스 구성, AI 기반 자동화를 통해 문서화 작업 흐름을 효율화할 수 있습니다.

Notion 통합을 사용하기 전에 다음을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 워크스페이스 권한이 있는 Notion 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Notion 계정을 연결함

### 1. Notion 계정 연결하기

1. [CrewAI AMP Integrations](https://app.crewai.com/crewai_plus/connectors)로 이동합니다.
2. 인증 통합(Auhtentication Integrations) 섹션에서 **Notion**을(를) 찾습니다.
3. **Connect**를 클릭하고 OAuth 플로우를 완료합니다.
4. 페이지 및 데이터베이스 관리를 위한 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="notion/create_page">
    **설명:** Notion에서 페이지를 생성합니다.

* `parent` (object, 필수): 상위 - 새 페이지가 삽입될 상위 페이지 또는 데이터베이스를 나타내는 JSON 객체로, page\_id 또는 database\_id 키를 포함합니다.
      
    * `properties` (object, 필수): 속성 - 페이지 속성의 값입니다. 상위가 데이터베이스인 경우, 스키마는 상위 데이터베이스의 속성과 일치해야 합니다.
      
    * `icon` (object, 필수): 아이콘 - 페이지 아이콘입니다.
      
    * `children` (object, 선택): 자식 - 페이지에 추가할 콘텐츠 블록입니다.
      
    * `cover` (object, 선택): 표지 - 페이지 표지 이미지입니다.
      
  </Accordion>

<Accordion title="notion/update_page">
    **설명:** Notion에서 페이지를 업데이트합니다.

* `pageId` (string, 필수): 페이지 ID - 업데이트할 페이지의 ID를 지정합니다. (예: "59833787-2cf9-4fdf-8782-e53db20768a5").
    * `icon` (object, 필수): 아이콘 - 페이지 아이콘입니다.
      
    * `archived` (boolean, 선택): 보관됨 - 페이지가 보관(삭제)되었는지 여부입니다. true로 설정하면 페이지를 보관합니다. false로 설정하면 보관 해제(복원)합니다.
    * `properties` (object, 선택): 속성 - 페이지에서 업데이트할 속성 값입니다.
      
    * `cover` (object, 선택): 표지 - 페이지 표지 이미지입니다.
      
  </Accordion>

<Accordion title="notion/get_page_by_id">
    **설명:** Notion에서 ID로 페이지를 가져옵니다.

* `pageId` (string, 필수): 페이지 ID - 가져올 페이지의 ID를 지정합니다. (예: "59833787-2cf9-4fdf-8782-e53db20768a5").
  </Accordion>

<Accordion title="notion/archive_page">
    **설명:** Notion에서 페이지를 보관합니다.

* `pageId` (string, 필수): 페이지 ID - 보관할 페이지의 ID를 지정합니다. (예: "59833787-2cf9-4fdf-8782-e53db20768a5").
  </Accordion>

<Accordion title="notion/search_pages">
    **설명:** 필터를 사용하여 Notion에서 페이지를 검색합니다.

* `searchByTitleFilterSearch` (object, 선택): 불리언 정규형(OR 조건 그룹의 AND 그룹) 형태의 필터입니다.
      
      사용 가능한 필드: `query`, `filter.value`, `direction`, `page_size`
  </Accordion>

<Accordion title="notion/get_page_content">
    **설명:** Notion에서 페이지 콘텐츠(블록)를 가져옵니다.

* `blockId` (string, 필수): 페이지 ID - 해당 블록이나 페이지의 모든 자식 블록을 순서대로 가져오기 위해 Block 또는 Page ID를 지정합니다. (예: "59833787-2cf9-4fdf-8782-e53db20768a5").
  </Accordion>

<Accordion title="notion/update_block">
    **설명:** Notion에서 블록을 업데이트합니다.

* `blockId` (string, 필수): 블록 ID - 업데이트할 블록의 ID를 지정합니다. (예: "9bc30ad4-9373-46a5-84ab-0a7845ee52e6").
    * `archived` (boolean, 선택): 보관됨 - true로 설정하면 블록을 보관(삭제)합니다. false로 설정하면 보관 해제(복원)합니다.
    * `paragraph` (object, 선택): 단락 콘텐츠.
      
    * `image` (object, 선택): 이미지 블록.
      
    * `bookmark` (object, 선택): 북마크 블록.
      
    * `code` (object, 선택): 코드 블록.
      
    * `pdf` (object, 선택): PDF 블록.
      
    * `table` (object, 선택): 테이블 블록.
      
    * `tableOfContent` (object, 선택): 목차 블록.
      
    * `additionalFields` (object, 선택): 추가 블록 유형.
      
  </Accordion>

<Accordion title="notion/get_block_by_id">
    **설명:** Notion에서 ID로 블록을 가져옵니다.

* `blockId` (string, 필수): 블록 ID - 가져올 블록의 ID를 지정합니다. (예: "9bc30ad4-9373-46a5-84ab-0a7845ee52e6").
  </Accordion>

<Accordion title="notion/delete_block">
    **설명:** Notion에서 블록을 삭제합니다.

* `blockId` (string, 필수): 블록 ID - 삭제할 블록의 ID를 지정합니다. (예: "9bc30ad4-9373-46a5-84ab-0a7845ee52e6").
  </Accordion>
</AccordionGroup>

### 기본 Notion Agent 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 액션

<AccordionGroup>
  <Accordion title="notion/create_page">
    **설명:** Notion에서 페이지를 생성합니다.

    **파라미터:**

    * `parent` (object, 필수): 상위 - 새 페이지가 삽입될 상위 페이지 또는 데이터베이스를 나타내는 JSON 객체로, page\_id 또는 database\_id 키를 포함합니다.
```

Example 4 (unknown):
```unknown
* `properties` (object, 필수): 속성 - 페이지 속성의 값입니다. 상위가 데이터베이스인 경우, 스키마는 상위 데이터베이스의 속성과 일치해야 합니다.
```

---

## Create a knowledge source from web content

**URL:** llms-txt#create-a-knowledge-source-from-web-content

content_source = CrewDoclingSource(
    file_paths=[
        "https://lilianweng.github.io/posts/2024-11-28-reward-hacking",
        "https://lilianweng.github.io/posts/2024-07-07-hallucination",
    ],
)

---

## AI Mind Tool

**URL:** llms-txt#ai-mind-tool

Source: https://docs.crewai.com/pt-BR/tools/ai-ml/aimindtool

O `AIMindTool` foi desenvolvido para consultar fontes de dados em linguagem natural.

---

## Databricks SQL Query Tool

**URL:** llms-txt#databricks-sql-query-tool

Source: https://docs.crewai.com/pt-BR/tools/search-research/databricks-query-tool

The `DatabricksQueryTool` executes SQL queries against Databricks workspace tables.

---

## Spider 스크레이퍼

**URL:** llms-txt#spider-스크레이퍼

Source: https://docs.crewai.com/ko/tools/web-scraping/spidertool

SpiderTool은 Spider를 사용하여 지정된 웹사이트의 콘텐츠를 추출하고 읽도록 설계되었습니다.

---

## Initialize the tool for semantic searches within a specific GitHub repository, so the agent can search any repository if it learns about during its execution

**URL:** llms-txt#initialize-the-tool-for-semantic-searches-within-a-specific-github-repository,-so-the-agent-can-search-any-repository-if-it-learns-about-during-its-execution

**Contents:**
- Arguments
- Custom model and embeddings

tool = GithubSearchTool(
	gh_token='your_github_personal_access_token',
	content_types=['code', 'issue'] # Options: code, repo, pr, issue
)
python Code theme={null}
tool = GithubSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # or google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # or openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Arguments

* `github_repo` : The URL of the GitHub repository where the search will be conducted. This is a mandatory field and specifies the target repository for your search.
* `gh_token` : Your GitHub Personal Access Token (PAT) required for authentication. You can create one in your GitHub account settings under Developer Settings > Personal Access Tokens.
* `content_types` : Specifies the types of content to include in your search. You must provide a list of content types from the following options: `code` for searching within the code,
  `repo` for searching within the repository's general information, `pr` for searching within pull requests, and `issue` for searching within issues.
  This field is mandatory and allows tailoring the search to specific content types within the GitHub repository.

## Custom model and embeddings

By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows:
```

---

## Crie um agente com capacidades do Microsoft Word

**URL:** llms-txt#crie-um-agente-com-capacidades-do-microsoft-word

word_agent = Agent(
    role="Gerenciador de Documentos",
    goal="Gerenciar documentos do Word e arquivos de texto de forma eficiente",
    backstory="Um assistente IA especializado em operações de documentos do Microsoft Word e gerenciamento de conteúdo.",
    apps=['microsoft_word']  # Todas as ações do Word estarão disponíveis
)

---

## 킥오프 전후 후크(Before and After Kickoff Hooks)

**URL:** llms-txt#킥오프-전후-후크(before-and-after-kickoff-hooks)

**Contents:**
- 킥오프 이전 훅
- 킥오프 후 훅

Source: https://docs.crewai.com/ko/learn/before-and-after-kickoff-hooks

CrewAI에서 킥오프 전후 후크를 사용하는 방법을 알아보세요

CrewAI는 crew의 kickoff 전후에 코드를 실행할 수 있는 hook을 제공합니다. 이러한 hook은 입력값을 사전 처리하거나 결과를 사후 처리하는 데 유용합니다.

킥오프 이전 훅은 크루가 작업을 시작하기 전에 실행됩니다. 이 훅은 입력 딕셔너리를 받아 이를 수정한 후 크루에 전달할 수 있습니다. 이 훅을 사용하여 환경을 설정하거나, 필요한 데이터를 불러오거나, 입력값을 전처리할 수 있습니다. 입력 데이터가 크루에 의해 처리되기 전에 보완 또는 검증이 필요한 경우에 유용합니다.

다음은 `crew.py`에서 킥오프 이전 함수를 정의하는 예시입니다:

이 예시에서, prepare\_data 함수는 입력값에 입력이 이미 처리되었음을 나타내는 새로운 키-값 쌍을 추가하여 입력값을 수정합니다.

킥오프 후 훅은 crew의 작업이 완료된 후에 실행됩니다. 이 훅은 crew 실행의 출력값을 담은 result 객체를 전달받습니다. 이 훅은 로깅, 데이터 변환 또는 추가 분석과 같이 결과를 후처리하는 데 이상적입니다.

`crew.py`에서 킥오프 후 함수를 정의하는 방법은 다음과 같습니다.

```python  theme={null}
from crewai import CrewBase
from crewai.project import after_kickoff

@CrewBase
class MyCrew:
    @after_kickoff
    def log_results(self, result):
        # Log or modify the results
        print("Crew execution completed with result:", result)
        return result

**Examples:**

Example 1 (unknown):
```unknown
이 예시에서, prepare\_data 함수는 입력값에 입력이 이미 처리되었음을 나타내는 새로운 키-값 쌍을 추가하여 입력값을 수정합니다.

## 킥오프 후 훅

킥오프 후 훅은 crew의 작업이 완료된 후에 실행됩니다. 이 훅은 crew 실행의 출력값을 담은 result 객체를 전달받습니다. 이 훅은 로깅, 데이터 변환 또는 추가 분석과 같이 결과를 후처리하는 데 이상적입니다.

`crew.py`에서 킥오프 후 함수를 정의하는 방법은 다음과 같습니다.
```

---

## Busca geral em conteúdo JSON

**URL:** llms-txt#busca-geral-em-conteúdo-json

---

## Example: Customer Support Flow with structured processing

**URL:** llms-txt#example:-customer-support-flow-with-structured-processing

from crewai.flow.flow import Flow, listen, router, start
from pydantic import BaseModel
from typing import List, Dict

---

## Crie LLM com guardrails

**URL:** llms-txt#crie-llm-com-guardrails

portkey_llm = LLM(
    model="gpt-4o",
    base_url=PORTKEY_GATEWAY_URL,
    api_key="dummy",
    extra_headers=createHeaders(
        api_key="YOUR_PORTKEY_API_KEY",
        virtual_key="YOUR_OPENAI_VIRTUAL_KEY",
        config={
            "input_guardrails": ["guardrails-id-xxx", "guardrails-id-yyy"],
            "output_guardrails": ["guardrails-id-zzz"]
        }
    )
)

---

## Inicialize a ferramenta para pesquisar no conteúdo de qualquer arquivo de texto

**URL:** llms-txt#inicialize-a-ferramenta-para-pesquisar-no-conteúdo-de-qualquer-arquivo-de-texto

---

## Stripe 연동

**URL:** llms-txt#stripe-연동

**Contents:**
- 개요
- 사전 준비 사항
- Stripe 통합 설정
  - 1. Stripe 계정 연결
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 도구
  - **고객 관리**
  - **구독 관리**
  - **제품 관리**

Source: https://docs.crewai.com/ko/enterprise/integrations/stripe

CrewAI를 위한 Stripe 연동을 통한 결제 처리 및 구독 관리.

에이전트가 Stripe를 통해 결제, 구독 및 고객 청구 관리를 할 수 있도록 지원합니다. 고객 데이터 처리, 구독 관리, 상품 관리, 재무 거래 추적 등을 통해 AI 기반 자동화로 결제 워크플로를 효율화하세요.

Stripe 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 API 권한이 있는 Stripe 계정
* [통합 페이지](https://app.crewai.com/integrations)를 통해 Stripe 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동합니다.
2. 인증 통합 섹션에서 **Stripe**를 찾습니다.
3. **연결**을 클릭하고 OAuth 과정을 완료합니다.
4. 결제 처리에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="stripe/create_customer">
    **설명:** Stripe 계정에 새로운 고객을 생성합니다.

* `emailCreateCustomer` (string, 필수): 고객의 이메일 주소
    * `name` (string, 선택): 고객의 전체 이름
    * `description` (string, 선택): 내부 참조용 고객 설명
    * `metadataCreateCustomer` (object, 선택): 추가 메타데이터를 key-value 쌍으로 입력 (예: `{"field1": 1, "field2": 2}`)
  </Accordion>

<Accordion title="stripe/get_customer_by_id">
    **설명:** Stripe 고객 ID로 특정 고객을 조회합니다.

* `idGetCustomer` (string, 필수): 조회할 Stripe 고객 ID
  </Accordion>

<Accordion title="stripe/get_customers">
    **설명:** 필터링 옵션과 함께 고객 리스트를 조회합니다.

* `emailGetCustomers` (string, 선택): 이메일 주소로 고객 필터링
    * `createdAfter` (string, 선택): 이 날짜 이후 생성된 고객 필터링 (유닉스 타임스탬프)
    * `createdBefore` (string, 선택): 이 날짜 이전 생성된 고객 필터링 (유닉스 타임스탬프)
    * `limitGetCustomers` (string, 선택): 반환할 최대 고객 수 (기본값 10)
  </Accordion>

<Accordion title="stripe/update_customer">
    **설명:** 기존 고객의 정보를 업데이트합니다.

* `customerId` (string, 필수): 업데이트할 고객의 ID
    * `emailUpdateCustomer` (string, 선택): 업데이트할 이메일 주소
    * `name` (string, 선택): 업데이트할 고객 이름
    * `description` (string, 선택): 업데이트할 고객 설명
    * `metadataUpdateCustomer` (object, 선택): 업데이트할 메타데이터를 key-value 쌍으로 입력
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="stripe/create_subscription">
    **설명:** 고객을 위한 새로운 구독을 생성합니다.

* `customerIdCreateSubscription` (string, 필수): 구독이 생성될 고객 ID
    * `plan` (string, 필수): 구독을 위한 플랜 ID - 사용자가 플랜을 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요
    * `metadataCreateSubscription` (object, 선택): 구독에 대한 추가 메타데이터
  </Accordion>

<Accordion title="stripe/get_subscriptions">
    **설명:** 선택적 필터링으로 구독을 조회합니다.

* `customerIdGetSubscriptions` (string, 선택): 고객 ID로 구독을 필터링
    * `subscriptionStatus` (string, 선택): 구독 상태별 필터링 - 옵션: incomplete, incomplete\_expired, trialing, active, past\_due, canceled, unpaid
    * `limitGetSubscriptions` (string, 선택): 반환할 구독의 최대 개수(기본값은 10)
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="stripe/create_product">
    **설명:** Stripe 카탈로그에 새 제품을 생성합니다.

* `productName` (string, 필수): 제품 이름
    * `description` (string, 선택): 제품 설명
    * `metadataProduct` (object, 선택): 키-값 쌍으로 구성된 추가 제품 메타데이터
  </Accordion>

<Accordion title="stripe/get_product_by_id">
    **설명:** Stripe 제품 ID로 특정 제품을 조회합니다.

* `productId` (string, 필수): 조회할 Stripe 제품 ID
  </Accordion>

<Accordion title="stripe/get_products">
    **설명:** 선택적 필터링을 통해 제품 목록을 조회합니다.

* `createdAfter` (string, 선택): 이 날짜 이후 생성된 제품만 필터링 (Unix 타임스탬프)
    * `createdBefore` (string, 선택): 이 날짜 이전 생성된 제품만 필터링 (Unix 타임스탬프)
    * `limitGetProducts` (string, 선택): 반환할 최대 제품 수 (기본값 10)
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="stripe/get_balance_transactions">
    **설명:** Stripe 계정에서 잔액 거래를 조회합니다.

* `balanceTransactionType` (string, 선택 사항): 거래 유형별 필터 - 옵션: charge, refund, payment, payment\_refund
    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>

<Accordion title="stripe/get_plans">
    **설명:** Stripe 계정에서 구독 플랜을 조회합니다.

* `isPlanActive` (boolean, 선택 사항): 플랜 상태별 필터 - true는 활성 플랜, false는 비활성 플랜
    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>
</AccordionGroup>

### 기본 Stripe 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 도구

### **고객 관리**

<AccordionGroup>
  <Accordion title="stripe/create_customer">
    **설명:** Stripe 계정에 새로운 고객을 생성합니다.

    **파라미터:**

    * `emailCreateCustomer` (string, 필수): 고객의 이메일 주소
    * `name` (string, 선택): 고객의 전체 이름
    * `description` (string, 선택): 내부 참조용 고객 설명
    * `metadataCreateCustomer` (object, 선택): 추가 메타데이터를 key-value 쌍으로 입력 (예: `{"field1": 1, "field2": 2}`)
  </Accordion>

  <Accordion title="stripe/get_customer_by_id">
    **설명:** Stripe 고객 ID로 특정 고객을 조회합니다.

    **파라미터:**

    * `idGetCustomer` (string, 필수): 조회할 Stripe 고객 ID
  </Accordion>

  <Accordion title="stripe/get_customers">
    **설명:** 필터링 옵션과 함께 고객 리스트를 조회합니다.

    **파라미터:**

    * `emailGetCustomers` (string, 선택): 이메일 주소로 고객 필터링
    * `createdAfter` (string, 선택): 이 날짜 이후 생성된 고객 필터링 (유닉스 타임스탬프)
    * `createdBefore` (string, 선택): 이 날짜 이전 생성된 고객 필터링 (유닉스 타임스탬프)
    * `limitGetCustomers` (string, 선택): 반환할 최대 고객 수 (기본값 10)
  </Accordion>

  <Accordion title="stripe/update_customer">
    **설명:** 기존 고객의 정보를 업데이트합니다.

    **파라미터:**

    * `customerId` (string, 필수): 업데이트할 고객의 ID
    * `emailUpdateCustomer` (string, 선택): 업데이트할 이메일 주소
    * `name` (string, 선택): 업데이트할 고객 이름
    * `description` (string, 선택): 업데이트할 고객 설명
    * `metadataUpdateCustomer` (object, 선택): 업데이트할 메타데이터를 key-value 쌍으로 입력
  </Accordion>
</AccordionGroup>

### **구독 관리**

<AccordionGroup>
  <Accordion title="stripe/create_subscription">
    **설명:** 고객을 위한 새로운 구독을 생성합니다.

    **파라미터:**

    * `customerIdCreateSubscription` (string, 필수): 구독이 생성될 고객 ID
    * `plan` (string, 필수): 구독을 위한 플랜 ID - 사용자가 플랜을 선택할 수 있도록 Connect Portal Workflow Settings를 사용하세요
    * `metadataCreateSubscription` (object, 선택): 구독에 대한 추가 메타데이터
  </Accordion>

  <Accordion title="stripe/get_subscriptions">
    **설명:** 선택적 필터링으로 구독을 조회합니다.

    **파라미터:**

    * `customerIdGetSubscriptions` (string, 선택): 고객 ID로 구독을 필터링
    * `subscriptionStatus` (string, 선택): 구독 상태별 필터링 - 옵션: incomplete, incomplete\_expired, trialing, active, past\_due, canceled, unpaid
    * `limitGetSubscriptions` (string, 선택): 반환할 구독의 최대 개수(기본값은 10)
  </Accordion>
</AccordionGroup>

### **제품 관리**

<AccordionGroup>
  <Accordion title="stripe/create_product">
    **설명:** Stripe 카탈로그에 새 제품을 생성합니다.

    **파라미터:**

    * `productName` (string, 필수): 제품 이름
    * `description` (string, 선택): 제품 설명
    * `metadataProduct` (object, 선택): 키-값 쌍으로 구성된 추가 제품 메타데이터
  </Accordion>

  <Accordion title="stripe/get_product_by_id">
    **설명:** Stripe 제품 ID로 특정 제품을 조회합니다.

    **파라미터:**

    * `productId` (string, 필수): 조회할 Stripe 제품 ID
  </Accordion>

  <Accordion title="stripe/get_products">
    **설명:** 선택적 필터링을 통해 제품 목록을 조회합니다.

    **파라미터:**

    * `createdAfter` (string, 선택): 이 날짜 이후 생성된 제품만 필터링 (Unix 타임스탬프)
    * `createdBefore` (string, 선택): 이 날짜 이전 생성된 제품만 필터링 (Unix 타임스탬프)
    * `limitGetProducts` (string, 선택): 반환할 최대 제품 수 (기본값 10)
  </Accordion>
</AccordionGroup>

### **금융 운영**

<AccordionGroup>
  <Accordion title="stripe/get_balance_transactions">
    **설명:** Stripe 계정에서 잔액 거래를 조회합니다.

    **매개변수:**

    * `balanceTransactionType` (string, 선택 사항): 거래 유형별 필터 - 옵션: charge, refund, payment, payment\_refund
    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>

  <Accordion title="stripe/get_plans">
    **설명:** Stripe 계정에서 구독 플랜을 조회합니다.

    **매개변수:**

    * `isPlanActive` (boolean, 선택 사항): 플랜 상태별 필터 - true는 활성 플랜, false는 비활성 플랜
    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>
</AccordionGroup>

## 사용 예시

### 기본 Stripe 에이전트 설정
```

---

## Busca RAG em Canal do YouTube

**URL:** llms-txt#busca-rag-em-canal-do-youtube

Source: https://docs.crewai.com/pt-BR/tools/search-research/youtubechannelsearchtool

O `YoutubeChannelSearchTool` foi desenvolvido para realizar buscas RAG (Retrieval-Augmented Generation) no conteúdo de um canal do Youtube.

---

## Integração Microsoft OneDrive

**URL:** llms-txt#integração-microsoft-onedrive

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Microsoft OneDrive
  - 1. Conecte sua Conta Microsoft
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Microsoft OneDrive

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/microsoft_onedrive

Gerenciamento de arquivos e pastas com integração Microsoft OneDrive para CrewAI.

Permita que seus agentes façam upload, download e gerenciem arquivos e pastas no Microsoft OneDrive. Automatize operações de arquivos, organize conteúdo, crie links de compartilhamento e simplifique seus fluxos de trabalho de armazenamento em nuvem com automação alimentada por IA.

Antes de usar a integração Microsoft OneDrive, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Microsoft com acesso ao OneDrive
* Conectado sua conta Microsoft através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Microsoft OneDrive

### 1. Conecte sua Conta Microsoft

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Microsoft OneDrive** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a arquivos
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="microsoft_onedrive/list_files">
    **Descrição:** Listar arquivos e pastas no OneDrive.

* `top` (integer, opcional): Número de itens a recuperar (máx 1000). Padrão: 50.
    * `orderby` (string, opcional): Ordenar por campo (ex: "name asc", "lastModifiedDateTime desc"). Padrão: "name asc".
    * `filter` (string, opcional): Expressão de filtro OData.
  </Accordion>

<Accordion title="microsoft_onedrive/get_file_info">
    **Descrição:** Obter informações sobre um arquivo ou pasta específica.

* `item_id` (string, obrigatório): O ID do arquivo ou pasta.
  </Accordion>

<Accordion title="microsoft_onedrive/download_file">
    **Descrição:** Baixar um arquivo do OneDrive.

* `item_id` (string, obrigatório): O ID do arquivo a baixar.
  </Accordion>

<Accordion title="microsoft_onedrive/upload_file">
    **Descrição:** Fazer upload de um arquivo para o OneDrive.

* `file_name` (string, obrigatório): Nome do arquivo a fazer upload.
    * `content` (string, obrigatório): Conteúdo do arquivo codificado em Base64.
  </Accordion>

<Accordion title="microsoft_onedrive/create_folder">
    **Descrição:** Criar uma nova pasta no OneDrive.

* `folder_name` (string, obrigatório): Nome da pasta a criar.
  </Accordion>

<Accordion title="microsoft_onedrive/delete_item">
    **Descrição:** Excluir um arquivo ou pasta do OneDrive.

* `item_id` (string, obrigatório): O ID do arquivo ou pasta a excluir.
  </Accordion>

<Accordion title="microsoft_onedrive/copy_item">
    **Descrição:** Copiar um arquivo ou pasta no OneDrive.

* `item_id` (string, obrigatório): O ID do arquivo ou pasta a copiar.
    * `parent_id` (string, opcional): O ID da pasta de destino (opcional, padrão para raiz).
    * `new_name` (string, opcional): Novo nome para o item copiado (opcional).
  </Accordion>

<Accordion title="microsoft_onedrive/move_item">
    **Descrição:** Mover um arquivo ou pasta no OneDrive.

* `item_id` (string, obrigatório): O ID do arquivo ou pasta a mover.
    * `parent_id` (string, obrigatório): O ID da pasta de destino.
    * `new_name` (string, opcional): Novo nome para o item (opcional).
  </Accordion>

<Accordion title="microsoft_onedrive/search_files">
    **Descrição:** Pesquisar arquivos e pastas no OneDrive.

* `query` (string, obrigatório): String de consulta de pesquisa.
    * `top` (integer, opcional): Número de resultados a retornar (máx 1000). Padrão: 50.
  </Accordion>

<Accordion title="microsoft_onedrive/share_item">
    **Descrição:** Criar um link de compartilhamento para um arquivo ou pasta.

* `item_id` (string, obrigatório): O ID do arquivo ou pasta a compartilhar.
    * `type` (string, opcional): Tipo de link de compartilhamento. Opções: view, edit, embed. Padrão: view.
    * `scope` (string, opcional): Escopo do link de compartilhamento. Opções: anonymous, organization. Padrão: anonymous.
  </Accordion>

<Accordion title="microsoft_onedrive/get_thumbnails">
    **Descrição:** Obter miniaturas para um arquivo.

* `item_id` (string, obrigatório): O ID do arquivo.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Microsoft OneDrive

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="microsoft_onedrive/list_files">
    **Descrição:** Listar arquivos e pastas no OneDrive.

    **Parâmetros:**

    * `top` (integer, opcional): Número de itens a recuperar (máx 1000). Padrão: 50.
    * `orderby` (string, opcional): Ordenar por campo (ex: "name asc", "lastModifiedDateTime desc"). Padrão: "name asc".
    * `filter` (string, opcional): Expressão de filtro OData.
  </Accordion>

  <Accordion title="microsoft_onedrive/get_file_info">
    **Descrição:** Obter informações sobre um arquivo ou pasta específica.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo ou pasta.
  </Accordion>

  <Accordion title="microsoft_onedrive/download_file">
    **Descrição:** Baixar um arquivo do OneDrive.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo a baixar.
  </Accordion>

  <Accordion title="microsoft_onedrive/upload_file">
    **Descrição:** Fazer upload de um arquivo para o OneDrive.

    **Parâmetros:**

    * `file_name` (string, obrigatório): Nome do arquivo a fazer upload.
    * `content` (string, obrigatório): Conteúdo do arquivo codificado em Base64.
  </Accordion>

  <Accordion title="microsoft_onedrive/create_folder">
    **Descrição:** Criar uma nova pasta no OneDrive.

    **Parâmetros:**

    * `folder_name` (string, obrigatório): Nome da pasta a criar.
  </Accordion>

  <Accordion title="microsoft_onedrive/delete_item">
    **Descrição:** Excluir um arquivo ou pasta do OneDrive.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo ou pasta a excluir.
  </Accordion>

  <Accordion title="microsoft_onedrive/copy_item">
    **Descrição:** Copiar um arquivo ou pasta no OneDrive.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo ou pasta a copiar.
    * `parent_id` (string, opcional): O ID da pasta de destino (opcional, padrão para raiz).
    * `new_name` (string, opcional): Novo nome para o item copiado (opcional).
  </Accordion>

  <Accordion title="microsoft_onedrive/move_item">
    **Descrição:** Mover um arquivo ou pasta no OneDrive.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo ou pasta a mover.
    * `parent_id` (string, obrigatório): O ID da pasta de destino.
    * `new_name` (string, opcional): Novo nome para o item (opcional).
  </Accordion>

  <Accordion title="microsoft_onedrive/search_files">
    **Descrição:** Pesquisar arquivos e pastas no OneDrive.

    **Parâmetros:**

    * `query` (string, obrigatório): String de consulta de pesquisa.
    * `top` (integer, opcional): Número de resultados a retornar (máx 1000). Padrão: 50.
  </Accordion>

  <Accordion title="microsoft_onedrive/share_item">
    **Descrição:** Criar um link de compartilhamento para um arquivo ou pasta.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo ou pasta a compartilhar.
    * `type` (string, opcional): Tipo de link de compartilhamento. Opções: view, edit, embed. Padrão: view.
    * `scope` (string, opcional): Escopo do link de compartilhamento. Opções: anonymous, organization. Padrão: anonymous.
  </Accordion>

  <Accordion title="microsoft_onedrive/get_thumbnails">
    **Descrição:** Obter miniaturas para um arquivo.

    **Parâmetros:**

    * `item_id` (string, obrigatório): O ID do arquivo.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Microsoft OneDrive
```

---

## Brave Search

**URL:** llms-txt#brave-search

Source: https://docs.crewai.com/pt-BR/tools/search-research/bravesearchtool

O `BraveSearchTool` foi projetado para pesquisar na internet usando a Brave Search API.

---

## Implementação de LLM Personalizada

**URL:** llms-txt#implementação-de-llm-personalizada

**Contents:**
- Visão Geral
- Início Rápido

Source: https://docs.crewai.com/pt-BR/learn/custom-llm

Aprenda a criar implementações personalizadas de LLM no CrewAI.

O CrewAI oferece suporte a implementações personalizadas de LLM por meio da classe abstrata `BaseLLM`. Isso permite integrar qualquer provedor de LLM que não tenha suporte nativo no LiteLLM ou implementar mecanismos de autenticação personalizados.

Aqui está uma implementação mínima de LLM personalizada:

```python  theme={null}

---

## 항상 백업 옵션 포함

**URL:** llms-txt#항상-백업-옵션-포함

mcps=[
    "https://primary-api.com/mcp",       # 주요 선택
    "https://backup-api.com/mcp",        # 백업 옵션
    "crewai-amp:reliable-service"        # AMP 폴백
]
```

---

## Opção 3: Usando o método to_dict()

**URL:** llms-txt#opção-3:-usando-o-método-to_dict()

print("Acessando propriedades - Opção 3")
output_dict = result.to_dict()
title = output_dict["title"]
content = output_dict["content"]
print("Título:", title)
print("Conteúdo:", content)

---

## Task 2: Competitive Analysis

**URL:** llms-txt#task-2:-competitive-analysis

competitor_analysis_task:
  description: "Analyze strategies of the top 3 competitors based on the market research."
  expected_output: "A comparison table of competitor strategies."
  context: [market_research_task]

---

## Ensure files are in the correct location

**URL:** llms-txt#ensure-files-are-in-the-correct-location

from crewai.utilities.constants import KNOWLEDGE_DIRECTORY
import os

knowledge_dir = KNOWLEDGE_DIRECTORY  # Usually "knowledge"
file_path = os.path.join(knowledge_dir, "your_file.pdf")

if not os.path.exists(file_path):
    print(f"File not found: {file_path}")
    print(f"Current working directory: {os.getcwd()}")
    print(f"Expected knowledge directory: {os.path.abspath(knowledge_dir)}")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Erros "Incompatibilidade de dimensão de embedding":**
```

---

## Initialize the tool with QdrantConfig

**URL:** llms-txt#initialize-the-tool-with-qdrantconfig

qdrant_tool = QdrantVectorSearchTool(
    qdrant_config=QdrantConfig(
        qdrant_url="your_qdrant_url",
        qdrant_api_key="your_qdrant_api_key",
        collection_name="your_collection"
    )
)

---

## PDF 파일 추가

**URL:** llms-txt#pdf-파일-추가

rag_tool.add(data_type="file", path="path/to/your/document.pdf")

---

## HITL 워크플로우

**URL:** llms-txt#hitl-워크플로우

**Contents:**
- HITL 워크플로 설정
- 모범 사례
- 일반적인 사용 사례

Source: https://docs.crewai.com/ko/enterprise/guides/human-in-the-loop

CrewAI에서 의사결정 향상을 위한 Human-In-The-Loop 워크플로우 구현 방법을 알아보세요

인간-중심(Human-In-The-Loop, HITL)은 인공지능과 인간 전문 지식을 결합하여 의사결정을 강화하고 작업 결과를 향상시키는 강력한 접근 방식입니다. 이 가이드는 CrewAI 내에서 HITL을 구현하는 방법을 보여줍니다.

<Steps>
  <Step title="작업 구성">
    사람 입력이 활성화된 상태로 작업을 설정하세요:

<Frame>
      <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=cb2e2bab131e9eff86b0c51dceb16e11" alt="Crew Human Input" data-og-width="624" width="624" data-og-height="165" height="165" data-path="images/enterprise/crew-human-input.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1bc2a85e5aa6e736a118fe2c91452dc6 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=137c8e9c09c9a93ba1b683ad3e247e0d 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=79c8be91790b117c1498568ca48f4287 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=4da8411c0c26ee98c0dcdde6117353fe 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1b24b707df7ec697db2652d80ed3ff8f 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-human-input.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=39a7543043c397cf4ff84582216ddb65 2500w" />
    </Frame>
  </Step>

<Step title="Webhook URL 제공">
    crew를 시작할 때 인간 입력을 위한 webhook URL을 포함하세요:

<Frame>
      <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f2d298c0b4c7b3a62e1dee4e2e6f1bb3" alt="Crew Webhook URL" data-og-width="624" width="624" data-og-height="259" height="259" data-path="images/enterprise/crew-webhook-url.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=80f52cbe2cd1c6a2a4cd3e2039c22971 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=6496d6f5e1fe13fec8be8a406e635b26 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=27cfbbf1fecdab2540df4aeb7ddd15b6 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=57d3439e96917a0627189bfd188af4a0 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=cad1f034d8fd4113f08df6bf1a58f3fa 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-webhook-url.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=fba10cd375c57bcd9b2a216067b5bd44 2500w" />
    </Frame>
  </Step>

<Step title="Webhook 알림 받기">
    crew가 사람 입력이 필요한 작업을 완료하면 다음 정보를 포함한 webhook 알림을 받게 됩니다:

* **Execution ID**
    * **Task ID**
    * **Task output**
  </Step>

<Step title="작업 출력 검토">
    시스템이 `Pending Human Input` 상태에서 일시 중지됩니다. 작업 출력을 신중하게 검토하세요.
  </Step>

<Step title="사람 피드백 제출">
    다음 정보를 포함하여 crew의 resume endpoint를 호출하세요:

<Frame>
      <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1e1c2ca22a2d674426f8e663fed33eca" alt="Crew Resume Endpoint" data-og-width="624" width="624" data-og-height="261" height="261" data-path="images/enterprise/crew-resume-endpoint.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=09014207ae06e6522303b77e4648f0d4 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1ad53990ab04014e622b3acdb37ca604 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=afb11308edffa03de969712505cf95ab 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=9bd69f0d75ec47ac2c6280f24a550bff 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f81e1ebcdc8a9348133503eb5eb4e37a 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/crew-resume-endpoint.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=b12843fa2b80cc86580220766a1f4cc4 2500w" />
    </Frame>

<Warning>
      **중요: Webhook URL을 다시 제공해야 합니다**:
      kickoff 호출에서 사용한 것과 동일한 webhook URL(`taskWebhookUrl`, `stepWebhookUrl`, `crewWebhookUrl`)을 resume 호출에서 **반드시** 제공해야 합니다. Webhook 설정은 kickoff에서 자동으로 전달되지 **않으므로**, 작업 완료, 에이전트 단계, crew 완료에 대한 알림을 계속 받으려면 resume 요청에 명시적으로 포함해야 합니다.
    </Warning>

Webhook을 포함한 resume 호출 예시:

<Warning>
      **피드백이 작업 실행에 미치는 영향**:
      피드백 전체 내용이 이후 작업 실행을 위한 추가 컨텍스트로 통합되므로 피드백 제공 시 신중함이 매우 중요합니다.
    </Warning>

* 피드백에 입력한 모든 정보가 작업의 컨텍스트 일부가 됩니다.
    * 관련 없는 상세 정보는 부정적인 영향을 줄 수 있습니다.
    * 간결하고 관련성 높은 피드백이 작업의 집중도와 효율성을 유지하는 데 도움이 됩니다.
    * 제출 전 항상 피드백을 신중히 검토하여 작업 실행을 긍정적으로 안내할 수 있는 관련 정보만 포함되어 있는지 확인하세요.
  </Step>

<Step title="부정적 피드백 처리">
    부정적인 피드백을 제공하는 경우:

* crew가 귀하의 피드백에서 추가된 컨텍스트와 함께 작업을 재시도합니다.
    * 추가 확인을 위한 다른 webhook 알림을 받게 됩니다.
    * 만족할 때까지 4-6단계를 반복하세요.
  </Step>

<Step title="작업 실행 계속 진행">
    긍정적인 피드백을 제출하면 실행이 다음 단계로 진행됩니다.
  </Step>
</Steps>

* **구체적으로 작성하세요**: 해당 작업에 직접적으로 관련된 명확하고 실행 가능한 피드백을 제공하세요
* **관련성 유지**: 작업 수행 개선에 도움이 되는 정보만 포함하세요
* **적시에 응답하세요**: 워크플로우 지연을 피하기 위해 HITL 프롬프트에 신속하게 응답하세요
* **꼼꼼하게 검토하세요**: 제출 전에 피드백을 다시 확인하여 정확성을 보장하세요

HITL 워크플로우는 특히 다음과 같은 경우에 유용합니다:

* 품질 보증 및 검증
* 복잡한 의사 결정 시나리오
* 민감하거나 위험도가 높은 작업
* 인간의 판단이 필요한 창의적 작업
* 준수 및 규제 검토

---

## Initialize the tool with a specific PDF path for exclusive search within that document

**URL:** llms-txt#initialize-the-tool-with-a-specific-pdf-path-for-exclusive-search-within-that-document

**Contents:**
- Arguments
- Custom model and embeddings

tool = PDFSearchTool(pdf='path/to/your/document.pdf')
python Code theme={null}
from crewai_tools import PDFSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Arguments

* `pdf`: **Optional** The PDF path for the search. Can be provided at initialization or within the `run` method's arguments. If provided at initialization, the tool confines its search to the specified document.

## Custom model and embeddings

By default, the tool uses OpenAI for both embeddings and summarization. To customize the model, you can use a config dictionary as follows. Note: a vector database is required because generated embeddings must be stored and queried from a vectordb.
```

---

## Carregador Web EXA Search

**URL:** llms-txt#carregador-web-exa-search

Source: https://docs.crewai.com/pt-BR/tools/search-research/exasearchtool

O `EXASearchTool` foi projetado para realizar uma busca semântica para uma consulta especificada a partir do conteúdo de um texto em toda a internet.

---

## Microsoft Teams 기능을 가진 에이전트 생성

**URL:** llms-txt#microsoft-teams-기능을-가진-에이전트-생성

teams_agent = Agent(
    role="Teams 코디네이터",
    goal="Teams 커뮤니케이션 및 회의를 효율적으로 관리",
    backstory="Microsoft Teams 작업 및 팀 협업 전문 AI 어시스턴트.",
    apps=['microsoft_teams']  # 모든 Teams 작업을 사용할 수 있습니다
)

---

## Initialize the tool with the database URI and the target table name

**URL:** llms-txt#initialize-the-tool-with-the-database-uri-and-the-target-table-name

**Contents:**
- 인자(Arguments)
- 커스텀 모델 및 임베딩

tool = PGSearchTool(
    db_uri='postgresql://user:password@localhost:5432/mydatabase',
    table_name='employees'
)
python Code theme={null}
tool = PGSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # 혹은 google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # 혹은 openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자(Arguments)

PGSearchTool은 작동을 위해 다음과 같은 인자를 요구합니다:

| 인자              | 타입       | 설명                                                                                            |
| :-------------- | :------- | :-------------------------------------------------------------------------------------------- |
| **db\_uri**     | `string` | **필수**. 쿼리할 PostgreSQL 데이터베이스의 URI를 나타내는 문자열입니다. 이 인자는 필수이며, 필요한 인증 정보와 데이터베이스의 위치를 포함해야 합니다. |
| **table\_name** | `string` | **필수**. 데이터베이스 내에서 시맨틱 검색이 수행될 테이블의 이름을 지정하는 문자열입니다. 이 인자 또한 필수입니다.                           |

## 커스텀 모델 및 임베딩

이 툴은 기본적으로 임베딩과 요약을 위해 OpenAI를 사용하도록 설계되었습니다. 사용자는 아래와 같이 config 딕셔너리를 통해 모델을 커스터마이즈할 수 있는 옵션을 제공합니다.
```

---

## Create agent with multiple MCP sources

**URL:** llms-txt#create-agent-with-multiple-mcp-sources

multi_source_agent = Agent(
    role="Multi-Source Research Analyst",
    goal="Conduct comprehensive research using multiple data sources",
    backstory="""Expert researcher with access to web search, weather data,
    financial information, and academic research tools""",
    mcps=[
        # External MCP servers
        "https://mcp.exa.ai/mcp?api_key=your_exa_key&profile=research",
        "https://weather.api.com/mcp#get_current_conditions",

# CrewAI AMP marketplace
        "crewai-amp:financial-insights",
        "crewai-amp:academic-research#pubmed_search",
        "crewai-amp:market-intelligence#competitor_analysis"
    ]
)

---

## 구조화된 출력 형식 정의

**URL:** llms-txt#구조화된-출력-형식-정의

class MarketAnalysis(BaseModel):
    key_trends: List[str]
    opportunities: List[str]
    recommendation: str

---

## Task 1

**URL:** llms-txt#task-1

research_task:
  description: "Research the top 5 market trends in the AI industry for 2024."
  expected_output: "A markdown list of the 5 trends with supporting evidence."

---

## This context enables Claude to perform like a domain expert

**URL:** llms-txt#this-context-enables-claude-to-perform-like-a-domain-expert

---

## Agente com limites estritos de contexto

**URL:** llms-txt#agente-com-limites-estritos-de-contexto

**Contents:**
  - Como Escolher a Melhor Configuração

strict_agent = Agent(
    role="Legal Document Reviewer",
    goal="Provide precise legal analysis without information loss",
    backstory="Legal expert requiring complete context for accurate analysis",
    respect_context_window=False,  # ❌ Stop execution on context limit
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**O que acontece quando os limites de contexto são excedidos:**

* ❌ **Mensagem de erro**: `"Context length exceeded. Consider using smaller text or RAG tools from crewai_tools."`
* 🛑 **Execução interrompida**: A execução da tarefa é parada imediatamente
* 🔧 **Intervenção manual necessária**: Você precisará modificar sua abordagem

### Como Escolher a Melhor Configuração

#### Use `respect_context_window=True` (padrão) quando:

* **Processar documentos grandes** que podem ultrapassar os limites de contexto
* **Conversas longas** onde certo grau de resumo é aceitável
* **Tarefas de pesquisa** onde o contexto geral é mais importante que detalhes exatos
* **Prototipagem e desenvolvimento** quando se deseja execução robusta
```

---

## Braintrust 통합

**URL:** llms-txt#braintrust-통합

**Contents:**
- 시작하기
  - 1단계: 의존성 설치
  - 2단계: 환경 변수 설정

이 가이드는 **Braintrust**를 **CrewAI**와 OpenTelemetry를 사용하여 포괄적인 추적 및 평가와 함께 통합하는 방법을 보여줍니다. 이 가이드를 완료하면 CrewAI agent를 추적하고, 성능을 모니터링하며, Braintrust의 강력한 관찰성 플랫폼을 사용하여 출력을 평가할 수 있습니다.

> **Braintrust란?** [Braintrust](https://www.braintrust.dev)는 내장된 실험 추적 및 성능 분석을 통해 AI 애플리케이션에 대한 포괄적인 추적, 평가 및 모니터링을 제공하는 AI 평가 및 관찰성 플랫폼입니다.

CrewAI를 사용하고 포괄적인 관찰성 및 평가를 위해 OpenTelemetry를 통해 Braintrust와 통합하는 간단한 예제를 단계별로 안내합니다.

Braintrust API 키를 설정하고 추적을 Braintrust로 전송하도록 OpenTelemetry를 구성합니다. Braintrust API 키와 OpenAI API 키가 필요합니다.

```python  theme={null}
import os
from getpass import getpass

**Examples:**

Example 1 (unknown):
```unknown
### 2단계: 환경 변수 설정

Braintrust API 키를 설정하고 추적을 Braintrust로 전송하도록 OpenTelemetry를 구성합니다. Braintrust API 키와 OpenAI API 키가 필요합니다.
```

---

## `GithubSearchTool`

**URL:** llms-txt#`githubsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, portanto pode haver comportamentos inesperados ou mudanças no futuro.
</Note>

O GithubSearchTool é uma ferramenta de Recuperação Aprimorada por Geração (RAG) especificamente projetada para realizar buscas semânticas em repositórios GitHub. Utilizando funcionalidades avançadas de busca semântica, ele examina códigos, pull requests, issues e repositórios, tornando-se uma ferramenta essencial para desenvolvedores, pesquisadores ou qualquer pessoa que precise de informações precisas do GitHub.

Para usar o GithubSearchTool, primeiro certifique-se de que o pacote crewai\_tools está instalado em seu ambiente Python:

Esse comando instala o pacote necessário para rodar o GithubSearchTool juntamente com outras ferramentas incluídas no pacote crewai\_tools.

Veja como você pode usar o GithubSearchTool para realizar buscas semânticas dentro de um repositório GitHub:

```python Code theme={null}
from crewai_tools import GithubSearchTool

**Examples:**

Example 1 (unknown):
```unknown
Esse comando instala o pacote necessário para rodar o GithubSearchTool juntamente com outras ferramentas incluídas no pacote crewai\_tools.

## Exemplo

Veja como você pode usar o GithubSearchTool para realizar buscas semânticas dentro de um repositório GitHub:
```

---

## Create custom storage with specific embedder

**URL:** llms-txt#create-custom-storage-with-specific-embedder

custom_storage = KnowledgeStorage(
    embedder={
        "provider": "ollama",
        "config": {"model": "mxbai-embed-large"}
    },
    collection_name="my_custom_knowledge"
)

---

## Escreva conteúdo em um arquivo em um diretório especificado

**URL:** llms-txt#escreva-conteúdo-em-um-arquivo-em-um-diretório-especificado

**Contents:**
- Argumentos
- Conclusão

result = file_writer_tool._run('example.txt', 'This is a test content.', 'test_directory')
print(result)
```

* `filename`: O nome do arquivo que você deseja criar ou sobrescrever.
* `content`: O conteúdo a ser escrito no arquivo.
* `directory` (opcional): O caminho para o diretório onde o arquivo será criado. Por padrão, utiliza o diretório atual (`.`). Se o diretório não existir, ele será criado.

Ao integrar o `FileWriterTool` aos seus crews, os agentes podem escrever conteúdo em arquivos de forma confiável em diferentes sistemas operacionais.\
Esta ferramenta é essencial para tarefas que exigem salvamento de dados de saída, criação de sistemas de arquivos estruturados e manipulação de operações de arquivos multiplataforma.\
É especialmente recomendada para usuários do Windows que possam enfrentar problemas ao escrever arquivos com as operações padrão do Python.

Seguindo as orientações de configuração e uso fornecidas, incorporar essa ferramenta em projetos é simples e garante um comportamento consistente de escrita de arquivos em todas as plataformas.

---

## Inicialize a ferramenta

**URL:** llms-txt#inicialize-a-ferramenta

youtube_search_tool = YoutubeVideoSearchTool()

---

## Microsoft Outlook 기능을 가진 에이전트 생성

**URL:** llms-txt#microsoft-outlook-기능을-가진-에이전트-생성

outlook_agent = Agent(
    role="이메일 어시스턴트",
    goal="이메일, 캘린더 이벤트 및 연락처를 효율적으로 관리",
    backstory="Microsoft Outlook 작업 및 커뮤니케이션 관리 전문 AI 어시스턴트.",
    apps=['microsoft_outlook']  # 모든 Outlook 작업을 사용할 수 있습니다
)

---

## Get only the tool to create contacts

**URL:** llms-txt#get-only-the-tool-to-create-contacts

actions_list=["hubspot/create_contact"]
)

contact_creator = Agent(
    role="Contact Creator",
    goal="Create new contacts in HubSpot",
    backstory="An AI assistant that focuses on creating new contact entries in the CRM.",
    apps=['hubspot']
)

---

## Task to create a meeting

**URL:** llms-txt#task-to-create-a-meeting

create_meeting_task = Task(
    description="Create a team standup meeting for tomorrow at 9 AM with the development team",
    agent=calendar_agent,
    expected_output="Meeting created successfully with Google Meet link"
)

---

## Run the tool with input parameters

**URL:** llms-txt#run-the-tool-with-input-parameters

results = tool.run(run_input={"query": "What is CrewAI?", "maxResults": 5})

---

## Solução melhor: Use ferramentas RAG para dados volumosos

**URL:** llms-txt#solução-melhor:-use-ferramentas-rag-para-dados-volumosos

from crewai_tools import RagTool
agent.tools = [RagTool()]

---

## 3. Servidor Streamable HTTP:

**URL:** llms-txt#3.-servidor-streamable-http:

server_params = {
    "url": "http://localhost:8001/mcp",
    "transport": "streamable-http"
}

---

## Transporte Stdio

**URL:** llms-txt#transporte-stdio

**Contents:**
- Visão Geral
- Conceitos-Chave
- Conectando via Stdio
  - 1. Conexão Totalmente Gerenciada (Recomendado)

Source: https://docs.crewai.com/pt-BR/mcp/stdio

Aprenda como conectar o CrewAI a servidores MCP locais usando o mecanismo de transporte Stdio (Entrada/Saída Padrão).

O transporte Stdio (Entrada/Saída Padrão) é projetado para conectar o `MCPServerAdapter` a servidores MCP locais que se comunicam por meio de seus fluxos de entrada e saída padrão. Isso é normalmente utilizado quando o servidor MCP é um script ou executável rodando na mesma máquina da sua aplicação CrewAI.

* **Execução Local**: O transporte Stdio gerencia um processo localmente em execução para o servidor MCP.
* **`StdioServerParameters`**: Esta classe da biblioteca `mcp` é usada para configurar o comando, argumentos e variáveis de ambiente para iniciar o servidor Stdio.

## Conectando via Stdio

Você pode se conectar a um servidor MCP baseado em Stdio usando duas abordagens principais para gerenciar o ciclo de vida da conexão:

### 1. Conexão Totalmente Gerenciada (Recomendado)

Usar um context manager do Python (declaração `with`) é a abordagem recomendada. Ela lida automaticamente com o início do processo do servidor MCP e sua finalização quando o contexto é encerrado.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters
import os

---

## Check your MCP server URL and authentication

**URL:** llms-txt#check-your-mcp-server-url-and-authentication

---

## Option 2: Printing the Entire Blog Object

**URL:** llms-txt#option-2:-printing-the-entire-blog-object

**Contents:**
- 도구와 작업 통합
- 도구와 함께 Task 생성하기

print("Accessing Properties - Option 2")
print("Blog:", result)
python Code theme={null}
import os
os.environ["OPENAI_API_KEY"] = "Your Key"
os.environ["SERPER_API_KEY"] = "Your Key" # serper.dev API key

from crewai import Agent, Task, Crew
from crewai_tools import SerperDevTool

research_agent = Agent(
  role='Researcher',
  goal='Find and summarize the latest AI news',
  backstory="""You're a researcher at a large company.
  You're responsible for analyzing data and providing insights
  to the business.""",
  verbose=True
)

**Examples:**

Example 1 (unknown):
```unknown
이 예시에서:

* Pydantic 모델인 Blog가 title과 content 필드로 정의되어 있으며, 이는 JSON 출력의 구조를 명시하는 데 사용됩니다.
* 태스크 task1은 output\_json 속성을 사용하여 Blog 모델에 부합하는 JSON 출력을 기대함을 나타냅니다.
* crew를 실행한 후, 두 가지 방식으로 구조화된 JSON 출력을 접근할 수 있습니다.

#### 출력 접근 방법 설명

1. 딕셔너리 스타일 인덱싱을 사용하여 속성 접근하기: result\["field\_name"]과 같이 필드를 직접 접근할 수 있습니다. 이는 CrewOutput 클래스가 **getitem** 메서드를 구현하고 있어 출력을 딕셔너리처럼 사용할 수 있기 때문입니다. 이 방법에서는 result에서 title과 content를 가져옵니다.
2. 전체 블로그 객체 출력하기: result를 출력하면 CrewOutput 객체의 문자열 표현을 얻을 수 있습니다. **str** 메서드가 JSON 출력을 반환하도록 구현되어 있기 때문에, 전체 출력을 Blog 객체를 나타내는 형식이 잘 갖추어진 문자열로 볼 수 있습니다.

***

output\_pydantic 또는 output\_json을 사용하면, 작업의 출력이 일관되고 구조화된 형식으로 생성되므로 애플리케이션 내 또는 여러 작업 간에 데이터를 더 쉽게 처리하고 활용할 수 있습니다.

## 도구와 작업 통합

향상된 작업 성능과 에이전트 상호작용을 위해 [CrewAI Toolkit](https://github.com/joaomdmoura/crewai-tools) 및 [LangChain Tools](https://python.langchain.com/docs/integrations/tools)의 도구를 활용하세요.

## 도구와 함께 Task 생성하기
```

---

## 크루 로그 저장하기

**URL:** llms-txt#크루-로그-저장하기

**Contents:**
- 메모리 활용
- 캐시 활용
- Crew 사용 메트릭

crew = Crew(output_log_file = True)  # 로그는 logs.txt로 저장됩니다
crew = Crew(output_log_file = file_name)  # 로그는 file_name.txt로 저장됩니다
crew = Crew(output_log_file = file_name.txt)  # 로그는 file_name.txt로 저장됩니다
crew = Crew(output_log_file = file_name.json)  # 로그는 file_name.json으로 저장됩니다
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 메모리 활용

crew는 메모리(단기, 장기 및 엔티티 메모리)를 활용하여 시간이 지남에 따라 실행 및 학습을 향상시킬 수 있습니다. 이 기능을 통해 crew는 실행 메모리를 저장하고 회상할 수 있어, 의사결정 및 작업 실행 전략에 도움이 됩니다.

## 캐시 활용

캐시는 도구 실행 결과를 저장하는 데 사용될 수 있으며, 동일한 작업을 반복 실행할 필요를 줄여 프로세스의 효율성을 높입니다.

## Crew 사용 메트릭

crew 실행 후, `usage_metrics` 속성에 접근하여 crew가 실행한 모든 작업에 대한 언어 모델(LLM) 사용 메트릭을 확인할 수 있습니다. 이를 통해 운영 효율성과 개선이 필요한 영역에 대한 인사이트를 얻을 수 있습니다.
```

---

## ❌ Evite: Papéis sobrepostos ou vagos

**URL:** llms-txt#❌-evite:-papéis-sobrepostos-ou-vagos

**Contents:**
  - 2. **Delegação Estratégica Habilitada**

agent1 = Agent(role="General Assistant", ...)
agent2 = Agent(role="Helper", ...)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 2. **Delegação Estratégica Habilitada**
```

---

## - embedding_model (required): choose provider + provider-specific config

**URL:** llms-txt#--embedding_model-(required):-choose-provider-+-provider-specific-config

---

## Create a task that requires code execution

**URL:** llms-txt#create-a-task-that-requires-code-execution

data_analysis_task = Task(
    description="Analyze the given dataset and calculate the average age of participants. Ages: {ages}",
    agent=coding_agent,
    expected_output="The average age calculated from the dataset"
)

---

## Task to list teams and channels

**URL:** llms-txt#task-to-list-teams-and-channels

explore_teams_task = Task(
    description="List all teams I'm a member of and then get the channels for the first team.",
    agent=teams_agent,
    expected_output="List of teams and channels displayed."
)

---

## Obtenha suas credenciais do Phoenix Cloud

**URL:** llms-txt#obtenha-suas-credenciais-do-phoenix-cloud

PHOENIX_API_KEY = getpass("🔑 Digite sua Phoenix Cloud API Key: ")

---

## Define o agente

**URL:** llms-txt#define-o-agente

blog_agent = Agent(
    role="Blog Content Generator Agent",
    goal="Gerar um título e conteúdo para blog",
    backstory="""Você é um especialista em criação de conteúdo, habilidoso em escrever posts de blogs engajadores e informativos.""",
    verbose=False,
    allow_delegation=False,
    llm="gpt-4o",
)

---

## 커스텀 매니저 에이전트

**URL:** llms-txt#커스텀-매니저-에이전트

Source: https://docs.crewai.com/ko/learn/custom-manager-agent

CrewAI에서 커스텀 에이전트를 매니저로 설정하여 작업 관리 및 조정을 보다 세밀하게 제어하는 방법을 알아보세요.

---

## 이제 에이전트는 해당 웹사이트 내에서만 검색할 수 있음

**URL:** llms-txt#이제-에이전트는-해당-웹사이트-내에서만-검색할-수-있음

**Contents:**
- 인자
- 커스터마이즈 옵션

tool = WebsiteSearchTool(website='https://example.com')
python Code theme={null}
tool = WebsiteSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # or google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # or openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

* `website`: 선택적으로 웹사이트 URL을 지정하여 집중적인 검색을 수행할 수 있도록 하는 인자입니다. 이 인자는 필요에 따라 타겟팅된 검색을 가능하게 하여 도구의 유연성을 높이기 위해 설계되었습니다.

## 커스터마이즈 옵션

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 커스터마이즈하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다:
```

---

## Create a coding agent with the custom tool

**URL:** llms-txt#create-a-coding-agent-with-the-custom-tool

coding_agent = Agent(
        role="Data Scientist",
        goal="Produce amazing reports on AI",
        backstory="You work with data and AI",
        tools=[MyCustomTool(result_as_answer=True)],
    )

---

## Conexão MCP é feita apenas quando uma ferramenta é realmente executada

**URL:** llms-txt#conexão-mcp-é-feita-apenas-quando-uma-ferramenta-é-realmente-executada

---

## Criar um filtro para condições específicas

**URL:** llms-txt#criar-um-filtro-para-condições-específicas

preset_filter = qmodels.Filter(
    must=[
        qmodels.FieldCondition(
            key="categoria",
            match=qmodels.MatchValue(value="pesquisa")
        ),
        qmodels.FieldCondition(
            key="ano",
            match=qmodels.MatchValue(value=2024)
        )
    ]
)

---

## Comportamento padrão - diretórios são criados automaticamente

**URL:** llms-txt#comportamento-padrão---diretórios-são-criados-automaticamente

**Contents:**
  - Desabilitando a Criação de Diretórios

report_task = Task(
    description='Gerar um relatório abrangente de análise de mercado',
    expected_output='Uma análise detalhada de mercado com gráficos e insights',
    agent=analyst_agent,
    output_file='reports/2025/market_analysis.md',  # Cria 'reports/2025/' se não existir
    markdown=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Desabilitando a Criação de Diretórios

Se você quiser evitar a criação automática de diretórios e garantir que o diretório já exista, defina `create_directory=False`:
```

---

## Check chunking behavior

**URL:** llms-txt#check-chunking-behavior

print(f"Original content length: {len(test_source.content)}")
print(f"Chunk size: {test_source.chunk_size}")
print(f"Chunk overlap: {test_source.chunk_overlap}")

---

## Obter ou criar coleção

**URL:** llms-txt#obter-ou-criar-coleção

test_docs = client.collections.get("example_collections")
if not test_docs:
    test_docs = client.collections.create(
        name="example_collections",
        vectorizer_config=Configure.Vectorizer.text2vec_openai(model="nomic-embed-text"),
        generative_config=Configure.Generative.openai(model="gpt-4o"),
    )

---

## Tarefa de automação de agendamento complexo

**URL:** llms-txt#tarefa-de-automação-de-agendamento-complexo

**Contents:**
- Solução de Problemas
  - Problemas Comuns
  - Obtendo Ajuda

automation_task = Task(
    description="""
    1. Liste todos os eventos futuros das próximas duas semanas
    2. Identifique conflitos de agendamento ou reuniões consecutivas
    3. Sugira horários ótimos de reunião verificando as disponibilidades
    4. Crie intervalos entre reuniões quando necessário
    5. Atualize a descrição dos eventos com pautas e links de reunião
    """,
    agent=scheduling_automator,
    expected_output="Calendário otimizado com conflitos resolvidos, intervalos e detalhes das reuniões atualizados"
)

crew = Crew(
    agents=[scheduling_automator],
    tasks=[automation_task]
)

## Solução de Problemas

**Erros de Autenticação**

* Certifique-se de que sua conta Google possui as permissões necessárias para acessar o calendário
* Verifique se a conexão OAuth inclui todos os escopos necessários para a API do Google Calendar
* Confirme se as configurações de compartilhamento do calendário permitem o nível de acesso necessário

**Problemas na Criação de Eventos**

* Verifique se os formatos de horário estão corretos (ISO8601 ou timestamps Unix)
* Assegure-se de que os endereços de e-mail dos participantes estão corretamente formatados
* Verifique se o calendário de destino existe e está acessível
* Confirme se os fusos horários estão especificados corretamente

**Disponibilidade e Conflitos de Horário**

* Use formato ISO adequado para os intervalos de horário ao verificar disponibilidade
* Certifique-se de que os fusos horários estão consistentes em todas as operações
* Verifique se os IDs dos calendários estão corretos ao consultar múltiplos calendários

**Pesquisa de Contatos e Pessoas**

* Assegure-se de que os termos de pesquisa estão devidamente formatados
* Verifique se as permissões para acesso ao diretório foram concedidas
* Certifique-se de que as informações de contato estão atualizadas e acessíveis

**Atualização e Exclusão de Eventos**

* Verifique se os IDs dos eventos estão corretos e se os eventos existem
* Assegure-se de que você possui permissões de edição para os eventos
* Verifique se a propriedade do calendário permite modificações

<Card title="Precisa de ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nosso time de suporte para assistência na configuração da integração com o Google Calendar ou solução de problemas.
</Card>

---

## 사용자 지정 연결 타임아웃 예시

**URL:** llms-txt#사용자-지정-연결-타임아웃-예시

with MCPServerAdapter(server_params, connect_timeout=60) as tools:
    # 60초 이내에 연결이 설정되지 않으면 타임아웃 발생
    pass
python  theme={null}
from crewai import Agent
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters # Stdio 서버용

**Examples:**

Example 1 (unknown):
```unknown

```

---

## Agent knowledge storage

**URL:** llms-txt#agent-knowledge-storage

agent_collection_name = agent.role  # e.g., "Especialista Técnico"

---

## Microsoft Teams 통합

**URL:** llms-txt#microsoft-teams-통합

**Contents:**
- 개요
- 전제 조건
- Microsoft Teams 통합 설정
  - 1. Microsoft 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Microsoft Teams 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/microsoft_teams

CrewAI를 위한 Microsoft Teams 통합으로 팀 협업 및 커뮤니케이션.

에이전트가 Teams 데이터에 액세스하고, 메시지를 보내고, 회의를 만들고, 채널을 관리할 수 있도록 합니다. AI 기반 자동화로 팀 커뮤니케이션을 자동화하고, 회의를 예약하고, 메시지를 검색하며, 협업 워크플로를 간소화합니다.

Microsoft Teams 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Teams 액세스 권한이 있는 Microsoft 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Microsoft 계정 연결

## Microsoft Teams 통합 설정

### 1. Microsoft 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Microsoft Teams** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. Teams 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="microsoft_teams/get_teams">
    **설명:** 사용자가 멤버인 모든 팀을 가져옵니다.

* 매개변수가 필요하지 않습니다.
  </Accordion>

<Accordion title="microsoft_teams/get_channels">
    **설명:** 특정 팀의 채널을 가져옵니다.

* `team_id` (string, 필수): 팀의 ID.
  </Accordion>

<Accordion title="microsoft_teams/send_message">
    **설명:** Teams 채널에 메시지를 보냅니다.

* `team_id` (string, 필수): 팀의 ID.
    * `channel_id` (string, 필수): 채널의 ID.
    * `message` (string, 필수): 메시지 내용.
    * `content_type` (string, 선택사항): 콘텐츠 유형 (html 또는 text). 옵션: html, text. 기본값: text.
  </Accordion>

<Accordion title="microsoft_teams/get_messages">
    **설명:** Teams 채널에서 메시지를 가져옵니다.

* `team_id` (string, 필수): 팀의 ID.
    * `channel_id` (string, 필수): 채널의 ID.
    * `top` (integer, 선택사항): 검색할 메시지 수 (최대 50). 기본값: 20.
  </Accordion>

<Accordion title="microsoft_teams/create_meeting">
    **설명:** Teams 회의를 만듭니다.

* `subject` (string, 필수): 회의 제목/제목.
    * `startDateTime` (string, 필수): 회의 시작 시간 (시간대가 포함된 ISO 8601 형식).
    * `endDateTime` (string, 필수): 회의 종료 시간 (시간대가 포함된 ISO 8601 형식).
  </Accordion>

<Accordion title="microsoft_teams/search_online_meetings_by_join_url">
    **설명:** 웹 참가 URL로 온라인 회의를 검색합니다.

* `join_web_url` (string, 필수): 검색할 회의의 웹 참가 URL.
  </Accordion>
</AccordionGroup>

### 기본 Microsoft Teams 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="microsoft_teams/get_teams">
    **설명:** 사용자가 멤버인 모든 팀을 가져옵니다.

    **매개변수:**

    * 매개변수가 필요하지 않습니다.
  </Accordion>

  <Accordion title="microsoft_teams/get_channels">
    **설명:** 특정 팀의 채널을 가져옵니다.

    **매개변수:**

    * `team_id` (string, 필수): 팀의 ID.
  </Accordion>

  <Accordion title="microsoft_teams/send_message">
    **설명:** Teams 채널에 메시지를 보냅니다.

    **매개변수:**

    * `team_id` (string, 필수): 팀의 ID.
    * `channel_id` (string, 필수): 채널의 ID.
    * `message` (string, 필수): 메시지 내용.
    * `content_type` (string, 선택사항): 콘텐츠 유형 (html 또는 text). 옵션: html, text. 기본값: text.
  </Accordion>

  <Accordion title="microsoft_teams/get_messages">
    **설명:** Teams 채널에서 메시지를 가져옵니다.

    **매개변수:**

    * `team_id` (string, 필수): 팀의 ID.
    * `channel_id` (string, 필수): 채널의 ID.
    * `top` (integer, 선택사항): 검색할 메시지 수 (최대 50). 기본값: 20.
  </Accordion>

  <Accordion title="microsoft_teams/create_meeting">
    **설명:** Teams 회의를 만듭니다.

    **매개변수:**

    * `subject` (string, 필수): 회의 제목/제목.
    * `startDateTime` (string, 필수): 회의 시작 시간 (시간대가 포함된 ISO 8601 형식).
    * `endDateTime` (string, 필수): 회의 종료 시간 (시간대가 포함된 ISO 8601 형식).
  </Accordion>

  <Accordion title="microsoft_teams/search_online_meetings_by_join_url">
    **설명:** 웹 참가 URL로 온라인 회의를 검색합니다.

    **매개변수:**

    * `join_web_url` (string, 필수): 검색할 회의의 웹 참가 URL.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Microsoft Teams 에이전트 설정
```

---

## 모든 사용 가능한 명령어 보기

**URL:** llms-txt#모든-사용-가능한-명령어-보기

---

## Create an Agent using Llama-specific layouts

**URL:** llms-txt#create-an-agent-using-llama-specific-layouts

principal_engineer = Agent(
    role="Principal Engineer",
    goal="Oversee AI architecture and make high-level decisions",
    backstory="You are the lead engineer responsible for critical AI systems",
    verbose=True,
    llm="groq/llama-3.3-70b-versatile",  # Using the Llama 3 model
    system_template=system_template,
    prompt_template=prompt_template,
    response_template=response_template,
    tools=[DirectoryReadTool(), FileReadTool()]
)

---

## 웹 페이지 추가

**URL:** llms-txt#웹-페이지-추가

rag_tool.add(data_type="web_page", url="https://example.com")

---

## Access structured data

**URL:** llms-txt#access-structured-data

**Contents:**
  - 여러 개의 메시지
  - 비동기 지원
- 중요한 고려사항 및 모범 사례
  - 보안 및 코드 실행
  - 성능 최적화
  - 메모리 및 컨텍스트 관리
  - 고급 기능
  - 에이전트 협업
  - 날짜 인식 및 추론
  - 모델 호환성

print(result.pydantic.main_points)
print(result.pydantic.future_predictions)
python Code theme={null}
messages = [
    {"role": "user", "content": "I need information about large language models"},
    {"role": "assistant", "content": "I'd be happy to help with that! What specifically would you like to know?"},
    {"role": "user", "content": "What are the latest developments in 2025?"}
]

result = researcher.kickoff(messages)
python Code theme={null}
import asyncio

async def main():
    result = await researcher.kickoff_async("What are the latest developments in AI?")
    print(result.raw)

asyncio.run(main())
```

<Note>
  `kickoff()` 메서드는 내부적으로 `LiteAgent`를 사용하며, 모든 agent 설정(역할, 목표, 백스토리, 도구 등)을 유지하면서도 더 간단한 실행 흐름을 제공합니다.
</Note>

* `allow_code_execution`을 사용할 때는 사용자 입력에 주의하고 항상 입력 값을 검증하세요
* 운영 환경에서는 `code_execution_mode: "safe"`(Docker)를 사용하세요
* 무한 루프를 방지하기 위해 적절한 `max_execution_time` 제한을 설정하는 것을 고려하세요

* `respect_context_window: true`를 사용하여 토큰 제한 문제를 방지하세요.
* 적절한 `max_rpm`을 설정하여 속도 제한을 피하세요.
* 반복적인 작업의 성능 향상을 위해 `cache: true`를 활성화하세요.
* 작업의 복잡도에 따라 `max_iter`와 `max_retry_limit`을 조정하세요.

* 도메인별 정보를 위해 `knowledge_sources`를 활용하세요
* 커스텀 임베딩 모델을 사용할 때는 `embedder`를 구성하세요
* 에이전트 행동을 세밀하게 제어하려면 커스텀 템플릿(`system_template`, `prompt_template`, `response_template`)을 사용하세요

* 복잡한 작업을 실행하기 전에 계획을 세우고 반성해야 하는 에이전트의 경우 `reasoning: true`를 활성화하세요.
* 계획 반복 횟수를 제어하려면 적절한 `max_reasoning_attempts` 값을 설정하세요 (무제한 시 None 사용).
* 시간에 민감한 작업을 위해 에이전트가 현재 날짜를 인식할 수 있도록 `inject_date: true`를 사용하세요.
* 표준 Python datetime 형식 코드를 사용하여 `date_format`으로 날짜 형식을 맞춤 설정할 수 있습니다.
* 텍스트와 시각적 콘텐츠를 모두 처리해야 하는 에이전트의 경우 `multimodal: true`를 활성화하세요.

* 에이전트들이 함께 작업해야 할 때 `allow_delegation: true`를 활성화하세요
* 에이전트 상호작용을 모니터링하고 기록하려면 `step_callback`을 사용하세요
* 다양한 목적에 따라 서로 다른 LLM을 사용하는 것을 고려하세요:
  * 복잡한 추론에는 메인 `llm`
  * 효율적인 도구 사용에는 `function_calling_llm`

* 시간에 민감한 작업을 위해 `inject_date: true`를 사용하여 에이전트에게 현재 날짜 인식 기능을 제공합니다.
* 표준 Python datetime 형식 코드를 사용하는 `date_format`으로 날짜 형식을 사용자 정의할 수 있습니다.
* 유효한 형식 코드는 다음과 같습니다: %Y (연도), %m (월), %d (일), %B (전체 월 이름) 등.
* 잘못된 날짜 형식은 경고로 기록되며, 작업 설명을 수정하지 않습니다.
* 사전 계획 및 성찰이 필요한 복잡한 작업의 경우 `reasoning: true`를 활성화하세요.

* 시스템 메시지를 지원하지 않는 이전 모델의 경우 `use_system_prompt: false`로 설정하세요
* 선택한 `llm`이(가) 필요한 기능(예: 함수 호출)을 지원하는지 확인하세요

1. **Rate Limiting(속도 제한)**: API 속도 제한에 도달하는 경우:
   * 적절한 `max_rpm` 구현
   * 반복적인 작업에 캐싱 사용
   * 요청을 일괄 처리(batch)하는 것 고려

2. **Context Window Errors(컨텍스트 윈도우 오류)**: 컨텍스트 한계를 초과하는 경우:
   * `respect_context_window` 활성화
   * 더 효율적인 프롬프트 사용
   * 주기적으로 에이전트 메모리 정리

3. **Code Execution Issues(코드 실행 문제)**: 코드 실행이 실패하는 경우:
   * 안전 모드를 위해 Docker 설치 여부 확인
   * 실행 권한 확인
   * 코드 샌드박스 설정 검토

4. **Memory Issues(메모리 문제)**: 에이전트 응답이 일관되지 않은 경우:
   * knowledge 소스 구성 확인
   * 대화 기록 관리 검토

에이전트는 특정 사용 사례에 맞게 구성될 때 가장 효과적입니다. 자신의 요구 사항을 이해하고 이에 맞게 이러한 매개변수를 조정하는 데 시간을 투자하세요.

**Examples:**

Example 1 (unknown):
```unknown
### 여러 개의 메시지

대화 기록을 메시지 딕셔너리의 목록으로 제공할 수도 있습니다:
```

Example 2 (unknown):
```unknown
### 비동기 지원

동일한 매개변수를 사용하는 비동기 버전은 `kickoff_async()`를 통해 사용할 수 있습니다:
```

---

## Task to create a new document

**URL:** llms-txt#task-to-create-a-new-document

create_doc_task = Task(
    description="Create a new Google Document titled 'Project Status Report'",
    agent=docs_agent,
    expected_output="New Google Document 'Project Status Report' created successfully"
)

---

## Register a custom evaluator

**URL:** llms-txt#register-a-custom-evaluator

@client.register_local_evaluator("random_evaluator")
def random_evaluator(**kwargs):
    score = random.random()
    return EvaluationResult(
        score_raw=score,
        pass_=score >= 0.5,
        explanation="example explanation",
    )

---

## Creative model for content generation

**URL:** llms-txt#creative-model-for-content-generation

content_llm = LLM(model="claude-3-5-sonnet-20241022", temperature=0.7)

---

## Option 3: Accessing Properties Using the to_dict() Method

**URL:** llms-txt#option-3:-accessing-properties-using-the-to_dict()-method

print("Accessing Properties - Option 3")
output_dict = result.to_dict()
title = output_dict["title"]
content = output_dict["content"]
print("Title:", title)
print("Content:", content)

---

## Use kickoff() to interact directly with the agent

**URL:** llms-txt#use-kickoff()-to-interact-directly-with-the-agent

result = researcher.kickoff("What are the latest developments in language models?")

---

## Verificar conexão

**URL:** llms-txt#verificar-conexão

**Contents:**
  - Passo 3: Inicialize o OpenLit
  - Passo 4: Crie uma Aplicação Simples CrewAI
  - Passo 5: Veja os Traces no Langfuse
- Referências

if langfuse.auth_check():
    print("Cliente Langfuse autenticado e pronto!")
else:
    print("Falha na autenticação. Verifique suas credenciais e host.")
python  theme={null}
import openlit

openlit.init()
python  theme={null}
from crewai import Agent, Task, Crew

from crewai_tools import (
    WebsiteSearchTool
)

web_rag_tool = WebsiteSearchTool()

escritor = Agent(
    role="Escritor",
    goal="Você torna a matemática envolvente e compreensível para crianças pequenas através de poesias",
    backstory="Você é especialista em escrever haicais mas não sabe nada de matemática.",
    tools=[web_rag_tool],  
)

tarefa = Task(description=("O que é {multiplicação}?"),
              expected_output=("Componha um haicai que inclua a resposta."),
              agent=escritor)

equipe = Crew(
  agents=[escritor],
  tasks=[tarefa],
  share_crew=False
)
```

### Passo 5: Veja os Traces no Langfuse

Após rodar o agente, você pode visualizar os traces gerados pela sua aplicação CrewAI no [Langfuse](https://cloud.langfuse.com). Você verá etapas detalhadas das interações do LLM, o que pode ajudar na depuração e otimização do seu agente de IA.

![Exemplo de trace CrewAI no Langfuse](https://langfuse.com/images/cookbook/integration_crewai/crewai-example-trace.png)

*[Exemplo público de trace no Langfuse](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/e2cf380ffc8d47d28da98f136140642b?timestamp=2025-02-05T15%3A12%3A02.717Z\&observation=3b32338ee6a5d9af)*

* [Documentação Langfuse OpenTelemetry](https://langfuse.com/docs/opentelemetry/get-started)

**Examples:**

Example 1 (unknown):
```unknown
### Passo 3: Inicialize o OpenLit

Inicialize o SDK de instrumentação OpenTelemetry do OpenLit para começar a capturar traces do OpenTelemetry.
```

Example 2 (unknown):
```unknown
### Passo 4: Crie uma Aplicação Simples CrewAI

Vamos criar uma aplicação simples CrewAI onde múltiplos agentes colaboram para responder à pergunta de um usuário.
```

---

## Opção 4: Imprimindo o objeto Blog inteiro

**URL:** llms-txt#opção-4:-imprimindo-o-objeto-blog-inteiro

**Contents:**
  - Usando `output_json`

print("Acessando propriedades - Opção 5")
print("Blog:", result)

python Code theme={null}
import json

from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

**Examples:**

Example 1 (unknown):
```unknown
Neste exemplo:

* Um modelo Pydantic Blog é definido com os campos title e content.
* A tarefa task1 utiliza a propriedade output\_pydantic para especificar que sua saída deve seguir o modelo Blog.
* Após executar o crew, você pode acessar a saída estruturada de várias formas, como mostrado.

#### Explicação sobre o acesso à saída

1. Indexação estilo dicionário: Acesse os campos diretamente usando result\["nome\_do\_campo"]. Isso funciona porque a classe CrewOutput implementa o método **getitem**.
2. Diretamente do modelo Pydantic: Acesse os atributos diretamente do objeto result.pydantic.
3. Usando o método to\_dict(): Converta a saída para um dicionário e acesse os campos.
4. Imprimindo o objeto inteiro: Simplesmente imprima o objeto result para ver a saída estruturada.

### Usando `output_json`

A propriedade `output_json` permite definir o formato de saída esperado em JSON. Isso garante que a saída da tarefa seja uma estrutura JSON válida que pode ser facilmente analisada e utilizada na aplicação.

Veja um exemplo de uso do `output_json`:
```

---

## Traces

**URL:** llms-txt#traces

**Contents:**
- Visão Geral
- O que são Traces?
- Acessando os Traces
- Entendendo a Interface do Trace
  - 1. Resumo da Execução
  - 2. Tarefas & Agentes
  - 3. Saída Final
  - 4. Linha do Tempo da Execução
  - 5. Visão Detalhada da Tarefa
- Usando Traces para Depuração

Source: https://docs.crewai.com/pt-BR/enterprise/features/traces

Usando Traces para monitorar seus Crews

Traces fornecem visibilidade abrangente sobre as execuções dos seus crews, ajudando você a monitorar o desempenho, depurar problemas e otimizar os fluxos de trabalho dos seus agentes de IA.

Traces no CrewAI AMP são registros detalhados de execução que capturam todos os aspectos da operação do seu crew, desde as entradas iniciais até as saídas finais. Eles registram:

* Pensamentos e raciocínio do agente
* Detalhes da execução das tarefas
* Uso de ferramentas e resultados
* Métricas de consumo de tokens
* Tempos de execução
* Estimativas de custo

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9c02d5b7306bf7adaeadd77a018f8fea" alt="Traces Overview" data-og-width="2244" width="2244" data-og-height="1422" height="1422" data-path="images/enterprise/traces-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e66e7c56a8848b69266563ea8cddfc4e 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f590b3901aaa5994042c79426d78bd6c 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=0ecb9dcb307e8f130f53393bd3abc12d 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=5fc6fcfc51c4e8f4ce16d237228043d6 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=253eaed4ec34a35798dad42e9a388859 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/traces-overview.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ec818e09bc20b3f72b1bcf1970804d13 2500w" />
</Frame>

## Acessando os Traces

<Steps>
  <Step title="Navegue até a aba Traces">
    No seu painel do CrewAI AMP, clique em **Traces** para ver todos os registros de execução.
  </Step>

<Step title="Selecione uma Execução">
    Você verá uma lista de todas as execuções do crew, ordenadas por data. Clique em qualquer execução para visualizar seu trace detalhado.
  </Step>
</Steps>

## Entendendo a Interface do Trace

A interface do trace é dividida em várias seções, cada uma fornecendo diferentes insights sobre a execução do seu crew:

### 1. Resumo da Execução

A seção superior exibe métricas de alto nível sobre a execução:

* **Total de Tokens**: Número de tokens consumidos em todas as tarefas
* **Prompt Tokens**: Tokens usados em prompts para o LLM
* **Completion Tokens**: Tokens gerados nas respostas do LLM
* **Requisições**: Número de chamadas de API feitas
* **Tempo de Execução**: Duração total da execução do crew
* **Custo Estimado**: Custo aproximado com base no uso de tokens

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a6a26eda2add26a6f649b1727bf90d8d" alt="Execution Summary" data-og-width="2576" width="2576" data-og-height="916" height="916" data-path="images/enterprise/trace-summary.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=52f47a0c5d9f2dc1d0c93d1c2446cb10 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=584cdc9fded1e3875799da73e60cdebd 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2e4f500438545badfa9b3bb3704786ce 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c3e0987a95638f9512ba6c64a5927eda 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=d80e2d9de9db7449368151ccaac8106b 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-summary.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=39ccb1a6b12aecd0f6863f2783b1bfc6 2500w" />
</Frame>

### 2. Tarefas & Agentes

Esta seção mostra todas as tarefas e agentes que fizeram parte da execução do crew:

* Nome da tarefa e atribuição do agente
* Agentes e LLMs usados em cada tarefa
* Status (concluído/falhou)
* Tempo de execução individual da tarefa

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f0358b4a17e78532500b4a14964bc30c" alt="Task List" data-og-width="1778" width="1778" data-og-height="594" height="594" data-path="images/enterprise/trace-tasks.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a775268b18c71e0ffa497c9a4e1ad179 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3dadaad60870c3841f859857d5d6f53d 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a0a1d24573dd32cb9d5a3f089536c547 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2ccc370f5e0b6b38521a5ed39e02b062 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=4d717a70fd61ce713f7d5d91ccf867fe 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-tasks.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2c577a5f8e1acea3942de29c5ca49343 2500w" />
</Frame>

Exibe o resultado final produzido pelo crew após a conclusão de todas as tarefas.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=5ca9ef8e4071ee570c3e0c8f93ff4253" alt="Final Output" data-og-width="2212" width="2212" data-og-height="1572" height="1572" data-path="images/enterprise/final-output.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ab97b6b386304f03fe21c6ba2393c683 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3839e312b2a9caa45f3f4b72345ea87b 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b032c2c57ffcd5fb558c43915d385f9a 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=63390d70d70f1a2265a224e8c20d0204 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=abc4a7b81c51049ca606130a0dd543f7 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/final-output.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9fc40fc5f8ad52996aba482d62348f0f 2500w" />
</Frame>

### 4. Linha do Tempo da Execução

Uma representação visual de quando cada tarefa começou e terminou, ajudando a identificar gargalos ou padrões de execução paralela.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c860975d3e15e3a6988bedc7d1bf6ba4" alt="Execution Timeline" data-og-width="2210" width="2210" data-og-height="1406" height="1406" data-path="images/enterprise/trace-timeline.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b74d67bda34ce88ea23c30c580dfb2fc 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=99c6688c1d290548cc480232bb13b0e0 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=4876c794ddde894e1e2cf15f1926efcb 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c44f7eec8f0998e488bc951eee8961ea 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c25e4827f5a83172483c38f40e6685de 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-timeline.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=b3b2f72954e565f7177b5175d89dfe79 2500w" />
</Frame>

### 5. Visão Detalhada da Tarefa

Ao clicar em uma tarefa específica na linha do tempo ou na lista de tarefas, você verá:

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=74f5e92354196325edca8d62c29363c7" alt="Detailed Task View" data-og-width="2036" width="2036" data-og-height="1572" height="1572" data-path="images/enterprise/trace-detailed-task.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=d260407501639bcd1a45da51762f488e 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=e577e06eb7658f045e56f2e40e03cf94 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=fcafbac3507eb800e08153352016bf14 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9b2b0decb758802aaa2d8b0b2bd39e6f 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=66a9362f6d8f2edd5a2dad353700e440 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/trace-detailed-task.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=faadd7f3c9e9176060e21c2987c3d8c9 2500w" />
</Frame>

* **Task Key**: Identificador único da tarefa
* **Task ID**: Identificador técnico no sistema
* **Status**: Estado atual (concluída/em execução/falhou)
* **Agente**: Qual agente executou a tarefa
* **LLM**: Modelo de linguagem usado nesta tarefa
* **Início/Fim**: Quando a tarefa foi iniciada e concluída
* **Tempo de Execução**: Duração desta tarefa específica
* **Descrição da Tarefa**: O que o agente foi instruído a fazer
* **Expected Output**: Qual formato de saída foi solicitado
* **Input**: Qualquer entrada fornecida a essa tarefa vinda de tarefas anteriores
* **Output**: O resultado real produzido pelo agente

## Usando Traces para Depuração

Traces são indispensáveis para solucionar problemas nos seus crews:

<Steps>
  <Step title="Identifique Pontos de Falha">
    Quando uma execução de crew não produzir os resultados esperados, examine o trace para encontrar onde ocorreu o problema. Procure por:

* Tarefas que falharam
    * Decisões inesperadas dos agentes
    * Erros no uso de ferramentas
    * Instruções mal interpretadas

<Frame>
            <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c892a75b7a22a57949a2641a0fe45bfa" alt="Failure Points" data-og-width="820" width="820" data-og-height="924" height="924" data-path="images/enterprise/failure.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ecbcbd312dd467cb5cc1dae4a443c56d 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c0452a9db1f339e63686941a533d8946 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ded3f2fff055c8d16bcad99ad537da46 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f871feb85f88ba397a259ee8392aef3e 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2acf042b2e6b185f1fbc41100751e03f 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/failure.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1e9fc9104e6b55b586a9b13e120de908 2500w" />
    </Frame>
  </Step>

<Step title="Otimizar Desempenho">
    Use métricas de execução para identificar gargalos de desempenho:

* Tarefas que demoraram mais do que o esperado
    * Uso excessivo de tokens
    * Operações redundantes de ferramentas
    * Chamadas de API desnecessárias
  </Step>

<Step title="Melhore a Eficiência de Custos">
    Analise o uso de tokens e as estimativas de custo para otimizar a eficiência do seu crew:

* Considere usar modelos menores para tarefas mais simples
    * Refine prompts para serem mais concisos
    * Faça cache de informações acessadas frequentemente
    * Estruture tarefas para minimizar operações redundantes
  </Step>
</Steps>

<Card title="Precisa de ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nossa equipe de suporte para assistência com análise de traces ou outros recursos do CrewAI AMP.
</Card>

---

## Task to create and populate a workbook

**URL:** llms-txt#task-to-create-and-populate-a-workbook

data_management_task = Task(
    description="Create a new sales report workbook with data analysis and charts",
    agent=excel_agent,
    expected_output="Excel workbook created with sales data, analysis, and visualizations"
)

---

## 크루 업데이트

**URL:** llms-txt#크루-업데이트

**Contents:**
- 왜 Crew를 업데이트해야 하나요?
- 1. 최신 커밋으로 Crew 코드 업데이트하기
- 2. 베어러 토큰 재설정
- 3. 환경 변수 업데이트하기
- 업데이트 후

Source: https://docs.crewai.com/ko/enterprise/guides/update-crew

CrewAI AMP에서 크루 업데이트하기

<Note>
  CrewAI AMP에 crew를 배포한 후, 코드, 보안 설정 또는 구성을 업데이트해야 할 수 있습니다.
  이 가이드는 이러한 일반적인 업데이트 작업을 수행하는 방법을 설명합니다.
</Note>

## 왜 Crew를 업데이트해야 하나요?

CrewAI는 기본적으로 GitHub 업데이트를 자동으로 반영하지 않으므로, 배포 시 `Auto-update` 옵션을 선택하지 않았다면 수동으로 업데이트를 트리거해야 합니다.

Crew 배포를 업데이트하고 싶은 이유는 여러 가지가 있을 수 있습니다:

* GitHub에 푸시한 최신 커밋으로 코드를 업데이트하고 싶은 경우
* 보안상의 이유로 bearer 토큰을 재설정하고 싶은 경우
* 환경 변수를 업데이트하고 싶은 경우

## 1. 최신 커밋으로 Crew 코드 업데이트하기

GitHub 저장소에 새로운 커밋을 푸시한 후 배포를 업데이트하려면 다음 단계를 따르세요:

1. CrewAI AMP 플랫폼에서 자신의 crew로 이동하세요.
2. crew 상세 페이지에서 `Re-deploy` 버튼을 클릭하세요.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1dc96ae0dd8f0dc2f5f62f58ebd6e5d0" alt="Re-deploy Button" data-og-width="980" width="980" data-og-height="852" height="852" data-path="images/enterprise/redeploy-button.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8d240851abcc6a015002a129ac12274b 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=2655800484e20180df0d3bc88e563ef8 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f8d7850c288577c99242ada871e5eb7c 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=d5c4dd51e512466df9209fa6218bbb9e 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=15e03da40d3e92fe0c9615b28f4efce8 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/redeploy-button.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8d29aa1f4ac64a30a01c449b2f31aead 2500w" />
</Frame>

이 작업을 수행하면 진행률 표시줄을 통해 추적할 수 있는 업데이트가 트리거됩니다. 시스템은 저장소에서 최신 코드를 가져와서 배포를 다시 빌드합니다.

현재 토큰이 유출되었을 가능성이 있다고 의심되는 경우 등, 새 베어러 토큰을 생성해야 한다면 다음 단계를 따르세요:

1. CrewAI AMP 플랫폼에서 해당 crew로 이동하세요.
2. `Bearer Token` 섹션을 찾으세요.
3. 현재 토큰 옆에 있는 `Reset` 버튼을 클릭하세요.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c38b0a22de7a192a1962b4b371e03119" alt="Reset Token" data-og-width="980" width="980" data-og-height="840" height="840" data-path="images/enterprise/reset-token.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=759453ab874cffd228bbbc91db2cbe3c 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=365f3075be71ad8ed85e1a9ba7cbe9b5 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7b689e67e67abb1e39cd6e98efa1e562 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7dfbd9d08e16bb16de00d6e7fde00a6d 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=900c92322f9cd90732ccdfa1f8d9ea42 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/reset-token.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=000718aaaa645b109514bc72c2f0b70e 2500w" />
</Frame>

<Warning>
  베어러 토큰을 재설정하면 이전 토큰은 즉시 사용할 수 없게 됩니다. 이전 토큰을 사용하고 있는 모든 애플리케이션이나 스크립트에서 토큰을 반드시 업데이트하세요.
</Warning>

crew의 환경 변수를 업데이트하려면 다음 단계를 따르세요:

1. 먼저 crew 이름을 클릭하여 배포 페이지에 접속합니다.

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=740ad7bcf5b860f35fe9fddd7a707271" alt="환경 변수 버튼" data-og-width="1216" width="1216" data-og-height="598" height="598" data-path="images/enterprise/env-vars-button.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=a4bdc54aee3c54cedc4c25f0b0e28aaa 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=f3012e2c4257313f080afeb2ab0c690b 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9532e4a7281391aacacc1faaf14e6f74 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ea0aaee0f92be7b9ef4b62cc64e12877 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=ca4a47c02e4761b05b83af8fb118e915 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/env-vars-button.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=542188110b78b31121abba738a28019d 2500w" />
</Frame>

2. `Environment Variables` 섹션을 찾습니다 (`Settings` 아이콘을 클릭해야 접근할 수 있습니다)
3. 제공된 필드에서 기존 변수를 수정하거나 새 변수를 추가합니다
4. 수정한 각 변수 옆의 `Update` 버튼을 클릭합니다

<Frame>
    <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=461ca7ce61dd14a4344f6237c584b891" alt="환경 변수 업데이트" data-og-width="2888" width="2888" data-og-height="1914" height="1914" data-path="images/enterprise/update-env-vars.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=9afc7b7e194a371365d7b69edc0ddac6 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8ccb5b296eab23dd57cc241f7f445589 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=374a4a1f02dd73e7eb7e30e4de59b0ac 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=23357a7c2e61f08b456e20450eaa255f 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=bb82e60664a74c99ae0fa88dae8366a8 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/update-env-vars.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1d764223f3032607fd6d2577452c021a 2500w" />
</Frame>

5. 마지막으로, 변경 사항을 적용하려면 페이지 하단의 `Update Deployment` 버튼을 클릭합니다

<Note>
  환경 변수를 업데이트하면 새로운 배포가 트리거되지만, 이는 환경 설정만 업데이트하며 코드 자체는 변경되지 않습니다.
</Note>

1. 시스템이 crew를 다시 빌드하고 배포합니다
2. 실시간으로 배포 진행 상황을 모니터링할 수 있습니다
3. 완료되면 변경 사항이 예상대로 작동하는지 crew를 테스트합니다

<Tip>
  업데이트 후 문제가 발생하면 플랫폼에서 배포 로그를 확인하거나 지원팀에 문의하여 도움을 받을 수 있습니다.
</Tip>

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  crew 업데이트나 배포 문제 해결에 대해 지원이 필요하시면 지원팀에 문의해 주세요.
</Card>

---

## 생성 타임스탬프 (자동 생성)

**URL:** llms-txt#생성-타임스탬프-(자동-생성)

created_at = fingerprint.created_at  # datetime 객체

---

## E a busca usa filter_by="ano", filter_value=2024

**URL:** llms-txt#e-a-busca-usa-filter_by="ano",-filter_value=2024

---

## Crie um agente com funcionalidades do Linear

**URL:** llms-txt#crie-um-agente-com-funcionalidades-do-linear

linear_agent = Agent(
    role="Development Manager",
    goal="Gerenciar issues do Linear e acompanhar o progresso do desenvolvimento de forma eficiente",
    backstory="Um assistente de IA especializado em gerenciamento de projetos de desenvolvimento de software.",
    apps=['linear']
)

---

## ✅ Solution: Clear hierarchy and responsibilities

**URL:** llms-txt#✅-solution:-clear-hierarchy-and-responsibilities

**Contents:**
- 고급 협업 기능
  - 맞춤 협업 규칙

manager = Agent(role="Manager", allow_delegation=True)
specialist1 = Agent(role="Specialist A", allow_delegation=False)  # No re-delegation
specialist2 = Agent(role="Specialist B", allow_delegation=False)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 고급 협업 기능

### 맞춤 협업 규칙
```

---

## Load model and tokenizer

**URL:** llms-txt#load-model-and-tokenizer

tokenizer = AutoTokenizer.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')
model = AutoModel.from_pretrained('sentence-transformers/all-MiniLM-L6-v2')

def custom_embeddings(text: str) -> list[float]:
    # Tokenize and get model outputs
    inputs = tokenizer(text, return_tensors="pt", padding=True, truncation=True)
    outputs = model(**inputs)

# Use mean pooling to get text embedding
    embeddings = outputs.last_hidden_state.mean(dim=1)

# Convert to list of floats and return
    return embeddings[0].tolist()

---

## Access the metadata

**URL:** llms-txt#access-the-metadata

**Contents:**
- 지문(Fingerprint) 지속성

print(f"Agent metadata: {agent.fingerprint.metadata}")
python  theme={null}
original_fingerprint = agent.fingerprint.uuid_str

**Examples:**

Example 1 (unknown):
```unknown
## 지문(Fingerprint) 지속성

지문은 컴포넌트의 생애 주기 전체에 걸쳐 지속되고 변하지 않도록 설계되었습니다. 컴포넌트를 수정하더라도 지문은 동일하게 유지됩니다:
```

---

## Agent with strict context limits

**URL:** llms-txt#agent-with-strict-context-limits

**Contents:**
  - 올바른 설정 선택

strict_agent = Agent(
    role="Legal Document Reviewer",
    goal="Provide precise legal analysis without information loss",
    backstory="Legal expert requiring complete context for accurate analysis",
    respect_context_window=False,  # ❌ Stop execution on context limit
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**컨텍스트 한도를 초과하면 발생하는 일:**

* ❌ **오류 메시지**: `"Context length exceeded. Consider using smaller text or RAG tools from crewai_tools."`
* 🛑 **실행 중지**: 작업 실행이 즉시 중단됨
* 🔧 **수동 개입 필요**: 접근 방식을 직접 수정해야 함

### 올바른 설정 선택

#### 다음과 같은 경우 `respect_context_window=True` (기본값)을 사용하세요:

* **문서가 클 경우** 컨텍스트 제한을 초과할 수 있습니다
* **오래 지속되는 대화**에서 일부 요약이 허용되는 경우
* **연구 과제**에서 정확한 세부사항보다는 전체적인 컨텍스트가 더 중요한 경우
* **프로토타이핑 및 개발**에서 견고한 실행을 원하는 경우
```

---

## Crie uma ferramenta RAG para processamento de documentos grandes

**URL:** llms-txt#crie-uma-ferramenta-rag-para-processamento-de-documentos-grandes

rag_agent = Agent(
    role="Research Assistant",
    goal="Query large knowledge bases efficiently",
    backstory="Expert at using RAG tools for information retrieval",
    tools=[rag_tool],  # Usar RAG ao invés de grandes janelas de contexto
    respect_context_window=True,
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### 2. Use Fontes de Conhecimento
```

---

## Acessando a saída da tarefa

**URL:** llms-txt#acessando-a-saída-da-tarefa

**Contents:**
- Formatação Markdown na Saída
  - Usando Formatação Markdown

task_output = task.output

print(f"Descrição da Tarefa: {task_output.description}")
print(f"Resumo da Tarefa: {task_output.summary}")
print(f"Saída Bruta: {task_output.raw}")
if task_output.json_dict:
    print(f"Saída em JSON: {json.dumps(task_output.json_dict, indent=2)}")
if task_output.pydantic:
    print(f"Saída Pydantic: {task_output.pydantic}")
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Formatação Markdown na Saída

O parâmetro `markdown` ativa a formatação automática em markdown na saída das tarefas. Quando configurado como `True`, a tarefa irá instruir o agente a formatar a resposta final utilizando a sintaxe Markdown correta.

### Usando Formatação Markdown
```

---

## Ferramenta Stagehand

**URL:** llms-txt#ferramenta-stagehand

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/stagehandtool

Ferramenta de automação web que integra o Stagehand ao CrewAI para interação e automação em navegadores

---

## MultiOn Tool

**URL:** llms-txt#multion-tool

**Contents:**
- Visão Geral
- Instalação
- Passos para Começar
- Exemplo

Source: https://docs.crewai.com/pt-BR/tools/automation/multiontool

O `MultiOnTool` permite que agentes CrewAI naveguem e interajam com a web por meio de instruções em linguagem natural.

O `MultiOnTool` foi projetado para envolver as capacidades de navegação web do [MultiOn](https://docs.multion.ai/welcome), permitindo que agentes CrewAI controlem navegadores web usando instruções em linguagem natural. Esta ferramenta facilita a navegação fluida, tornando-se um recurso essencial para projetos que requerem interação dinâmica com dados web e automação de tarefas baseadas na web.

Para utilizar esta ferramenta, é necessário instalar o pacote MultiOn:

Você também precisará instalar a extensão de navegador do MultiOn e habilitar o uso da API.

## Passos para Começar

Para usar o `MultiOnTool` de forma eficaz, siga estes passos:

1. **Instale o CrewAI**: Certifique-se de que o pacote `crewai[tools]` esteja instalado em seu ambiente Python.
2. **Instale e utilize o MultiOn**: Siga a [documentação do MultiOn](https://docs.multion.ai/learn/browser-extension) para instalar a extensão de navegador do MultiOn.
3. **Habilite o Uso da API**: Clique na extensão do MultiOn na pasta de extensões do seu navegador (não no ícone flutuante do MultiOn na página web) para abrir as configurações da extensão. Clique na opção para habilitar a API (API Enabled).

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma tarefa de navegação web:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import MultiOnTool

**Examples:**

Example 1 (unknown):
```unknown
Você também precisará instalar a extensão de navegador do MultiOn e habilitar o uso da API.

## Passos para Começar

Para usar o `MultiOnTool` de forma eficaz, siga estes passos:

1. **Instale o CrewAI**: Certifique-se de que o pacote `crewai[tools]` esteja instalado em seu ambiente Python.
2. **Instale e utilize o MultiOn**: Siga a [documentação do MultiOn](https://docs.multion.ai/learn/browser-extension) para instalar a extensão de navegador do MultiOn.
3. **Habilite o Uso da API**: Clique na extensão do MultiOn na pasta de extensões do seu navegador (não no ícone flutuante do MultiOn na página web) para abrir as configurações da extensão. Clique na opção para habilitar a API (API Enabled).

## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma tarefa de navegação web:
```

---

## DOCX RAG 검색

**URL:** llms-txt#docx-rag-검색

Source: https://docs.crewai.com/ko/tools/file-document/docxsearchtool

DOCXSearchTool은 DOCX 문서 내에서 의미 기반 검색을 수행하도록 설계된 RAG 도구입니다.

---

## Ferramenta Composio

**URL:** llms-txt#ferramenta-composio

Source: https://docs.crewai.com/pt-BR/tools/automation/composiotool

O Composio oferece mais de 250 ferramentas prontas para produção para agentes de IA com gerenciamento de autenticação flexível.

---

## 날씨 서버에서 예보 도구만 가져오기

**URL:** llms-txt#날씨-서버에서-예보-도구만-가져오기

"https://weather.api.com/mcp#get_forecast"

---

## `FirecrawlSearchTool`

**URL:** llms-txt#`firecrawlsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo
- Argumentos

[Firecrawl](https://firecrawl.dev) é uma plataforma para rastrear e converter qualquer site em markdown limpo ou dados estruturados.

* Obtenha uma chave de API em [firecrawl.dev](https://firecrawl.dev) e defina-a nas variáveis de ambiente (`FIRECRAWL_API_KEY`).
* Instale o [Firecrawl SDK](https://github.com/mendableai/firecrawl) junto com o pacote `crewai[tools]`:

Utilize o FirecrawlSearchTool da seguinte forma para permitir que seu agente carregue sites:

* `api_key`: Opcional. Especifica a chave de API do Firecrawl. O padrão é a variável de ambiente `FIRECRAWL_API_KEY`.
* `query`: A string da consulta de busca a ser utilizada na pesquisa.
* `page_options`: Opcional. Opções para formatação dos resultados.
  * `onlyMainContent`: Opcional. Retorna somente o conteúdo principal da página, excluindo cabeçalhos, navegações, rodapés, etc.
  * `includeHtml`: Opcional. Inclui o conteúdo HTML bruto da página. Vai gerar uma chave html na resposta.
  * `fetchPageContent`: Opcional. Busca o conteúdo completo da página.
* `search_options`: Opcional. Opções para controle do comportamento de rastreamento.
  * `limit`: Opcional. Número máximo de páginas a rastrear.

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Utilize o FirecrawlSearchTool da seguinte forma para permitir que seu agente carregue sites:
```

---

## AMP 서비스의 특정 도구

**URL:** llms-txt#amp-서비스의-특정-도구

"crewai-amp:research-tools#pubmed_search"

---

## A impressão digital permanece inalterada

**URL:** llms-txt#a-impressão-digital-permanece-inalterada

**Contents:**
- Impressões digitais determinísticas

assert agent.fingerprint.uuid_str == original_fingerprint
python  theme={null}
from crewai.security import Fingerprint

**Examples:**

Example 1 (unknown):
```unknown
## Impressões digitais determinísticas

Apesar de não ser possível definir diretamente o UUID e o timestamp de criação, é possível criar impressões digitais determinísticas usando o método `generate` com uma seed:
```

---

## Stagehand 도구

**URL:** llms-txt#stagehand-도구

Source: https://docs.crewai.com/ko/tools/web-scraping/stagehandtool

Stagehand를 CrewAI와 통합하여 브라우저 상호작용 및 자동화를 수행하는 웹 자동화 도구

---

## Ideal para processamento de documentos

**URL:** llms-txt#ideal-para-processamento-de-documentos

document_processor = Agent(
    role="Document Analyst",
    goal="Extract insights from large research papers",
    backstory="Expert at analyzing extensive documentation",
    respect_context_window=True,  # Lida com documentos grandes sem problemas
    max_iter=50,  # Permite mais iterações para análises complexas
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### Use `respect_context_window=False` quando:

* **Precisão é crítica** e perda de informação é inaceitável
* **Tarefas jurídicas ou médicas** que requerem contexto completo
* **Revisão de código** onde detalhes perdidos podem causar bugs
* **Análise financeira** onde precisão é fundamental
```

---

## Weave Overview

**URL:** llms-txt#weave-overview

**Contents:**
- Setup Instructions
- Features
- Resources

[Weights & Biases (W\&B) Weave](https://weave-docs.wandb.ai/) is a framework for tracking, experimenting with, evaluating, deploying, and improving LLM-based applications.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.gif?s=4a933830e3e3cf146c4c87cb44d46475" alt="Overview of W&B Weave CrewAI tracing usage" data-og-width="852" width="852" data-og-height="480" height="480" data-path="images/weave-tracing.gif" data-optimize="true" data-opv="3" />

Weave provides comprehensive support for every stage of your CrewAI application development:

* **Tracing & Monitoring**: Automatically track LLM calls and application logic to debug and analyze production systems
* **Systematic Iteration**: Refine and iterate on prompts, datasets, and models
* **Evaluation**: Use custom or pre-built scorers to systematically assess and enhance agent performance
* **Guardrails**: Protect your agents with pre- and post-safeguards for content moderation and prompt safety

Weave automatically captures traces for your CrewAI applications, enabling you to monitor and analyze your agents' performance, interactions, and execution flow. This helps you build better evaluation datasets and optimize your agent workflows.

## Setup Instructions

<Steps>
  <Step title="Install required packages">
    
  </Step>

<Step title="Set up W&B Account">
    Sign up for a [Weights & Biases account](https://wandb.ai) if you haven't already. You'll need this to view your traces and metrics.
  </Step>

<Step title="Initialize Weave in Your Application">
    Add the following code to your application:

After initialization, Weave will provide a URL where you can view your traces and metrics.
  </Step>

<Step title="Create your Crews/Flows">
    
  </Step>

<Step title="View Traces in Weave">
    After running your CrewAI application, visit the Weave URL provided during initialization to view:

* LLM calls and their metadata
    * Agent interactions and task execution flow
    * Performance metrics like latency and token usage
    * Any errors or issues that occurred during execution

<Frame caption="Weave Tracing Dashboard">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f59e556fcc0ac8fcca8eaeef4c0551ae" alt="Weave tracing example with CrewAI" data-og-width="3456" width="3456" data-og-height="1986" height="1986" data-path="images/weave-tracing.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=42efb320cedff3209765027d4f47e187 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=85318181f2afd6237c71cecedfda8104 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6124c3113060320d39847c47faa02ac4 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=e04300ff38ddf3624acc078bacf6712e 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c0ba473c3fa41c2939df4e28bc1098b5 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/weave-tracing.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=6d860d735bc5a42fb68085fc4ef01b2c 2500w" />
    </Frame>
  </Step>
</Steps>

* Weave automatically captures all CrewAI operations: agent interactions and task executions; LLM calls with metadata and token usage; tool usage and results.
* The integration supports all CrewAI execution methods: `kickoff()`, `kickoff_for_each()`, `kickoff_async()`, and `kickoff_for_each_async()`.
* Automatic tracing of all [crewAI-tools](https://github.com/crewAIInc/crewAI-tools).
* Flow feature support with decorator patching (`@start`, `@listen`, `@router`, `@or_`, `@and_`).
* Track custom guardrails passed to CrewAI `Task` with `@weave.op()`.

For detailed information on what's supported, visit the [Weave CrewAI documentation](https://weave-docs.wandb.ai/guides/integrations/crewai/#getting-started-with-flow).

* [📘 Weave Documentation](https://weave-docs.wandb.ai)
* [📊 Example Weave x CrewAI dashboard](https://wandb.ai/ayut/crewai_demo/weave/traces?cols=%7B%22wb_run_id%22%3Afalse%2C%22attributes.weave.client_version%22%3Afalse%2C%22attributes.weave.os_name%22%3Afalse%2C%22attributes.weave.os_release%22%3Afalse%2C%22attributes.weave.os_version%22%3Afalse%2C%22attributes.weave.source%22%3Afalse%2C%22attributes.weave.sys_version%22%3Afalse%7D\&peekPath=%2Fayut%2Fcrewai_demo%2Fcalls%2F0195c838-38cb-71a2-8a15-651ecddf9d89)
* [🐦 X](https://x.com/weave_wb)

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Set up W&B Account">
    Sign up for a [Weights & Biases account](https://wandb.ai) if you haven't already. You'll need this to view your traces and metrics.
  </Step>

  <Step title="Initialize Weave in Your Application">
    Add the following code to your application:
```

Example 2 (unknown):
```unknown
After initialization, Weave will provide a URL where you can view your traces and metrics.
  </Step>

  <Step title="Create your Crews/Flows">
```

---

## Modelo criativo para gerar conteúdo

**URL:** llms-txt#modelo-criativo-para-gerar-conteúdo

content_llm = LLM(model="claude-3-5-sonnet-20241022", temperature=0.7)

---

## Langfuse Integration

**URL:** llms-txt#langfuse-integration

Source: https://docs.crewai.com/en/observability/langfuse

Learn how to integrate Langfuse with CrewAI via OpenTelemetry using OpenLit

---

## ✅ Enable delegation for coordinators and generalists

**URL:** llms-txt#✅-enable-delegation-for-coordinators-and-generalists

lead_agent = Agent(
    role="Content Lead",
    allow_delegation=True,  # Can delegate to specialists
    ...
)

---

## Create output directory if it doesn't exist

**URL:** llms-txt#create-output-directory-if-it-doesn't-exist

**Contents:**
- 7단계: 환경 변수 설정하기

os.makedirs('output', exist_ok=True)

def run():
    """
    Run the research crew.
    """
    inputs = {
        'topic': 'Artificial Intelligence in Healthcare'
    }

# Create and run the crew
    result = ResearchCrew().crew().kickoff(inputs=inputs)

# Print the result
    print("\n\n=== FINAL REPORT ===\n\n")
    print(result.raw)

print("\n\nReport has been saved to output/report.md")

if __name__ == "__main__":
    run()
sh  theme={null}
SERPER_API_KEY=your_serper_api_key

**Examples:**

Example 1 (unknown):
```unknown
이 스크립트는 환경을 준비하고, 리서치 주제를 지정하며, crew의 작업을 시작합니다. CrewAI의 강력함은 이 코드가 얼마나 간단한지에서 드러납니다. 여러 AI 에이전트를 관리하는 모든 복잡함이 프레임워크에 의해 처리됩니다.

## 7단계: 환경 변수 설정하기

프로젝트 루트에 `.env` 파일을 생성하고 API 키를 입력하세요:
```

---

## Create RAG tool for large document processing

**URL:** llms-txt#create-rag-tool-for-large-document-processing

rag_agent = Agent(
    role="Research Assistant",
    goal="Query large knowledge bases efficiently",
    backstory="Expert at using RAG tools for information retrieval",
    tools=[rag_tool],  # Use RAG instead of large context windows
    respect_context_window=True,
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
#### 2. 지식 소스 사용
```

---

## 여러 MCP 서버의 파라미터 정의

**URL:** llms-txt#여러-mcp-서버의-파라미터-정의

**Contents:**
- 연결 관리

server_params_list = [
    # Streamable HTTP 서버
    {
        "url": "http://localhost:8001/mcp", 
        "transport": "streamable-http"
    },
    # SSE 서버
    {
        "url": "http://localhost:8000/sse",
        "transport": "sse"
    },
    # StdIO 서버
    StdioServerParameters(
        command="python3",
        args=["servers/your_stdio_server.py"],
        env={"UV_PYTHON": "3.12", **os.environ},
    )
]

try:
    with MCPServerAdapter(server_params_list) as aggregated_tools:
        print(f"Available aggregated tools: {[tool.name for tool in aggregated_tools]}")

multi_server_agent = Agent(
            role="Versatile Assistant",
            goal="Utilize tools from local Stdio, remote SSE, and remote HTTP MCP servers.",
            backstory="An AI agent capable of leveraging a diverse set of tools from multiple sources.",
            tools=aggregated_tools, # All tools are available here
            verbose=True,
        )

... # Your other agent, tasks, and crew code here

except Exception as e:
    print(f"Error connecting to or using multiple MCP servers (Managed): {e}")
    print("Ensure all MCP servers are running and accessible with correct configurations.")

컨텍스트 매니저(`with` 문)를 사용할 때, `MCPServerAdapter`는 구성된 MCP 서버와의 모든 연결의 라이프사이클(시작 및 종료)을 관리합니다. 이를 통해 리소스 관리를 단순화하고, 컨텍스트를 종료할 때 모든 연결이 적절하게 닫히도록 보장할 수 있습니다.

---

## 3. 스트림 가능 HTTP 서버:

**URL:** llms-txt#3.-스트림-가능-http-서버:

server_params = {
    "url": "http://localhost:8001/mcp",
    "transport": "streamable-http"
}

---

## Busca JSON RAG

**URL:** llms-txt#busca-json-rag

Source: https://docs.crewai.com/pt-BR/tools/file-document/jsonsearchtool

O `JSONSearchTool` foi projetado para buscar arquivos JSON e retornar os resultados mais relevantes.

---

## Crie um agente focado em atualizar apresentações

**URL:** llms-txt#crie-um-agente-focado-em-atualizar-apresentações

updater_agent = Agent(
    role="Atualizador de Apresentações",
    goal="Atualizar e modificar apresentações existentes do Google Slides",
    backstory="Um assistente IA habilidoso em fazer atualizações precisas no conteúdo de apresentações.",
    apps=['google_slides/batch_update_presentation']
)

---

## 2. SSE 서버:

**URL:** llms-txt#2.-sse-서버:

server_params = {
    "url": "http://localhost:8000/sse",
    "transport": "sse"
}

---

## 선택자를 사용하여 특정 정보 추출

**URL:** llms-txt#선택자를-사용하여-특정-정보-추출

**Contents:**
  - 3. Observe 명령어

result = stagehand_tool.run(
    instruction="Extract the main article title and content", 
    url="https://example.com/blog/article",
    command_type="extract",
    selector=".article-container"  # 선택적 CSS 선택자
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 3. Observe 명령어

`observe` 명령어 유형은 웹페이지 요소를 식별하고 분석합니다.
```

---

## Task to send a follow-up email

**URL:** llms-txt#task-to-send-a-follow-up-email

send_email_task = Task(
    description="Send a follow-up email to john@example.com about the project update meeting",
    agent=gmail_agent,
    expected_output="Email sent successfully with confirmation"
)

---

## Langtrace 연동

**URL:** llms-txt#langtrace-연동

Source: https://docs.crewai.com/ko/observability/langtrace

외부 가시성 도구인 Langtrace를 사용하여 CrewAI 에이전트의 비용, 지연 시간 및 성능을 모니터링하는 방법.

---

## `CodeDocsSearchTool`

**URL:** llms-txt#`codedocssearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  **Experimental**: Ainda estamos trabalhando para melhorar as ferramentas, então pode haver comportamentos inesperados ou mudanças no futuro.
</Note>

O CodeDocsSearchTool é uma poderosa ferramenta RAG (Geração Aumentada por Recuperação) projetada para buscas semânticas em documentação de código.
Ela permite que usuários encontrem de forma eficiente informações ou tópicos específicos dentro da documentação de código. Ao fornecer um `docs_url` durante a inicialização,
a ferramenta restringe a busca àquele site de documentação em particular. Alternativamente, sem um `docs_url` específico,
ela realiza buscas em uma ampla variedade de documentações de código conhecidas ou descobertas durante sua execução, tornando-a versátil para diversas necessidades de busca em documentação.

Para começar a usar o CodeDocsSearchTool, primeiro instale o pacote crewai\_tools via pip:

Utilize o CodeDocsSearchTool conforme abaixo para realizar buscas em documentação de código:

```python Code theme={null}
from crewai_tools import CodeDocsSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Utilize o CodeDocsSearchTool conforme abaixo para realizar buscas em documentação de código:
```

---

## 배포 삭제

**URL:** llms-txt#배포-삭제

**Contents:**
- 옵션 2: 웹 인터페이스를 통한 직접 배포
- ⚠️ 환경 변수 보안 요구사항
  - 차단된 환경 변수 패턴
  - 허용된 예외
  - 네이밍 문제 해결 방법

crewai deploy remove <deployment_id>
bash  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 옵션 2: 웹 인터페이스를 통한 직접 배포

GitHub 계정을 연결하여 CrewAI AMP 웹 인터페이스를 통해 crews를 직접 배포할 수도 있습니다. 이 방법은 로컬 머신에서 CLI를 사용할 필요가 없습니다.

<Steps>
  <Step title="GitHub로 푸시하기">
    crew를 GitHub 저장소에 푸시해야 합니다. 아직 crew를 만들지 않았다면, [이 튜토리얼](/ko/quickstart)을 따라할 수 있습니다.
  </Step>

  <Step title="GitHub를 CrewAI AMP에 연결하기">
    1. [CrewAI AMP](https://app.crewai.com)에 로그인합니다.
    2. "Connect GitHub" 버튼을 클릭합니다.

    <Frame>
            <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=e622053d392d9ca0033bb88b34d82f8d" alt="Connect GitHub Button" data-og-width="1021" width="1021" data-og-height="327" height="327" data-path="images/enterprise/connect-github.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=67a2ba40e2c5dabacfafcb2359e569cf 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=533ddd0da6106dc71b9cbcd010f89a5c 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=d8a3f55321172ab1e4179c6d05f30b4d 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=5dc5f7c278ecc22125a1f641454cec2d 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=1d8f3da31bd39d97f37b7f405ef3b048 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/connect-github.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=7ce7bda27a7f94bb173f25fe9845a1cb 2500w" />
    </Frame>
  </Step>

  <Step title="저장소 선택하기">
    GitHub 계정을 연결한 후 배포할 저장소를 선택할 수 있습니다:

    <Frame>
            <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=937cf62f283090f134e299aa157aad22" alt="Select Repository" data-og-width="3366" width="3366" data-og-height="956" height="956" data-path="images/enterprise/select-repo.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=3f5167362c6836f644ab356b61c7f8db 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c1293a61ff1fba1b19b8669b942595da 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=8ac1c94be313ab5c3c3f64741e3696be 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=7991df0620583adeb443551dfbf8eeb8 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=1bf91d7875849fb251fa92c24c1564aa 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/select-repo.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=17ab305443f30d6f4796b2415564a3dc 2500w" />
    </Frame>
  </Step>

  <Step title="환경 변수 설정하기">
    배포 전에, LLM 제공업체 또는 기타 서비스에 연결할 환경 변수를 설정해야 합니다:

    1. 변수를 개별적으로 또는 일괄적으로 추가할 수 있습니다.
    2. 환경 변수는 `KEY=VALUE` 형식(한 줄에 하나씩)으로 입력합니다.

    <Frame>
            <img src="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=84aa7644b9a1e20eb2e38309ce274ccb" alt="Set Environment Variables" data-og-width="3386" width="3386" data-og-height="606" height="606" data-path="images/enterprise/set-env-variables.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=280&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=c5521837a0ea86776e2ac13883f72750 280w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=560&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=98882c7ba545f4a09bc2248af54bc1ac 560w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=840&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=884ffc4ddc80104657dd60429f262254 840w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=1100&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=6f811c643a2268d264d95a3701a4d151 1100w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=1650&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=efd5564b6b4ffe6d68654cbdc8e515cc 1650w, https://mintcdn.com/crewai/Tp3HEbbp9mp-dy3H/images/enterprise/set-env-variables.png?w=2500&fit=max&auto=format&n=Tp3HEbbp9mp-dy3H&q=85&s=51fb85358802539cb78c5dc7cf997b92 2500w" />
    </Frame>
  </Step>

  <Step title="Crew 배포하기">
    1. "Deploy" 버튼을 클릭하여 배포 프로세스를 시작합니다.
    2. 진행 바를 통해 진행 상황을 모니터링할 수 있습니다.
    3. 첫 번째 배포에는 일반적으로 약 10-15분 정도 소요되며, 이후 배포는 더 빠릅니다.

    <Frame>
            <img src="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=2eb5fa4cf040c65462a372b6667adc60" alt="Deploy Progress" data-og-width="3386" width="3386" data-og-height="1170" height="1170" data-path="images/enterprise/deploy-progress.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=280&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=91d47e6e3edc1df183acb360cbc6af1f 280w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=560&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=f917ef44ece66ef051db174b4dea47d8 560w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=840&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=dfc99edd2ff1678afa564ae33cb9c784 840w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=1100&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=522b1ce917f9ecd15aee60c0e2241965 1100w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=1650&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=62ab85baa7a80d6fb98c50fdb7d588c7 1650w, https://mintcdn.com/crewai/5SZbe87tsCWZY09V/images/enterprise/deploy-progress.png?w=2500&fit=max&auto=format&n=5SZbe87tsCWZY09V&q=85&s=3190fa0b08cfbcdc75d385bde06535fa 2500w" />
    </Frame>

    배포가 완료되면 다음을 확인할 수 있습니다:

    * crew의 고유 URL
    * crew API를 보호할 Bearer 토큰
    * 배포를 삭제해야 하는 경우 "Delete" 버튼
  </Step>
</Steps>

## ⚠️ 환경 변수 보안 요구사항

<Warning>
  **중요**: CrewAI AMP는 환경 변수 이름에 대한 보안 제한이 있으며, 이를 따르지 않을 경우 배포가 실패할 수 있습니다.
</Warning>

### 차단된 환경 변수 패턴

보안상의 이유로, 다음과 같은 환경 변수 명명 패턴은 **자동으로 필터링**되며 배포에 문제가 발생할 수 있습니다:

**차단된 패턴:**

* `_TOKEN`으로 끝나는 변수 (예: `MY_API_TOKEN`)
* `_PASSWORD`로 끝나는 변수 (예: `DB_PASSWORD`)
* `_SECRET`로 끝나는 변수 (예: `API_SECRET`)
* 특정 상황에서 `_KEY`로 끝나는 변수

**특정 차단 변수:**

* `GITHUB_USER`, `GITHUB_TOKEN`
* `AWS_REGION`, `AWS_DEFAULT_REGION`
* 다양한 내부 CrewAI 시스템 변수

### 허용된 예외

일부 변수는 차단된 패턴과 일치하더라도 명시적으로 허용됩니다:

* `AZURE_AD_TOKEN`
* `AZURE_OPENAI_AD_TOKEN`
* `ENTERPRISE_ACTION_TOKEN`
* `CREWAI_ENTEPRISE_TOOLS_TOKEN`

### 네이밍 문제 해결 방법

환경 변수 제한으로 인해 배포가 실패하는 경우:
```

---

## Inicializa a ferramenta com um caminho específico para arquivo XML

**URL:** llms-txt#inicializa-a-ferramenta-com-um-caminho-específico-para-arquivo-xml

---

## Proteção contra Alucinações

**URL:** llms-txt#proteção-contra-alucinações

**Contents:**
- Visão Geral
- O que são Alucinações?
- Uso Básico
  - Configurando a Proteção

Source: https://docs.crewai.com/pt-BR/enterprise/features/hallucination-guardrail

Previna e detecte alucinações de IA nas suas tarefas do CrewAI

A Proteção contra Alucinações é um recurso empresarial que valida o conteúdo gerado por IA para garantir que esteja fundamentado em fatos e não contenha alucinações. Ela analisa as saídas das tarefas em relação ao contexto de referência e fornece feedback detalhado quando é detectado conteúdo potencialmente alucinado.

## O que são Alucinações?

Alucinações em IA ocorrem quando modelos de linguagem geram conteúdos que parecem plausíveis, mas estão factualmente incorretos ou não são suportados pelo contexto fornecido. A Proteção contra Alucinações ajuda a prevenir esses problemas por meio de:

* Comparação das saídas com o contexto de referência
* Avaliação da fidelidade ao material de origem
* Fornecimento de feedback detalhado sobre conteúdo problemático
* Suporte a limiares personalizados para rigor da validação

### Configurando a Proteção

```python  theme={null}
from crewai.tasks.hallucination_guardrail import HallucinationGuardrail
from crewai import LLM

---

## Exemplo de tarefa para extrair manchetes de um site de notícias

**URL:** llms-txt#exemplo-de-tarefa-para-extrair-manchetes-de-um-site-de-notícias

scrape_task = Task(
    description="Extraia as principais manchetes da página inicial da CNN. Use o seletor CSS '.headline' para atingir os elementos de manchete.",
    expected_output="Uma lista das principais manchetes da CNN.",
    agent=web_scraper_agent,
)

---

## `S3ReaderTool`

**URL:** llms-txt#`s3readertool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

O `S3ReaderTool` foi projetado para ler arquivos de buckets Amazon S3. Esta ferramenta permite que os agentes CrewAI acessem e recuperem conteúdos armazenados no S3, tornando-a ideal para fluxos de trabalho que exigem leitura de dados, arquivos de configuração ou qualquer outro conteúdo armazenado no AWS S3.

Para utilizar esta ferramenta, é necessário instalar as dependências requeridas:

## Passos para Começar

Para usar o `S3ReaderTool` efetivamente, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários usando o comando acima.
2. **Configure as Credenciais AWS**: Defina suas credenciais AWS como variáveis de ambiente.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta.
4. **Especifique o Caminho S3**: Forneça o caminho S3 do arquivo que deseja ler.

O exemplo a seguir demonstra como utilizar o `S3ReaderTool` para ler um arquivo de um bucket S3:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools.aws.s3 import S3ReaderTool

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para usar o `S3ReaderTool` efetivamente, siga estes passos:

1. **Instale as Dependências**: Instale os pacotes necessários usando o comando acima.
2. **Configure as Credenciais AWS**: Defina suas credenciais AWS como variáveis de ambiente.
3. **Inicialize a Ferramenta**: Crie uma instância da ferramenta.
4. **Especifique o Caminho S3**: Forneça o caminho S3 do arquivo que deseja ler.

## Exemplo

O exemplo a seguir demonstra como utilizar o `S3ReaderTool` para ler um arquivo de um bucket S3:
```

---

## 코드 문서 RAG 검색

**URL:** llms-txt#코드-문서-rag-검색

Source: https://docs.crewai.com/ko/tools/search-research/codedocssearchtool

CodeDocsSearchTool은(는) 코드 문서 내에서 의미론적 검색을 위해 설계된 강력한 RAG(Retrieval-Augmented Generation) 도구입니다.

---

## 수동 연결 관리나 도구 구성이 필요 없습니다

**URL:** llms-txt#수동-연결-관리나-도구-구성이-필요-없습니다

**Contents:**
- 지원되는 참조 형식
  - 외부 MCP 원격 서버

**Examples:**

Example 1 (unknown):
```unknown
## 지원되는 참조 형식

### 외부 MCP 원격 서버
```

---

## Definir tarefas

**URL:** llms-txt#definir-tarefas

search_task = Task(
    description="""Search for relevant documents about the {query}.
    Your final answer should include:
    - The relevant information found
    - The similarity scores of the results
    - The metadata of the relevant documents""",
    agent=search_agent
)

answer_task = Task(
    description="""Given the context and metadata of relevant documents,
    generate a final answer based on the context.""",
    agent=answer_agent
)

---

## Configurar variáveis de ambiente

**URL:** llms-txt#configurar-variáveis-de-ambiente

**Contents:**
  - Passo 3: Inicializar OpenTelemetry com Braintrust
  - Passo 4: Criar uma Aplicação CrewAI

os.environ["BRAINTRUST_API_KEY"] = BRAINTRUST_API_KEY
os.environ["BRAINTRUST_PARENT"] = "project_name:crewai-demo"
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
python  theme={null}
import os
from typing import Any, Dict

from braintrust.otel import BraintrustSpanProcessor
from crewai import Agent, Crew, Task
from crewai.llm import LLM
from opentelemetry import trace
from opentelemetry.instrumentation.crewai import CrewAIInstrumentor
from opentelemetry.instrumentation.openai import OpenAIInstrumentor
from opentelemetry.sdk.trace import TracerProvider

def setup_tracing() -> None:
    """Configurar rastreamento OpenTelemetry com Braintrust."""
    current_provider = trace.get_tracer_provider()
    if isinstance(current_provider, TracerProvider):
        provider = current_provider
    else:
        provider = TracerProvider()
        trace.set_tracer_provider(provider)

provider.add_span_processor(BraintrustSpanProcessor())
    CrewAIInstrumentor().instrument(tracer_provider=provider)
    OpenAIInstrumentor().instrument(tracer_provider=provider)

setup_tracing()
python  theme={null}
from crewai import Agent, Crew, Process, Task
from crewai_tools import SerperDevTool

def create_crew() -> Crew:
    """Criar uma crew com múltiplos agentes para rastreamento abrangente."""
    llm = LLM(model="gpt-4o-mini")
    search_tool = SerperDevTool()

# Definir agentes com papéis específicos
    researcher = Agent(
        role="Analista de Pesquisa Sênior",
        goal="Descobrir desenvolvimentos de ponta em IA e ciência de dados",
        backstory="""Você trabalha em um think tank de tecnologia líder.
        Sua especialidade está em identificar tendências emergentes.
        Você tem talento para dissecar dados complexos e apresentar insights acionáveis.""",
        verbose=True,
        allow_delegation=False,
        llm=llm,
        tools=[search_tool],
    )

writer = Agent(
        role="Estrategista de Conteúdo Tecnológico",
        goal="Criar conteúdo envolvente sobre avanços tecnológicos",
        backstory="""Você é um Estrategista de Conteúdo renomado, conhecido por seus artigos perspicazes e envolventes.
        Você transforma conceitos complexos em narrativas convincentes.""",
        verbose=True,
        allow_delegation=True,
        llm=llm,
    )

# Criar tarefas para seus agentes
    research_task = Task(
        description="""Realize uma análise abrangente dos últimos avanços em {topic}.
        Identifique tendências principais, tecnologias revolucionárias e impactos potenciais na indústria.""",
        expected_output="Relatório de análise completo em pontos de bala",
        agent=researcher,
    )

writing_task = Task(
        description="""Usando os insights fornecidos, desenvolva um post de blog envolvente
        que destaque os avanços mais significativos em {topic}.
        Seu post deve ser informativo, mas acessível, atendendo a um público conhecedor de tecnologia.
        Faça soar legal, evite palavras complexas para não soar como IA.""",
        expected_output="Post de blog completo de pelo menos 4 parágrafos",
        agent=writer,
        context=[research_task],
    )

# Instanciar sua crew com um processo sequencial
    crew = Crew(
        agents=[researcher, writer], 
        tasks=[research_task, writing_task], 
        verbose=True, 
        process=Process.sequential
    )

def run_crew():
    """Executar a crew e retornar resultados."""
    crew = create_crew()
    result = crew.kickoff(inputs={"topic": "desenvolvimentos em IA"})
    return result

**Examples:**

Example 1 (unknown):
```unknown
### Passo 3: Inicializar OpenTelemetry com Braintrust

Inicialize a instrumentação OpenTelemetry do Braintrust para começar a capturar rastreamentos e enviá-los para o Braintrust.
```

Example 2 (unknown):
```unknown
### Passo 4: Criar uma Aplicação CrewAI

Vamos criar uma aplicação CrewAI onde dois agentes colaboram para pesquisar e escrever um post de blog sobre avanços em IA, com rastreamento abrangente habilitado.
```

---

## Primeira criação de agente - descobre ferramentas do servidor

**URL:** llms-txt#primeira-criação-de-agente---descobre-ferramentas-do-servidor

agente1 = Agent(role="Primeiro", goal="Teste", backstory="Teste",
               mcps=["https://api.example.com/mcp"])

---

## LangDB credentials

**URL:** llms-txt#langdb-credentials

export LANGDB_API_KEY="<your_langdb_api_key>"
export LANGDB_PROJECT_ID="<your_langdb_project_id>"
export LANGDB_API_BASE_URL='https://api.us-east-1.langdb.ai'

---

## List all available organizations

**URL:** llms-txt#list-all-available-organizations

<Note>
  When loading agents from repositories, you must be authenticated and switched to the correct organization. If you receive errors, check your authentication status and organization settings using the CLI commands above.
</Note>

---

## 커스텀 LLM 구현

**URL:** llms-txt#커스텀-llm-구현

**Contents:**
- 개요
- 빠른 시작
- 사용자 지정 LLM 사용하기

Source: https://docs.crewai.com/ko/learn/custom-llm

CrewAI에서 커스텀 LLM 구현을 만드는 방법을 알아보세요.

CrewAI는 `BaseLLM` 추상 기반 클래스를 통해 커스텀 LLM 구현을 지원합니다. 이를 통해 LiteLLM에 내장 지원이 없는 모든 LLM 제공자를 통합하거나, 커스텀 인증 메커니즘을 구현할 수 있습니다.

여기 최소한의 커스텀 LLM 구현 예시가 있습니다:

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
## 사용자 지정 LLM 사용하기
```

---

## "country": "us",  # Select a proxy location

**URL:** llms-txt#"country":-"us",--#-select-a-proxy-location

---

## To search any code documentation content

**URL:** llms-txt#to-search-any-code-documentation-content

---

## `FileWriterTool`

**URL:** llms-txt#`filewritertool`

**Contents:**
- Descrição
- Instalação
- Exemplo

O `FileWriterTool` é um componente do pacote crewai\_tools, projetado para simplificar o processo de escrita de conteúdo em arquivos com compatibilidade multiplataforma (Windows, Linux, macOS).\
É particularmente útil em cenários como geração de relatórios, salvamento de logs, criação de arquivos de configuração e mais.\
Essa ferramenta lida com diferenças de caminhos entre sistemas operacionais, suporta codificação UTF-8 e cria diretórios automaticamente caso eles não existam, facilitando a organização da sua saída de forma confiável em diferentes plataformas.

Instale o pacote crewai\_tools para utilizar o `FileWriterTool` em seus projetos:

Para começar a usar o `FileWriterTool`:

```python Code theme={null}
from crewai_tools import FileWriterTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

Para começar a usar o `FileWriterTool`:
```

---

## Esta configuração permite que o agente busque somente no arquivo CSV fornecido.

**URL:** llms-txt#esta-configuração-permite-que-o-agente-busque-somente-no-arquivo-csv-fornecido.

tool = CSVSearchTool(csv='path/to/your/csvfile.csv')

---

## Browserbase 웹 로더

**URL:** llms-txt#browserbase-웹-로더

Source: https://docs.crewai.com/ko/tools/web-scraping/browserbaseloadtool

Browserbase는 헤드리스 브라우저를 신뢰성 있게 실행, 관리 및 모니터링할 수 있는 개발자 플랫폼입니다.

---

## my_custom_listener.py

**URL:** llms-txt#my_custom_listener.py

from crewai.events import BaseEventListener

---

## Arize Phoenix 통합

**URL:** llms-txt#arize-phoenix-통합

**Contents:**
- 시작하기
  - 1단계: 의존성 설치
  - 2단계: 환경 변수 설정

이 가이드는 [OpenInference](https://github.com/openinference/openinference) SDK를 통해 OpenTelemetry를 사용하여 **Arize Phoenix**를 **CrewAI**와 통합하는 방법을 보여줍니다. 이 가이드를 완료하면 CrewAI agent를 추적하고 agent를 쉽게 디버그할 수 있습니다.

> **Arize Phoenix란?** [Arize Phoenix](https://phoenix.arize.com)는 AI 애플리케이션을 위한 추적 및 평가 기능을 제공하는 LLM 가시성(observability) 플랫폼입니다.

[![Phoenix와의 통합 영상 데모 보기](https://storage.googleapis.com/arize-assets/fixtures/setup_crewai.png)](https://www.youtube.com/watch?v=Yc5q3l6F7Ww)

CrewAI를 사용하고 OpenInference를 통해 OpenTelemetry와 Arize Phoenix를 연동하는 간단한 예제를 단계별로 안내합니다.

이 가이드는 [Google Colab](https://colab.research.google.com/github/Arize-ai/phoenix/blob/main/tutorials/tracing/crewai_tracing_tutorial.ipynb)에서도 확인하실 수 있습니다.

Phoenix Cloud API 키를 설정하고 OpenTelemetry를 구성하여 추적 정보를 Phoenix로 전송합니다. Phoenix Cloud는 Arize Phoenix의 호스팅 버전이지만, 이 통합을 사용하는 데 필수는 아닙니다.

무료 Serper API 키는 [여기](https://serper.dev/)에서 받을 수 있습니다.

```python  theme={null}
import os
from getpass import getpass

**Examples:**

Example 1 (unknown):
```unknown
### 2단계: 환경 변수 설정

Phoenix Cloud API 키를 설정하고 OpenTelemetry를 구성하여 추적 정보를 Phoenix로 전송합니다. Phoenix Cloud는 Arize Phoenix의 호스팅 버전이지만, 이 통합을 사용하는 데 필수는 아닙니다.

무료 Serper API 키는 [여기](https://serper.dev/)에서 받을 수 있습니다.
```

---

## When using Claude as your LLM...

**URL:** llms-txt#when-using-claude-as-your-llm...

agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    llm=LLM(provider="anthropic", model="claude-3-sonnet")  # Using Claude
)

---

## Define our flow state

**URL:** llms-txt#define-our-flow-state

**Contents:**
- 6단계: 환경 변수 설정하기

class GuideCreatorState(BaseModel):
    topic: str = ""
    audience_level: str = ""
    guide_outline: GuideOutline = None
    sections_content: Dict[str, str] = {}

class GuideCreatorFlow(Flow[GuideCreatorState]):
    """Flow for creating a comprehensive guide on any topic"""

@start()
    def get_user_input(self):
        """Get input from the user about the guide topic and audience"""
        print("\n=== Create Your Comprehensive Guide ===\n")

# Get user input
        self.state.topic = input("What topic would you like to create a guide for? ")

# Get audience level with validation
        while True:
            audience = input("Who is your target audience? (beginner/intermediate/advanced) ").lower()
            if audience in ["beginner", "intermediate", "advanced"]:
                self.state.audience_level = audience
                break
            print("Please enter 'beginner', 'intermediate', or 'advanced'")

print(f"\nCreating a guide on {self.state.topic} for {self.state.audience_level} audience...\n")
        return self.state

@listen(get_user_input)
    def create_guide_outline(self, state):
        """Create a structured outline for the guide using a direct LLM call"""
        print("Creating guide outline...")

# Initialize the LLM
        llm = LLM(model="openai/gpt-4o-mini", response_format=GuideOutline)

# Create the messages for the outline
        messages = [
            {"role": "system", "content": "You are a helpful assistant designed to output JSON."},
            {"role": "user", "content": f"""
            Create a detailed outline for a comprehensive guide on "{state.topic}" for {state.audience_level} level learners.

The outline should include:
            1. A compelling title for the guide
            2. An introduction to the topic
            3. 4-6 main sections that cover the most important aspects of the topic
            4. A conclusion or summary

For each section, provide a clear title and a brief description of what it should cover.
            """}
        ]

# Make the LLM call with JSON response format
        response = llm.call(messages=messages)

# Parse the JSON response
        outline_dict = json.loads(response)
        self.state.guide_outline = GuideOutline(**outline_dict)

# Ensure output directory exists before saving
        os.makedirs("output", exist_ok=True)

# Save the outline to a file
        with open("output/guide_outline.json", "w") as f:
            json.dump(outline_dict, f, indent=2)

print(f"Guide outline created with {len(self.state.guide_outline.sections)} sections")
        return self.state.guide_outline

@listen(create_guide_outline)
    def write_and_compile_guide(self, outline):
        """Write all sections and compile the guide"""
        print("Writing guide sections and compiling...")
        completed_sections = []

# Process sections one by one to maintain context flow
        for section in outline.sections:
            print(f"Processing section: {section.title}")

# Build context from previous sections
            previous_sections_text = ""
            if completed_sections:
                previous_sections_text = "# Previously Written Sections\n\n"
                for title in completed_sections:
                    previous_sections_text += f"## {title}\n\n"
                    previous_sections_text += self.state.sections_content.get(title, "") + "\n\n"
            else:
                previous_sections_text = "No previous sections written yet."

# Run the content crew for this section
            result = ContentCrew().crew().kickoff(inputs={
                "section_title": section.title,
                "section_description": section.description,
                "audience_level": self.state.audience_level,
                "previous_sections": previous_sections_text,
                "draft_content": ""
            })

# Store the content
            self.state.sections_content[section.title] = result.raw
            completed_sections.append(section.title)
            print(f"Section completed: {section.title}")

# Compile the final guide
        guide_content = f"# {outline.title}\n\n"
        guide_content += f"## Introduction\n\n{outline.introduction}\n\n"

# Add each section in order
        for section in outline.sections:
            section_content = self.state.sections_content.get(section.title, "")
            guide_content += f"\n\n{section_content}\n\n"

# Add conclusion
        guide_content += f"## Conclusion\n\n{outline.conclusion}\n\n"

# Save the guide
        with open("output/complete_guide.md", "w") as f:
            f.write(guide_content)

print("\nComplete guide compiled and saved to output/complete_guide.md")
        return "Guide creation completed successfully"

def kickoff():
    """Run the guide creator flow"""
    GuideCreatorFlow().kickoff()
    print("\n=== Flow Complete ===")
    print("Your comprehensive guide is ready in the output directory.")
    print("Open output/complete_guide.md to view it.")

def plot():
    """Generate a visualization of the flow"""
    flow = GuideCreatorFlow()
    flow.plot("guide_creator_flow")
    print("Flow visualization saved to guide_creator_flow.html")

if __name__ == "__main__":
    kickoff()
sh .env theme={null}
OPENAI_API_KEY=your_openai_api_key

**Examples:**

Example 1 (unknown):
```unknown
이 플로우에서 일어나는 과정을 분석해봅시다:

1. 구조화된 데이터에 대한 Pydantic 모델을 정의하여 타입 안전성과 명확한 데이터 표현을 보장합니다.
2. 플로우 단계별로 데이터를 유지하기 위한 state 클래스를 생성합니다.
3. 세 가지 주요 플로우 단계를 구현합니다:
   * `@start()` 데코레이터로 사용자 입력을 받습니다.
   * 직접 LLM 호출로 가이드 개요를 생성합니다.
   * content crew로 각 섹션을 처리합니다.
4. `@listen()` 데코레이터를 활용해 단계 간 이벤트 기반 관계를 설정합니다.

이것이 바로 flows의 힘입니다 - 다양한 처리 유형(사용자 상호작용, 직접적인 LLM 호출, crew 기반 작업)을 하나의 일관된 이벤트 기반 시스템으로 결합할 수 있습니다.

## 6단계: 환경 변수 설정하기

프로젝트 루트에 `.env` 파일을 생성하고 API 키를 입력하세요. 공급자 구성에 대한 자세한 내용은 [LLM 설정 가이드](/ko/concepts/llms#setting-up-your-llm)를 참고하세요.
```

---

## Crie um agente com capacidades HubSpot

**URL:** llms-txt#crie-um-agente-com-capacidades-hubspot

hubspot_agent = Agent(
    role="CRM Manager",
    goal="Manage company and contact records in HubSpot",
    backstory="An AI assistant specialized in CRM management.",
    apps=['hubspot']
)

---

## Print raw result first

**URL:** llms-txt#print-raw-result-first

print("Raw result:", result)

---

## Complex documentation automation task

**URL:** llms-txt#complex-documentation-automation-task

**Contents:**
- Solução de Problemas
  - Problemas Comuns
  - Obtendo Ajuda

automation_task = Task(
    description="""
    1. Search for pages that haven't been updated in the last 30 days
    2. Review and update outdated content blocks
    3. Create weekly team update pages with consistent formatting
    4. Add status indicators and progress tracking to project pages
    5. Generate monthly documentation health reports
    6. Archive completed project pages and organize them in archive sections
    """,
    agent=doc_automator,
    expected_output="Documentation automated with updated content, weekly reports, and organized archives"
)

crew = Crew(
    agents=[doc_automator],
    tasks=[automation_task]
)

## Solução de Problemas

**Erros de Permissão**

* Certifique-se de que sua conta Notion possui acesso de edição ao workspace desejado
* Verifique se a conexão OAuth inclui os escopos necessários para a API do Notion
* Confira se as páginas e bancos de dados estão compartilhados com a integração autenticada

**IDs de Página e Bloco Inválidos**

* Revise os IDs de página e bloco para garantir que estejam no formato UUID correto
* Garanta que as páginas e blocos referenciados existem e são acessíveis
* Verifique se os IDs da página ou banco de dados pai são válidos ao criar novas páginas

**Problemas com Schema de Propriedades**

* Assegure que as propriedades da página correspondem ao schema do banco de dados ao criar páginas em bancos de dados
* Verifique se os nomes e tipos das propriedades estão corretos para o banco de dados alvo
* Confirme que as propriedades obrigatórias estão incluídas ao criar ou atualizar páginas

**Estrutura dos Blocos de Conteúdo**

* Assegure que o conteúdo dos blocos segue as especificações de rich text do Notion
* Verifique se estruturas aninhadas de blocos estão devidamente formatadas
* Confira se URLs de mídias são acessíveis e estão corretamente formatadas

**Problemas de Pesquisa e Filtros**

* Certifique-se de que as queries de pesquisa estão devidamente formatadas e não estão vazias
* Use nomes de campos válidos em fórmulas de filtro: `query`, `filter.value`, `direction`, `page_size`
* Teste pesquisas simples antes de construir condições de filtro mais complexas

**Relacionamentos Pai-Filho**

* Verifique se a página ou banco de dados pai existe antes de criar páginas filhas
* Assegure que existam permissões apropriadas para o container pai
* Confirme que os schemas do banco permitem definir as propriedades desejadas

**Rich Text e Conteúdo de Mídia**

* Assegure que URLs para imagens externas, PDFs e bookmarks sejam acessíveis
* Verifique se a formatação rich text segue as especificações da API do Notion
* Confira se os tipos de linguagem nos blocos de código são suportados pelo Notion

**Operações de Arquivamento e Exclusão**

* Entenda a diferença entre arquivar (reversível) e excluir (permanente)
* Certifique-se de ter permissões para arquivar ou excluir o conteúdo desejado
* Tenha cuidado com operações em massa que possam afetar múltiplas páginas ou blocos

<Card title="Precisa de ajuda?" icon="headset" href="mailto:support@crewai.com">
  Entre em contato com nosso time de suporte para auxílio na configuração ou solução de problemas com a integração Notion.
</Card>

---

## Firecrawl Search

**URL:** llms-txt#firecrawl-search

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/firecrawlsearchtool

O `FirecrawlSearchTool` foi projetado para pesquisar sites e convertê-los em markdown limpo ou dados estruturados.

---

## Crie seu agente

**URL:** llms-txt#crie-seu-agente

agent = Agent(
    role="Data Analyst",
    goal="Analyze data and provide insights",
    backstory="You are an expert data analyst with 10 years of experience.",
    verbose=True
)

---

## PDF Text Writing Tool

**URL:** llms-txt#pdf-text-writing-tool

Source: https://docs.crewai.com/pt-BR/tools/file-document/pdf-text-writing-tool

The `PDFTextWritingTool` writes text to specific positions in a PDF, supporting custom fonts.

---

## Google Contacts 통합

**URL:** llms-txt#google-contacts-통합

**Contents:**
- 개요
- 전제 조건
- Google Contacts 통합 설정
  - 1. Google 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Google Contacts 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/google_contacts

CrewAI를 위한 Google Contacts 통합으로 연락처 및 디렉토리 관리.

에이전트가 Google Contacts를 통해 연락처와 디렉토리 정보를 관리할 수 있도록 합니다. 개인 연락처에 액세스하고, 디렉토리 사람들을 검색하고, 연락처 정보를 생성 및 업데이트하고, AI 기반 자동화로 연락처 그룹을 관리합니다.

Google Contacts 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* Google Contacts 액세스 권한이 있는 Google 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Google 계정 연결

## Google Contacts 통합 설정

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Google Contacts** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 연락처 및 디렉토리 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="google_contacts/get_contacts">
    **설명:** Google Contacts에서 사용자의 연락처를 검색합니다.

* `pageSize` (integer, 선택사항): 반환할 연락처 수 (최대 1000). 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 검색할 페이지의 토큰.
    * `personFields` (string, 선택사항): 포함할 필드 (예: 'names,emailAddresses,phoneNumbers'). 기본값: names,emailAddresses,phoneNumbers
    * `requestSyncToken` (boolean, 선택사항): 응답에 동기화 토큰을 포함할지 여부. 기본값: false
    * `sortOrder` (string, 선택사항): 연결을 정렬할 순서. 옵션: LAST\_MODIFIED\_ASCENDING, LAST\_MODIFIED\_DESCENDING, FIRST\_NAME\_ASCENDING, LAST\_NAME\_ASCENDING
  </Accordion>

<Accordion title="google_contacts/search_contacts">
    **설명:** 쿼리 문자열을 사용하여 연락처를 검색합니다.

* `query` (string, 필수): 검색 쿼리 문자열
    * `readMask` (string, 필수): 읽을 필드 (예: 'names,emailAddresses,phoneNumbers')
    * `pageSize` (integer, 선택사항): 반환할 결과 수. 최소: 1, 최대: 30
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `sources` (array, 선택사항): 검색할 소스. 옵션: READ\_SOURCE\_TYPE\_CONTACT, READ\_SOURCE\_TYPE\_PROFILE. 기본값: READ\_SOURCE\_TYPE\_CONTACT
  </Accordion>

<Accordion title="google_contacts/list_directory_people">
    **설명:** 인증된 사용자의 디렉토리에 있는 사람들을 나열합니다.

* `sources` (array, 필수): 검색할 디렉토리 소스. 옵션: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE, DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_CONTACT. 기본값: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE
    * `pageSize` (integer, 선택사항): 반환할 사람 수. 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `readMask` (string, 선택사항): 읽을 필드 (예: 'names,emailAddresses')
    * `requestSyncToken` (boolean, 선택사항): 응답에 동기화 토큰을 포함할지 여부. 기본값: false
    * `mergeSources` (array, 선택사항): 디렉토리 사람 응답에 병합할 추가 데이터. 옵션: CONTACT
  </Accordion>

<Accordion title="google_contacts/search_directory_people">
    **설명:** 디렉토리에서 사람을 검색합니다.

* `query` (string, 필수): 검색 쿼리
    * `sources` (string, 필수): 디렉토리 소스 ('DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE' 사용)
    * `pageSize` (integer, 선택사항): 반환할 결과 수
    * `readMask` (string, 선택사항): 읽을 필드
  </Accordion>

<Accordion title="google_contacts/list_other_contacts">
    **설명:** 기타 연락처를 나열합니다 (사용자의 개인 연락처에 없는).

* `pageSize` (integer, 선택사항): 반환할 연락처 수. 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `readMask` (string, 선택사항): 읽을 필드
    * `requestSyncToken` (boolean, 선택사항): 응답에 동기화 토큰을 포함할지 여부. 기본값: false
  </Accordion>

<Accordion title="google_contacts/search_other_contacts">
    **설명:** 기타 연락처를 검색합니다.

* `query` (string, 필수): 검색 쿼리
    * `readMask` (string, 필수): 읽을 필드 (예: 'names,emailAddresses')
    * `pageSize` (integer, 선택사항): 결과 수
  </Accordion>

<Accordion title="google_contacts/get_person">
    **설명:** 리소스 이름으로 한 사람의 연락처 정보를 가져옵니다.

* `resourceName` (string, 필수): 가져올 사람의 리소스 이름 (예: 'people/c123456789')
    * `personFields` (string, 선택사항): 포함할 필드 (예: 'names,emailAddresses,phoneNumbers'). 기본값: names,emailAddresses,phoneNumbers
  </Accordion>

<Accordion title="google_contacts/create_contact">
    **설명:** 사용자의 주소록에 새 연락처를 만듭니다.

* `names` (array, 선택사항): 사람의 이름들. 각 항목은 `givenName` (string), `familyName` (string), `displayName` (string)이 있는 객체.
    * `emailAddresses` (array, 선택사항): 이메일 주소들. 각 항목은 `value` (string, 이메일 주소)와 `type` (string, 'home', 'work', 'other', 기본값 'other')이 있는 객체.
    * `phoneNumbers` (array, 선택사항): 전화번호들. 각 항목은 `value` (string, 전화번호)와 `type` (string, 'home', 'work', 'mobile', 'other', 기본값 'other')이 있는 객체.
    * `addresses` (array, 선택사항): 우편 주소들. 각 항목은 `formattedValue` (string, 형식화된 주소)와 `type` (string, 'home', 'work', 'other', 기본값 'other')이 있는 객체.
    * `organizations` (array, 선택사항): 조직/회사들. 각 항목은 `name` (string, 조직 이름), `title` (string, 직책), `type` (string, 'work', 'other', 기본값 'work')이 있는 객체.
  </Accordion>

<Accordion title="google_contacts/update_contact">
    **설명:** 기존 연락처의 정보를 업데이트합니다.

* `resourceName` (string, 필수): 업데이트할 사람의 리소스 이름 (예: 'people/c123456789').
    * `updatePersonFields` (string, 필수): 업데이트할 필드 (예: 'names,emailAddresses,phoneNumbers').
    * `names` (array, 선택사항): 사람의 이름들. 각 항목은 `givenName` (string), `familyName` (string), `displayName` (string)이 있는 객체.
    * `emailAddresses` (array, 선택사항): 이메일 주소들. 각 항목은 `value` (string, 이메일 주소)와 `type` (string, 'home', 'work', 'other')이 있는 객체.
    * `phoneNumbers` (array, 선택사항): 전화번호들. 각 항목은 `value` (string, 전화번호)와 `type` (string, 'home', 'work', 'mobile', 'other')이 있는 객체.
  </Accordion>

<Accordion title="google_contacts/delete_contact">
    **설명:** 사용자의 주소록에서 연락처를 삭제합니다.

* `resourceName` (string, 필수): 삭제할 사람의 리소스 이름 (예: 'people/c123456789').
  </Accordion>

<Accordion title="google_contacts/batch_get_people">
    **설명:** 한 번의 요청으로 여러 사람에 대한 정보를 가져옵니다.

* `resourceNames` (array, 필수): 가져올 사람들의 리소스 이름 (최대 200개 항목).
    * `personFields` (string, 선택사항): 포함할 필드 (예: 'names,emailAddresses,phoneNumbers'). 기본값: names,emailAddresses,phoneNumbers
  </Accordion>

<Accordion title="google_contacts/list_contact_groups">
    **설명:** 사용자의 연락처 그룹(라벨)을 나열합니다.

* `pageSize` (integer, 선택사항): 반환할 연락처 그룹 수. 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `groupFields` (string, 선택사항): 포함할 필드 (예: 'name,memberCount,clientData'). 기본값: name,memberCount
  </Accordion>

<Accordion title="google_contacts/get_contact_group">
    **설명:** 리소스 이름으로 특정 연락처 그룹을 가져옵니다.

* `resourceName` (string, 필수): 연락처 그룹의 리소스 이름 (예: 'contactGroups/myContactGroup').
    * `maxMembers` (integer, 선택사항): 포함할 최대 멤버 수. 최소: 0, 최대: 20000
    * `groupFields` (string, 선택사항): 포함할 필드 (예: 'name,memberCount,clientData'). 기본값: name,memberCount
  </Accordion>

<Accordion title="google_contacts/create_contact_group">
    **설명:** 새 연락처 그룹(라벨)을 만듭니다.

* `name` (string, 필수): 연락처 그룹의 이름.
    * `clientData` (array, 선택사항): 클라이언트별 데이터. 각 항목은 `key` (string)와 `value` (string)가 있는 객체.
  </Accordion>
</AccordionGroup>

### 기본 Google Contacts 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="google_contacts/get_contacts">
    **설명:** Google Contacts에서 사용자의 연락처를 검색합니다.

    **매개변수:**

    * `pageSize` (integer, 선택사항): 반환할 연락처 수 (최대 1000). 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 검색할 페이지의 토큰.
    * `personFields` (string, 선택사항): 포함할 필드 (예: 'names,emailAddresses,phoneNumbers'). 기본값: names,emailAddresses,phoneNumbers
    * `requestSyncToken` (boolean, 선택사항): 응답에 동기화 토큰을 포함할지 여부. 기본값: false
    * `sortOrder` (string, 선택사항): 연결을 정렬할 순서. 옵션: LAST\_MODIFIED\_ASCENDING, LAST\_MODIFIED\_DESCENDING, FIRST\_NAME\_ASCENDING, LAST\_NAME\_ASCENDING
  </Accordion>

  <Accordion title="google_contacts/search_contacts">
    **설명:** 쿼리 문자열을 사용하여 연락처를 검색합니다.

    **매개변수:**

    * `query` (string, 필수): 검색 쿼리 문자열
    * `readMask` (string, 필수): 읽을 필드 (예: 'names,emailAddresses,phoneNumbers')
    * `pageSize` (integer, 선택사항): 반환할 결과 수. 최소: 1, 최대: 30
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `sources` (array, 선택사항): 검색할 소스. 옵션: READ\_SOURCE\_TYPE\_CONTACT, READ\_SOURCE\_TYPE\_PROFILE. 기본값: READ\_SOURCE\_TYPE\_CONTACT
  </Accordion>

  <Accordion title="google_contacts/list_directory_people">
    **설명:** 인증된 사용자의 디렉토리에 있는 사람들을 나열합니다.

    **매개변수:**

    * `sources` (array, 필수): 검색할 디렉토리 소스. 옵션: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE, DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_CONTACT. 기본값: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE
    * `pageSize` (integer, 선택사항): 반환할 사람 수. 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `readMask` (string, 선택사항): 읽을 필드 (예: 'names,emailAddresses')
    * `requestSyncToken` (boolean, 선택사항): 응답에 동기화 토큰을 포함할지 여부. 기본값: false
    * `mergeSources` (array, 선택사항): 디렉토리 사람 응답에 병합할 추가 데이터. 옵션: CONTACT
  </Accordion>

  <Accordion title="google_contacts/search_directory_people">
    **설명:** 디렉토리에서 사람을 검색합니다.

    **매개변수:**

    * `query` (string, 필수): 검색 쿼리
    * `sources` (string, 필수): 디렉토리 소스 ('DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE' 사용)
    * `pageSize` (integer, 선택사항): 반환할 결과 수
    * `readMask` (string, 선택사항): 읽을 필드
  </Accordion>

  <Accordion title="google_contacts/list_other_contacts">
    **설명:** 기타 연락처를 나열합니다 (사용자의 개인 연락처에 없는).

    **매개변수:**

    * `pageSize` (integer, 선택사항): 반환할 연락처 수. 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `readMask` (string, 선택사항): 읽을 필드
    * `requestSyncToken` (boolean, 선택사항): 응답에 동기화 토큰을 포함할지 여부. 기본값: false
  </Accordion>

  <Accordion title="google_contacts/search_other_contacts">
    **설명:** 기타 연락처를 검색합니다.

    **매개변수:**

    * `query` (string, 필수): 검색 쿼리
    * `readMask` (string, 필수): 읽을 필드 (예: 'names,emailAddresses')
    * `pageSize` (integer, 선택사항): 결과 수
  </Accordion>

  <Accordion title="google_contacts/get_person">
    **설명:** 리소스 이름으로 한 사람의 연락처 정보를 가져옵니다.

    **매개변수:**

    * `resourceName` (string, 필수): 가져올 사람의 리소스 이름 (예: 'people/c123456789')
    * `personFields` (string, 선택사항): 포함할 필드 (예: 'names,emailAddresses,phoneNumbers'). 기본값: names,emailAddresses,phoneNumbers
  </Accordion>

  <Accordion title="google_contacts/create_contact">
    **설명:** 사용자의 주소록에 새 연락처를 만듭니다.

    **매개변수:**

    * `names` (array, 선택사항): 사람의 이름들. 각 항목은 `givenName` (string), `familyName` (string), `displayName` (string)이 있는 객체.
    * `emailAddresses` (array, 선택사항): 이메일 주소들. 각 항목은 `value` (string, 이메일 주소)와 `type` (string, 'home', 'work', 'other', 기본값 'other')이 있는 객체.
    * `phoneNumbers` (array, 선택사항): 전화번호들. 각 항목은 `value` (string, 전화번호)와 `type` (string, 'home', 'work', 'mobile', 'other', 기본값 'other')이 있는 객체.
    * `addresses` (array, 선택사항): 우편 주소들. 각 항목은 `formattedValue` (string, 형식화된 주소)와 `type` (string, 'home', 'work', 'other', 기본값 'other')이 있는 객체.
    * `organizations` (array, 선택사항): 조직/회사들. 각 항목은 `name` (string, 조직 이름), `title` (string, 직책), `type` (string, 'work', 'other', 기본값 'work')이 있는 객체.
  </Accordion>

  <Accordion title="google_contacts/update_contact">
    **설명:** 기존 연락처의 정보를 업데이트합니다.

    **매개변수:**

    * `resourceName` (string, 필수): 업데이트할 사람의 리소스 이름 (예: 'people/c123456789').
    * `updatePersonFields` (string, 필수): 업데이트할 필드 (예: 'names,emailAddresses,phoneNumbers').
    * `names` (array, 선택사항): 사람의 이름들. 각 항목은 `givenName` (string), `familyName` (string), `displayName` (string)이 있는 객체.
    * `emailAddresses` (array, 선택사항): 이메일 주소들. 각 항목은 `value` (string, 이메일 주소)와 `type` (string, 'home', 'work', 'other')이 있는 객체.
    * `phoneNumbers` (array, 선택사항): 전화번호들. 각 항목은 `value` (string, 전화번호)와 `type` (string, 'home', 'work', 'mobile', 'other')이 있는 객체.
  </Accordion>

  <Accordion title="google_contacts/delete_contact">
    **설명:** 사용자의 주소록에서 연락처를 삭제합니다.

    **매개변수:**

    * `resourceName` (string, 필수): 삭제할 사람의 리소스 이름 (예: 'people/c123456789').
  </Accordion>

  <Accordion title="google_contacts/batch_get_people">
    **설명:** 한 번의 요청으로 여러 사람에 대한 정보를 가져옵니다.

    **매개변수:**

    * `resourceNames` (array, 필수): 가져올 사람들의 리소스 이름 (최대 200개 항목).
    * `personFields` (string, 선택사항): 포함할 필드 (예: 'names,emailAddresses,phoneNumbers'). 기본값: names,emailAddresses,phoneNumbers
  </Accordion>

  <Accordion title="google_contacts/list_contact_groups">
    **설명:** 사용자의 연락처 그룹(라벨)을 나열합니다.

    **매개변수:**

    * `pageSize` (integer, 선택사항): 반환할 연락처 그룹 수. 최소: 1, 최대: 1000
    * `pageToken` (string, 선택사항): 반환할 결과 페이지를 지정하는 토큰.
    * `groupFields` (string, 선택사항): 포함할 필드 (예: 'name,memberCount,clientData'). 기본값: name,memberCount
  </Accordion>

  <Accordion title="google_contacts/get_contact_group">
    **설명:** 리소스 이름으로 특정 연락처 그룹을 가져옵니다.

    **매개변수:**

    * `resourceName` (string, 필수): 연락처 그룹의 리소스 이름 (예: 'contactGroups/myContactGroup').
    * `maxMembers` (integer, 선택사항): 포함할 최대 멤버 수. 최소: 0, 최대: 20000
    * `groupFields` (string, 선택사항): 포함할 필드 (예: 'name,memberCount,clientData'). 기본값: name,memberCount
  </Accordion>

  <Accordion title="google_contacts/create_contact_group">
    **설명:** 새 연락처 그룹(라벨)을 만듭니다.

    **매개변수:**

    * `name` (string, 필수): 연락처 그룹의 이름.
    * `clientData` (array, 선택사항): 클라이언트별 데이터. 각 항목은 `key` (string)와 `value` (string)가 있는 객체.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Google Contacts 에이전트 설정
```

---

## PG RAG Search

**URL:** llms-txt#pg-rag-search

**Contents:**
- Visão geral
- Descrição
- Instalação
- Exemplo de Uso

Source: https://docs.crewai.com/pt-BR/tools/database-data/pgsearchtool

O `PGSearchTool` foi desenvolvido para pesquisar bancos de dados PostgreSQL e retornar os resultados mais relevantes.

<Note>
  O PGSearchTool está atualmente em desenvolvimento. Este documento descreve a funcionalidade e a interface pretendidas.
  Conforme o desenvolvimento avança, esteja ciente de que alguns recursos podem não estar disponíveis ou podem mudar.
</Note>

O PGSearchTool é concebido como uma ferramenta poderosa para facilitar buscas semânticas em tabelas de bancos de dados PostgreSQL. Aproveitando tecnologia avançada de Recuperação e Geração (RAG),
ele visa fornecer um meio eficiente para consultar o conteúdo de tabelas de banco de dados, especificamente voltado para bancos de dados PostgreSQL.
O objetivo da ferramenta é simplificar o processo de encontrar dados relevantes por meio de consultas semânticas, oferecendo um recurso valioso para usuários que precisam realizar buscas avançadas em
grandes volumes de dados dentro de um ambiente PostgreSQL.

O pacote `crewai_tools`, que incluirá o PGSearchTool assim que for lançado, pode ser instalado usando o comando abaixo:

<Note>
  O PGSearchTool ainda não está disponível na versão atual do pacote `crewai_tools`. Este comando de instalação será atualizado assim que a ferramenta for lançada.
</Note>

Abaixo está um exemplo proposto mostrando como utilizar o PGSearchTool para realizar uma busca semântica em uma tabela dentro de um banco de dados PostgreSQL:

```python Code theme={null}
from crewai_tools import PGSearchTool

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  O PGSearchTool ainda não está disponível na versão atual do pacote `crewai_tools`. Este comando de instalação será atualizado assim que a ferramenta for lançada.
</Note>

## Exemplo de Uso

Abaixo está um exemplo proposto mostrando como utilizar o PGSearchTool para realizar uma busca semântica em uma tabela dentro de um banco de dados PostgreSQL:
```

---

## Integração com GitHub

**URL:** llms-txt#integração-com-github

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com GitHub
  - 1. Conecte sua conta GitHub
  - 2. Instale o pacote necessário
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de Agente GitHub

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/github

Gerenciamento de repositórios e issues com a integração do GitHub para CrewAI.

Permita que seus agentes gerenciem repositórios, issues e releases através do GitHub. Crie e atualize issues, gerencie releases, acompanhe o desenvolvimento do projeto e otimize seu fluxo de trabalho de desenvolvimento de software com automação alimentada por IA.

Antes de usar a integração do GitHub, assegure-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta GitHub com permissões adequadas no repositório
* Conta do GitHub conectada através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com GitHub

### 1. Conecte sua conta GitHub

1. Acesse [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **GitHub** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de repositório e issues
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o pacote necessário

<AccordionGroup>
  <Accordion title="github/create_issue">
    **Descrição:** Cria uma issue no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `title` (string, obrigatório): Título da Issue - Especifique o título da issue a ser criada.
    * `body` (string, opcional): Corpo da Issue - Especifique o conteúdo do corpo da issue a ser criada.
    * `assignees` (string, opcional): Responsáveis - Especifique o login dos responsáveis no GitHub como um array de strings para esta issue. (exemplo: `["octocat"]`).
  </Accordion>

<Accordion title="github/update_issue">
    **Descrição:** Atualiza uma issue no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `issue_number` (string, obrigatório): Número da Issue - Especifique o número da issue a ser atualizada.
    * `title` (string, obrigatório): Título da Issue - Especifique o título da issue a ser atualizada.
    * `body` (string, opcional): Corpo da Issue - Especifique o conteúdo do corpo da issue a ser atualizada.
    * `assignees` (string, opcional): Responsáveis - Especifique o login dos responsáveis no GitHub como um array de strings para esta issue. (exemplo: `["octocat"]`).
    * `state` (string, opcional): Estado - Especifique o estado atualizado da issue.
      * Opções: `open`, `closed`
  </Accordion>

<Accordion title="github/get_issue_by_number">
    **Descrição:** Obtém uma issue pelo número no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `issue_number` (string, obrigatório): Número da Issue - Especifique o número da issue a ser buscada.
  </Accordion>

<Accordion title="github/lock_issue">
    **Descrição:** Bloqueia uma issue no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `issue_number` (string, obrigatório): Número da Issue - Especifique o número da issue a ser bloqueada.
    * `lock_reason` (string, obrigatório): Motivo do Bloqueio - Especifique um motivo para bloquear a discussão da issue ou pull request.
      * Opções: `off-topic`, `too heated`, `resolved`, `spam`
  </Accordion>

<Accordion title="github/search_issue">
    **Descrição:** Busca por issues no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `filter` (object, obrigatório): Um filtro em forma normal disjuntiva - OU de grupos E de condições simples.
      
      Campos disponíveis: `assignee`, `creator`, `mentioned`, `labels`
  </Accordion>

<Accordion title="github/create_release">
    **Descrição:** Cria um release no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `tag_name` (string, obrigatório): Nome - Especifique o nome da tag do release a ser criada. (exemplo: "v1.0.0").
    * `target_commitish` (string, opcional): Destino - Especifique o destino do release. Pode ser o nome de um branch ou o SHA de um commit. Padrão é o branch principal. (exemplo: "master").
    * `body` (string, opcional): Descrição - Especifique uma descrição para este release.
    * `draft` (string, opcional): Rascunho - Especifique se o release criado deve ser um rascunho (não publicado).
      * Opções: `true`, `false`
    * `prerelease` (string, opcional): Pré-lançamento - Especifique se o release criado deve ser um pré-lançamento.
      * Opções: `true`, `false`
    * `discussion_category_name` (string, opcional): Nome da Categoria de Discussão - Se especificado, uma discussão da categoria indicada é criada e vinculada ao release. O valor deve ser uma categoria já existente no repositório.
    * `generate_release_notes` (string, opcional): Notas de Release - Especifique se o release criado deve criar automaticamente notas de release usando o nome e a descrição fornecidos.
      * Opções: `true`, `false`
  </Accordion>

<Accordion title="github/update_release">
    **Descrição:** Atualiza um release no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `id` (string, obrigatório): ID do Release - Especifique o ID do release a ser atualizado.
    * `tag_name` (string, opcional): Nome - Especifique o nome da tag do release a ser atualizado. (exemplo: "v1.0.0").
    * `target_commitish` (string, opcional): Destino - Especifique o destino do release. Pode ser o nome de um branch ou o SHA de um commit. Padrão é o branch principal. (exemplo: "master").
    * `body` (string, opcional): Descrição - Especifique uma descrição para este release.
    * `draft` (string, opcional): Rascunho - Especifique se o release criado deve ser um rascunho (não publicado).
      * Opções: `true`, `false`
    * `prerelease` (string, opcional): Pré-lançamento - Especifique se o release criado deve ser um pré-lançamento.
      * Opções: `true`, `false`
    * `discussion_category_name` (string, opcional): Nome da Categoria de Discussão - Se especificado, uma discussão da categoria indicada é criada e vinculada ao release. O valor deve ser uma categoria já existente no repositório.
    * `generate_release_notes` (string, opcional): Notas de Release - Especifique se o release criado deve criar automaticamente notas de release usando o nome e a descrição fornecidos.
      * Opções: `true`, `false`
  </Accordion>

<Accordion title="github/get_release_by_id">
    **Descrição:** Obtém um release por ID no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `id` (string, obrigatório): ID do Release - Especifique o ID do release a ser recuperado.
  </Accordion>

<Accordion title="github/get_release_by_tag_name">
    **Descrição:** Obtém um release pelo nome da tag no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `tag_name` (string, obrigatório): Nome - Especifique o nome da tag do release a ser recuperado. (exemplo: "v1.0.0").
  </Accordion>

<Accordion title="github/delete_release">
    **Descrição:** Exclui um release no GitHub.

* `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `id` (string, obrigatório): ID do Release - Especifique o ID do release a ser excluído.
  </Accordion>
</AccordionGroup>

### Configuração Básica de Agente GitHub

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="github/create_issue">
    **Descrição:** Cria uma issue no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `title` (string, obrigatório): Título da Issue - Especifique o título da issue a ser criada.
    * `body` (string, opcional): Corpo da Issue - Especifique o conteúdo do corpo da issue a ser criada.
    * `assignees` (string, opcional): Responsáveis - Especifique o login dos responsáveis no GitHub como um array de strings para esta issue. (exemplo: `["octocat"]`).
  </Accordion>

  <Accordion title="github/update_issue">
    **Descrição:** Atualiza uma issue no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `issue_number` (string, obrigatório): Número da Issue - Especifique o número da issue a ser atualizada.
    * `title` (string, obrigatório): Título da Issue - Especifique o título da issue a ser atualizada.
    * `body` (string, opcional): Corpo da Issue - Especifique o conteúdo do corpo da issue a ser atualizada.
    * `assignees` (string, opcional): Responsáveis - Especifique o login dos responsáveis no GitHub como um array de strings para esta issue. (exemplo: `["octocat"]`).
    * `state` (string, opcional): Estado - Especifique o estado atualizado da issue.
      * Opções: `open`, `closed`
  </Accordion>

  <Accordion title="github/get_issue_by_number">
    **Descrição:** Obtém uma issue pelo número no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `issue_number` (string, obrigatório): Número da Issue - Especifique o número da issue a ser buscada.
  </Accordion>

  <Accordion title="github/lock_issue">
    **Descrição:** Bloqueia uma issue no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `issue_number` (string, obrigatório): Número da Issue - Especifique o número da issue a ser bloqueada.
    * `lock_reason` (string, obrigatório): Motivo do Bloqueio - Especifique um motivo para bloquear a discussão da issue ou pull request.
      * Opções: `off-topic`, `too heated`, `resolved`, `spam`
  </Accordion>

  <Accordion title="github/search_issue">
    **Descrição:** Busca por issues no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a esta Issue. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a esta Issue.
    * `filter` (object, obrigatório): Um filtro em forma normal disjuntiva - OU de grupos E de condições simples.
```

Example 2 (unknown):
```unknown
Campos disponíveis: `assignee`, `creator`, `mentioned`, `labels`
  </Accordion>

  <Accordion title="github/create_release">
    **Descrição:** Cria um release no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `tag_name` (string, obrigatório): Nome - Especifique o nome da tag do release a ser criada. (exemplo: "v1.0.0").
    * `target_commitish` (string, opcional): Destino - Especifique o destino do release. Pode ser o nome de um branch ou o SHA de um commit. Padrão é o branch principal. (exemplo: "master").
    * `body` (string, opcional): Descrição - Especifique uma descrição para este release.
    * `draft` (string, opcional): Rascunho - Especifique se o release criado deve ser um rascunho (não publicado).
      * Opções: `true`, `false`
    * `prerelease` (string, opcional): Pré-lançamento - Especifique se o release criado deve ser um pré-lançamento.
      * Opções: `true`, `false`
    * `discussion_category_name` (string, opcional): Nome da Categoria de Discussão - Se especificado, uma discussão da categoria indicada é criada e vinculada ao release. O valor deve ser uma categoria já existente no repositório.
    * `generate_release_notes` (string, opcional): Notas de Release - Especifique se o release criado deve criar automaticamente notas de release usando o nome e a descrição fornecidos.
      * Opções: `true`, `false`
  </Accordion>

  <Accordion title="github/update_release">
    **Descrição:** Atualiza um release no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `id` (string, obrigatório): ID do Release - Especifique o ID do release a ser atualizado.
    * `tag_name` (string, opcional): Nome - Especifique o nome da tag do release a ser atualizado. (exemplo: "v1.0.0").
    * `target_commitish` (string, opcional): Destino - Especifique o destino do release. Pode ser o nome de um branch ou o SHA de um commit. Padrão é o branch principal. (exemplo: "master").
    * `body` (string, opcional): Descrição - Especifique uma descrição para este release.
    * `draft` (string, opcional): Rascunho - Especifique se o release criado deve ser um rascunho (não publicado).
      * Opções: `true`, `false`
    * `prerelease` (string, opcional): Pré-lançamento - Especifique se o release criado deve ser um pré-lançamento.
      * Opções: `true`, `false`
    * `discussion_category_name` (string, opcional): Nome da Categoria de Discussão - Se especificado, uma discussão da categoria indicada é criada e vinculada ao release. O valor deve ser uma categoria já existente no repositório.
    * `generate_release_notes` (string, opcional): Notas de Release - Especifique se o release criado deve criar automaticamente notas de release usando o nome e a descrição fornecidos.
      * Opções: `true`, `false`
  </Accordion>

  <Accordion title="github/get_release_by_id">
    **Descrição:** Obtém um release por ID no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `id` (string, obrigatório): ID do Release - Especifique o ID do release a ser recuperado.
  </Accordion>

  <Accordion title="github/get_release_by_tag_name">
    **Descrição:** Obtém um release pelo nome da tag no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `tag_name` (string, obrigatório): Nome - Especifique o nome da tag do release a ser recuperado. (exemplo: "v1.0.0").
  </Accordion>

  <Accordion title="github/delete_release">
    **Descrição:** Exclui um release no GitHub.

    **Parâmetros:**

    * `owner` (string, obrigatório): Proprietário - Especifique o nome do proprietário da conta do repositório associado a este Release. (exemplo: "abc").
    * `repo` (string, obrigatório): Repositório - Especifique o nome do repositório associado a este Release.
    * `id` (string, obrigatório): ID do Release - Especifique o ID do release a ser excluído.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica de Agente GitHub
```

---

## Complex automation task

**URL:** llms-txt#complex-automation-task

**Contents:**
  - Financial Modeling and Analysis

automation_task = Task(
    description="""
    1. Scan all Excel workbooks for specific data patterns
    2. Create consolidated reports from multiple workbooks
    3. Generate charts and tables for trend analysis
    4. Set up named ranges for easy data reference
    5. Create dashboard worksheets with key metrics
    6. Clean up unused worksheets and tables
    """,
    agent=excel_automator,
    expected_output="Automated Excel workflow completed with consolidated reports and dashboards"
)

crew = Crew(
    agents=[excel_automator],
    tasks=[automation_task]
)

crew.kickoff()
python  theme={null}
from crewai import Agent, Task, Crew

financial_modeler = Agent(
    role="Financial Modeler",
    goal="Create financial models and analysis in Excel",
    backstory="An AI assistant specialized in financial modeling and analysis using Excel.",
    apps=['microsoft_excel']
)

**Examples:**

Example 1 (unknown):
```unknown
### Financial Modeling and Analysis
```

---

## Task to organize SharePoint content

**URL:** llms-txt#task-to-organize-sharepoint-content

content_organization_task = Task(
    description="List all accessible SharePoint sites and organize content by department",
    agent=sharepoint_agent,
    expected_output="SharePoint sites listed and content organized by department"
)

---

## Example with custom connection timeout

**URL:** llms-txt#example-with-custom-connection-timeout

with MCPServerAdapter(server_params, connect_timeout=60) as tools:
    # Connection will timeout after 60 seconds if not established
    pass
python  theme={null}
from crewai import Agent
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters # For Stdio Server

**Examples:**

Example 1 (unknown):
```unknown

```

---

## Use without exposing keys in code

**URL:** llms-txt#use-without-exposing-keys-in-code

**Contents:**
  - 다양한 임베딩 제공자 테스트하기

crew = Crew(
    memory=True,
    embedder={
        "provider": "openai",
        "config": {
            "model": "text-embedding-3-small"
            # API key automatically loaded from environment
        }
    }
)
python  theme={null}
from crewai import Crew
from crewai.utilities.paths import db_storage_path

**Examples:**

Example 1 (unknown):
```unknown
### 다양한 임베딩 제공자 테스트하기

특정 사용 사례에 맞게 임베딩 제공자를 비교하세요:
```

---

## 파일 쓰기

**URL:** llms-txt#파일-쓰기

Source: https://docs.crewai.com/ko/tools/file-document/filewritetool

FileWriterTool은 파일에 내용을 쓰도록 설계되었습니다.

---

## 컨텍스트 밖에서는 임시 핸들러가 제거됩니다

**URL:** llms-txt#컨텍스트-밖에서는-임시-핸들러가-제거됩니다

**Contents:**
- 사용 사례
- 모범 사례

이벤트 리스너는 다양한 목적으로 사용할 수 있습니다:

1. **로깅 및 모니터링**: Crew의 실행을 추적하고 중요한 이벤트를 기록합니다
2. **분석**: Crew의 성능과 동작에 대한 데이터를 수집합니다
3. **디버깅**: 특정 문제를 디버깅하기 위해 임시 리스너를 설정합니다
4. **통합**: CrewAI를 모니터링 플랫폼, 데이터베이스 또는 알림 서비스와 같은 외부 시스템과 연결합니다
5. **사용자 정의 동작**: 특정 이벤트에 따라 사용자 정의 동작을 트리거합니다

1. **핸들러를 가볍게 유지하세요**: 이벤트 핸들러는 경량이어야 하며, 블로킹 작업을 피해야 합니다.
2. **오류 처리**: 예외가 메인 실행에 영향을 주지 않도록 이벤트 핸들러에 적절한 오류 처리를 포함하세요.
3. **정리**: 리스너가 자원을 할당한다면, 이를 적절하게 정리하는지 확인하세요.
4. **선택적 리스닝**: 실제로 처리해야 하는 이벤트에만 리스닝하세요.
5. **테스트**: 이벤트 리스너가 예상대로 동작하는지 독립적으로 테스트하세요.

CrewAI의 이벤트 시스템을 활용하면 기능을 확장하고 기존 인프라와 원활하게 통합할 수 있습니다.

---

## null

**URL:** llms-txt#null

Source: https://docs.crewai.com/pt-BR/snippets/snippet-intro

Um dos princípios fundamentais do desenvolvimento de software é o DRY (Don't Repeat Yourself, ou Não Se Repita). Esse princípio também se aplica à documentação. Se você perceber que está repetindo o mesmo conteúdo em vários lugares, considere criar um snippet personalizado para manter seu conteúdo sincronizado.

---

## Both filters will be combined (AND logic)

**URL:** llms-txt#both-filters-will-be-combined-(and-logic)

**Contents:**
- Search Parameters
- Return Format
- Default Embedding
- Custom Embeddings

json  theme={null}
[
  {
    "metadata": {
      // Any metadata stored with the document
    },
    "context": "The actual text content of the document",
    "distance": 0.95  // Similarity score
  }
]
python  theme={null}
from transformers import AutoTokenizer, AutoModel
import torch

**Examples:**

Example 1 (unknown):
```unknown
## Search Parameters

The tool accepts these parameters in its schema:

* `query` (str): The search query to find similar documents
* `filter_by` (str, optional): Metadata field to filter on
* `filter_value` (Any, optional): Value to filter by

## Return Format

The tool returns results in JSON format:
```

Example 2 (unknown):
```unknown
## Default Embedding

By default, the tool uses OpenAI's `text-embedding-3-large` model for vectorization. This requires:

* OpenAI API key set in environment: `OPENAI_API_KEY`

## Custom Embeddings

Instead of using the default embedding model, you might want to use your own embedding function in cases where you:

1. Want to use a different embedding model (e.g., Cohere, HuggingFace, Ollama models)
2. Need to reduce costs by using open-source embedding models
3. Have specific requirements for vector dimensions or embedding quality
4. Want to use domain-specific embeddings (e.g., for medical or legal text)

Here's an example using a HuggingFace model:
```

---

## Acessar os metadados

**URL:** llms-txt#acessar-os-metadados

**Contents:**
- Persistência das impressões digitais

print(f"Agent metadata: {agent.fingerprint.metadata}")
python  theme={null}
original_fingerprint = agent.fingerprint.uuid_str

**Examples:**

Example 1 (unknown):
```unknown
## Persistência das impressões digitais

As impressões digitais foram projetadas para persistir e permanecer inalteradas durante todo o ciclo de vida de um componente. Se você modificar um componente, a impressão digital permanece a mesma:
```

---

## Exemplo de tarefa com formatação markdown ativada

**URL:** llms-txt#exemplo-de-tarefa-com-formatação-markdown-ativada

**Contents:**
  - Configuração YAML com Markdown
  - Benefícios da Saída Markdown
- Dependências de Tarefas e Contexto
- Guardrails em Tarefas
  - Guardrails Baseados em Função
  - Requisitos da Função Guardrail
  - Melhores Práticas de Tratamento de Erros
  - Tratamento dos Resultados do Guardrail
- Obtendo Saídas Estruturadas e Consistentes das Tarefas
  - Usando `output_pydantic`

formatted_task = Task(
    description="Crie um relatório abrangente sobre tendências em IA",
    expected_output="Um relatório bem estruturado com títulos, seções e bullet points",
    agent=reporter_agent,
    markdown=True  # Habilita a formatação automática em markdown
)
yaml tasks.yaml theme={null}
analysis_task:
  description: >
    Analise os dados de mercado e crie um relatório detalhado
  expected_output: >
    Uma análise completa com gráficos e descobertas-chave
  agent: analyst
  markdown: true  # Habilita formatação em markdown
  output_file: analysis.md
python Code theme={null}
research_task = Task(
    description="Pesquise os últimos avanços em IA",
    expected_output="Uma lista de avanços recentes em IA",
    agent=researcher
)

analysis_task = Task(
    description="Analise os achados da pesquisa e identifique as tendências principais",
    expected_output="Relatório de análise das tendências em IA",
    agent=analyst,
    context=[research_task]  # Esta tarefa aguardará a conclusão da research_task
)
python Code theme={null}
from typing import Tuple, Union, Dict, Any
from crewai import TaskOutput

def validate_blog_content(result: TaskOutput) -> Tuple[bool, Any]:
    """Valida se o conteúdo do blog atende aos requisitos."""
    try:
        # Verifica a contagem de palavras
        word_count = len(result.split())
        if word_count > 200:
            return (False, "O conteúdo do blog excede 200 palavras")

# Lógica adicional de validação aqui
        return (True, result.strip())
    except Exception as e:
        return (False, "Erro inesperado durante a validação")

blog_task = Task(
    description="Escreva um post de blog sobre IA",
    expected_output="Um post de blog com menos de 200 palavras",
    agent=blog_agent,
    guardrail=validate_blog_content  # Adiciona a função guardrail
)
python Code theme={null}
from crewai import TaskOutput, LLMGuardrail

def validate_with_context(result: TaskOutput) -> Tuple[bool, Any]:
    try:
        # Lógica principal de validação
        validated_data = perform_validation(result)
        return (True, validated_data)
    except ValidationError as e:
        return (False, f"ERRO_DE_VALIDACAO: {str(e)}")
    except Exception as e:
        return (False, str(e))
python Code theme={null}
from typing import Any, Dict, List, Tuple, Union
from crewai import TaskOutput

def complex_validation(result: TaskOutput) -> Tuple[bool, Any]:
    """Encadeia múltiplas etapas de validação."""
    # Passo 1: Validação básica
    if not result:
        return (False, "Resultado vazio")

# Passo 2: Validação de conteúdo
    try:
        validated = validate_content(result)
        if not validated:
            return (False, "Conteúdo inválido")

# Passo 3: Validação de formato
        formatted = format_output(validated)
        return (True, formatted)
    except Exception as e:
        return (False, str(e))
python Code theme={null}
from typing import Optional, Tuple, Union
from crewai import TaskOutput, Task

def validate_json_output(result: TaskOutput) -> Tuple[bool, Any]:
    """Valida e faz o parsing da saída como JSON."""
    try:
        # Tenta realizar o parsing como JSON
        data = json.loads(result)
        return (True, data)
    except json.JSONDecodeError as e:
        return (False, "Formato JSON inválido")

task = Task(
    description="Gere um relatório em JSON",
    expected_output="Um objeto JSON válido",
    agent=analyst,
    guardrail=validate_json_output,
    guardrail_max_retries=3  # Limite de tentativas
)
python Code theme={null}
import json

from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

class Blog(BaseModel):
    title: str
    content: str

blog_agent = Agent(
    role="Blog Content Generator Agent",
    goal="Gerar um título e conteúdo para blog",
    backstory="""Você é um especialista em criação de conteúdo, habilidoso em escrever posts de blogs engajadores e informativos.""",
    verbose=False,
    allow_delegation=False,
    llm="gpt-4o",
)

task1 = Task(
    description="""Crie um título e conteúdo para blog sobre um tópico. Certifique-se de que o conteúdo tenha menos de 200 palavras.""",
    expected_output="Um título atraente e um conteúdo bem escrito para blog.",
    agent=blog_agent,
    output_pydantic=Blog,
)

**Examples:**

Example 1 (unknown):
```unknown
Quando `markdown=True`, o agente recebe instruções extras para formatar a saída usando:

* `#` para títulos
* `**texto**` para negrito
* `*texto*` para itálico
* `-` ou `*` para bullet points
* `` `código` `` para código inline
* ` `linguagem \`\`\` para blocos de código

### Configuração YAML com Markdown
```

Example 2 (unknown):
```unknown
### Benefícios da Saída Markdown

* **Formatação Consistente**: Garante que todas as saídas sigam as convenções de markdown
* **Maior Legibilidade**: Conteúdo estruturado com títulos, listas e ênfase
* **Pronto para Documentação**: A saída pode ser usada diretamente em sistemas de documentação
* **Compatibilidade Multi-plataforma**: Markdown é universalmente suportado

<Note>
  As instruções de formatação em markdown são adicionadas automaticamente ao prompt da tarefa quando `markdown=True`, então não é necessário detalhar os requisitos de formatação na descrição da tarefa.
</Note>

## Dependências de Tarefas e Contexto

As tarefas podem depender da saída de outras tarefas utilizando o atributo `context`. Por exemplo:
```

Example 3 (unknown):
```unknown
## Guardrails em Tarefas

Guardrails (trilhas de proteção) de tarefas fornecem uma maneira de validar e transformar as saídas das tarefas antes que elas sejam passadas para a próxima tarefa. Esse recurso assegura a qualidade dos dados e oferece feedback aos agentes quando sua saída não atende a critérios específicos.

Guardrails são implementados como funções Python que contêm lógica de validação customizada, proporcionando controle total sobre o processo de validação e garantindo resultados confiáveis e determinísticos.

### Guardrails Baseados em Função

Para adicionar um guardrail baseado em função a uma tarefa, forneça uma função de validação por meio do parâmetro `guardrail`:
```

Example 4 (unknown):
```unknown
### Requisitos da Função Guardrail

1. **Assinatura da Função**:
   * Deve aceitar exatamente um parâmetro (a saída da tarefa)
   * Deve retornar uma tupla `(bool, Any)`
   * Type hints são recomendados, mas opcionais

2. **Valores de Retorno**:
   * Em caso de sucesso: retorna uma tupla `(True, resultado_validado)`
   * Em caso de falha: retorna uma tupla `(False, "mensagem de erro explicando a falha")`

### Melhores Práticas de Tratamento de Erros

1. **Respostas de Erro Estruturadas**:
```

---

## Também é possível definir metadados

**URL:** llms-txt#também-é-possível-definir-metadados

**Contents:**
- Uso avançado
  - Estrutura da impressão digital

custom_fingerprint = Fingerprint.generate(
    seed="my-agent-id",
    metadata={"version": "1.0"}
)
python  theme={null}
from crewai.security import Fingerprint

fingerprint = agent.fingerprint

**Examples:**

Example 1 (unknown):
```unknown
## Uso avançado

### Estrutura da impressão digital

Cada impressão digital possui a seguinte estrutura:
```

---

## Execute uma busca

**URL:** llms-txt#execute-uma-busca

**Contents:**
- Exemplo de Integração com Agente

results = tool.run(search_query="Latest AI developments")
print(results)
python Code theme={null}
from crewai import Agent
from crewai.project import agent
from crewai_tools import BraveSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo de Integração com Agente

Veja como integrar o `BraveSearchTool` com um agente CrewAI:
```

---

## 모든 사이트 가져오기 작업

**URL:** llms-txt#모든-사이트-가져오기-작업

get_sites_task = Task(
    description="액세스할 수 있는 모든 SharePoint 사이트를 나열하세요.",
    agent=sharepoint_agent,
    expected_output="표시 이름과 URL이 포함된 SharePoint 사이트 목록."
)

---

## Vision Tool

**URL:** llms-txt#vision-tool

Source: https://docs.crewai.com/pt-BR/tools/ai-ml/visiontool

O `VisionTool` foi projetado para extrair texto de imagens.

---

## Ferramenta de Extração de Elementos de Website

**URL:** llms-txt#ferramenta-de-extração-de-elementos-de-website

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/scrapeelementfromwebsitetool

A `ScrapeElementFromWebsiteTool` permite que agentes CrewAI extraiam elementos específicos de websites usando seletores CSS.

---

## ✅ Solução: Hierarquia e responsabilidades bem definidas

**URL:** llms-txt#✅-solução:-hierarquia-e-responsabilidades-bem-definidas

**Contents:**
- Recursos Avançados de Colaboração
  - Regras Personalizadas de Colaboração

manager = Agent(role="Manager", allow_delegation=True)
specialist1 = Agent(role="Specialist A", allow_delegation=False)  # No re-delegation
specialist2 = Agent(role="Specialist B", allow_delegation=False)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Recursos Avançados de Colaboração

### Regras Personalizadas de Colaboração
```

---

## `HyperbrowserLoadTool`

**URL:** llms-txt#`hyperbrowserloadtool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo

O `HyperbrowserLoadTool` permite realizar web scraping e crawling utilizando o [Hyperbrowser](https://hyperbrowser.ai), uma plataforma para executar e escalar browsers headless. Essa ferramenta possibilita extrair dados de uma única página ou rastrear um site inteiro, retornando o conteúdo em markdown ou HTML corretamente formatado.

Principais Características:

* Escalabilidade Instantânea – Inicie centenas de sessões de browser em segundos sem se preocupar com infraestrutura
* Integração Simples – Funciona perfeitamente com ferramentas populares como Puppeteer e Playwright
* APIs Poderosas – APIs fáceis de usar para scraping/crawling de qualquer site
* Supera Medidas Anti-Bot – Inclui modo stealth, bloqueio de anúncios, resolução automática de CAPTCHA e proxies rotativos

Para utilizar esta ferramenta, você precisa instalar o SDK do Hyperbrowser:

## Passos para Começar

Para usar efetivamente o `HyperbrowserLoadTool`, siga estes passos:

1. **Cadastre-se**: Vá até o [Hyperbrowser](https://app.hyperbrowser.ai/) para criar uma conta e gerar uma chave de API.
2. **Chave de API**: Defina a variável de ambiente `HYPERBROWSER_API_KEY` ou passe-a diretamente no construtor da ferramenta.
3. **Instale o SDK**: Instale o SDK do Hyperbrowser usando o comando acima.

O exemplo a seguir demonstra como inicializar a ferramenta e utilizá-la para extrair dados de um site:

```python Code theme={null}
from crewai_tools import HyperbrowserLoadTool
from crewai import Agent

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para usar efetivamente o `HyperbrowserLoadTool`, siga estes passos:

1. **Cadastre-se**: Vá até o [Hyperbrowser](https://app.hyperbrowser.ai/) para criar uma conta e gerar uma chave de API.
2. **Chave de API**: Defina a variável de ambiente `HYPERBROWSER_API_KEY` ou passe-a diretamente no construtor da ferramenta.
3. **Instale o SDK**: Instale o SDK do Hyperbrowser usando o comando acima.

## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e utilizá-la para extrair dados de um site:
```

---

## Using Tool: Search the internet

**URL:** llms-txt#using-tool:-search-the-internet

---

## S3 Writer Tool

**URL:** llms-txt#s3-writer-tool

Source: https://docs.crewai.com/ko/tools/cloud-storage/s3writertool

S3WriterTool은 CrewAI 에이전트가 Amazon S3 버킷의 파일에 콘텐츠를 쓸 수 있도록 해줍니다.

---

## ❌ Avoid: Overlapping or vague roles

**URL:** llms-txt#❌-avoid:-overlapping-or-vague-roles

**Contents:**
  - 2. **전략적 위임 활성화**

agent1 = Agent(role="General Assistant", ...)
agent2 = Agent(role="Helper", ...)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 2. **전략적 위임 활성화**
```

---

## psycopg2 foi instalado para rodar este exemplo com PostgreSQL

**URL:** llms-txt#psycopg2-foi-instalado-para-rodar-este-exemplo-com-postgresql

**Contents:**
- Exemplo

nl2sql = NL2SQLTool(db_uri="postgresql://example@localhost:5432/test_db")

@agent
def researcher(self) -> Agent:
    return Agent(
        config=self.agents_config["researcher"],
        allow_delegation=False,
        tools=[nl2sql]
    )
md  theme={null}
 DB -> Agent -> ... -> Agent -> DB
```

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O objetivo principal da tarefa era:

"Recupere a receita mensal média, máxima e mínima para cada cidade, mas inclua apenas cidades que tenham mais de um usuário. Além disso, conte o número de usuários em cada cidade e classifique os resultados pela receita mensal média em ordem decrescente"

Assim, o Agente tentou obter informações do banco de dados; a primeira vez está errada, então o Agente tenta novamente, consegue a informação correta e repassa para o próximo agente.

![alt text](https://github.com/crewAIInc/crewAI-tools/blob/main/crewai_tools/tools/nl2sql/images/image-2.png?raw=true)
![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-3.png)

O segundo objetivo da tarefa foi:

"Revise os dados e crie um relatório detalhado e, em seguida, crie a tabela no banco de dados com os campos baseados nos dados fornecidos. Inclua informações sobre a receita mensal média, máxima e mínima para cada cidade, mas apenas inclua cidades que possuam mais de um usuário. Também conte o número de usuários em cada cidade e classifique os resultados pela receita mensal média em ordem decrescente."

Agora as coisas começam a ficar interessantes: o Agente gera a consulta SQL não só para criar a tabela, mas também inserir os dados na tabela. E, ao final, o Agente ainda retorna o relatório final que condiz exatamente com o que estava no banco de dados.

![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-4.png)
![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-5.png)

![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-9.png)
![alt text](https://github.com/crewAIInc/crewAI-tools/raw/main/crewai_tools/tools/nl2sql/images/image-7.png)

Este é um exemplo simples de como o NL2SQLTool pode ser utilizado para interagir com o banco de dados e gerar relatórios baseados nos dados do banco.

A ferramenta oferece possibilidades infinitas para a lógica do Agente e como ele pode interagir com o banco de dados.
```

---

## Arxiv 논문 도구

**URL:** llms-txt#arxiv-논문-도구

Source: https://docs.crewai.com/ko/tools/search-research/arxivpapertool

ArxivPaperTool은 쿼리에 맞는 논문을 arXiv에서 검색하고, 선택적으로 PDF를 다운로드합니다.

---

## Choose which LLM to use for each agent based on your needs

**URL:** llms-txt#choose-which-llm-to-use-for-each-agent-based-on-your-needs

**Contents:**
- CrewAI를 위한 엔터프라이즈 거버넌스 설정
- 자주 묻는 질문
- 자료

researcher = Agent(
    role="Senior Research Scientist",
    goal="Discover groundbreaking insights about the assigned topic",
    backstory="You are an expert researcher with deep domain knowledge.",
    verbose=True,
    llm=openai_llm  # Use anthropic_llm for Anthropic
)
json  theme={null}
       {
           "virtual_key": "YOUR_VIRTUAL_KEY_FROM_STEP1",
          	"override_params": {
             "model": "gpt-4o" // 선호하는 모델명
           }
       }
       python  theme={null}
    from crewai import Agent, LLM
    from portkey_ai import PORTKEY_GATEWAY_URL

# API 키로 LLM 구성
    portkey_llm = LLM(
        model="gpt-4o",
        base_url=PORTKEY_GATEWAY_URL,
        api_key="YOUR_PORTKEY_API_KEY"
    )

# Portkey가 적용된 LLM으로 agent 생성
    researcher = Agent(
        role="Senior Research Scientist",
        goal="Discover groundbreaking insights about the assigned topic",
        backstory="You are an expert researcher with deep domain knowledge.",
        verbose=True,
        llm=portkey_llm
    )
    json  theme={null}
    {
    	"strategy": {
    		"mode": "single"
    	},
    	"targets": [
    		{
    			"virtual_key": "YOUR_OPENAI_VIRTUAL_KEY",
    			"override_params": {
    				"model": "gpt-4o"
    			}
    		}
    	]
    }
    python  theme={null}
    from portkey_ai import Portkey

portkey = Portkey(api_key="YOUR_ADMIN_API_KEY")

api_key = portkey.api_keys.create(
        name="engineering-team",
        type="organisation",
        workspace_id="YOUR_WORKSPACE_ID",
        defaults={
            "config_id": "your-config-id",
            "metadata": {
                "environment": "production",
                "department": "engineering"
            }
        },
        scopes=["logs.view", "configs.read"]
    )
    ```

자세한 키 관리 방법은 [API 키 문서](/ko/api-reference/admin-api/control-plane/api-keys/create-api-key)를 참조하세요.
  </Accordion>

<Accordion title="4단계: 배포 및 모니터링">
    ### 4단계: 배포 및 모니터링

팀원들에게 API 키를 배포한 후, 엔터프라이즈 준비가 완료된 CrewAI 설정이 준비됩니다. 이제 각 팀원은 지정된 API 키로 적절한 액세스 수준 및 예산 제어와 함께 사용할 수 있습니다.

Portkey 대시보드에서 사용량 모니터링:

* 부서별 비용 추적
    * 모델 사용 패턴
    * 요청량
    * 오류율
  </Accordion>
</AccordionGroup>

<Note>
  ### 엔터프라이즈 기능이 이제 사용 가능합니다

**귀하의 CrewAI 통합에는 이제 다음과 같은 기능이 포함됩니다:**

* 부서별 예산 관리
  * 모델 접근 거버넌스
  * 사용량 추적 및 귀속
  * 보안 가드레일
  * 신뢰성 기능
</Note>

<AccordionGroup>
  <Accordion title="Portkey는 CrewAI를 어떻게 향상시키나요?">
    Portkey는 종합적인 가시성(트레이스, 로그, 메트릭), 신뢰성 기능(폴백, 재시도, 캐싱) 및 통합 인터페이스를 통한 200개 이상의 LLM 접속을 통해 CrewAI에 프로덕션 환경에 적합한 기능을 추가합니다. 이를 통해 에이전트 애플리케이션을 더 쉽게 디버깅, 최적화, 확장할 수 있습니다.
  </Accordion>

<Accordion title="Portkey를 기존 CrewAI 애플리케이션과 함께 사용할 수 있나요?">
    네! Portkey는 기존 CrewAI 애플리케이션과 매끄럽게 통합됩니다. LLM 구성 코드를 Portkey가 적용된 버전으로 업데이트하기만 하면 됩니다. 나머지 에이전트 및 crew 코드는 변경하지 않아도 됩니다.
  </Accordion>

<Accordion title="Portkey는 모든 CrewAI 기능과 호환되나요?">
    Portkey는 에이전트, 도구, human-in-the-loop 워크플로우, 모든 태스크 프로세스 유형(순차적, 계층적 등)을 포함하여 모든 CrewAI 기능을 지원합니다. 프레임워크의 기능에 제한을 두지 않으면서 가시성과 신뢰성을 추가합니다.
  </Accordion>

<Accordion title="Crew 내 여러 에이전트의 사용 내역을 추적할 수 있나요?">
    네, Portkey를 사용하면 crew 내 여러 에이전트에 일관된 `trace_id`를 적용하여 전체 워크플로우를 추적할 수 있습니다. 특히 여러 에이전트가 포함된 복잡한 crew에서 전체 실행 경로를 파악할 때 유용합니다.
  </Accordion>

<Accordion title="특정 crew 실행에 대한 로그와 트레이스를 어떻게 필터링하나요?">
    Portkey를 통해 LLM 구성에 사용자 지정 메타데이터를 추가할 수 있으며, 이를 필터링에 활용할 수 있습니다. `crew_name`, `crew_type`, `session_id`와 같은 필드를 추가해 손쉽게 특정 crew 실행을 찾아 분석할 수 있습니다.
  </Accordion>

<Accordion title="내 API 키를 Portkey에서 사용할 수 있나요?">
    네! Portkey는 다양한 LLM 제공업체에 대해 사용자의 API 키를 사용합니다. API 키를 가상 키로 안전하게 저장하여, 코드 변경 없이 쉽게 키를 관리하고 교체할 수 있습니다.
  </Accordion>
</AccordionGroup>

<CardGroup cols="3">
  <Card title="CrewAI Docs" icon="book" href="https://docs.crewai.com/">
    <p>공식 CrewAI 문서</p>
  </Card>

<Card title="Book a Demo" icon="calendar" href="https://calendly.com/portkey-ai">
    <p>이 통합 구현에 대한 맞춤형 안내를 받아보세요</p>
  </Card>
</CardGroup>

**Examples:**

Example 1 (unknown):
```unknown
Portkey는 다음을 포함한 제공업체의 LLM에 액세스를 제공합니다:

* OpenAI (GPT-4o, GPT-4 Turbo 등)
* Anthropic (Claude 3.5 Sonnet, Claude 3 Opus 등)
* Mistral AI (Mistral Large, Mistral Medium 등)
* Google Vertex AI (Gemini 1.5 Pro 등)
* Cohere (Command, Command-R 등)
* AWS Bedrock (Claude, Titan 등)
* 로컬/프라이빗 모델

<Card title="지원되는 제공업체" icon="server" href="https://portkey.ai/docs/integrations/llms">
  Portkey에서 지원하는 전체 LLM 제공업체 목록 보기
</Card>

## CrewAI를 위한 엔터프라이즈 거버넌스 설정

**엔터프라이즈 거버넌스가 필요한 이유**
조직 내에서 CrewAI를 사용하는 경우, 여러 거버넌스 측면을 고려해야 합니다:

* **비용 관리**: 팀별 AI 사용 비용 통제 및 추적
* **접근 제어**: 특정 팀이 특정 모델을 사용할 수 있도록 관리
* **사용 분석**: 조직 전반에서 AI 사용 현황 파악
* **보안 및 컴플라이언스**: 엔터프라이즈 수준의 보안 기준 유지
* **신뢰성**: 모든 사용자에게 일관된 서비스 제공 보장

Portkey는 이러한 엔터프라이즈 요구를 해결하는 종합적인 거버넌스 계층을 추가합니다. 이제 이러한 컨트롤을 단계별로 구현해보겠습니다.

<Steps>
  <Step title="Virtual Key 생성">
    Virtual Key는 Portkey의 안전한 LLM 공급자 API 키 관리 방식입니다. 주요 제어 기능을 제공합니다:

    * API 사용에 대한 예산 제한
    * 속도 제한(Rate limiting) 기능
    * 안전한 API 키 저장

    Virtual Key를 생성하려면:
    Portkey 앱에서 [Virtual Keys](https://app.portkey.ai/virtual-keys)로 이동하세요. Virtual Key ID를 저장하고 복사하세요.

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Virtual%20Key%20from%20Portkey%20Docs.png" width="500" />
    </Frame>

    <Note>
      Virtual Key ID를 저장하세요. 다음 단계에서 필요합니다.
    </Note>
  </Step>

  <Step title="기본 Config 생성">
    Portkey에서 Config는 요청 라우팅 방식을 정의하며, 고급 라우팅·폴백·재시도 등 기능을 제공합니다.

    Config를 생성하려면:

    1. Portkey 대시보드의 [Configs](https://app.portkey.ai/configs)로 이동
    2. 아래와 같은 새 config 생성:
```

Example 2 (unknown):
```unknown
3. Config 이름을 저장하고 다음 단계에 사용하세요.

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20Portkey%20Docs%20Config.png" width="500" />
    </Frame>
  </Step>

  <Step title="Portkey API Key 설정">
    이제 Portkey API 키를 생성하고, 2단계에서 만든 config에 연결하세요:

    1. Portkey의 [API Keys](https://app.portkey.ai/api-keys)로 이동해 새 API 키 생성
    2. `2단계`에서 만든 config 선택
    3. API 키를 생성 및 저장

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/CrewAI%20API%20Key.png" width="500" />
    </Frame>
  </Step>

  <Step title="CrewAI에 연결">
    Portkey API 키와 config를 설정한 후, 이를 CrewAI agent에 연결하세요:
```

Example 3 (unknown):
```unknown
</Step>
</Steps>

<AccordionGroup>
  <Accordion title="1단계: 예산 제어 및 속도 제한 구현">
    ### 1단계: 예산 통제 및 속도 제한 구현

    Virtual Keys를 사용하면 팀/부서 수준에서 LLM 접근을 세밀하게 제어할 수 있습니다. 이를 통해 다음과 같은 이점이 있습니다:

    * [예산 한도](https://portkey.ai/docs/product/ai-gateway/virtual-keys/budget-limits) 설정
    * 속도 제한을 통해 예기치 않은 사용량 급증 방지
    * 부서별 지출 추적

    #### 부서별 제어 설정하기:

    1. Portkey 대시보드에서 [Virtual Keys](https://app.portkey.ai/virtual-keys)로 이동하세요.
    2. 각 부서마다 예산 한도와 속도 제한이 포함된 새로운 Virtual Key를 생성하세요.
    3. 부서별 한도를 구성하세요.

    <Frame>
      <img src="https://raw.githubusercontent.com/siddharthsambharia-portkey/Portkey-Product-Images/refs/heads/main/Virtual%20Key%20from%20Portkey%20Docs.png" width="500" />
    </Frame>
  </Accordion>

  <Accordion title="2단계: 모델 접근 규칙 정의">
    ### 단계 2: 모델 접근 규칙 정의

    AI 사용이 확장됨에 따라, 각 팀이 특정 모델에 접근할 수 있도록 제어하는 것이 중요해집니다. Portkey Configs는 다음과 같은 기능을 제공하여 이러한 제어 계층을 지원합니다:

    #### 접근 제어 기능:

    * **모델 제한**: 특정 모델에 대한 액세스 제한
    * **데이터 보호**: 민감한 데이터에 대한 가드레일 구현
    * **신뢰성 제어**: 폴백 및 재시도 로직 추가

    #### 예시 구성:

    다음은 OpenAI, 특히 GPT-4o로 요청을 라우팅하는 기본 구성입니다:
```

Example 4 (unknown):
```unknown
Portkey 대시보드에서 [구성 페이지](https://app.portkey.ai/configs)에서 자신의 구성을 생성하세요.

    <Note>
      구성은 언제든지 업데이트하여 실행 중인 애플리케이션에 영향을 주지 않고 제어를 조정할 수 있습니다.
    </Note>
  </Accordion>

  <Accordion title="3단계: 액세스 제어 구현">
    ### 3단계: 액세스 제어 구현

    사용자별 API 키를 생성하면 자동으로 다음을 수행합니다:

    * 가상 키를 활용하여 사용자/팀별 사용량 추적
    * 요청 라우팅을 위한 적절한 구성 적용
    * 로그를 필터링하기 위한 관련 메타데이터 수집
    * 액세스 권한 적용

    API 키 생성 방법:

    * [Portkey App](https://app.portkey.ai/)
    * [API Key Management API](/ko/api-reference/admin-api/control-plane/api-keys/create-api-key)

    Python SDK를 사용한 예시:
```

---

## Task to curate knowledge base

**URL:** llms-txt#task-to-curate-knowledge-base

**Contents:**
  - Estrutura e Organização de Conteúdo

curation_task = Task(
    description="""
    1. Search for existing documentation pages related to our new product feature
    2. Create a comprehensive feature documentation page with proper structure
    3. Add code examples, images, and links to related resources
    4. Update existing pages with cross-references to the new documentation
    """,
    agent=knowledge_curator,
    expected_output="Feature documentation created and integrated with existing knowledge base"
)

crew = Crew(
    agents=[knowledge_curator],
    tasks=[curation_task]
)

crew.kickoff()
python  theme={null}
from crewai import Agent, Task, Crew

content_organizer = Agent(
    role="Content Organizer",
    goal="Organize and structure content blocks for optimal readability",
    backstory="An AI assistant that specializes in content structure and user experience.",
    apps=['notion']
)

**Examples:**

Example 1 (unknown):
```unknown
### Estrutura e Organização de Conteúdo
```

---

## Example task

**URL:** llms-txt#example-task

task = Task(
    description='Find and summarize the latest AI news',
    expected_output='A bullet list summary of the top 5 most important AI news',
    agent=research_agent,
    tools=[search_tool]
)

---

## Telemetria

**URL:** llms-txt#telemetria

**Contents:**
- Telemetria
  - Exemplos:

Source: https://docs.crewai.com/pt-BR/telemetry

Entendendo os dados de telemetria coletados pelo CrewAI e como eles contribuem para o aprimoramento da biblioteca.

<Note>
  Por padrão, não coletamos dados que possam ser considerados informações pessoais segundo a GDPR e outras regulamentações de privacidade.
  Coletamos nomes das ferramentas e funções dos agentes, portanto, evite incluir qualquer informação pessoal nos nomes das ferramentas ou nas funções dos agentes.
  Como nenhuma informação pessoal é coletada, não é necessário se preocupar com localidade dos dados.
  Quando `share_crew` está ativado, dados adicionais são coletados e podem conter informações pessoais caso sejam incluídas pelo usuário.
  Usuários devem tomar cuidado ao habilitar este recurso para garantir conformidade com regulamentações de privacidade.
</Note>

O CrewAI utiliza telemetria anônima para coletar estatísticas de uso com o objetivo principal de aprimorar a biblioteca.
Nosso foco está em melhorar e desenvolver as funcionalidades, integrações e ferramentas mais utilizadas pelos usuários.

É fundamental compreender que, por padrão, **NENHUM dado pessoal é coletado** referente a prompts, descrições de tarefas, histórias ou objetivos dos agentes,
uso de ferramentas, chamadas de API, respostas, quaisquer dados processados pelos agentes ou segredos e variáveis de ambiente.
Quando o recurso `share_crew` está ativado, dados detalhados, incluindo descrições das tarefas, histórias ou objetivos dos agentes e outros atributos específicos são coletados
para fornecer insights mais detalhados. Essa coleta expandida pode incluir informações pessoais caso o usuário as tenha inserido em seus crews ou tarefas.
Usuários devem considerar cuidadosamente o conteúdo de seus crews e tarefas antes de habilitar o `share_crew`.
A telemetria pode ser desabilitada ao definir a variável de ambiente `CREWAI_DISABLE_TELEMETRY` como `true` ou ao definir `OTEL_SDK_DISABLED` como `true` (observe que esta última desabilita toda instrumentação OpenTelemetry globalmente).

```python  theme={null}

---

## Visão Geral do OpenLIT

**URL:** llms-txt#visão-geral-do-openlit

**Contents:**
  - Funcionalidades
- Instruções de Configuração

[OpenLIT](https://github.com/openlit/openlit?src=crewai-docs) é uma ferramenta open-source que simplifica o monitoramento de desempenho de agentes de IA, LLMs, VectorDBs e GPUs com apenas **uma** linha de código.

Ela oferece rastreamento e métricas nativos do OpenTelemetry para acompanhar parâmetros importantes como custo, latência, interações e sequências de tarefas.
Essa configuração permite acompanhar hiperparâmetros e monitorar problemas de desempenho, ajudando a encontrar formas de aprimorar e refinar seus agentes com o tempo.

<Frame caption="Painel do OpenLIT">
  <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=2b7fe9d84e9ec2b33c5eae6fa5668bee" alt="Visão geral do uso de agentes, incluindo custo e tokens" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/openlit1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c971bf515a852fd31020a8b1324f1c1c 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=84c289d1cb65df00729c0265b937953d 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a2f16c0fff510b112190d86e4d660f57 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d16913f544b0bab3b1b6df63f9d221eb 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f3fb2555418f5a64d567b5ab2c16da87 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=58ca748851de32f75bfeb36bb2cbdcfa 2500w" />

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=74bb57f622b6eeb67fd33d93d682df26" alt="Visão geral dos rastreamentos e métricas otel do agente" data-og-width="3024" width="3024" data-og-height="1728" height="1728" data-path="images/openlit2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5f8faf220f9d7a5660652ec531dd07f9 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a02410c4bf920c9aafe972416e52a400 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=21b69af51e7ed46fb5b38a932a64471b 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b32ebaa0e210ff7151bb831d4e2fd5fc 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c360d0388bd1af92dedde1967e41017f 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9f14c8d65a0ca1177c2aa848c7a57aaa 2500w" />

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=734cbc0c8fee538986d74b063c20cef6" alt="Visão detalhada dos rastreamentos do agente" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/openlit3.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=37d3f6eb4f5b66f6466fba0c02137aec 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9769fd3fdadf6acd8eadb2f80b4cc352 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=0f3367e37d8642fe4aa81f444c17b03d 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a2c9c17452fde4610823a981d60ce226 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=bf6526be4832980353137d0e19e38768 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit3.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a0c09334de9c7d1bb7f90a7ea636379f 2500w" />
</Frame>

* **Painel Analítico**: Monitore a saúde e desempenho dos seus Agentes com dashboards detalhados que acompanham métricas, custos e interações dos usuários.
* **SDK de Observabilidade Nativo OpenTelemetry**: SDKs neutros de fornecedor para enviar rastreamentos e métricas para suas ferramentas de observabilidade existentes como Grafana, DataDog e outros.
* **Rastreamento de Custos para Modelos Customizados e Ajustados**: Adapte estimativas de custo para modelos específicos usando arquivos de precificação customizados para orçamentos precisos.
* **Painel de Monitoramento de Exceções**: Identifique e solucione rapidamente problemas ao rastrear exceções comuns e erros por meio de um painel de monitoramento.
* **Conformidade e Segurança**: Detecte ameaças potenciais como profanidade e vazamento de dados sensíveis (PII).
* **Detecção de Prompt Injection**: Identifique possíveis injeções de código e vazamentos de segredos.
* **Gerenciamento de Chaves de API e Segredos**: Gerencie suas chaves de API e segredos do LLM de forma centralizada e segura, evitando práticas inseguras.
* **Gerenciamento de Prompt**: Gerencie e versiona prompts de Agente usando o PromptHub para acesso consistente e fácil entre os agentes.
* **Model Playground** Teste e compare diferentes modelos para seus agentes CrewAI antes da implantação.

## Instruções de Configuração

<Steps>
  <Step title="Implantar o OpenLIT">
    <Steps>
      <Step title="Clonar o Repositório do OpenLIT">
        
      </Step>

<Step title="Iniciar o Docker Compose">
        A partir do diretório raiz do [Repositório OpenLIT](https://github.com/openlit/openlit), execute o comando abaixo:

</Step>
    </Steps>
  </Step>

<Step title="Instalar o SDK OpenLIT">
    
  </Step>

<Step title="Inicializar o OpenLIT em Sua Aplicação">
    Adicione as duas linhas abaixo ao seu código de aplicação:

<Tabs>
      <Tab title="Configuração usando argumentos de função">

Exemplo de uso para monitoramento de um Agente CrewAI:

<Tab title="Configuração usando Variáveis de Ambiente">
        Adicione as duas linhas abaixo ao seu código de aplicação:

Execute o seguinte comando para configurar o endpoint de exportação OTEL:

Exemplo de uso para monitoramento de um Agente CrewAI Async:

Consulte o [repositório do SDK Python do OpenLIT](https://github.com/openlit/openlit/tree/main/sdk/python) para configurações e casos de uso avançados.
  </Step>

<Step title="Visualizar e Analisar">
    Com os dados de Observabilidade dos Agentes agora sendo coletados e enviados ao OpenLIT, o próximo passo é visualizar e analisar esses dados para obter insights sobre o desempenho, comportamento e identificar oportunidades de melhoria dos seus Agentes.

Basta acessar o OpenLIT em `127.0.0.1:3000` no seu navegador para começar a explorar. Você pode fazer login usando as credenciais padrão

* **Email**: `user@openlit.io`
    * **Senha**: `openlituser`

<Frame caption="Painel do OpenLIT">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=2b7fe9d84e9ec2b33c5eae6fa5668bee" alt="Visão geral do uso de agentes, incluindo custo e tokens" data-og-width="3024" width="3024" data-og-height="1720" height="1720" data-path="images/openlit1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c971bf515a852fd31020a8b1324f1c1c 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=84c289d1cb65df00729c0265b937953d 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a2f16c0fff510b112190d86e4d660f57 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=d16913f544b0bab3b1b6df63f9d221eb 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f3fb2555418f5a64d567b5ab2c16da87 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=58ca748851de32f75bfeb36bb2cbdcfa 2500w" />

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=74bb57f622b6eeb67fd33d93d682df26" alt="Visão geral dos rastreamentos e métricas otel do agente" data-og-width="3024" width="3024" data-og-height="1728" height="1728" data-path="images/openlit2.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5f8faf220f9d7a5660652ec531dd07f9 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=a02410c4bf920c9aafe972416e52a400 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=21b69af51e7ed46fb5b38a932a64471b 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=b32ebaa0e210ff7151bb831d4e2fd5fc 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c360d0388bd1af92dedde1967e41017f 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/openlit2.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=9f14c8d65a0ca1177c2aa848c7a57aaa 2500w" />
    </Frame>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

      <Step title="Iniciar o Docker Compose">
        A partir do diretório raiz do [Repositório OpenLIT](https://github.com/openlit/openlit), execute o comando abaixo:
```

Example 2 (unknown):
```unknown
</Step>
    </Steps>
  </Step>

  <Step title="Instalar o SDK OpenLIT">
```

Example 3 (unknown):
```unknown
</Step>

  <Step title="Inicializar o OpenLIT em Sua Aplicação">
    Adicione as duas linhas abaixo ao seu código de aplicação:

    <Tabs>
      <Tab title="Configuração usando argumentos de função">
```

Example 4 (unknown):
```unknown
Exemplo de uso para monitoramento de um Agente CrewAI:
```

---

## Task for financial modeling

**URL:** llms-txt#task-for-financial-modeling

**Contents:**
- Troubleshooting
  - Common Issues
  - Getting Help

modeling_task = Task(
    description="""
    1. Create financial model workbooks with multiple scenarios
    2. Set up input tables for assumptions and variables
    3. Create calculation worksheets with formulas and logic
    4. Generate charts for financial projections and trends
    5. Add summary tables for key financial metrics
    6. Create sensitivity analysis tables
    """,
    agent=financial_modeler,
    expected_output="Financial model created with scenarios, calculations, and analysis charts"
)

crew = Crew(
    agents=[financial_modeler],
    tasks=[modeling_task]
)

**Permission Errors**

* Ensure your Microsoft account has appropriate permissions for Excel and OneDrive/SharePoint
* Verify that the OAuth connection includes required scopes (Files.Read.All, Files.ReadWrite.All)
* Check that you have access to the specific workbooks you're trying to modify

**File ID and Path Issues**

* Verify that file IDs are correct and files exist in your OneDrive or SharePoint
* Ensure file paths are properly formatted when creating new workbooks
* Check that workbook files have the correct .xlsx extension

**Worksheet and Range Issues**

* Verify that worksheet names exist in the specified workbook
* Ensure range addresses are properly formatted (e.g., 'A1:C10')
* Check that ranges don't exceed worksheet boundaries

**Data Format Issues**

* Ensure data values are properly formatted for Excel (strings, numbers, integers)
* Verify that 2D arrays for ranges have consistent row and column counts
* Check that table data includes proper headers when has\_headers is true

**Chart Creation Issues**

* Verify that chart types are supported (ColumnClustered, Line, Pie, etc.)
* Ensure source data ranges contain appropriate data for the chart type
* Check that the source data range exists and contains data

**Table Management Issues**

* Ensure table names are unique within worksheets
* Verify that table ranges don't overlap with existing tables
* Check that new row data matches the table's column structure

**Cell and Range Operations**

* Verify that row and column indices are 0-based for cell operations
* Ensure ranges contain data when using get\_used\_range
* Check that named ranges exist before referencing them

<Card title="Need Help?" icon="headset" href="mailto:support@crewai.com">
  Contact our support team for assistance with Microsoft Excel integration setup or troubleshooting.
</Card>

---

## O agente precisará informar o caminho do CSV em tempo de execução.

**URL:** llms-txt#o-agente-precisará-informar-o-caminho-do-csv-em-tempo-de-execução.

**Contents:**
- Argumentos
- Modelo e embeddings personalizados

tool = CSVSearchTool()
python Code theme={null}
tool = CSVSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # ou google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # ou openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## Argumentos

Os seguintes parâmetros podem ser utilizados para personalizar o comportamento do `CSVSearchTool`:

| Argumento | Tipo     | Descrição                                                                                                                                                                                    |
| :-------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **csv**   | `string` | *Opcional*. O caminho para o arquivo CSV que você deseja buscar. Este é um argumento obrigatório se a ferramenta for inicializada sem um arquivo CSV específico; caso contrário, é opcional. |

## Modelo e embeddings personalizados

Por padrão, a ferramenta utiliza OpenAI tanto para embeddings quanto para sumarização. Para personalizar o modelo, você pode usar um dicionário de configuração como segue:
```

---

## ---

**URL:** llms-txt#---

**Contents:**
- Conclusão

Ao integrar o `SerperDevTool` em projetos Python, os usuários obtêm a capacidade de realizar buscas em tempo real e relevantes na internet diretamente de suas aplicações.
Os parâmetros atualizados permitem resultados de busca mais personalizados e localizados. Seguindo as diretrizes de configuração e uso fornecidas, a incorporação desta ferramenta nos projetos é simplificada e direta.

---

## `SerperDevTool`

**URL:** llms-txt#`serperdevtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando na melhoria das ferramentas, portanto, pode haver comportamentos inesperados ou mudanças no futuro.
</Note>

Esta ferramenta foi projetada para realizar buscas semânticas para uma consulta especificada a partir do conteúdo de um texto na internet. Ela utiliza a API do [serper.dev](https://serper.dev)
para buscar e exibir os resultados de pesquisa mais relevantes com base na consulta fornecida pelo usuário.

Para incorporar esta ferramenta em seu projeto, siga as instruções de instalação abaixo:

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca com uma consulta fornecida:

```python Code theme={null}
from crewai_tools import SerperDevTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O exemplo a seguir demonstra como inicializar a ferramenta e executar uma busca com uma consulta fornecida:
```

---

## Add metadata to the agent's fingerprint

**URL:** llms-txt#add-metadata-to-the-agent's-fingerprint

agent.security_config.fingerprint.metadata = {
    "version": "1.0",
    "department": "Data Science",
    "project": "Customer Analysis"
}

---

## Instanciar as ferramentas

**URL:** llms-txt#instanciar-as-ferramentas

docs_tool = DirectoryReadTool(directory='./blog-posts')
file_tool = FileReadTool()
search_tool = SerperDevTool()
web_rag_tool = WebsiteSearchTool()

---

## Define your task

**URL:** llms-txt#define-your-task

task = Task(
    description="Generate a list of 5 interesting ideas for an article, then write one captivating paragraph for each idea that showcases the potential of a full article on this topic. Return the list of ideas with their paragraphs and your notes.",
    expected_output="5 bullet points, each with a paragraph and accompanying notes.",
)

---

## Create agent with specific Google Sheets actions only

**URL:** llms-txt#create-agent-with-specific-google-sheets-actions-only

data_collector = Agent(
    role="Data Collector",
    goal="Collect and organize data in spreadsheets",
    backstory="An AI assistant that focuses on data collection and organization.",
    apps=[
        'google_sheets/get_values',
        'google_sheets/update_values'
    ]
)

---

## Obtenha saída estruturada

**URL:** llms-txt#obtenha-saída-estruturada

structured_result = analyst.kickoff(
    "Forneça uma análise estruturada do mercado de IA em 2025",
    response_format=MarketAnalysis
)

---

## Defina a tarefa

**URL:** llms-txt#defina-a-tarefa

research_task = Task(
    description="Pesquise os avanços mais recentes em IA...",
    expected_output="",
    agent=pesquisador
)

---

## Verify storage location consistency

**URL:** llms-txt#verify-storage-location-consistency

**Contents:**
  - Comandos de Reset de Knowledge

import os
from crewai.utilities.paths import db_storage_path

print("CREWAI_STORAGE_DIR:", os.getenv("CREWAI_STORAGE_DIR"))
print("Computed storage path:", db_storage_path())
print("Knowledge path:", os.path.join(db_storage_path(), "knowledge"))
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Comandos de Reset de Knowledge
```

---

## Task to create a folder structure

**URL:** llms-txt#task-to-create-a-folder-structure

create_structure_task = Task(
    description="Create a folder called 'Project Files' in the root directory and upload a document from URL",
    agent=box_agent,
    expected_output="Folder created and file uploaded successfully"
)

---

## `YoutubeVideoSearchTool`

**URL:** llms-txt#`youtubevideosearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando para melhorar as ferramentas, portanto podem ocorrer comportamentos inesperados ou mudanças no futuro.
</Note>

Esta ferramenta faz parte do pacote `crewai_tools` e foi projetada para realizar buscas semânticas dentro do conteúdo de vídeos do Youtube, utilizando técnicas de Geração Auxiliada por Recuperação (RAG).
É uma das diversas ferramentas de "Pesquisa" do pacote que aproveitam RAG para diferentes fontes.
O YoutubeVideoSearchTool permite flexibilidade nas buscas: usuários podem pesquisar em qualquer conteúdo de vídeo do Youtube sem especificar uma URL,
ou podem direcionar sua busca para um vídeo específico fornecendo sua URL.

Para utilizar o `YoutubeVideoSearchTool`, é necessário primeiro instalar o pacote `crewai_tools`.
Esse pacote contém o `YoutubeVideoSearchTool` entre outras utilidades desenvolvidas para melhorar suas tarefas de análise e processamento de dados.
Instale o pacote executando o seguinte comando em seu terminal:

O exemplo a seguir demonstra como usar o `YoutubeVideoSearchTool` com um agente CrewAI:

```python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import YoutubeVideoSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O exemplo a seguir demonstra como usar o `YoutubeVideoSearchTool` com um agente CrewAI:
```

---

## Criar um agente com capacidades do Google Calendar

**URL:** llms-txt#criar-um-agente-com-capacidades-do-google-calendar

calendar_agent = Agent(
    role="Schedule Manager",
    goal="Gerenciar eventos de calendário e agendamento de maneira eficiente",
    backstory="Um assistente de IA especializado em gerenciamento de agendas e coordenação de horários.",
    apps=['google_calendar']
)

---

## 다중 AMP 서비스

**URL:** llms-txt#다중-amp-서비스

**Contents:**
- 완전한 예제

mcps=[
    "crewai-amp:weather-insights",
    "crewai-amp:market-analysis",
    "crewai-amp:social-media-monitoring"
]
python  theme={null}
from crewai import Agent, Task, Crew, Process

**Examples:**

Example 1 (unknown):
```unknown
## 완전한 예제

다음은 여러 MCP 서버를 사용하는 완전한 예제입니다:
```

---

## 또는

**URL:** llms-txt#또는

---

## MySQL RAG Search

**URL:** llms-txt#mysql-rag-search

**Contents:**
- Overview
- Installation
- Example

Source: https://docs.crewai.com/en/tools/database-data/mysqltool

The `MySQLSearchTool` is designed to search MySQL databases and return the most relevant results.

This tool is designed to facilitate semantic searches within MySQL database tables. Leveraging the RAG (Retrieve and Generate) technology,
the MySQLSearchTool provides users with an efficient means of querying database table content, specifically tailored for MySQL databases.
It simplifies the process of finding relevant data through semantic search queries, making it an invaluable resource for users needing
to perform advanced queries on extensive datasets within a MySQL database.

To install the `crewai_tools` package and utilize the MySQLSearchTool, execute the following command in your terminal:

Below is an example showcasing how to use the MySQLSearchTool to conduct a semantic search on a table within a MySQL database:

```python Code theme={null}
from crewai_tools import MySQLSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Example

Below is an example showcasing how to use the MySQLSearchTool to conduct a semantic search on a table within a MySQL database:
```

---

## Task output validation flow

**URL:** llms-txt#task-output-validation-flow

**Contents:**
  - 이벤트 추적
- 모범 사례
  - 컨텍스트 가이드라인
  - 임계값 선택
- 성능 고려사항
  - 실행 시간에 미치는 영향
  - 비용 최적화
- 문제 해결

task_output = agent.execute_task(task)
validation_result = guardrail(task_output)

if validation_result.valid:
    # Task completes successfully
    return task_output
else:
    # Task fails with validation feedback
    raise ValidationError(validation_result.feedback)
python  theme={null}
    context = """
    Company XYZ was founded in 2020 and specializes in renewable energy solutions.
    They have 150 employees and generated $50M revenue in 2023.
    Their main products include solar panels and wind turbines.
    """
    python  theme={null}
    # Good: Focused context
    context = "The current weather in New York is 18°C with light rain."

# Avoid: Unrelated information
    context = "The weather is 18°C. The city has 8 million people. Traffic is heavy."
    ```
  </Step>

<Step title="컨텍스트를 정기적으로 업데이트하기">
    참고하는 컨텍스트가 최신이고 정확한 정보를 반영하는지 확인하세요.
  </Step>
</Steps>

<Steps>
  <Step title="기본 검증으로 시작하기">
    맞춤 임계값 없이 시작하여 기준 성능을 파악합니다.
  </Step>

<Step title="요구사항에 따라 조정하기">
    * **중요 콘텐츠**: 최대 정확도를 위해 임계값 8-10 사용
    * **일반 콘텐츠**: 균형 잡힌 검증을 위해 임계값 6-7 사용
    * **창의적 콘텐츠**: 임계값 4-5 또는 기본 판정 기반 검증 사용
  </Step>

<Step title="모니터링 및 반복">
    검증 결과를 추적하고, 오탐/미탐을 기반으로 임계값을 조정합니다.
  </Step>
</Steps>

* **검증 오버헤드**: 각 가드레일마다 작업당 약 1\~3초가 추가됩니다
* **LLM 효율성**: 평가에는 효율적인 모델을 선택하세요 (예: gpt-4o-mini)

* **모델 선택**: guardrail 평가에는 더 작고 효율적인 모델을 사용하세요
* **컨텍스트 크기**: 참조 컨텍스트는 간결하면서도 포괄적으로 유지하세요
* **캐싱**: 반복적인 콘텐츠의 검증 결과를 캐싱하는 것을 고려하세요

<Accordion title="검증이 항상 실패함">
  **가능한 원인:**

* 컨텍스트가 너무 제한적이거나 작업 결과와 관련이 없음
  * 임계값이 콘텐츠 유형에 비해 너무 높게 설정됨
  * 참조 컨텍스트에 오래된 정보가 포함되어 있음

* 작업 요구사항에 맞게 컨텍스트를 검토하고 업데이트하세요
  * 임계값을 낮추거나 기본 판정 기반 검증을 사용하세요
  * 컨텍스트가 최신이며 정확한지 확인하세요
</Accordion>

<Accordion title="오탐 (유효한 콘텐츠가 무효로 판정됨)">
  **가능한 원인:**

* 창의적이거나 해석적인 작업에 임계값이 너무 높음
  * 컨텍스트가 결과의 모든 유효한 측면을 포함하지 않음
  * 평가 모델이 과도하게 보수적임

* 임계값을 낮추거나 기본 검증을 사용하세요
  * 폭넓은 허용 가능한 콘텐츠를 포함하도록 컨텍스트를 확장하세요
  * 다른 평가 모델로 테스트하세요
</Accordion>

<Accordion title="평가 오류">
  **가능한 원인:**

* 네트워크 연결 문제
  * LLM 모델 사용 불가 또는 속도 제한
  * 잘못된 형식의 작업 출력 또는 컨텍스트

* 네트워크 연결 및 LLM 서비스 상태를 확인하세요
  * 일시적 오류에 대해 재시도 로직을 구현하세요
  * guardrail 평가 전에 작업 출력 형식을 검증하세요
</Accordion>

<Card title="도움이 필요하신가요?" icon="headset" href="mailto:support@crewai.com">
  환각 guardrail 구성 또는 문제 해결에 도움이 필요하시면 지원팀에 문의하세요.
</Card>

**Examples:**

Example 1 (unknown):
```unknown
### 이벤트 추적

guardrail은 CrewAI의 이벤트 시스템과 통합되어 가시성을 제공합니다:

* **검증 시작됨**: guardrail 평가가 시작될 때
* **검증 완료됨**: 평가가 결과와 함께 종료될 때
* **검증 실패**: 평가 중 기술적 오류가 발생할 때

## 모범 사례

### 컨텍스트 가이드라인

<Steps>
  <Step title="포괄적인 컨텍스트 제공">
    AI가 출력할 때 기반이 되어야 할 모든 관련 사실 정보를 포함하세요:
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="관련 있는 컨텍스트만 유지하기">
    혼란을 피하기 위해 작업과 직접적으로 관련된 정보만 포함하세요:
```

---

## Defina templates para mensagens de system, user (prompt) e assistant (resposta)

**URL:** llms-txt#defina-templates-para-mensagens-de-system,-user-(prompt)-e-assistant-(resposta)

system_template = """<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>"""
prompt_template = """<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>"""
response_template = """<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>"""

---

## Define an agent with the BraveSearchTool

**URL:** llms-txt#define-an-agent-with-the-bravesearchtool

**Contents:**
- 결론

@agent
def researcher(self) -> Agent:
    return Agent(
        config=self.agents_config["researcher"],
        allow_delegation=False,
        tools=[brave_search_tool]
    )
```

`BraveSearchTool`을 Python 프로젝트에 통합함으로써, 사용자는 애플리케이션 내에서 직접 실시간으로 관련성 높은 인터넷 검색을 수행할 수 있습니다. 이 도구는 강력한 Brave Search API에 대한 간단한 인터페이스를 제공하여, 검색 결과를 프로그래밍적으로 손쉽게 가져오고 처리할 수 있게 해줍니다. 제공된 설정 및 사용 지침을 따르면, 이 도구를 프로젝트에 통합하는 과정이 간편하고 직관적입니다.

---

## `CSVSearchTool`

**URL:** llms-txt#`csvsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  **Experimental**: Ainda estamos trabalhando na melhoria das ferramentas, portanto podem ocorrer comportamentos inesperados ou mudanças futuras.
</Note>

Esta ferramenta é utilizada para realizar buscas RAG (Geração com Recuperação Aprimorada) no conteúdo de um arquivo CSV. Ela permite que usuários façam buscas semânticas por consultas no conteúdo de um arquivo CSV especificado.
Este recurso é particularmente útil para extrair informações de grandes datasets CSV, em que métodos de busca tradicionais poderiam ser ineficientes. Todas as ferramentas com "Search" no nome, incluindo o CSVSearchTool,
são ferramentas RAG projetadas para busca em diferentes fontes de dados.

Instale o pacote crewai\_tools

```python Code theme={null}
from crewai_tools import CSVSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo
```

---

## MCP 도구들이 이제 자동으로 사용 가능합니다!

**URL:** llms-txt#mcp-도구들이-이제-자동으로-사용-가능합니다!

---

## ❌ Descrições vagas que não orientam a colaboração

**URL:** llms-txt#❌-descrições-vagas-que-não-orientam-a-colaboração

**Contents:**
- Solução de Problemas em Colaboração
  - Problema: Agentes Não Colaboram

Task(description="Do some research about chatbots", ...)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Solução de Problemas em Colaboração

### Problema: Agentes Não Colaboram

**Sintomas:** Agentes trabalham isoladamente, sem ocorrer delegação
```

---

## Credenciais LangDB

**URL:** llms-txt#credenciais-langdb

export LANGDB_API_KEY="<sua_chave_api_langdb>"
export LANGDB_PROJECT_ID="<seu_id_projeto_langdb>"
export LANGDB_API_BASE_URL='https://api.us-east-1.langdb.ai'

---

## Each can use different embedding providers

**URL:** llms-txt#each-can-use-different-embedding-providers

**Contents:**
- Configuração de Knowledge
- Parâmetros de Knowledge Suportados
- Transparência do Armazenamento de Knowledge
  - Onde o CrewAI Armazena Arquivos de Knowledge
  - Encontrando Sua Localização de Armazenamento de Knowledge

python Code theme={null}
from crewai.knowledge.knowledge_config import KnowledgeConfig

knowledge_config = KnowledgeConfig(results_limit=10, score_threshold=0.5)

agent = Agent(
    ...
    knowledge_config=knowledge_config
)

~/Library/Application Support/CrewAI/{project_name}/
└── knowledge/                    # Knowledge ChromaDB files
    ├── chroma.sqlite3           # ChromaDB metadata
    ├── {collection_id}/         # Vector embeddings
    └── knowledge_{collection}/  # Named collections

~/.local/share/CrewAI/{project_name}/
└── knowledge/
    ├── chroma.sqlite3
    ├── {collection_id}/
    └── knowledge_{collection}/

C:\Users\{username}\AppData\Local\CrewAI\{project_name}\
└── knowledge\
    ├── chroma.sqlite3
    ├── {collection_id}\
    └── knowledge_{collection}\
python  theme={null}
from crewai.utilities.paths import db_storage_path
import os

**Examples:**

Example 1 (unknown):
```unknown
<Tip>
  Diferente da recuperação de um banco de dados vetorial usando uma ferramenta, agentes pré-carregados com knowledge não precisarão de uma persona de recuperação ou tarefa.
  Simplesmente adicione as fontes de knowledge relevantes que seu agente ou crew precisa para funcionar.

  As fontes de knowledge podem ser adicionadas no nível do agente ou da crew.
  As fontes de knowledge no nível da crew serão usadas por **todos os agentes** na crew.
  As fontes de knowledge no nível do agente serão usadas pelo **agente específico** que é pré-carregado com o knowledge.
</Tip>

## Configuração de Knowledge

Você pode configurar a configuração de knowledge para a crew ou agente.
```

Example 2 (unknown):
```unknown
<Tip>
  `results_limit`: é o número de documentos relevantes a retornar. Padrão é 3.
  `score_threshold`: é a pontuação mínima para um documento ser considerado relevante. Padrão é 0.35.
</Tip>

## Parâmetros de Knowledge Suportados

<ParamField body="sources" type="List[BaseKnowledgeSource]" required="Yes">
  Lista de fontes de knowledge que fornecem conteúdo para ser armazenado e consultado. Pode incluir PDF, CSV, Excel, JSON, arquivos de texto ou conteúdo de string.
</ParamField>

<ParamField body="collection_name" type="str">
  Nome da coleção onde o knowledge será armazenado. Usado para identificar diferentes conjuntos de knowledge. Padrão é "knowledge" se não fornecido.
</ParamField>

<ParamField body="storage" type="Optional[KnowledgeStorage]">
  Configuração de armazenamento personalizada para gerenciar como o knowledge é armazenado e recuperado. Se não fornecido, um armazenamento padrão será criado.
</ParamField>

## Transparência do Armazenamento de Knowledge

<Info>
  **Entendendo o Armazenamento de Knowledge**: O CrewAI armazena automaticamente as fontes de knowledge em diretórios específicos da plataforma usando ChromaDB para armazenamento vetorial. Entender essas localizações e padrões ajuda com implantações de produção, depuração e gerenciamento de armazenamento.
</Info>

### Onde o CrewAI Armazena Arquivos de Knowledge

Por padrão, o CrewAI usa o mesmo sistema de armazenamento que a memória, armazenando knowledge em diretórios específicos da plataforma:

#### Localizações de Armazenamento Padrão por Plataforma

**macOS:**
```

Example 3 (unknown):
```unknown
**Linux:**
```

Example 4 (unknown):
```unknown
**Windows:**
```

---

## Exemplo de uso (descomente e adapte após definir server_params):

**URL:** llms-txt#exemplo-de-uso-(descomente-e-adapte-após-definir-server_params):

**Contents:**
- Filtrando Ferramentas
- Usando com CrewBase
  - Configuração de Timeout de Conexão
  - Filtragem de Ferramentas
- Explore Integrações MCP
- Segurança ao Usar MCP
  - Limitações

with MCPServerAdapter(server_params, connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

meu_agente = Agent(
        role="Usuário de Ferramentas MCP",
        goal="Utilizar ferramentas de um servidor MCP.",
        backstory="Posso conectar a servidores MCP e usar suas ferramentas.",
        tools=mcp_tools, # Passe as ferramentas carregadas para o seu agente
        reasoning=True,
        verbose=True
    )
    # ... restante da configuração do seu crew ...
python  theme={null}
with MCPServerAdapter(server_params, connect_timeout=60) as mcp_tools:
    print(f"Available tools: {[tool.name for tool in mcp_tools]}")

meu_agente = Agent(
        role="Usuário de Ferramentas MCP",
        goal="Utilizar ferramentas de um servidor MCP.",
        backstory="Posso conectar a servidores MCP e usar suas ferramentas.",
        tools=mcp_tools["tool_name"], # Passe as ferramentas filtradas para o seu agente
        reasoning=True,
        verbose=True
    )
    # ... restante da configuração do seu crew ...
python  theme={null}
@CrewBase
class CrewWithMCP:
  # ... defina o arquivo de configuração de agentes e tasks ...

mcp_server_params = [
    # Servidor Streamable HTTP
    {
        "url": "http://localhost:8001/mcp",
        "transport": "streamable-http"
    },
    # Servidor SSE
    {
        "url": "http://localhost:8000/sse",
        "transport": "sse"
    },
    # Servidor StdIO
    StdioServerParameters(
        command="python3",
        args=["servers/your_stdio_server.py"],
        env={"UV_PYTHON": "3.12", **os.environ},
    )
  ]

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools()) # obter todas as ferramentas disponíveis

# ... restante da configuração do seu crew ...
python  theme={null}
@CrewBase
class CrewWithMCP:
  mcp_server_params = [...]
  mcp_connect_timeout = 60  # timeout de 60 segundos para todas as conexões MCP

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools())
python  theme={null}
@CrewBase
class CrewWithDefaultTimeout:
  mcp_server_params = [...]
  # Nenhum mcp_connect_timeout especificado - usa padrão de 30 segundos

@agent
  def your_agent(self):
      return Agent(config=self.agents_config["your_agent"], tools=self.get_mcp_tools())
python  theme={null}
@agent
def another_agent(self):
    return Agent(
      config=self.agents_config["your_agent"],
      tools=self.get_mcp_tools("tool_1", "tool_2") # obter ferramentas específicas
    )
python  theme={null}
@CrewBase
class CrewWithCustomTimeout:
  mcp_server_params = [...]
  mcp_connect_timeout = 90  # timeout de 90 segundos para todas as conexões MCP

@agent
  def filtered_agent(self):
      return Agent(
        config=self.agents_config["your_agent"],
        tools=self.get_mcp_tools("tool_1", "tool_2") # ferramentas específicas com timeout personalizado
      )
```

## Explore Integrações MCP

<CardGroup cols={2}>
  <Card title="Transporte Stdio" icon="server" href="/pt-BR/mcp/stdio" color="#3B82F6">
    Conecte-se a servidores MCP locais via entrada/saída padrão. Ideal para scripts e executáveis locais.
  </Card>

<Card title="Transporte SSE" icon="wifi" href="/pt-BR/mcp/sse" color="#10B981">
    Integre com servidores MCP remotos usando Server-Sent Events para streaming de dados em tempo real.
  </Card>

<Card title="Transporte HTTP Streamable" icon="globe" href="/pt-BR/mcp/streamable-http" color="#F59E0B">
    Utilize HTTP Streamable para uma comunicação robusta com servidores MCP remotos.
  </Card>

<Card title="Conectando a Múltiplos Servidores" icon="layer-group" href="/pt-BR/mcp/multiple-servers" color="#8B5CF6">
    Agregue ferramentas de vários servidores MCP simultaneamente usando um único adaptador.
  </Card>

<Card title="Considerações de Segurança" icon="lock" href="/pt-BR/mcp/security" color="#EF4444">
    Revise práticas importantes de segurança para integração MCP e mantenha seus agentes protegidos.
  </Card>
</CardGroup>

Confira este repositório para demonstrações completas e exemplos de integração MCP com CrewAI! 👇

<Card title="Repositório GitHub" icon="github" href="https://github.com/tonykipkemboi/crewai-mcp-demo" target="_blank">
  Demo MCP do CrewAI
</Card>

## Segurança ao Usar MCP

<Warning>
  Sempre assegure-se de confiar no servidor MCP antes de utilizá-lo.
</Warning>

#### Aviso de Segurança: Ataques de DNS Rebinding

Transportes SSE podem ser vulneráveis a ataques de DNS rebinding se não forem devidamente protegidos.
Para prevenir isso:

1. **Sempre valide os cabeçalhos Origin** das conexões SSE recebidas para garantir que venham de fontes esperadas
2. **Evite vincular servidores a todas as interfaces de rede** (0.0.0.0) quando executando localmente – faça o bind apenas para localhost (127.0.0.1)
3. **Implemente autenticação adequada** para todas as conexões SSE

Sem essas proteções, invasores podem usar DNS rebinding para interagir com servidores MCP locais via sites remotos.

Para mais detalhes, consulte a [documentação de Segurança de Transporte da MCP da Anthropic](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations).

* **Primitivas Suportadas**: Atualmente, o `MCPServerAdapter` suporta principalmente a adaptação de `tools` MCP.
  Outras primitivas MCP como `prompts` ou `resources` não são integradas diretamente como componentes CrewAI através deste adaptador por enquanto.
* **Manipulação de Saída**: O adaptador normalmente processa a saída principal de texto de uma ferramenta MCP (por exemplo, `.content[0].text`). Saídas complexas ou multimodais podem exigir tratamento customizado caso não se encaixem nesse padrão.

**Examples:**

Example 1 (unknown):
```unknown
Este padrão geral mostra como integrar ferramentas. Para exemplos específicos para cada transporte, consulte os guias detalhados abaixo.

## Filtrando Ferramentas
```

Example 2 (unknown):
```unknown
## Usando com CrewBase

Para usar ferramentas de servidores MCP dentro de uma classe CrewBase, utilize o método `get_mcp_tools`. As configurações dos servidores devem ser fornecidas via o atributo `mcp_server_params`. Você pode passar uma configuração única ou uma lista com múltiplas configurações.
```

Example 3 (unknown):
```unknown
<Tip>
  Quando uma classe é decorada com `@CrewBase`, o ciclo de vida do adaptador é controlado automaticamente:

  * A primeira chamada a `get_mcp_tools()` cria de forma preguiçosa um `MCPServerAdapter` compartilhado que é reutilizado por todos os agentes do crew.
  * Após a conclusão de `.kickoff()`, um hook pós-kickoff injetado por `@CrewBase` encerra o adaptador, dispensando qualquer limpeza manual.
  * Se `mcp_server_params` não estiver definido, `get_mcp_tools()` retorna uma lista vazia, permitindo manter o mesmo fluxo de código com ou sem MCP configurado.

  Assim, é seguro chamar `get_mcp_tools()` em vários agentes ou habilitar/desabilitar MCP dependendo do ambiente.
</Tip>

### Configuração de Timeout de Conexão

Você pode configurar o timeout de conexão para servidores MCP definindo o atributo de classe `mcp_connect_timeout`. Se nenhum timeout for especificado, o padrão é 30 segundos.
```

Example 4 (unknown):
```unknown

```

---

## `PDFTextWritingTool`

**URL:** llms-txt#`pdftextwritingtool`

**Contents:**
- Description
- Parameters
  - Run Parameters
- Example
  - Direct usage
- Tips

Write text at precise coordinates on a PDF page, optionally embedding a custom TrueType font.

* `pdf_path` (str, required): Path to the input PDF.
* `text` (str, required): Text to add.
* `position` (tuple\[int, int], required): `(x, y)` coordinates.
* `font_size` (int, default `12`)
* `font_color` (str, default `"0 0 0 rg"`)
* `font_name` (str, default `"F1"`)
* `font_file` (str, optional): Path to `.ttf` file.
* `page_number` (int, default `0`)

* Coordinate origin is the bottom‑left corner.
* If using a custom font (`font_file`), ensure it is a valid `.ttf`.

**Examples:**

Example 1 (unknown):
```unknown
### Direct usage
```

---

## Opik Integration

**URL:** llms-txt#opik-integration

Source: https://docs.crewai.com/en/observability/opik

Learn how to use Comet Opik to debug, evaluate, and monitor your CrewAI applications with comprehensive tracing, automated evaluations, and production-ready dashboards.

---

## Obter ferramentas empresariais (as ferramentas do Google Calendar serão incluídas)

**URL:** llms-txt#obter-ferramentas-empresariais-(as-ferramentas-do-google-calendar-serão-incluídas)

---

## Tarefa para adicionar novos dados a uma planilha

**URL:** llms-txt#tarefa-para-adicionar-novos-dados-a-uma-planilha

data_entry_task = Task(
    description="Adicionar novo registro de cliente na planilha de banco de dados de clientes com nome, e-mail e data de cadastro",
    agent=sheets_agent,
    expected_output="Novo registro de cliente adicionado com sucesso à planilha"
)

---

## Firecrawl 검색

**URL:** llms-txt#firecrawl-검색

Source: https://docs.crewai.com/ko/tools/web-scraping/firecrawlsearchtool

FirecrawlSearchTool은 웹사이트를 검색하고 이를 깔끔한 마크다운 또는 구조화된 데이터로 변환하도록 설계되었습니다.

---

## Create agent with specific HubSpot actions only

**URL:** llms-txt#create-agent-with-specific-hubspot-actions-only

contact_creator = Agent(
    role="Contact Creator",
    goal="Create new contacts in HubSpot",
    backstory="An AI assistant that focuses on creating new contact entries in the CRM.",
    apps=['hubspot/create_contact']  # Only contact creation action
)

---

## Serper Scrape Website

**URL:** llms-txt#serper-scrape-website

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/serperscrapewebsitetool

The `SerperScrapeWebsiteTool` is designed to scrape websites and extract clean, readable content using Serper's scraping API.

---

## Tarefa de criação de reunião

**URL:** llms-txt#tarefa-de-criação-de-reunião

create_meeting_task = Task(
    description="Crie uma reunião diária de equipe amanhã às 9h com o time de desenvolvimento",
    agent=calendar_agent,
    expected_output="Reunião criada com sucesso com link do Google Meet"
)

---

## Microsoft OneDrive 통합

**URL:** llms-txt#microsoft-onedrive-통합

**Contents:**
- 개요
- 전제 조건
- Microsoft OneDrive 통합 설정
  - 1. Microsoft 계정 연결
  - 2. 필요한 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 작업
- 사용 예제
  - 기본 Microsoft OneDrive 에이전트 설정

Source: https://docs.crewai.com/ko/enterprise/integrations/microsoft_onedrive

CrewAI를 위한 Microsoft OneDrive 통합으로 파일 및 폴더 관리.

에이전트가 Microsoft OneDrive에서 파일과 폴더를 업로드, 다운로드 및 관리할 수 있도록 합니다. AI 기반 자동화로 파일 작업을 자동화하고, 콘텐츠를 구성하고, 공유 링크를 생성하며, 클라우드 스토리지 워크플로를 간소화합니다.

Microsoft OneDrive 통합을 사용하기 전에 다음 사항을 확인하세요:

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* OneDrive 액세스 권한이 있는 Microsoft 계정
* [통합 페이지](https://app.crewai.com/crewai_plus/connectors)를 통해 Microsoft 계정 연결

## Microsoft OneDrive 통합 설정

### 1. Microsoft 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동
2. 인증 통합 섹션에서 **Microsoft OneDrive** 찾기
3. **연결**을 클릭하고 OAuth 플로우 완료
4. 파일 액세스에 필요한 권한 부여
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token 복사

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="microsoft_onedrive/list_files">
    **설명:** OneDrive의 파일과 폴더를 나열합니다.

* `top` (integer, 선택사항): 검색할 항목 수 (최대 1000). 기본값: 50.
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "name asc", "lastModifiedDateTime desc"). 기본값: "name asc".
    * `filter` (string, 선택사항): OData 필터 표현식.
  </Accordion>

<Accordion title="microsoft_onedrive/get_file_info">
    **설명:** 특정 파일 또는 폴더에 대한 정보를 가져옵니다.

* `item_id` (string, 필수): 파일 또는 폴더의 ID.
  </Accordion>

<Accordion title="microsoft_onedrive/download_file">
    **설명:** OneDrive에서 파일을 다운로드합니다.

* `item_id` (string, 필수): 다운로드할 파일의 ID.
  </Accordion>

<Accordion title="microsoft_onedrive/upload_file">
    **설명:** OneDrive에 파일을 업로드합니다.

* `file_name` (string, 필수): 업로드할 파일의 이름.
    * `content` (string, 필수): Base64로 인코딩된 파일 내용.
  </Accordion>

<Accordion title="microsoft_onedrive/create_folder">
    **설명:** OneDrive에 새 폴더를 만듭니다.

* `folder_name` (string, 필수): 만들 폴더의 이름.
  </Accordion>

<Accordion title="microsoft_onedrive/delete_item">
    **설명:** OneDrive에서 파일 또는 폴더를 삭제합니다.

* `item_id` (string, 필수): 삭제할 파일 또는 폴더의 ID.
  </Accordion>

<Accordion title="microsoft_onedrive/copy_item">
    **설명:** OneDrive에서 파일 또는 폴더를 복사합니다.

* `item_id` (string, 필수): 복사할 파일 또는 폴더의 ID.
    * `parent_id` (string, 선택사항): 대상 폴더의 ID (선택사항, 기본값은 루트).
    * `new_name` (string, 선택사항): 복사된 항목의 새 이름 (선택사항).
  </Accordion>

<Accordion title="microsoft_onedrive/move_item">
    **설명:** OneDrive에서 파일 또는 폴더를 이동합니다.

* `item_id` (string, 필수): 이동할 파일 또는 폴더의 ID.
    * `parent_id` (string, 필수): 대상 폴더의 ID.
    * `new_name` (string, 선택사항): 항목의 새 이름 (선택사항).
  </Accordion>

<Accordion title="microsoft_onedrive/search_files">
    **설명:** OneDrive에서 파일과 폴더를 검색합니다.

* `query` (string, 필수): 검색 쿼리 문자열.
    * `top` (integer, 선택사항): 반환할 결과 수 (최대 1000). 기본값: 50.
  </Accordion>

<Accordion title="microsoft_onedrive/share_item">
    **설명:** 파일 또는 폴더의 공유 링크를 만듭니다.

* `item_id` (string, 필수): 공유할 파일 또는 폴더의 ID.
    * `type` (string, 선택사항): 공유 링크 유형. 옵션: view, edit, embed. 기본값: view.
    * `scope` (string, 선택사항): 공유 링크 범위. 옵션: anonymous, organization. 기본값: anonymous.
  </Accordion>

<Accordion title="microsoft_onedrive/get_thumbnails">
    **설명:** 파일의 썸네일을 가져옵니다.

* `item_id` (string, 필수): 파일의 ID.
  </Accordion>
</AccordionGroup>

### 기본 Microsoft OneDrive 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 작업

<AccordionGroup>
  <Accordion title="microsoft_onedrive/list_files">
    **설명:** OneDrive의 파일과 폴더를 나열합니다.

    **매개변수:**

    * `top` (integer, 선택사항): 검색할 항목 수 (최대 1000). 기본값: 50.
    * `orderby` (string, 선택사항): 필드별 정렬 (예: "name asc", "lastModifiedDateTime desc"). 기본값: "name asc".
    * `filter` (string, 선택사항): OData 필터 표현식.
  </Accordion>

  <Accordion title="microsoft_onedrive/get_file_info">
    **설명:** 특정 파일 또는 폴더에 대한 정보를 가져옵니다.

    **매개변수:**

    * `item_id` (string, 필수): 파일 또는 폴더의 ID.
  </Accordion>

  <Accordion title="microsoft_onedrive/download_file">
    **설명:** OneDrive에서 파일을 다운로드합니다.

    **매개변수:**

    * `item_id` (string, 필수): 다운로드할 파일의 ID.
  </Accordion>

  <Accordion title="microsoft_onedrive/upload_file">
    **설명:** OneDrive에 파일을 업로드합니다.

    **매개변수:**

    * `file_name` (string, 필수): 업로드할 파일의 이름.
    * `content` (string, 필수): Base64로 인코딩된 파일 내용.
  </Accordion>

  <Accordion title="microsoft_onedrive/create_folder">
    **설명:** OneDrive에 새 폴더를 만듭니다.

    **매개변수:**

    * `folder_name` (string, 필수): 만들 폴더의 이름.
  </Accordion>

  <Accordion title="microsoft_onedrive/delete_item">
    **설명:** OneDrive에서 파일 또는 폴더를 삭제합니다.

    **매개변수:**

    * `item_id` (string, 필수): 삭제할 파일 또는 폴더의 ID.
  </Accordion>

  <Accordion title="microsoft_onedrive/copy_item">
    **설명:** OneDrive에서 파일 또는 폴더를 복사합니다.

    **매개변수:**

    * `item_id` (string, 필수): 복사할 파일 또는 폴더의 ID.
    * `parent_id` (string, 선택사항): 대상 폴더의 ID (선택사항, 기본값은 루트).
    * `new_name` (string, 선택사항): 복사된 항목의 새 이름 (선택사항).
  </Accordion>

  <Accordion title="microsoft_onedrive/move_item">
    **설명:** OneDrive에서 파일 또는 폴더를 이동합니다.

    **매개변수:**

    * `item_id` (string, 필수): 이동할 파일 또는 폴더의 ID.
    * `parent_id` (string, 필수): 대상 폴더의 ID.
    * `new_name` (string, 선택사항): 항목의 새 이름 (선택사항).
  </Accordion>

  <Accordion title="microsoft_onedrive/search_files">
    **설명:** OneDrive에서 파일과 폴더를 검색합니다.

    **매개변수:**

    * `query` (string, 필수): 검색 쿼리 문자열.
    * `top` (integer, 선택사항): 반환할 결과 수 (최대 1000). 기본값: 50.
  </Accordion>

  <Accordion title="microsoft_onedrive/share_item">
    **설명:** 파일 또는 폴더의 공유 링크를 만듭니다.

    **매개변수:**

    * `item_id` (string, 필수): 공유할 파일 또는 폴더의 ID.
    * `type` (string, 선택사항): 공유 링크 유형. 옵션: view, edit, embed. 기본값: view.
    * `scope` (string, 선택사항): 공유 링크 범위. 옵션: anonymous, organization. 기본값: anonymous.
  </Accordion>

  <Accordion title="microsoft_onedrive/get_thumbnails">
    **설명:** 파일의 썸네일을 가져옵니다.

    **매개변수:**

    * `item_id` (string, 필수): 파일의 ID.
  </Accordion>
</AccordionGroup>

## 사용 예제

### 기본 Microsoft OneDrive 에이전트 설정
```

---

## certifique-se de que as variáveis OXYLABS_USERNAME e OXYLABS_PASSWORD estejam definidas

**URL:** llms-txt#certifique-se-de-que-as-variáveis-oxylabs_username-e-oxylabs_password-estejam-definidas

tool = OxylabsUniversalScraperTool(
    config={
        "render": "html",
        "user_agent_type": "mobile",
        "context": [
            {"key": "force_headers", "value": True},
            {"key": "force_cookies", "value": True},
            {
                "key": "headers",
                "value": {
                    "Custom-Header-Name": "custom header content",
                },
            },
            {
                "key": "cookies",
                "value": [
                    {"key": "NID", "value": "1234567890"},
                    {"key": "1P JAR", "value": "0987654321"},
                ],
            },
            {"key": "http_method", "value": "get"},
            {"key": "follow_redirects", "value": True},
            {"key": "successful_status_codes", "value": [808, 909]},
        ],
    }
)

result = tool.run(url="https://ip.oxylabs.io")

---

## so the agent can search within the given text file's content

**URL:** llms-txt#so-the-agent-can-search-within-the-given-text-file's-content

**Contents:**
- 인자
- 커스텀 모델 및 임베딩

tool = TXTSearchTool(txt='path/to/text/file.txt')
python Code theme={null}
from chromadb.config import Settings

tool = TXTSearchTool(
    config={
        # 필수: 임베딩 제공자 + 설정
        "embedding_model": {
            "provider": "openai",  # 또는 google-generativeai, cohere, ollama 등
            "config": {
                "model": "text-embedding-3-small",
                # "api_key": "sk-...",  # 환경변수 사용 시 생략 가능
                # 공급자별 예시: Google → model: "models/embedding-001", task_type: "retrieval_document"
            },
        },

# 필수: 벡터DB 설정
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # Chroma 설정(영속성 예시)
                # "settings": Settings(persist_directory="/content/chroma", allow_reset=True, is_persistent=True),

# Qdrant 벡터 파라미터 예시:
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),

# 참고: 컬렉션 이름은 도구에서 관리합니다(기본값: "rag_tool_collection").
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

* `txt` (str): **선택 사항**입니다. 검색하려는 텍스트 파일의 경로입니다.
  이 인자는 도구가 특정 텍스트 파일로 초기화되지 않은 경우에만 필요합니다;
  그렇지 않은 경우 검색은 처음에 제공된 텍스트 파일 내에서 수행됩니다.

## 커스텀 모델 및 임베딩

기본적으로 이 도구는 임베딩과 요약을 위해 OpenAI를 사용합니다.
모델을 커스터마이징하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다:
```

---

## Weave 통합

**URL:** llms-txt#weave-통합

Source: https://docs.crewai.com/ko/observability/weave

Weights & Biases(W&B) Weave를 사용하여 CrewAI 애플리케이션을 추적, 실험, 평가 및 개선하는 방법을 알아보세요.

---

## Create your task with the guardrail

**URL:** llms-txt#create-your-task-with-the-guardrail

**Contents:**
- 고급 구성
  - 사용자 지정 임계값 검증

task = Task(
    description="Write a summary about AI capabilities",
    expected_output="A factual summary based on the provided context",
    agent=my_agent,
    guardrail=guardrail  # Add the guardrail to validate output
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 고급 구성

### 사용자 지정 임계값 검증

보다 엄격한 검증을 위해 사용자 지정 신뢰성 임계값(0-10 범위)를 설정할 수 있습니다:
```

---

## Criação de um LlamaIndex FunctionTool

**URL:** llms-txt#criação-de-um-llamaindex-functiontool

og_tool = FunctionTool.from_defaults(
    search_data, 
    name="DataSearchTool",
    description="Search for information in the data"
)

---

## 결과는 category == "기술"인 항목으로 필터링됩니다

**URL:** llms-txt#결과는-category-==-"기술"인-항목으로-필터링됩니다

**Contents:**
  - QdrantConfig를 사용한 사전 설정 필터

python  theme={null}
from qdrant_client.http import models as qmodels
from crewai_tools import QdrantVectorSearchTool, QdrantConfig

**Examples:**

Example 1 (unknown):
```unknown
### QdrantConfig를 사용한 사전 설정 필터

복잡한 필터링의 경우 구성에서 Qdrant Filter 인스턴스를 사용하세요:
```

---

## Specific tool from AMP service

**URL:** llms-txt#specific-tool-from-amp-service

"crewai-amp:research-tools#pubmed_search"

---

## Selenium 스크래퍼

**URL:** llms-txt#selenium-스크래퍼

Source: https://docs.crewai.com/ko/tools/web-scraping/seleniumscrapingtool

SeleniumScrapingTool은 Selenium을 사용하여 지정된 웹사이트의 콘텐츠를 추출하고 읽도록 설계되었습니다.

---

## Access the fingerprints

**URL:** llms-txt#access-the-fingerprints

agent_fingerprint = agent.fingerprint
crew_fingerprint = crew.fingerprint
task_fingerprint = task.fingerprint

---

## Using MCPServerAdapter with a context manager

**URL:** llms-txt#using-mcpserveradapter-with-a-context-manager

**Contents:**
  - 2. Ciclo de Vida Manual da Conexão
- Considerações de Segurança para SSE

try:
    with MCPServerAdapter(server_params) as tools:
        print(f"Available tools from SSE MCP server: {[tool.name for tool in tools]}")

# Example: Using a tool from the SSE MCP server
        agente_sse = Agent(
            role="Usuário de Serviço Remoto",
            goal="Utilizar uma ferramenta fornecida por um servidor MCP remoto via SSE.",
            backstory="Um agente de IA que conecta a serviços externos via SSE.",
            tools=tools,
            reasoning=True,
            verbose=True,
        )

sse_task = Task(
            description="Buscar atualizações em tempo real das ações 'AAPL' usando uma ferramenta SSE.",
            expected_output="O preço mais recente da ação AAPL.",
            agent=agente_sse,
            markdown=True
        )

sse_crew = Crew(
            agents=[agente_sse],
            tasks=[sse_task],
            verbose=True,
            process=Process.sequential
        )
        
        if tools: # Only kickoff if tools were loaded
            result = sse_crew.kickoff() # Add inputs={'stock_symbol': 'AAPL'} if tool requires it
            print("\nCrew Task Result (SSE - Managed):\n", result)
        else:
            print("Skipping crew kickoff as tools were not loaded (check server connection).")

except Exception as e:
    print(f"Error connecting to or using SSE MCP server (Managed): {e}")
    print("Ensure the SSE MCP server is running and accessible at the specified URL.")

python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter

server_params = {
    "url": "http://localhost:8000/sse", # Replace with your actual SSE server URL
    "transport": "sse"
}

mcp_server_adapter = None 
try:
    mcp_server_adapter = MCPServerAdapter(server_params)
    mcp_server_adapter.start()
    tools = mcp_server_adapter.tools
    print(f"Available tools (manual SSE): {[tool.name for tool in tools]}")

manual_sse_agent = Agent(
        role="Analista Remoto de Dados",
        goal="Analisar dados obtidos de um servidor MCP remoto SSE usando gerenciamento manual de conexão.",
        backstory="Um agente de IA especializado em gerenciar conexões SSE explicitamente.",
        tools=tools,
        verbose=True
    )
    
    analysis_task = Task(
        description="Buscar e analisar as tendências mais recentes de atividade de usuários do servidor SSE.",
        expected_output="Um relatório resumido das tendências de atividade dos usuários.",
        agent=manual_sse_agent
    )
    
    analysis_crew = Crew(
        agents=[manual_sse_agent],
        tasks=[analysis_task],
        verbose=True,
        process=Process.sequential
    )
    
    result = analysis_crew.kickoff()
    print("\nCrew Task Result (SSE - Manual):\n", result)

except Exception as e:
    print(f"An error occurred during manual SSE MCP integration: {e}")
    print("Ensure the SSE MCP server is running and accessible.")
finally:
    if mcp_server_adapter and mcp_server_adapter.is_connected:
        print("Stopping SSE MCP server connection (manual)...")
        mcp_server_adapter.stop()  # **Crucial: Ensure stop is called**
    elif mcp_server_adapter:
        print("SSE MCP server adapter was not connected. No stop needed or start failed.")

## Considerações de Segurança para SSE

<Warning>
  **Ataques de DNS Rebinding**: Transportes SSE podem ser vulneráveis a ataques de DNS rebinding se o servidor MCP não estiver devidamente protegido. Isso pode permitir que sites maliciosos interajam com servidores MCP locais ou da intranet.
</Warning>

Para mitigar esse risco:

* As implementações do servidor MCP devem **validar os cabeçalhos `Origin`** em conexões SSE recebidas.
* Ao rodar servidores MCP SSE locais para desenvolvimento, **faça o bind apenas em `localhost` (`127.0.0.1`)** ao invés de todas as interfaces de rede (`0.0.0.0`).
* Implemente **autenticação adequada** para todas as conexões SSE caso exponham ferramentas ou dados sensíveis.

Para uma visão abrangente das melhores práticas de segurança, consulte nossa página de [Considerações de Segurança](./security.mdx) e a documentação oficial [MCP Transport Security](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations).

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  Substitua `"http://localhost:8000/sse"` pela URL real do seu servidor MCP SSE.
</Note>

### 2. Ciclo de Vida Manual da Conexão

Caso precise de um controle mais detalhado, você pode gerenciar manualmente o ciclo de vida da conexão do `MCPServerAdapter`.

<Info>
  Você **DEVE** chamar `mcp_server_adapter.stop()` para garantir que a conexão seja encerrada e os recursos liberados. O uso de um bloco `try...finally` é altamente recomendado.
</Info>
```

---

## Scrapfly Scrape Website Tool

**URL:** llms-txt#scrapfly-scrape-website-tool

Source: https://docs.crewai.com/en/tools/web-scraping/scrapflyscrapetool

The `ScrapflyScrapeWebsiteTool` leverages Scrapfly's web scraping API to extract content from websites in various formats.

---

## Hooks Antes e Depois do Kickoff

**URL:** llms-txt#hooks-antes-e-depois-do-kickoff

**Contents:**
- Hook Antes do Kickoff
- Hook Depois do Kickoff

Source: https://docs.crewai.com/pt-BR/learn/before-and-after-kickoff-hooks

Aprenda a usar hooks antes e depois do kickoff em CrewAI

O CrewAI fornece hooks que permitem executar código antes e depois do kickoff de uma crew. Esses hooks são úteis para pré-processar entradas ou pós-processar resultados.

## Hook Antes do Kickoff

O hook antes do kickoff é executado antes da crew iniciar suas tarefas. Ele recebe o dicionário de entradas e pode modificá-lo antes de passá-lo para a crew. Você pode usar esse hook para configurar seu ambiente, carregar dados necessários ou pré-processar suas entradas. Isso é útil em cenários onde os dados de entrada podem precisar de enriquecimento ou validação antes de serem processados pela crew.

Aqui está um exemplo de como definir uma função antes do kickoff em seu `crew.py`:

Neste exemplo, a função preparar\_dados modifica as entradas adicionando um novo par chave-valor indicando que as entradas foram processadas.

## Hook Depois do Kickoff

O hook depois do kickoff é executado após a crew completar suas tarefas. Ele recebe o objeto de resultado, que contém as saídas da execução da crew. Este hook é ideal para pós-processar resultados, como log, transformação de dados ou análise adicional.

Veja como você pode definir uma função depois do kickoff em seu `crew.py`:

```python  theme={null}
from crewai import CrewBase
from crewai.project import after_kickoff

@CrewBase
class MinhaEquipe:
    @after_kickoff
    def registrar_resultados(self, resultado):
        # Registra ou modifica os resultados
        print("Execução da equipe concluída com resultado:", resultado)
        return resultado

**Examples:**

Example 1 (unknown):
```unknown
Neste exemplo, a função preparar\_dados modifica as entradas adicionando um novo par chave-valor indicando que as entradas foram processadas.

## Hook Depois do Kickoff

O hook depois do kickoff é executado após a crew completar suas tarefas. Ele recebe o objeto de resultado, que contém as saídas da execução da crew. Este hook é ideal para pós-processar resultados, como log, transformação de dados ou análise adicional.

Veja como você pode definir uma função depois do kickoff em seu `crew.py`:
```

---

## Crie um agente com capacidades do Microsoft Excel

**URL:** llms-txt#crie-um-agente-com-capacidades-do-microsoft-excel

excel_agent = Agent(
    role="Gerenciador de Dados Excel",
    goal="Gerenciar pastas de trabalho e dados do Excel de forma eficiente",
    backstory="Um assistente IA especializado em operações do Microsoft Excel e manipulação de dados.",
    apps=['microsoft_excel']  # Todas as ações do Excel estarão disponíveis
)

---

## MCP 도구들이 이제 자동으로 에이전트에서 사용 가능합니다!

**URL:** llms-txt#mcp-도구들이-이제-자동으로-에이전트에서-사용-가능합니다!

**Contents:**
  - 🔧 **고급: MCPServerAdapter** (복잡한 시나리오용)
- 비디오 튜토리얼
- 설치
- 주요 개념 및 시작하기
- 연결 구성

shell  theme={null}
uv pip install 'crewai-tools[mcp]'
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 🔧 **고급: MCPServerAdapter** (복잡한 시나리오용)

수동 연결 관리가 필요한 고급 사용 사례의 경우 `crewai-tools` 라이브러리는 `MCPServerAdapter` 클래스를 제공합니다.

현재 다음과 같은 전송 메커니즘을 지원합니다:

* **HTTPS**: 원격 서버용 (HTTPS를 통한 보안 통신)
* **Server-Sent Events (SSE)**: 원격 서버용 (서버에서 클라이언트로의 일방향, 실시간 데이터 스트리밍, HTTP 기반)
* **Streamable HTTP**: 원격 서버용 (유연하며 잠재적으로 양방향 통신이 가능, 주로 SSE를 활용한 서버-클라이언트 스트림 제공, HTTP 기반)

## 비디오 튜토리얼

CrewAI와 MCP 통합에 대한 종합적인 안내를 위해 이 비디오 튜토리얼을 시청하세요:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/TpQ45lAZh48" title="CrewAI MCP Integration Guide" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />

## 설치

`crewai-tools`와 함께 MCP를 사용하기 전에, 아래 명령어를 통해 `mcp` 추가 `crewai-tools` 종속성을 설치해야 합니다:
```

Example 2 (unknown):
```unknown
## 주요 개념 및 시작하기

`crewai-tools`의 `MCPServerAdapter` 클래스는 MCP 서버에 연결하고 해당 도구들을 CrewAI 에이전트에서 사용할 수 있도록 하는 기본 방법입니다. 다양한 전송 메커니즘을 지원하며 연결 관리를 간소화합니다.

파이썬 컨텍스트 매니저(`with` 문)를 사용하는 것이 `MCPServerAdapter`를 위한 **권장 방법**입니다. 이를 통해 MCP 서버와의 연결 시작 및 종료가 자동으로 처리됩니다.

## 연결 구성

`MCPServerAdapter`는 연결 동작을 맞춤화할 수 있는 여러 구성 옵션을 지원합니다:

* **`connect_timeout`** (선택 사항): MCP 서버에 연결을 설정하기 위해 대기할 최대 시간(초 단위)입니다. 명시하지 않으면 기본값은 30초입니다. 응답 시간이 가변적인 원격 서버에 특히 유용합니다.
```

---

## Task to create a new company

**URL:** llms-txt#task-to-create-a-new-company

create_company_task = Task(
    description="Create a new company in HubSpot with name 'Innovate Corp' and domain 'innovatecorp.com'.",
    agent=hubspot_agent,
    expected_output="Company created successfully with confirmation"
)

---

## The fingerprint remains unchanged

**URL:** llms-txt#the-fingerprint-remains-unchanged

**Contents:**
- 결정론적 지문

assert agent.fingerprint.uuid_str == original_fingerprint
python  theme={null}
from crewai.security import Fingerprint

**Examples:**

Example 1 (unknown):
```unknown
## 결정론적 지문

UUID와 생성 타임스탬프를 직접 설정할 수는 없지만, `generate` 메서드와 시드(seed)를 사용하여 결정론적 지문을 만들 수 있습니다:
```

---

## Initialize the tool without a specific CSV file.

**URL:** llms-txt#initialize-the-tool-without-a-specific-csv-file.

---

## ✅ Good: Specific, complementary roles

**URL:** llms-txt#✅-good:-specific,-complementary-roles

researcher = Agent(role="Market Research Analyst", ...)
writer = Agent(role="Technical Content Writer", ...)

---

## Integração Google Contacts

**URL:** llms-txt#integração-google-contacts

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Google Contacts
  - 1. Conecte sua Conta Google
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Google Contacts

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/google_contacts

Gerenciamento de contatos e diretório com integração Google Contacts para CrewAI.

Permita que seus agentes gerenciem informações de contatos e diretório através do Google Contacts. Acesse contatos pessoais, pesquise pessoas no diretório, crie e atualize informações de contato, e gerencie grupos de contatos com automação alimentada por IA.

Antes de usar a integração Google Contacts, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Google com acesso ao Google Contacts
* Conectado sua conta Google através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Google Contacts

### 1. Conecte sua Conta Google

1. Navegue para [Integrações CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Google Contacts** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso a contatos e diretório
5. Copie seu Token Enterprise das [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="google_contacts/get_contacts">
    **Descrição:** Recuperar contatos do usuário do Google Contacts.

* `pageSize` (integer, opcional): Número de contatos a retornar (máx 1000). Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): O token da página a recuperar.
    * `personFields` (string, opcional): Campos a incluir (ex: 'names,emailAddresses,phoneNumbers'). Padrão: names,emailAddresses,phoneNumbers
    * `requestSyncToken` (boolean, opcional): Se a resposta deve incluir um token de sincronização. Padrão: false
    * `sortOrder` (string, opcional): A ordem na qual as conexões devem ser classificadas. Opções: LAST\_MODIFIED\_ASCENDING, LAST\_MODIFIED\_DESCENDING, FIRST\_NAME\_ASCENDING, LAST\_NAME\_ASCENDING
  </Accordion>

<Accordion title="google_contacts/search_contacts">
    **Descrição:** Pesquisar por contatos usando uma string de consulta.

* `query` (string, obrigatório): String de consulta de pesquisa
    * `readMask` (string, obrigatório): Campos a ler (ex: 'names,emailAddresses,phoneNumbers')
    * `pageSize` (integer, opcional): Número de resultados a retornar. Mínimo: 1, Máximo: 30
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `sources` (array, opcional): As fontes para pesquisar. Opções: READ\_SOURCE\_TYPE\_CONTACT, READ\_SOURCE\_TYPE\_PROFILE. Padrão: READ\_SOURCE\_TYPE\_CONTACT
  </Accordion>

<Accordion title="google_contacts/list_directory_people">
    **Descrição:** Listar pessoas no diretório do usuário autenticado.

* `sources` (array, obrigatório): Fontes de diretório para pesquisar. Opções: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE, DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_CONTACT. Padrão: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE
    * `pageSize` (integer, opcional): Número de pessoas a retornar. Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `readMask` (string, opcional): Campos a ler (ex: 'names,emailAddresses')
    * `requestSyncToken` (boolean, opcional): Se a resposta deve incluir um token de sincronização. Padrão: false
    * `mergeSources` (array, opcional): Dados adicionais para mesclar nas respostas de pessoas do diretório. Opções: CONTACT
  </Accordion>

<Accordion title="google_contacts/search_directory_people">
    **Descrição:** Pesquisar por pessoas no diretório.

* `query` (string, obrigatório): Consulta de pesquisa
    * `sources` (string, obrigatório): Fontes de diretório (use 'DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE')
    * `pageSize` (integer, opcional): Número de resultados a retornar
    * `readMask` (string, opcional): Campos a ler
  </Accordion>

<Accordion title="google_contacts/list_other_contacts">
    **Descrição:** Listar outros contatos (não nos contatos pessoais do usuário).

* `pageSize` (integer, opcional): Número de contatos a retornar. Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `readMask` (string, opcional): Campos a ler
    * `requestSyncToken` (boolean, opcional): Se a resposta deve incluir um token de sincronização. Padrão: false
  </Accordion>

<Accordion title="google_contacts/search_other_contacts">
    **Descrição:** Pesquisar outros contatos.

* `query` (string, obrigatório): Consulta de pesquisa
    * `readMask` (string, obrigatório): Campos a ler (ex: 'names,emailAddresses')
    * `pageSize` (integer, opcional): Número de resultados
  </Accordion>

<Accordion title="google_contacts/get_person">
    **Descrição:** Obter informações de contato de uma única pessoa por nome do recurso.

* `resourceName` (string, obrigatório): O nome do recurso da pessoa a obter (ex: 'people/c123456789')
    * `personFields` (string, opcional): Campos a incluir (ex: 'names,emailAddresses,phoneNumbers'). Padrão: names,emailAddresses,phoneNumbers
  </Accordion>

<Accordion title="google_contacts/create_contact">
    **Descrição:** Criar um novo contato no catálogo de endereços do usuário.

* `names` (array, opcional): Nomes da pessoa. Cada item é um objeto com `givenName` (string), `familyName` (string), `displayName` (string).
    * `emailAddresses` (array, opcional): Endereços de email. Cada item é um objeto com `value` (string, endereço de email) e `type` (string, 'home', 'work', 'other', padrão 'other').
    * `phoneNumbers` (array, opcional): Números de telefone. Cada item é um objeto com `value` (string, número de telefone) e `type` (string, 'home', 'work', 'mobile', 'other', padrão 'other').
    * `addresses` (array, opcional): Endereços postais. Cada item é um objeto com `formattedValue` (string, endereço formatado) e `type` (string, 'home', 'work', 'other', padrão 'other').
    * `organizations` (array, opcional): Organizações/empresas. Cada item é um objeto com `name` (string, nome da organização), `title` (string, cargo) e `type` (string, 'work', 'other', padrão 'work').
  </Accordion>

<Accordion title="google_contacts/update_contact">
    **Descrição:** Atualizar informações de um contato existente.

* `resourceName` (string, obrigatório): O nome do recurso da pessoa a atualizar (ex: 'people/c123456789').
    * `updatePersonFields` (string, obrigatório): Campos a atualizar (ex: 'names,emailAddresses,phoneNumbers').
    * `names` (array, opcional): Nomes da pessoa. Cada item é um objeto com `givenName` (string), `familyName` (string), `displayName` (string).
    * `emailAddresses` (array, opcional): Endereços de email. Cada item é um objeto com `value` (string, endereço de email) e `type` (string, 'home', 'work', 'other').
    * `phoneNumbers` (array, opcional): Números de telefone. Cada item é um objeto com `value` (string, número de telefone) e `type` (string, 'home', 'work', 'mobile', 'other').
  </Accordion>

<Accordion title="google_contacts/delete_contact">
    **Descrição:** Excluir um contato do catálogo de endereços do usuário.

* `resourceName` (string, obrigatório): O nome do recurso da pessoa a excluir (ex: 'people/c123456789').
  </Accordion>

<Accordion title="google_contacts/batch_get_people">
    **Descrição:** Obter informações sobre várias pessoas em uma única solicitação.

* `resourceNames` (array, obrigatório): Nomes de recursos das pessoas a obter (máx 200 itens).
    * `personFields` (string, opcional): Campos a incluir (ex: 'names,emailAddresses,phoneNumbers'). Padrão: names,emailAddresses,phoneNumbers
  </Accordion>

<Accordion title="google_contacts/list_contact_groups">
    **Descrição:** Listar os grupos de contatos (rótulos) do usuário.

* `pageSize` (integer, opcional): Número de grupos de contatos a retornar. Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `groupFields` (string, opcional): Campos a incluir (ex: 'name,memberCount,clientData'). Padrão: name,memberCount
  </Accordion>

<Accordion title="google_contacts/get_contact_group">
    **Descrição:** Obter um grupo de contatos específico por nome do recurso.

* `resourceName` (string, obrigatório): O nome do recurso do grupo de contatos (ex: 'contactGroups/myContactGroup').
    * `maxMembers` (integer, opcional): Número máximo de membros a incluir. Mínimo: 0, Máximo: 20000
    * `groupFields` (string, opcional): Campos a incluir (ex: 'name,memberCount,clientData'). Padrão: name,memberCount
  </Accordion>

<Accordion title="google_contacts/create_contact_group">
    **Descrição:** Criar um novo grupo de contatos (rótulo).

* `name` (string, obrigatório): O nome do grupo de contatos.
    * `clientData` (array, opcional): Dados específicos do cliente. Cada item é um objeto com `key` (string) e `value` (string).
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Google Contacts

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="google_contacts/get_contacts">
    **Descrição:** Recuperar contatos do usuário do Google Contacts.

    **Parâmetros:**

    * `pageSize` (integer, opcional): Número de contatos a retornar (máx 1000). Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): O token da página a recuperar.
    * `personFields` (string, opcional): Campos a incluir (ex: 'names,emailAddresses,phoneNumbers'). Padrão: names,emailAddresses,phoneNumbers
    * `requestSyncToken` (boolean, opcional): Se a resposta deve incluir um token de sincronização. Padrão: false
    * `sortOrder` (string, opcional): A ordem na qual as conexões devem ser classificadas. Opções: LAST\_MODIFIED\_ASCENDING, LAST\_MODIFIED\_DESCENDING, FIRST\_NAME\_ASCENDING, LAST\_NAME\_ASCENDING
  </Accordion>

  <Accordion title="google_contacts/search_contacts">
    **Descrição:** Pesquisar por contatos usando uma string de consulta.

    **Parâmetros:**

    * `query` (string, obrigatório): String de consulta de pesquisa
    * `readMask` (string, obrigatório): Campos a ler (ex: 'names,emailAddresses,phoneNumbers')
    * `pageSize` (integer, opcional): Número de resultados a retornar. Mínimo: 1, Máximo: 30
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `sources` (array, opcional): As fontes para pesquisar. Opções: READ\_SOURCE\_TYPE\_CONTACT, READ\_SOURCE\_TYPE\_PROFILE. Padrão: READ\_SOURCE\_TYPE\_CONTACT
  </Accordion>

  <Accordion title="google_contacts/list_directory_people">
    **Descrição:** Listar pessoas no diretório do usuário autenticado.

    **Parâmetros:**

    * `sources` (array, obrigatório): Fontes de diretório para pesquisar. Opções: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE, DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_CONTACT. Padrão: DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE
    * `pageSize` (integer, opcional): Número de pessoas a retornar. Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `readMask` (string, opcional): Campos a ler (ex: 'names,emailAddresses')
    * `requestSyncToken` (boolean, opcional): Se a resposta deve incluir um token de sincronização. Padrão: false
    * `mergeSources` (array, opcional): Dados adicionais para mesclar nas respostas de pessoas do diretório. Opções: CONTACT
  </Accordion>

  <Accordion title="google_contacts/search_directory_people">
    **Descrição:** Pesquisar por pessoas no diretório.

    **Parâmetros:**

    * `query` (string, obrigatório): Consulta de pesquisa
    * `sources` (string, obrigatório): Fontes de diretório (use 'DIRECTORY\_SOURCE\_TYPE\_DOMAIN\_PROFILE')
    * `pageSize` (integer, opcional): Número de resultados a retornar
    * `readMask` (string, opcional): Campos a ler
  </Accordion>

  <Accordion title="google_contacts/list_other_contacts">
    **Descrição:** Listar outros contatos (não nos contatos pessoais do usuário).

    **Parâmetros:**

    * `pageSize` (integer, opcional): Número de contatos a retornar. Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `readMask` (string, opcional): Campos a ler
    * `requestSyncToken` (boolean, opcional): Se a resposta deve incluir um token de sincronização. Padrão: false
  </Accordion>

  <Accordion title="google_contacts/search_other_contacts">
    **Descrição:** Pesquisar outros contatos.

    **Parâmetros:**

    * `query` (string, obrigatório): Consulta de pesquisa
    * `readMask` (string, obrigatório): Campos a ler (ex: 'names,emailAddresses')
    * `pageSize` (integer, opcional): Número de resultados
  </Accordion>

  <Accordion title="google_contacts/get_person">
    **Descrição:** Obter informações de contato de uma única pessoa por nome do recurso.

    **Parâmetros:**

    * `resourceName` (string, obrigatório): O nome do recurso da pessoa a obter (ex: 'people/c123456789')
    * `personFields` (string, opcional): Campos a incluir (ex: 'names,emailAddresses,phoneNumbers'). Padrão: names,emailAddresses,phoneNumbers
  </Accordion>

  <Accordion title="google_contacts/create_contact">
    **Descrição:** Criar um novo contato no catálogo de endereços do usuário.

    **Parâmetros:**

    * `names` (array, opcional): Nomes da pessoa. Cada item é um objeto com `givenName` (string), `familyName` (string), `displayName` (string).
    * `emailAddresses` (array, opcional): Endereços de email. Cada item é um objeto com `value` (string, endereço de email) e `type` (string, 'home', 'work', 'other', padrão 'other').
    * `phoneNumbers` (array, opcional): Números de telefone. Cada item é um objeto com `value` (string, número de telefone) e `type` (string, 'home', 'work', 'mobile', 'other', padrão 'other').
    * `addresses` (array, opcional): Endereços postais. Cada item é um objeto com `formattedValue` (string, endereço formatado) e `type` (string, 'home', 'work', 'other', padrão 'other').
    * `organizations` (array, opcional): Organizações/empresas. Cada item é um objeto com `name` (string, nome da organização), `title` (string, cargo) e `type` (string, 'work', 'other', padrão 'work').
  </Accordion>

  <Accordion title="google_contacts/update_contact">
    **Descrição:** Atualizar informações de um contato existente.

    **Parâmetros:**

    * `resourceName` (string, obrigatório): O nome do recurso da pessoa a atualizar (ex: 'people/c123456789').
    * `updatePersonFields` (string, obrigatório): Campos a atualizar (ex: 'names,emailAddresses,phoneNumbers').
    * `names` (array, opcional): Nomes da pessoa. Cada item é um objeto com `givenName` (string), `familyName` (string), `displayName` (string).
    * `emailAddresses` (array, opcional): Endereços de email. Cada item é um objeto com `value` (string, endereço de email) e `type` (string, 'home', 'work', 'other').
    * `phoneNumbers` (array, opcional): Números de telefone. Cada item é um objeto com `value` (string, número de telefone) e `type` (string, 'home', 'work', 'mobile', 'other').
  </Accordion>

  <Accordion title="google_contacts/delete_contact">
    **Descrição:** Excluir um contato do catálogo de endereços do usuário.

    **Parâmetros:**

    * `resourceName` (string, obrigatório): O nome do recurso da pessoa a excluir (ex: 'people/c123456789').
  </Accordion>

  <Accordion title="google_contacts/batch_get_people">
    **Descrição:** Obter informações sobre várias pessoas em uma única solicitação.

    **Parâmetros:**

    * `resourceNames` (array, obrigatório): Nomes de recursos das pessoas a obter (máx 200 itens).
    * `personFields` (string, opcional): Campos a incluir (ex: 'names,emailAddresses,phoneNumbers'). Padrão: names,emailAddresses,phoneNumbers
  </Accordion>

  <Accordion title="google_contacts/list_contact_groups">
    **Descrição:** Listar os grupos de contatos (rótulos) do usuário.

    **Parâmetros:**

    * `pageSize` (integer, opcional): Número de grupos de contatos a retornar. Mínimo: 1, Máximo: 1000
    * `pageToken` (string, opcional): Token especificando qual página de resultado retornar.
    * `groupFields` (string, opcional): Campos a incluir (ex: 'name,memberCount,clientData'). Padrão: name,memberCount
  </Accordion>

  <Accordion title="google_contacts/get_contact_group">
    **Descrição:** Obter um grupo de contatos específico por nome do recurso.

    **Parâmetros:**

    * `resourceName` (string, obrigatório): O nome do recurso do grupo de contatos (ex: 'contactGroups/myContactGroup').
    * `maxMembers` (integer, opcional): Número máximo de membros a incluir. Mínimo: 0, Máximo: 20000
    * `groupFields` (string, opcional): Campos a incluir (ex: 'name,memberCount,clientData'). Padrão: name,memberCount
  </Accordion>

  <Accordion title="google_contacts/create_contact_group">
    **Descrição:** Criar um novo grupo de contatos (rótulo).

    **Parâmetros:**

    * `name` (string, obrigatório): O nome do grupo de contatos.
    * `clientData` (array, opcional): Dados específicos do cliente. Cada item é um objeto com `key` (string) e `value` (string).
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Google Contacts
```

---

## Guia Estratégico de Seleção de LLMs

**URL:** llms-txt#guia-estratégico-de-seleção-de-llms

**Contents:**
- A Abordagem CrewAI para Seleção de LLMs
- Framework de Decisão Rápida
- Framework Central de Seleção
  - a. Pensamento Orientado à Tarefa
  - b. Mapeamento de Capacidades do Modelo
- Padrões Estratégicos de Configuração
  - a. Abordagem Multi-Modelo

Source: https://docs.crewai.com/pt-BR/learn/llm-selection-guide

Framework estratégico para escolher o LLM certo para seus agentes CrewAI e escrever definições eficazes de tarefas e agentes

## A Abordagem CrewAI para Seleção de LLMs

Em vez de recomendações prescritivas de modelos, defendemos um **framework de pensamento** que ajude você a tomar decisões informadas com base no seu caso de uso, restrições e requisitos específicos. O cenário de LLMs evolui rapidamente, com novos modelos surgindo regularmente e os existentes sendo atualizados frequentemente. O que mais importa é desenvolver uma abordagem sistemática de avaliação que permaneça relevante independentemente dos modelos disponíveis no momento.

<Note>
  Este guia foca em pensamento estratégico em vez de recomendações de modelos específicos, já que o cenário dos LLMs evolui rapidamente.
</Note>

## Framework de Decisão Rápida

<Steps>
  <Step title="Analise Suas Tarefas">
    Comece entendendo profundamente o que suas tarefas realmente exigem. Considere a complexidade cognitiva envolvida, a profundidade de raciocínio necessária, o formato dos resultados esperados e a quantidade de contexto que o modelo precisará processar. Essa análise fundamental guiará todas as decisões seguintes.
  </Step>

<Step title="Mapeie as Capacidades dos Modelos">
    Assim que você compreende seus requisitos, mapeie-os para as forças dos modelos. Diferentes famílias de modelos se destacam em diferentes tipos de trabalho; alguns são otimizados para raciocínio e análise, outros para criatividade e geração de conteúdo, e outros para velocidade e eficiência.
  </Step>

<Step title="Considere Restrições">
    Leve em conta suas reais restrições operacionais, incluindo limitações orçamentárias, requisitos de latência, necessidades de privacidade de dados e capacidades de infraestrutura. O melhor modelo teoricamente pode não ser a melhor escolha prática para sua situação.
  </Step>

<Step title="Teste e Itere">
    Comece com modelos confiáveis e bem conhecidos e otimize com base no desempenho real no seu caso de uso. Os resultados práticos frequentemente diferem dos benchmarks teóricos, então testes empíricos são cruciais.
  </Step>
</Steps>

## Framework Central de Seleção

### a. Pensamento Orientado à Tarefa

O passo mais crítico na seleção de LLMs é entender o que sua tarefa realmente exige. Frequentemente, equipes escolhem modelos com base em reputação geral ou pontuações de benchmark, sem analisar cuidadosamente suas necessidades específicas. Essa abordagem leva tanto ao superdimensionamento de tarefas simples usando modelos caros e complexos quanto à subutilização em tarefas sofisticadas com modelos sem as capacidades necessárias.

<Tabs>
  <Tab title="Complexidade de Raciocínio">
    * **Tarefas Simples** representam a maioria do trabalho diário de IA e incluem seguir instruções básicas, processar dados simples e formatação elementar. Estas tarefas geralmente têm entradas e saídas claras, com mínima ambiguidade. A carga cognitiva é baixa e o modelo precisa apenas seguir instruções explícitas, não realizar raciocínio complexo.

* **Tarefas Complexas** exigem raciocínio de múltiplas etapas, pensamento estratégico e a capacidade de lidar com informações ambíguas ou incompletas. Podem envolver análise de múltiplas fontes de dados, desenvolvimento de estratégias abrangentes ou resolução de problemas que precisam ser decompostos em componentes menores. O modelo deve manter o contexto ao longo de várias etapas de raciocínio e frequentemente precisa inferir informações não explicitamente declaradas.

* **Tarefas Criativas** exigem um tipo diferente de capacidade cognitiva, focada em gerar conteúdo novo, envolvente e adequado ao contexto. Isso inclui storytelling, criação de textos de marketing e solução criativa de problemas. O modelo deve compreender nuances, tom e público, produzindo conteúdo autêntico e envolvente, não apenas fórmulas.
  </Tab>

<Tab title="Requisitos de Saída">
    * **Dados Estruturados** exigem precisão e consistência na adesão ao formato. Ao trabalhar com JSON, XML ou formatos de banco de dados, o modelo deve produzir saídas sintaticamente corretas, que possam ser processadas programaticamente. Essas tarefas possuem requisitos rígidos de validação e pouca tolerância a erros de formato, tornando a confiabilidade mais importante que a criatividade.

* **Conteúdo Criativo** requer equilíbrio entre competência técnica e criatividade. O modelo precisa compreender o público, tom e voz da marca, ao mesmo tempo em que produz conteúdo que engaja leitores e atinge objetivos comunicativos específicos. A qualidade aqui é mais subjetiva e exige modelos capazes de adaptar o estilo de escrita a diferentes contextos e propósitos.

* **Conteúdo Técnico** situa-se entre dados estruturados e conteúdo criativo, demandando precisão e clareza. Documentação, geração de código e análises técnicas precisam ser exatas e completas, mas ainda assim acessíveis ao público-alvo. O modelo deve entender conceitos técnicos complexos e comunicá-los de forma eficaz.
  </Tab>

<Tab title="Necessidades de Contexto">
    * **Contexto Curto** envolve tarefas imediatas e focalizadas, onde o modelo processa informações limitadas rapidamente. São interações transacionais em que velocidade e eficiência importam mais do que compreensão profunda. O modelo não precisa manter histórico extenso ou processar grandes documentos.

* **Contexto Longo** é necessário ao lidar com documentos substanciais, conversas extensas ou tarefas complexas de múltiplas partes. O modelo precisa manter coerência ao longo de milhares de tokens, referenciando informações anteriores com precisão. Essencial para análise de documentos, pesquisa abrangente e sistemas de diálogo sofisticados.

* **Contexto Muito Longo** ultrapassa os limites do possível hoje, com processamento de documentos massivos, síntese de pesquisas extensas ou interações multi-sessão. São casos que exigem modelos projetados especificamente para lidar com contexto estendido e envolvem trade-offs entre extensão e velocidade.
  </Tab>
</Tabs>

### b. Mapeamento de Capacidades do Modelo

Entender as capacidades dos modelos exige ir além do marketing e dos benchmarks, analisando forças e limitações fundamentais das arquiteturas e métodos de treinamento.

<AccordionGroup>
  <Accordion title="Modelos de Raciocínio" icon="brain">
    Modelos de raciocínio formam uma categoria especializada, projetada para tarefas de pensamento complexo e de múltiplas etapas. Eles se destacam na resolução de problemas que requerem análise cuidadosa, planejamento estratégico ou decomposição sistemática. Normalmente aplicam técnicas como chain-of-thought ou tree-of-thought para conduzir o raciocínio passo a passo.

O ponto forte é manter consistência lógica em cadeias longas de raciocínio e decompor problemas complexos em partes gerenciáveis. São especialmente valiosos para planejamento estratégico, análise complexa e situações onde a qualidade do raciocínio importa mais que a velocidade.

Entretanto, há trade-offs em termos de custo e velocidade. Podem ser menos adequados para tarefas criativas ou operações simples, onde suas capacidades avançadas não são necessárias. Considere-os quando as tarefas realmente se beneficiarem dessa análise detalhada.
  </Accordion>

<Accordion title="Modelos de Uso Geral" icon="microchip">
    Modelos de uso geral oferecem uma abordagem equilibrada, com desempenho sólido em uma ampla gama de tarefas, sem especialização extrema. São treinados em conjuntos de dados diversificados e otimizados para versatilidade.

A principal vantagem é a confiabilidade previsível em diversos trabalhos: pesquisa, análise, criação de conteúdo, processamento de dados. São ótimas opções iniciais para equipes que buscam consistência ao lidar com fluxos variados.

Embora não atinjam picos de desempenho como modelos especializados, oferecem simplicidade operacional e baixa complexidade na gestão. São o melhor ponto de partida para novos projetos, permitindo descobertas de necessidades antes de avançar para otimizações.
  </Accordion>

<Accordion title="Modelos Rápidos & Eficientes" icon="bolt">
    Modelos rápidos e eficientes priorizam velocidade, custo e eficiência de recursos, em vez de raciocínio sofisticado. São otimizados para cenários de alto volume onde respostas rápidas e baixos custos são mais importantes que compreensão ou criatividade profunda.

Brilham em operações rotineiras, processamento simples de dados, chamadas de funções e tarefas de alto volume. Aplicações que processam muitos pedidos rapidamente ou operam sob restrições orçamentárias se beneficiam desses modelos.

O ponto crucial é garantir que suas capacidades atendam às exigências da tarefa. Podem não atender tarefas que exijam entendimento profundo, raciocínio complexo ou geração de conteúdo sofisticado. São ideais para tarefas rotineiras bem definidas.
  </Accordion>

<Accordion title="Modelos Criativos" icon="pen">
    Modelos criativos são otimizados para geração de conteúdo, qualidade de escrita e pensamento inovador. Excelentes na compreensão de nuances, tom e estilo, produzindo conteúdo envolvente e natural.

O ponto forte está em adaptar o estilo para diferentes públicos, manter voz e tom consistentes e engajar leitores. Performam melhor em storytelling, textos publicitários, comunicações de marca e outras tarefas com criatividade como foco.

Ao selecionar esses modelos, considere não apenas a habilidade de gerar texto, mas a compreensão de público, contexto e objetivo. Os melhores modelos criativos adaptam a saída à voz da marca, diferentes segmentos e mantêm consistência em peças longas.
  </Accordion>

<Accordion title="Modelos Open Source" icon="code">
    Modelos open source oferecem vantagens em controle de custos, potencial de customização, privacidade de dados e flexibilidade de deployment. Podem ser rodados localmente ou em infraestrutura própria, dando controle total sobre dados e comportamento.

Os principais benefícios incluem eliminação de custos por token, possibilidade de fine-tuning, privacidade total e independência de fornecedores externos. Perfeitos para organizações com necessidade de privacidade, orçamento limitado ou desejo de customização.

Contudo, requerem maior expertise técnica para implantar e manter. Considere custos de infraestrutura, complexidade de gestão e esforços contínuos de atualização e otimização ao avaliar modelos open source. O custo total pode ser maior que o de alternativas em nuvem devido a esse overhead.
  </Accordion>
</AccordionGroup>

## Padrões Estratégicos de Configuração

### a. Abordagem Multi-Modelo

<Tip>
  Use diferentes modelos para diferentes propósitos dentro da mesma crew para otimizar desempenho e custos.
</Tip>

As implementações CrewAI mais sofisticadas empregam múltiplos modelos estrategicamente, designando-os conforme as funções e necessidades dos agentes. Assim, é possível otimizar desempenho e custos usando o modelo mais adequado para cada tipo de tarefa.

Agentes de planejamento se beneficiam de modelos de raciocínio para pensamento estratégico e análise multi-etapas. Esses agentes funcionam como o "cérebro" da operação. Agentes de conteúdo têm melhor desempenho com modelos criativos focados em qualidade de escrita e engajamento. Agentes de processamento, responsáveis por operações rotineiras, podem usar modelos eficientes priorizando velocidade.

**Exemplo: Crew de Pesquisa e Análise**

```python  theme={null}
from crewai import Agent, Task, Crew, LLM

---

## Define a sample task

**URL:** llms-txt#define-a-sample-task

engineering_task = Task(
    description="Review AI implementation files for potential improvements",
    expected_output="A summary of key findings and recommendations",
    agent=principal_engineer
)

---

## Strict mode - directory must already exist

**URL:** llms-txt#strict-mode---directory-must-already-exist

**Contents:**
  - YAML 구성
  - 사용 사례
  - 오류 처리
- 결론

strict_output_task = Task(
    description='Save critical data that requires existing infrastructure',
    expected_output='Data saved to pre-configured location',
    agent=data_agent,
    output_file='secure/vault/critical_data.json',
    create_directory=False  # Will raise RuntimeError if 'secure/vault/' doesn't exist
)
yaml tasks.yaml theme={null}
analysis_task:
  description: >
    분기별 재무 분석 생성
  expected_output: >
    분기별 인사이트가 포함된 종합 재무 보고서
  agent: financial_analyst
  output_file: reports/quarterly/q4_2024_analysis.pdf
  create_directory: true  # 'reports/quarterly/' 디렉토리를 자동으로 생성

audit_task:
  description: >
    컴플라이언스 감사 수행 및 기존 감사 디렉토리에 저장
  expected_output: >
    컴플라이언스 감사 보고서
  agent: auditor
  output_file: audit/compliance_report.md
  create_directory: false  # 디렉토리가 이미 존재해야 함
python Code theme={null}
try:
    result = crew.kickoff()
except RuntimeError as e:
    # Handle missing directory error
    print(f"Directory creation failed: {e}")
    # Create directory manually or use fallback location
```

아래 영상을 통해 CrewAI에서 구조화된 출력을 사용하는 방법을 확인하세요:

<iframe className="w-full aspect-video rounded-xl" src="https://www.youtube.com/embed/dNpKQk5uxHw" title="CrewAI에서 구조화된 출력 사용하기" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerPolicy="strict-origin-when-cross-origin" allowFullScreen />

작업(task)은 CrewAI 에이전트의 행동을 이끄는 원동력입니다.
작업과 그 결과를 적절하게 정의함으로써, 에이전트가 독립적으로 또는 협업 단위로 효과적으로 작동할 수 있는 기반을 마련할 수 있습니다.
작업에 적합한 도구를 장착하고, 실행 과정을 이해하며, 견고한 검증 절차를 따르는 것은 CrewAI의 잠재력을 극대화하는 데 필수적입니다.
이를 통해 에이전트가 할당된 작업에 효과적으로 준비되고, 작업이 의도대로 수행될 수 있습니다.

**Examples:**

Example 1 (unknown):
```unknown
### YAML 구성

이 동작은 YAML 태스크 정의에서도 구성할 수 있습니다:
```

Example 2 (unknown):
```unknown
### 사용 사례

**자동 디렉토리 생성 (`create_directory=True`):**

* 개발 및 프로토타이핑 환경
* 날짜 기반 폴더로 동적 보고서 생성
* 디렉토리 구조가 달라질 수 있는 자동화된 워크플로우
* 사용자별 폴더가 필요한 멀티 테넌트 애플리케이션

**수동 디렉토리 관리 (`create_directory=False`):**

* 엄격한 파일 시스템 제어가 필요한 운영 환경
* 디렉토리가 사전 구성되어야 하는 보안 민감 애플리케이션
* 특정 권한 요구 사항이 있는 시스템
* 디렉토리 생성이 감사되는 규정 준수 환경

### 오류 처리

`create_directory=False`이고 디렉토리가 존재하지 않는 경우, CrewAI는 `RuntimeError`를 발생시킵니다:
```

---

## First, install and run Ollama locally, then pull an embedding model:

**URL:** llms-txt#first,-install-and-run-ollama-locally,-then-pull-an-embedding-model:

---

## Notas de Versão

**URL:** llms-txt#notas-de-versão

Source: https://docs.crewai.com/pt-BR/changelog

Atualizações de produto, melhorias e correções do CrewAI

<Update label="30 set 2025">
  ## v1.0.0a1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/1.0.0a1)

### Melhorias e correções principais

* Corrigido o controle de permissões do atributo `actions` na configuração de agentes
  * Fluxos de CI e publicação atualizados para suportar a nova estrutura de monorepo
  * Migração para Python 3.13 e atualização do metadado dos pacotes

### Novos recursos e melhorias

* Novos atributos `apps` e `actions` nos agentes para controles avançados em runtime
  * Repositório `crewai-tools` incorporado ao workspace principal (monorepo)
  * Versão incrementada para 1.0.0a1 em todos os pacotes (marco alpha)

### Limpeza e infraestrutura

* Novo pipeline de CI com versionamento fixo e estratégia de publicação
  * Unificação do código interno para gerenciar múltiplos pacotes
</Update>

<Update label="26 set 2025">
  ## v0.201.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.201.1)

### Melhorias e correções principais

* Provedor de embeddings Watson renomeado para `watsonx` com prefixos de ambiente atualizados
  * Compatibilidade do ChromaDB com providers `watsonx` e `voyageai`

### Limpeza e descontinuações

* Padronização dos prefixos de variáveis de ambiente para todos os providers
  * Versão do CrewAI atualizada para 0.201.1 com dependências internas revisadas
</Update>

<Update label="24 set 2025">
  ## v0.201.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.201.0)

### Melhorias e correções principais

* Parâmetro `ready` agora é opcional em `_create_reasoning_plan`
  * Correções no tratamento de configuração aninhada para embedders
  * Suporte ao parâmetro `batch_size` para evitar limites de tokens
  * Corrigido o nome do diretório na documentação do Quickstart
  * Resolvidos problemas de cache da duração de testes e exportação de eventos
  * Adicionada lógica de fallback nas configurações de crew

### Novos recursos e melhorias

* Introduzido gerenciamento de contexto da plataforma thread-safe
  * Adicionado comando `crewai uv` para executar `uv` diretamente via CLI
  * Possibilidade de marcar traces como falhas para fluxos de observabilidade
  * Suporte a tipos de embedding personalizados e migração entre providers
  * ChromaDB atualizado para v1.1.0 com correções de compatibilidade e melhorias de tipagem
  * Validações compatíveis com Pydantic e reorganização dos grupos de dependências

### Documentação e guias

* Cobertura do changelog atualizada para os releases 0.193.x
  * Documentado suporte a metadados de eventos no LLM Guardrail
  * Orientações adicionais sobre fallback e visibilidade de parâmetros de configuração

### Limpeza e descontinuações

* Resolvidos problemas de Ruff e MyPy em diversos módulos
  * Melhorias nas anotações de tipos e consolidação de utilidades
  * Descontinuação de utilitários antigos em favor de importações compatíveis com Pydantic

* Novo contribuidor: @qizwiz (primeira contribuição)
</Update>

<Update label="20 set 2025">
  ## v0.193.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.193.2)

* Atualizados templates do pyproject para usar a versão correta
</Update>

<Update label="20 set 2025">
  ## v0.193.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.193.1)

* Série de pequenas correções e melhorias de linter
</Update>

<Update label="19 set 2025">
  ## v0.193.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.193.0)

## Melhorias e Correções Principais

* Corrigido manuseio do parâmetro `model` durante a inicialização do adaptador OpenAI
  * Resolvidos problemas de cache da duração de testes nos fluxos de CI
  * Corrigido teste instável relacionado ao uso repetido de ferramentas pelos agentes
  * Adicionadas exportações de eventos ausentes no `__init__.py` para comportamento consistente do módulo
  * Removido armazenamento de mensagem dos metadados no Mem0 para reduzir inchaço
  * Corrigido suporte à métrica de distância L2 para compatibilidade retroativa na busca vetorial

## Novos Recursos e Melhorias

* Introduzida gestão de contexto de plataforma com segurança de threads
  * Adicionado cache da duração de testes para execuções otimizadas do `pytest-split`
  * Melhorias de traces efêmeros para melhor controle de rastreamento
  * Parâmetros de busca para RAG, conhecimento e memória totalmente configuráveis
  * Habilitado ChromaDB para usar a OpenAI API para funções de embedding
  * Adicionadas ferramentas de observabilidade mais profundas para insights ao nível do usuário
  * Sistema de armazenamento RAG unificado com suporte a cliente específico por instância

## Documentação e Guias

* Atualizadas referências do `RagTool` para refletir a implementação nativa de RAG do CrewAI
  * Melhorada documentação interna para adaptadores de agente `langgraph` e `openai` com anotações de tipo e docstrings
</Update>

<Update label="11 set 2025">
  ## v0.186.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.186.1)

* Corrigida falha silenciosa de reversão quando a versão não era encontrada
  * Versão do CrewAI atualizada para 0.186.1 e dependências do CLI atualizadas
</Update>

<Update label="10 set 2025">
  ## v0.186.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.186.0)

* Consulte as notas de lançamento no GitHub para detalhes completos
</Update>

<Update label="04 set 2025">
  ## v0.177.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.177.0)

## Melhorias e Correções Principais

* Alcançada paridade entre o pacote `rag` e a implementação atual
  * Melhorado o manuseio de eventos LLM com metadados de tarefa e agente
  * Corrigidos argumentos padrão mutáveis substituindo-os por `None`
  * Suprimidos avisos de descontinuação do Pydantic durante a inicialização
  * Corrigido link de exemplo quebrado no `README.md`
  * Removidas regras do Ruff apenas para Python 3.12+ para compatibilidade
  * Migrados fluxos de trabalho de CI para usar `uv` e atualizado ferramentas de desenvolvimento

## Novos Recursos e Melhorias

* Adicionadas melhorias de rastreamento e limpeza
  * Centralizada a lógica de eventos movendo o módulo `events` para `crewai.events`

## Documentação e Guias

* Atualizada a seção de documentação do Token de Autenticação de Ação Empresarial
  * Publicadas atualizações de documentação para o lançamento `v0.175.0`

## Limpeza e Refatoração

* Refatorado o parser em funções modulares para melhor estrutura
</Update>

<Update label="28 ago 2025">
  ## v0.175.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.175.0)

## Melhorias e Correções Principais

* Corrigida a migração da seção `tool` durante `crewai update`
  * Revertido o pin do OpenAI: agora requer `openai >=1.13.3` devido a problemas de importação corrigidos
  * Corrigidos testes instáveis e melhorada a estabilidade dos testes
  * Melhorada a retomada do listener `Flow` para fluxos HITL e cíclicos
  * Aprimorado o manuseio de timeouts em `PlusAPI` e `TraceBatchManager`
  * Agrupados itens de memória de entidade para reduzir operações redundantes

## Novos Recursos e Melhorias

* Adicionado suporte para parâmetros adicionais nos métodos `Flow.start()`
  * Nomes das tarefas exibidos na saída detalhada do CLI
  * Adicionados tipos de embedding centralizados e introduzido um cliente base de embedding
  * Introduzidos clientes genéricos para ChromaDB e Qdrant
  * Adicionado suporte para `crewai config reset` para limpar tokens
  * Habilitada a auto-injeção de `crewai_trigger_payload`
  * Simplificada a inicialização do cliente RAG e introduzido um sistema de configuração RAG
  * Adicionado suporte ao provedor RAG do Qdrant
  * Melhorado o rastreamento com melhores dados de eventos
  * Adicionado suporte para remover Auth0 e entrada de e-mail em `crewai login`

## Documentação e Guias

* Adicionada documentação para gatilhos de automação
  * Corrigidas fontes e redirecionamentos da Referência da API OpenAPI
  * Adicionado parâmetro alpha de busca híbrida na documentação

## Limpeza e Depreciações

* Adicionado aviso de depreciação para `Task.max_retries`
  * Removida a dependência do Auth0 do fluxo de login
</Update>

<Update label="19 ago 2025">
  ## v0.165.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.165.1)

## Melhorias e Correções Principais

* Corrigida a compatibilidade no `XMLSearchTool` convertendo valores de configuração para strings para `configparser`
  * Corrigido teste instável do Pytest envolvendo `PytestUnraisableExceptionWarning`
  * Mocked telemetria na suíte de testes para execuções de CI mais estáveis
  * Movida a manipulação do arquivo de bloqueio do Chroma para `db_storage_path`
  * Ignorados avisos de depreciação do `chromadb`
  * Versão do OpenAI fixada em `<1.100.0` devido a problemas de importação do `ResponseTextConfigParam`

## Novos Recursos e Melhorias

* Incluídas mensagens de agentes trocadas nos metadados do `ExternalMemory`
  * `crewai_trigger_payload` injetado automaticamente
  * Renomeada a flag interna `inject_trigger_input` para `allow_crewai_trigger_context`
  * Continuadas melhorias de rastreamento e lógica de rastreamento efêmero
  * Consolidada as condições da lógica de rastreamento
  * Adicionado suporte para entradas de memória vinculadas a `agent_id` em `Mem0`

## Documentação e Guias

* Adicionado exemplo na documentação do Tool Repository
  * Atualizada a documentação do Mem0 para integração de Memória de Curto Prazo e Memória de Entidade
  * Revisadas traduções em coreano e melhoradas estruturas de frases

* Removida a integração de AgentOps deprecada
</Update>

<Update label="19 ago 2025">
  ## v0.165.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.165.0)

## Melhorias e Correções Principais

* Corrigida a compatibilidade no `XMLSearchTool` convertendo valores de configuração para strings para `configparser`
  * Corrigido teste instável do Pytest envolvendo `PytestUnraisableExceptionWarning`
  * Mocked telemetria na suíte de testes para execuções de CI mais estáveis
  * Movida a manipulação do arquivo de bloqueio do Chroma para `db_storage_path`
  * Ignorados avisos de depreciação do `chromadb`
  * Versão do OpenAI fixada em `<1.100.0` devido a problemas de importação do `ResponseTextConfigParam`

## Novos Recursos e Melhorias

* Incluídas mensagens de agentes trocadas nos metadados do `ExternalMemory`
  * `crewai_trigger_payload` injetado automaticamente
  * Renomeada a flag interna `inject_trigger_input` para `allow_crewai_trigger_context`
  * Continuadas melhorias de rastreamento e lógica de rastreamento efêmero
  * Consolidada as condições da lógica de rastreamento
  * Adicionado suporte para entradas de memória vinculadas a `agent_id` em `Mem0`

## Documentação e Guias

* Adicionado exemplo na documentação do Tool Repository
  * Atualizada a documentação do Mem0 para integração de Memória de Curto Prazo e Memória de Entidade
  * Revisadas traduções em coreano e melhoradas estruturas de frases

* Removida a integração de AgentOps deprecada
</Update>

<Update label="13 ago 2025">
  ## v0.159.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.159.0)

## Melhorias e Correções Principais

* Melhorou o desempenho de formatação de mensagens LLM para uma melhor eficiência em tempo de execução
  * Corrigido uso de endpoint incorreto na configuração de autenticação/parâmetros da empresa
  * Comentado verificação de retomabilidade do listener para estabilidade durante a retomada de fluxo parcial

## Novos Recursos e Melhorias

* Adicionado comando `enterprise configure` ao CLI para configuração simplificada da empresa
  * Introduzido suporte à retomabilidade de fluxo parcial

## Documentação e Guias

* Adicionada documentação para novas ferramentas
  * Adicionadas traduções em coreano
  * Atualizada a documentação com detalhes da integração do TrueFoundry
  * Adicionada documentação de RBAC e limpeza geral
  * Corrigida referência da API e reformulados exemplos/livros de receitas em EN, PT-BR e KO
</Update>

<Update label="06 ago 2025">
  ## v0.157.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.157.0)

## v0.157.0 O que Mudou

## Melhorias e Correções do Core

* Habilitada a quebra de linha para ferramentas de entrada longas
  * Permitido persistir o estado do Flow com entradas de `BaseModel`
  * Otimizadas operações de string usando `partition()` para desempenho
  * Removido suporte para o sistema de Memória de Usuário obsoleto
  * Atualizada a versão do LiteLLM para `1.74.9`
  * Corrigido o CLI para mostrar módulos ausentes de forma mais clara durante a importação
  * Suportada a autorização de dispositivos com Okta

## Novos Recursos e Melhorias

* Adicionado grupo de comandos CLI `crewai config` com testes
  * Adicionado suporte a valor padrão para `crew.name`
  * Introduzidas capacidades iniciais de rastreamento
  * Adicionado suporte para integração com LangDB
  * Adicionado suporte para documentação de configuração do CLI

## Documentação e Guias

* Atualizada a documentação do MCP com o atributo `connect_timeout`
  * Adicionada documentação de integração com LangDB
  * Adicionada documentação de configuração do CLI
  * Atualizações gerais e limpeza na documentação de recursos
</Update>

<Update label="30 jul 2025">
  ## v0.152.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.152.0)

## Melhorias e Correções Principais

* Removidas referências a `crewai signup` e substituídas por `crewai login`
  * Corrigido suporte para adicionar memórias ao Mem0 usando `agent_id`
  * Alterado o valor padrão na configuração do Mem0
  * Atualizado erro de importação para mostrar arquivos de módulo ausentes de forma clara
  * Adicionado suporte a fuso horário para timestamps de eventos

## Novos Recursos e Melhorias

* Aprimorada a classe `Flow` para suportar nomes de fluxo personalizados
  * Refatorados os componentes RAG em um módulo de nível superior dedicado

## Documentação e Guias

* Corrigida a nomenclatura incorreta de modelos na documentação do Google Vertex AI
</Update>

<Update label="23 jul 2025">
  ## v0.150.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.150.0)

## Melhorias e Correções Principais

* Usou bloqueio de arquivo em torno da inicialização do cliente Chroma
  * Removido workaround relacionado ao SQLite sem FTS5
  * Removido parâmetro `stop` não suportado para modelos LLM automaticamente
  * Corrigido método `save` e atualizado casos de teste relacionados
  * Corrigido o manuseio de mensagens para modelos Ollama quando a última mensagem é do assistente
  * Removida impressão duplicada em erro de chamada LLM
  * Adicionada nota de descontinuação ao `UserMemory`
  * Atualizado LiteLLM para a versão 1.74.3

## Novos Recursos e Melhorias

* Adicionado suporte para chamada de ferramentas ad-hoc via classe LLM interna
  * Atualizado Mem0 Storage da v1.1 para v2

## Documentação e Guias

* Corrigida a documentação do neatlogs
  * Adicionadas ferramentas Tavily Search & Extractor ao conjunto Search-Research
  * Adicionada documentação para `SerperScrapeWebsiteTool` e reorganizada a seção Serper
  * Atualizações e melhorias gerais na documentação

## crewai-tools v0.58.0

### Novas Ferramentas / Melhorias

* **SerperScrapeWebsiteTool**: Adicionada uma ferramenta para extrair conteúdo limpo de URLs
  * **Bedrock AgentCore**: Integrados kits de ferramentas de navegador e interpretador de código para agentes Bedrock
  * **Atualização do Stagehand**: Refatorada e atualizada a integração do Stagehand

### Correções e Limpeza

* **Suporte a FTS5**: Habilitado SQLite FTS5 para melhorar a busca de texto em fluxos de trabalho de teste
  * **Acelerações de Teste**: Paralelizado o conjunto de testes do GitHub Actions para execuções de CI mais rápidas
  * **Limpeza**: Removido workaround do SQLite devido ao suporte a FTS5 estar disponível
    **MongoDBVectorSearchTool**: Corrigido manuseio de serialização e esquema
</Update>

<Update label="16 jul 2025">
  ## v0.148.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.148.0)

## Melhorias e Correções Principais

* Usado ID do ambiente de produção do WorkOS
  * Adicionado suporte a SQLite FTS5 para testar fluxo de trabalho
  * Corrigido o manuseio do conhecimento do agente
  * Comparado usando a classe `BaseLLM` em vez de `LLM`
  * Corrigido parâmetro `create_directory` ausente na classe `Task`

## Novos Recursos e Melhorias

* Introduzida funcionalidade de avaliação de Agente
  * Adicionados métodos de experimento e teste de regressão do Avaliador
  * Implementado `AgentEvaluator` seguro para threads
  * Habilitada emissão de eventos para avaliação de Agente
  * Suportada avaliação de um único `Agent` e `LiteAgent`
  * Adicionada integração com `neatlogs`
  * Adicionado rastreamento de contexto da equipe para eventos de guardrail do LLM

## Documentação e Guias

* Adicionada documentação para atributos de `guardrail` e exemplos de uso
  * Adicionado guia de integração para `neatlogs`
  * Atualizada documentação para o repositório do Agente e uso de `Agent.kickoff`
</Update>

<Update label="09 jul 2025">
  ## v0.141.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.141.0)

## Melhorias e Correções Principais

* Acelerou os testes do GitHub Actions através da paralelização

## Novos Recursos e Melhorias

* Adicionada rastreamento de contexto da equipe para eventos de guardrail do LLM

## Documentação e Guias

* Adicionada documentação para uso do repositório Agent
  * Adicionada documentação para o método `Agent.kickoff`
</Update>

<Update label="02 jul 2025">
  ## v0.140.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.140.0)

## Melhorias e Correções Principais

* Corrigido erro de digitação em prompts de teste
  * Corrigida a normalização do nome do projeto removendo barras finais durante a criação da equipe
  * Garantido que as variáveis de ambiente sejam escritas em maiúsculas
  * Atualizada a dependência do LiteLLM
  * Refatorada a manipulação de coleções em `RAGStorage`
  * Implementada a versionamento dinâmico PEP 621

## Novos Recursos e Melhorias

* Adicionada a capacidade de rastrear chamadas de LLM por tarefa e agente
  * Introduzidos `MemoryEvents` para monitorar o uso de memória
  * Adicionado registro em console para eventos do sistema de memória e guardrails do LLM
  * Melhorado o suporte ao treinamento de dados para modelos de até 7B parâmetros
  * Adicionado rastreamento de análises do Scarf e Reo.dev
  * Login no CLI workos

## Documentação e Guias

* Atualizada a documentação do CLI LLM
  * Adicionada integração do Nebius à documentação
  * Corrigidos erros de digitação na documentação de instalação e pt-BR
  * Adicionadas documentações sobre `MemoryEvents`
  * Implementados redirecionamentos de documentação e incluídas ferramentas de desenvolvimento
</Update>

<Update label="25 jun 2025">
  ## v0.134.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.134.0)

## Melhorias e Correções Principais

* Corrigida a sintaxe do parâmetro de ferramentas
  * Corrigida a anotação de tipo em `Task`
  * Corrigido erro de SSL ao recuperar dados de LLM do GitHub
  * Garantida compatibilidade com Pydantic 2.7.x
  * Removido `mkdocs` das dependências do projeto
  * Atualizados exemplos de código do Langfuse para usar o Python SDK v3
  * Adicionada a funcionalidade de sanitização de papel na armazenagem `mem0`
  * Melhorada a busca do Crew durante a reinicialização da memória
  * Melhorada a saída do impressor do console

## Novos Recursos e Melhorias

* Adicionado suporte para inicializar uma ferramenta a partir de atributos `Tool` definidos
  * Adicionada maneira oficial de usar Ferramentas MCP dentro de um `CrewBase`
  * Suporte aprimorado para ferramentas MCP para permitir a seleção de várias ferramentas por agente em `CrewBase`
  * Adicionadas ferramentas de Web Scraping da Oxylabs

## Documentação e Guias

* Atualizado `quickstart.mdx`
  * Adicionadas documentações sobre eventos `LLMGuardrail`
  * Atualizada a documentação com detalhes abrangentes de integração de serviços
  * Atualizados filtros de recomendação para ferramentas MCP e Enterprise
  * Atualizadas documentações para observabilidade do Maxim
  * Adicionada tradução da documentação para pt-BR
  * Melhorias gerais na documentação
</Update>

<Update label="12 jun 2025">
  ## v0.130.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.130.0)

## Melhorias e Correções Principais

* Removida mensagem duplicada relacionada à saída de resultados da Ferramenta
  * Corrigidos tokens `manager_agent` ausentes em `usage_metrics` do kickoff
  * Corrigido singleton de telemetria para respeitar variáveis de ambiente dinâmicas
  * Corrigido problema onde logs de status do Flow poderiam ocultar entrada humana
  * Aumentado o espaçamento padrão do eixo X para plotagem de fluxo

## Novos Recursos e Melhorias

* Adicionado suporte para ações multi-org no CLI
  * Habilitadas execuções de ferramentas assíncronas para fluxos de trabalho mais eficientes
  * Introduzido `LiteAgent` com integração Guardrail
  * Atualizado `LiteLLM` para suportar a versão mais recente do OpenAI

## Documentação e Guias

* Documentada a versão mínima `UV` para o repositório da Ferramenta
  * Melhorados exemplos para o Guardrail de Alucinação
  * Atualizados documentos de planejamento para uso de LLM
  * Adicionada documentação para suporte a Maxim na observabilidade do Agente
  * Expandida a documentação de integrações com imagens para recursos empresariais
  * Corrigido guia sobre persistência
  * Atualizada a compatibilidade da versão do Python para suportar python 3.13.x
</Update>

<Update label="05 jun 2025">
  ## v0.126.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.126.0)

#### Melhorias e Correções do Núcleo

* Adicionado suporte para Python 3.13
  * Corrigido problema com fontes de conhecimento do agente
  * Persistidos ferramentas disponíveis de um repositório de Ferramentas
  * Habilitados ferramentas para serem carregadas do repositório do Agente via seu próprio módulo
  * Registrado uso de ferramentas quando chamadas por um LLM

#### Novos Recursos e Melhorias

* Adicionado suporte para transporte streamable-http na integração MCP
  * Adicionado suporte para análises comunitárias
  * Expandida seção compatível com OpenAI com um exemplo de Gemini
  * Introduzidas funcionalidades de transparência para prompts e sistemas de memória
  * Melhorias menores na publicação de Ferramentas

#### Documentação e Guias

* Reestruturação significativa da documentação para melhor navegação
  * Documentação da integração MCP expandida
  * Atualizados documentos de memória e visuais do README
  * Corrigidos palavras-chave await ausentes em exemplos de kickoff assíncronos
  * Atualizada a documentação de embeddings do Portkey e Azure
  * Adicionada imagem de teste empresarial ao guia do LLM
  * Atualizações gerais no README
</Update>

<Update label="27 mai 2025">
  ## v0.121.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.121.1)

# Correções de bugs e melhores documentos

Nesta atualização, abordamos várias correções de bugs e melhoramos a documentação para facilitar o uso do nosso produto.

* Corrigido um problema que causava falhas na aplicação ao carregar grandes conjuntos de dados.
  * Resolvido um erro que impedia a exportação de relatórios em formato PDF.
  * Ajustado o comportamento do botão de salvar, que não estava funcionando corretamente em algumas situações.

## Melhorias na Documentação

* Atualizamos a seção de **Instalação** para incluir instruções mais detalhadas.
  * Adicionamos exemplos de uso na seção de **API** para facilitar a integração com outros serviços.
  * Melhoramos a clareza das instruções na seção de **Solução de Problemas**.

Se você encontrar mais bugs ou tiver sugestões para melhorar a documentação, sinta-se à vontade para abrir uma issue no nosso repositório do GitHub.

* [Documentação Completa](https://example.com/documentation)
  * [Repositório no GitHub](https://github.com/example/repo)
  * [FAQ](https://example.com/faq)

Agradecemos seu feedback e apoio contínuo!
</Update>

<Update label="22 mai 2025">
  ## v0.121.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.121.0)

## Melhorias e Correções no Core

* Corrigido erro de codificação ao criar ferramentas
  * Corrigido teste do llama que falhou
  * Atualizada a configuração de logging para consistência
  * Aprimorada a inicialização de telemetria e o manuseio de eventos

## Novos Recursos e Melhorias

* Adicionado atributo markdown à classe Task
  * Adicionado atributo reasoning à classe Agent
  * Adicionado flag inject\_date ao Agent para injeção automática de data
  * Implementado HallucinationGuardrail (sem operação com cobertura de teste)

## Documentação e Guias

* Adicionada documentação para StagehandTool e melhorada a estrutura MDX
  * Adicionada documentação para integração MCP e atualizados os documentos empresariais
  * Documentados eventos de conhecimento e atualizados os documentos de raciocínio
  * Adicionada documentação do parâmetro stop
  * Corrigidas referências de importação nos exemplos de documentos (before\_kickoff, after\_kickoff)
  * Atualizações gerais de documentos e reestruturação para clareza
</Update>

<Update label="15 mai 2025">
  ## v0.120.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.120.1)

* Corrige a interpolação com hífens
</Update>

<Update label="14 mai 2025">
  ## v0.120.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.120.0)

### Melhorias e Correções Principais

•	Ativado conjunto completo de regras do Ruff por padrão para linting mais rigoroso
  •	Resolvida condição de corrida em FilteredStream usando gerenciadores de contexto
  •	Corrigido problema de redefinição do conhecimento do agente
  •	Refatorada a lógica de busca do agente para um módulo utilitário

### Novos Recursos e Melhorias

•	Adicionada suporte para carregar um Agente diretamente de um repositório
  •	Ativado o ajuste de um contexto vazio para a Tarefa
  •	Aprimorado o feedback do repositório do Agente e corrigido o comportamento de auto-importação de Ferramentas
  •	Introduzida a inicialização direta do conhecimento (ignorando knowledge\_sources)

### Documentação e Guias

•	Atualizado security.md para práticas de segurança atuais
  •	Limpa a seção de configuração do Google para maior clareza
  •	Adicionado link para AI Studio ao inserir a chave Gemini
  •	Atualizado guia de observabilidade do Arize Phoenix
  •	Atualizada a documentação de fluxo
</Update>

<Update label="08 mai 2025">
  ## v0.119.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.119.0)

## Melhorias e Correções Principais

* Melhorou a confiabilidade dos testes ao aprimorar o manuseio do pytest para testes instáveis
  * Corrigido o travamento de redefinição de memória quando há incompatibilidade nas dimensões de incorporação
  * Habilitada a identificação do fluxo pai para Crew e LiteAgent
  * Prevenidos travamentos relacionados à telemetria quando indisponível
  * Atualizada a versão do LiteLLM para melhor compatibilidade
  * Corrigidos os testes do conversor llama ao remover skip\_external\_api

## Novos Recursos e Melhorias

* Introduzido reescrita de prompt de recuperação de conhecimento no Agent para melhor rastreamento e depuração
  * Tornados os guias de configuração do LLM e de início rápido independentes de modelo

## Documentação e Guias

* Adicionada documentação de configuração avançada para a ferramenta RAG
  * Atualizado guia de solução de problemas do Windows
  * Refinados exemplos de documentação para melhor clareza
  * Corrigidos erros de digitação em toda a documentação e arquivos de configuração
</Update>

<Update label="30 abr 2025">
  ## v0.118.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.118.0)

### Melhorias e Correções Principais

* Corrigidos problemas com modelos de prompt ou sistema ausentes.
  * Removida a configuração de log global para evitar substituições indesejadas.
  * Renomeado TaskGuardrail para LLMGuardrail para maior clareza.
  * Rebaixada a litellm para a versão 1.167.1 para compatibilidade.
  * Adicionados arquivos **init**.py ausentes para garantir a inicialização adequada do módulo.

### Novos Recursos e Melhorias

* Adicionado suporte para criação de Guardrail sem código para simplificar o controle do comportamento da IA.

### Documentação e Guias

* Removido CrewStructuredTool da documentação pública para refletir o uso interno.
  * Atualizada a documentação empresarial e o embed do YouTube para melhorar a experiência de integração.
</Update>

<Update label="28 abr 2025">
  ## v0.117.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.117.1)

* build: atualizar crewai-tools
  * atualizar liteLLM para a versão mais recente
  * Corrigir Mem0 OSS
</Update>

<Update label="28 abr 2025">
  ## v0.117.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.117.0)

## Novos Recursos e Melhorias

* Adicionado suporte ao parâmetro `result_as_answer` no decorador `@tool`.
  * Introduzido suporte para novos modelos de linguagem: GPT-4.1, Gemini-2.0 e Gemini-2.5 Pro.
  * Melhoradas as capacidades de gerenciamento de conhecimento.
  * Adicionada opção de provedor Huggingface na CLI.
  * Melhorada a compatibilidade e suporte CI para Python 3.10+.

## Melhorias e Correções no Núcleo

* Corrigidos problemas com parâmetros de template incorretos e entradas ausentes.
  * Melhorado o manuseio de fluxo assíncrono com verificações de condição de corrotina.
  * Aprimorado o gerenciamento de memória com configuração isolada e cópia correta de objetos de memória.
  * Corrigida a inicialização de agentes lite com referências corretas.
  * Abordados problemas de dicas de tipo do Python e removidos imports redundantes.
  * Atualizada a colocação de eventos para melhor rastreamento do uso de ferramentas.
  * Levantadas exceções explícitas quando os fluxos falham.
  * Removido código não utilizado e comentários redundantes de vários módulos.
  * Atualizada a ação do token do GitHub App para v2.

## Documentação e Guias

* Estrutura de documentação aprimorada, incluindo instruções de implantação empresarial.
  * Criação automática de pastas de saída para geração de documentação.
  * Corrigido link quebrado na documentação do `WeaviateVectorSearchTool`.
  * Corrigida a utilização da documentação de guardrails e caminhos de importação para ferramentas de busca JSON.
  * Atualizada a documentação para `CodeInterpreterTool`.
  * Melhorado SEO, navegação contextual e tratamento de erros para páginas de documentação.
</Update>

<Update label="10 abr 2025">
  ## v0.114.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.114.0)

## Novos Recursos e Melhorias

* Agentes como uma unidade atômica. (`Agent(...).kickoff()`)
  * Suporte a implementações de LLM personalizadas.
  * Memória Externa integrada e observabilidade Opik.
  * Extração de YAML aprimorada.
  * Validação de agentes multimodais.
  * Adicionados Impressões digitais seguras para agentes e equipes.

## Melhorias e Correções Principais

* Melhoria na serialização, cópia de agentes e compatibilidade com Python.
  * Suporte a curingas adicionado ao emit()
  * Suporte adicionado para chamadas de roteador adicionais e ajustes na janela de contexto.
  * Corrigidos problemas de digitação, validação e declarações de importação.
  * Melhor desempenho dos métodos.
  * Aprimoramento no manuseio de tarefas de agentes, emissões de eventos e gerenciamento de memória.
  * Corrigidos problemas de CLI, tarefas condicionais, comportamento de clonagem e saídas de ferramentas.

## Documentação e Guias

* Estrutura, tema e organização da documentação aprimorados.
  * Guias adicionados para Local NVIDIA NIM com WSL2, W\&B Weave e Arize Phoenix.
  * Exemplos de configuração de ferramentas, prompts e documentos de observabilidade atualizados.
  * Guia sobre como usar agentes singulares dentro de Flows.
</Update>

<Update label="17 mar 2025">
  ## v0.108.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.108.0)

* Convertido tabs em espaços no template crew\.py no PR #2190
  * Melhorada a manipulação de resposta de streaming LLM e sistema de eventos no PR #2266
  * Incluído model\_name no PR #2310
  * Aprimorado o Listener de Eventos com visualização rica e registro melhorado no PR #2321
  * Adicionados fingerprints no PR #2332

* Corrigidos problemas do Mistral no PR #2308
  * Corrigido um bug na documentação no PR #2370
  * Corrigido erro de verificação de tipo na propriedade fingerprint no PR #2369

# Atualizações de Documentação

* Melhorada a documentação da ferramenta no PR #2259
  * Atualizado guia de instalação para o pacote da ferramenta uv no PR #2196
  * Adicionadas instruções para atualizar o crewAI com a ferramenta uv no PR #2363
  * Adicionada documentação para ApifyActorsTool no PR #2254
</Update>

<Update label="09 mar 2025">
  ## v0.105.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.105.0)

**Melhorias e Correções Principais**

* Corrigidos problemas com variáveis de template ausentes e configuração de memória do usuário.
  * Melhorado o suporte ao fluxo assíncrono e abordada a formatação da resposta do agente.
  * Aprimorada a funcionalidade de redefinição de memória e corrigidos comandos de memória do CLI.
  * Corrigidos problemas de tipo, propriedades de chamada de ferramenta e desacoplamento de telemetria.

**Novos Recursos e Melhorias**

* Adicionado exportação de estado de Fluxo e melhoradas utilidades de estado.
  * Aprimorada a configuração do conhecimento do agente com um incorporador de equipe opcional.
  * Introduzido emissor de eventos para melhor observabilidade e rastreamento de chamadas LLM.
  * Adicionado suporte para Python 3.10 e ChatOllama do langchain\_ollama.
  * Integrado suporte para tamanho da janela de contexto para o modelo o3-mini.
  * Adicionado suporte para múltiplas chamadas de roteador.

**Documentação e Guias**

* Melhorado o layout da documentação e a estrutura hierárquica.
  * Adicionado guia do QdrantVectorSearchTool e esclarecido o uso do listener de eventos.
  * Corrigidos erros de digitação em prompts e atualizadas as listagens de modelos do Amazon Bedrock.
</Update>

<Update label="13 fev 2025">
  ## v0.102.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.102.0)

### Melhorias e Correções Principais

* Suporte Aprimorado para LLM: Saída estruturada de LLM melhorada, manuseio de parâmetros e formatação para modelos da Anthropic.
  * Estabilidade do Crew & Agent: Corrigidos problemas com clonagem de agentes/equipes usando fontes de conhecimento, múltiplas saídas de tarefas em tarefas condicionais e callbacks de tarefas do Crew ignorados.
  * Correções de Memória & Armazenamento: Corrigido o manuseio de memória de curto prazo com Bedrock, garantida a inicialização correta do embedder e adicionada uma função de redefinição de memórias na classe crew.
  * Confiabilidade de Treinamento & Execução: Corrigidos problemas de treinamento e interpolação quebrados com tipos de entrada dict e list.

### Novos Recursos & Melhorias

* Gestão Avançada de Conhecimento: Convenções de nomenclatura melhoradas e configuração de embedding aprimorada com suporte a embedder personalizado.
  * Expansão de Registro & Observabilidade: Adicionado suporte ao formato JSON para registro e integrada a documentação de rastreamento do MLflow.
  * Melhorias no Manuseio de Dados: Atualizado excel\_knowledge\_source.py para processar arquivos com múltiplas abas.
  * Desempenho Geral & Limpeza do Código: Alinhamento de código empresarial otimizado e resolução de problemas de linting.
  * Adição da nova ferramenta QdrantVectorSearchTool

### Documentação & Guias

* Documentos de AI & Memória Atualizados: Documentação de Bedrock, Google AI e memória de longo prazo melhorada.
  * Clareza em Tarefas & Fluxos de Trabalho: Adicionada a linha "Entrada Humana" aos Atributos da Tarefa, guia do Langfuse e documentação da FileWriterTool.
  * Correção de Vários Erros de Digitação & Problemas de Formatação.

### Manutenção & Diversos

* Integrações do Google Docs refinadas e manuseio de tarefas para o ano atual.
</Update>

<Update label="28 jan 2025">
  ## v0.100.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.100.0)

* Feat: Adicionar documentação do Composio
  * Feat: Adicionar SageMaker como um provedor de LLM
  * Fix: Problemas gerais de conexão com LLM
  * Fix: Usando acessores seguros no treinamento
  * Fix: Adicionar verificação de versão ao crew\_chat.py
  * Docs: Novas documentações para o crewai chat
  * Docs: Melhorar formatação e clareza na documentação do CLI e da ferramenta Composio
</Update>

<Update label="20 jan 2025">
  ## v0.98.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.98.0)

* Feat: Conversa crew v1
  * Feat: Adicionar ID único aos estados de fluxo
  * Feat: Adicionar decorador @persist com interface FlowPersistence
  * Integração: Adicionar integração SambaNova
  * Integração: Adicionar provedor NVIDIA NIM no cli
  * Integração: Introduzindo VoyageAI
  * Tarefa: Atualizar data para o ano atual no template
  * Correção: Corrigir comportamento da chave API e manipulação de entidades na integração Mem0
  * Correção: Corrigir lógica do loop de invocação central e testes relevantes
  * Correção: Tornar entradas de ferramentas objetos reais e não strings
  * Correção: Adicionar partes importantes que estavam faltando na criação de ferramentas
  * Correção: Reduzir versão do litellm para evitar problema no Windows
  * Correção: Antes do início, se as entradas forem nulas
  * Correção: ERROS DE DIGITAÇÃO
  * Correção: Problema de modelo pydantic aninhado
  * Correção: Problemas de Docling
  * Correção: problema de união
  * Atualizações de Docs
</Update>

<Update label="04 jan 2025">
  ## v0.95.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.95.0)

* Feat: Adicionando Habilidades Multimodais ao Crew
  * Feat: Guardrails Programáticos
  * Feat: HITL múltiplas rodadas
  * Feat: Suporte ao Gemini 2.0
  * Feat: Melhorias nos Fluxos do CrewAI
  * Feat: Adicionar Permissões de Workflow
  * Feat: Adicionar suporte para langfuse com litellm
  * Feat: Integração do Portkey com CrewAI
  * Feat: Adicionar método interpolate\_only e melhorar o tratamento de erros
  * Feat: Suporte ao Docling
  * Feat: Suporte ao Weviate
  * Fix: output\_file não respeitando o caminho do sistema
  * Fix: erro de I/O de disco ao redefinir a memória de curto prazo.
  * Fix: CrewJSONEncoder agora aceita enums
  * Fix: versão máxima do Python
  * Fix: Interpolação para output\_file na Tarefa
  * Fix: Lidar corretamente com o nome do papel de colega de trabalho em relação a maiúsculas/espaços em branco
  * Fix: Adicionar tiktoken como dependência explícita e documentar requisito do Rust
  * Fix: Incluir conhecimento do agente no processo de planejamento
  * Fix: Alterar a inicialização de armazenamento para None para KnowledgeStorage
  * Fix: Corrigir verificações de armazenamento opcionais
  * Fix: incluir emissor de eventos nos fluxos
  * Fix: Melhorias em Docstring, Tratamento de Erros e Dicas de Tipo
  * Fix: Avisos de usuário suprimidos de problemas do litellm pydantic
</Update>

<Update label="05 dez 2024">
  ## v0.86.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.86.0)

## Remover todas as referências ao pipeline e ao roteador de pipeline

## docs: Adicionar Nvidia NIM como provedor no Custom LLM

## Adicionar demonstração de conhecimento + melhorar a documentação de conhecimento

## Brandon/cre 509 hitl múltiplas rodadas de acompanhamento

## Novas documentações sobre yaml crew com decoradores. Simplificar o template crew
</Update>

<Update label="04 dez 2024">
  ## v0.85.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.85.0)

* Adicionado conhecimento ao nível do agente
  * Feat/remover langchain
  * Melhorar saídas de tarefas tipadas
  * Fazer login no Repositório de Ferramentas com `crewai login`
  * Corrigir problemas com resultado como resposta não saindo corretamente do loop LLM
  * fix: nome da chave ausente ao rodar com o provedor ollama
  * corrigir problema de ortografia encontrado
  * Atualizar readme para rodar mypy
  * Adicionar conhecimento ao mint.json
  * Atualizar ações do Github
  * Atualização de Docs: Atualizar a documentação de Agentes para incluir duas abordagens para criar um agente
  * Melhorias na Documentação: Configuração e Uso do LLM
</Update>

<Update label="25 nov 2024">
  ## v0.83.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.83.0)

* Novos callbacks de equipe `before_kickoff` e `after_kickoff`
  * Suporte para pré-semeadura de agentes com Conhecimento
  * Adicionar suporte para recuperar preferências e memórias do usuário usando Mem0
  * Corrigir Execução Assíncrona
  * Atualizar chroma e ajustar gerador de função embedder
  * Atualizar modelos suportados pelo CLI Watson + docs
  * Reduzir nível para Bandit
  * Corrigir todos os testes
  * Atualizar Docs
</Update>

<Update label="14 nov 2024">
  ## v0.80.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.80.0)

* Correção do bug de substituição do callback de Tokens
  * Correção do problema do callback de Step
  * Adição de informações de tokens de prompt em cache nas métricas de uso
  * Correção do teste crew\_train\_success
</Update>

<Update label="11 nov 2024">
  ## v0.79.4

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.79.4)

Série de pequenas correções de bugs relacionadas ao suporte a llms
</Update>

<Update label="10 nov 2024">
  ## v0.79.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.79.0)

* Adicionar entradas aos fluxos
  * Melhorar o armazenamento de logs para suportar mais tipos de dados
  * Adicionar suporte à memória IBM
  * Adicionar Watson como uma opção na CLI
  * Adicionar arquivo security.md
  * Substituir .netrc por variáveis de ambiente uv
  * Mover BaseTool para o pacote principal e centralizar a geração de descrição de ferramentas
  * Levantar um erro se um LLM não retornar uma resposta
  * Corrigir fluxos para suportar ciclos e adicionar em teste
  * Atualizar como nomeamos as equipes e corrigir configuração ausente
  * Atualizar documentação
</Update>

<Update label="30 out 2024">
  ## v0.76.9

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.76.9)

* Atualizar comando de plotagem para crewai flow plot
  * Adicionar tomli para que possamos suportar 3.10
  * Encaminhar opções de comando de instalação para `uv sync`
  * Melhorar descrição do texto da ferramenta e argumentos
  * Melhorar documentação de ferramentas e fluxos
  * Atualizar cli de fluxos para permitir que você adicione facilmente equipes adicionais a um fluxo com crewai flow add-crew
  * Corrigido bug de fluxos ao usar múltiplos start e listen(and\_(..., ..., ...))
</Update>

<Update label="23 out 2024">
  ## v0.76.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.76.2)

# Atualizando o comando create do crewai

O comando `create` do crewai permite que você crie novos projetos de forma rápida e fácil. Esta documentação fornece informações sobre como atualizar o comando para garantir que você esteja utilizando as funcionalidades mais recentes.

Antes de atualizar o comando, verifique se você possui:

* A versão mais recente do crewai instalada.
  * Acesso à internet para baixar as atualizações.

## Passos para Atualização

1. **Verifique a versão atual do crewai:**

Execute o seguinte comando no seu terminal:

2. **Atualize o crewai:**

Para atualizar o crewai, use o seguinte comando:

3. **Confirme a atualização:**

Após a instalação, verifique novamente a versão para garantir que a atualização foi bem-sucedida:

## Novas Funcionalidades

Após a atualização, você poderá aproveitar as seguintes novas funcionalidades do comando `create`:

* **Melhorias na criação de projetos:** Agora, você pode especificar templates personalizados.
  * **Integração com GitHub:** Facilita a conexão e o gerenciamento de repositórios diretamente do seu projeto.

Para criar um novo projeto com o comando `create`, utilize a seguinte sintaxe:

Manter o crewai atualizado é essencial para aproveitar ao máximo suas funcionalidades. Siga os passos acima para garantir que você esteja sempre utilizando a versão mais recente do comando `create`. Para mais informações, consulte a [documentação oficial do crewai](https://crewai.com/docs).
</Update>

<Update label="23 out 2024">
  ## v0.76.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.76.0)

* correção/corrigido prompt da API ausente + atualização da documentação do CLI
  * tarefa(readme): corrigindo etapa para 'executar testes' na contribuição
  * suporte à execução de código não seguro. adicionar na instalação do docker e verificações de execução
  * Corrigir importações de memória para funções de incorporação
</Update>

<Update label="23 out 2024">
  ## v0.75.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.75.1)

# nova opção `--provider` no crewai crewat

A nova opção `--provider` foi adicionada ao comando `crewat` do CrewAI. Esta opção permite que os usuários especifiquem o provedor de serviços que desejam utilizar ao executar o comando.

Para utilizar a nova opção, você pode executar o seguinte comando:

Substitua `<nome_do_provedor>` pelo provedor desejado.

## Provedores suportados

Atualmente, os seguintes provedores são suportados:

* ProviderA
  * ProviderB
  * ProviderC

Aqui está um exemplo de como usar a nova opção:

Isso executará o comando `crewat` utilizando o ProviderA como provedor de serviços.

A adição da opção `--provider` no comando `crewat` do CrewAI oferece mais flexibilidade e controle sobre a escolha do provedor de serviços. Certifique-se de experimentar essa nova funcionalidade em seus projetos!
</Update>

<Update label="23 out 2024">
  ## v0.75.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.75.0)

* Corrigindo o treinamento de post de teste
  * Simplificar fluxos
  * Adaptar `crewai tool install <tool>`
  * Garantir que a configuração original de embedding funcione
  * Corrigir bugs
  * Atualizar docs - Incluindo adicionar configuração de exemplo do Cerebras LLM à documentação do LLM
  * Remover testes desnecessários
</Update>

<Update label="18 out 2024">
  ## v0.74.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.74.2)

* feat: adicionar poetry.lock à migração uv
  * fix: corrigir problema de chamada da ferramenta
</Update>

<Update label="18 out 2024">
  ## v0.74.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.74.0)

* Migração UV
  * Adaptar Tools CLI para UV
  * Adicionar aviso do Poetry -> UV
  * CLI para permitir seleção de modelo e envio de chaves de API
  * Nova Base de Memória
  * Corrigir Linting e Avisos
  * Atualizar Documentação
  * Correções de bugs
</Update>

<Update label="11 out 2024">
  ## v0.70.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.70.1)

* Novo recurso Flow
  * Visualizador de Flow
  * Criar comando `crewai create flow`
  * Criar comando `crewai tool create <tool>`
  * Adicionar validações Git para publicação de ferramentas
  * correção: codificação JSON de objetos de data
  * Novos Documentos
  * Atualizar README
  * Correções de bugs
</Update>

<Update label="27 set 2024">
  ## v0.65.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.65.2)

* Adicionando recurso experimental de Flows
  * Corrigindo bug na ordem das tarefas
  * Atualizando templates
</Update>

<Update label="27 set 2024">
  ## v0.64.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.64.0)

* Ordenação correta de tarefas
  * Correção da lógica de sumarização
  * Correção da lógica de palavras de parada
  * Aumenta o número máximo de iterações padrão para 20
  * Corrige a chave do crew após a interpolação de entrada
  * Correção da Funcionalidade de Treinamento
  * Adicionando API de ferramentas inicial
  * ERROS DE DIGITAÇÃO
  * Atualizando Documentação

Correções: #1359 #1355 #1353 #1356 e outras
</Update>

<Update label="25 set 2024">
  ## v0.63.6

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.6)

* Atualizando modelos de projetos
</Update>

<Update label="25 set 2024">
  ## v0.63.5

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.5)

* Reintroduzindo suporte à família o1 e a qualquer modelo que não suporte palavras de parada
  * Atualizando dependências
  * Atualizando logs
  * Atualizando documentos
</Update>

<Update label="24 set 2024">
  ## v0.63.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.2)

* Adicionando OPENAI\_BASE\_URL como fallback
  * Adicionando importação adequada de LLM
  * Atualizando a documentação
</Update>

<Update label="24 set 2024">
  ## v0.63.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.1)

* Pequena correção de bug para suportar futuras implantações do CrewAI
</Update>

<Update label="24 set 2024">
  ## v0.63.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.63.0)

* Nova classe LLM para interagir com LLMs (aproveitando LiteLLM)
  * Adicionando suporte a interfaces de memória personalizadas
  * Tornando o GPT-4o-mini o modelo padrão
  * Atualizações na documentação
  * Atualizando dependências
  * Correções de bugs
    * Remover criação redundante de tarefas em `kickoff_for_each_async`
</Update>

<Update label="18 set 2024">
  ## v0.61.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.61.0)

* Atualizando dependências
  * Imprimindo mensagem de rpm máximo em uma cor diferente
  * Atualizando todas as fitas para testes
  * Sempre terminando com uma mensagem para o usuário - para melhor suporte a certos modelos, como os modelos bedrock
  * Correções de bugs gerais
</Update>

<Update label="16 set 2024">
  ## v0.60.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.60.0)

* Removendo LangChain e Reconstruindo Executor
  * Colocando todos os nossos testes de volta ao verde
  * Adiciona a capacidade de não usar o prompt do sistema use\_system\_prompt no Agente
  * Adiciona a capacidade de não usar palavras de parada (para suportar modelos o1) use\_stop\_words no Agente
  * A janela de contexto deslizante foi renomeada para respect\_context\_window e ativada por padrão
  * A delegação agora está desativada por padrão
  * Os prompts internos foram ligeiramente alterados também
  * Confiabilidade e qualidade geral dos resultados
  * Novo suporte para:
    * Número máximo de requisições por minuto
    * Um número máximo de iterações antes de dar uma resposta final
    * Aproveitar adequadamente os prompts do sistema
    * Fluxo de cálculo de tokens
    * Novo registro da execução da equipe e do agente
</Update>

<Update label="13 set 2024">
  ## v0.55.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.55.2)

* Adicionando a capacidade de autocompletar
  * Adicionar nome e expected\_output ao TaskOutput
  * Novo CLI `crewai install`
  * Novo CLI `crewai deploy`
  * Limpeza da funcionalidade Pipeline
  * Documentação atualizada
  * Melhorias na experiência do desenvolvedor, como pipeline CI bandit
  * Correção de bugs:
    * Capacidade de usar `planning_llm`
    * Corrigir projetos baseados em YAML
    * Corrigir suporte ao Azure
    * Adicionar suporte ao Python 3.10
    * Migrando do Pydantic v1
</Update>

<Update label="11 ago 2024">
  ## v0.51.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.51.0)

* crewAI Testes / Avaliação - [https://docs.crewai.com/core-concepts/Testing/](https://docs.crewai.com/core-concepts/Testing/)
  * Adicionando nova janela de contexto deslizante
  * Permitindo todos os atributos no YAML - [https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#customizing-your-project](https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#customizing-your-project)
  * Adicionando Estrutura Inicial do Pipeline - [https://docs.crewai.com/core-concepts/Pipeline/](https://docs.crewai.com/core-concepts/Pipeline/)
  * Capacidade de definir LLM para a etapa de planejamento - [https://docs.crewai.com/core-concepts/Planning/](https://docs.crewai.com/core-concepts/Planning/)
  * Novo comando crew run - [https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#running-your-project](https://docs.crewai.com/getting-started/Start-a-New-CrewAI-Project-Template-Method/#running-your-project)
  * Salvando arquivo agora despeja dicionário em JSON - [https://docs.crewai.com/core-concepts/Tasks/#creating-directories-when-saving-files](https://docs.crewai.com/core-concepts/Tasks/#creating-directories-when-saving-files)
  * Usando configurações verbosas para saídas de ferramentas
  * Adicionados novos Modelos do Github
  * Nova ferramenta Vision - [https://docs.crewai.com/tools/VisionTool/](https://docs.crewai.com/tools/VisionTool/)
  * Nova ferramenta DALL-E - [https://docs.crewai.com/tools/DALL-ETool/](https://docs.crewai.com/tools/DALL-ETool/)
  * Nova ferramenta MySQL - [https://docs.crewai.com/tools/MySQLTool/](https://docs.crewai.com/tools/MySQLTool/)
  * Nova ferramenta NL2SQL - [https://docs.crewai.com/tools/NL2SQLTool.md](https://docs.crewai.com/tools/NL2SQLTool.md)
  * Correções de Bugs:
    * Bug com a saída da funcionalidade de planejamento
    * Tarefas assíncronas para processo hierárquico
    * Melhor saída pydantic para modelos não OAI
    * Problemas de truncamento de JSON
    * Corrigir tipos de log
    * Importar AgentOps apenas se a Chave do Env estiver definida
    * Sanitizar funções de agente para garantir nomes de diretórios válidos (Windows)
    * Nome das ferramentas não deve conter espaço para OpenAI
    * Um monte de problemas menores
</Update>

<Update label="20 jul 2024">
  ## v0.41.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.41.1)

* Corrigir bug com a funcionalidade de planejamento
</Update>

<Update label="19 jul 2024">
  ## v0.41.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.41.0)

* **\[Mudança Quebrada]** Saída Tipo Seguro
    * Todas as equipes e tarefas agora retornam um objeto apropriado TaskOuput e CrewOutput
  * **\[Recurso]** Novo recurso de planejamento para equipes (planejar antes de agir)
    * adicionando planning=True à instância da Crew
  * **\[Recurso]** Introduzido Recurso de Replay
    * Nova CLI que permite listar as tarefas da última execução e reproduzir a partir de uma específica
  * **\[Recurso]** Capacidade de redefinir a memória
    * Você pode limpar a memória da sua equipe antes de executá-la novamente
  * **\[Recurso]** Adicionada funcionalidade de retry para chamadas LLM
    * Você pode tentar novamente chamadas llm e não interromper a execução da equipe
  * **\[Recurso]** Adicionada capacidade de personalizar o conversor
  * **\[Ferramenta]** Ferramentas aprimoradas com dicas de tipo e novos atributos
  * **\[Ferramenta]** Adicionada Ferramenta MultiON
  * **\[Ferramenta]** Corrigidas ferramentas filecrawl
  * **\[Ferramenta]** Corrigido bug na ferramenta de Scraping
  * **\[Ferramentas]** Atualizada a dependência crewAI-tools para a versão
  * **\[Bugs]** Correções gerais de bugs e melhorias
  * **\[Bugs]** Correções de Telemetria
  * **\[Bugs]** Correções de verificação ortográfica
  * **\[Docs]** Documentação atualizada
</Update>

<Update label="06 jul 2024">
  ## v0.36.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.36.0)

* Correção de bugs
  * Atualização da documentação
  * Atualização dos prompts nativos
  * Correção de TYPOs nos prompts
  * Adição de suporte nativo ao AgentOps
  * Adição das Ferramentas Firecrawl
  * Adição de nova capacidade para retornar os resultados de uma ferramenta como resultado de um agente
  * Melhoria na ferramenta de Interpretação de Código
  * Adição de nova opção para criar sua própria classe de corveter (documentação pendente)
</Update>

<Update label="04 jul 2024">
  ## v0.35.8

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.8)

* corrigindo problema de dependência do embechain
</Update>

<Update label="02 jul 2024">
  ## v0.35.7

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.7)

* Nova integração @composiohq está disponível
  * Atualização da documentação
  * Custom GPT atualizado
  * Ajustando o nível de verbosidade do gerente
  * Correções de bugs
</Update>

<Update label="01 jul 2024">
  ## v0.35.5

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.5)

* Corrigir dependência do embedchain
</Update>

<Update label="01 jul 2024">
  ## v0.35.4

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.4)

* Atualizando o crewai create CLI para usar a nova versão
</Update>

<Update label="01 jul 2024">
  ## v0.35.3

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.3)

* Correção de bug na execução de código
  * Atualização da documentação geral
  * Atualização da versão do crewai-tools
  * Atualização das versões de várias dependências
  * Correções de bugs gerais
</Update>

<Update label="29 jun 2024">
  ## v0.35.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.35.0)

* Seus agentes agora podem executar código
  * Traga qualquer agente de terceiros, LlamaIndex, LangChain e Autogen podem agora fazer parte da sua equipe!
  * Treine sua equipe antes de executá-la e obtenha resultados consistentes! Novo CLI `crewai train -n X`
  * Correções de bugs e atualizações de documentação (ainda faltando algumas novas atualizações de documentação que virão em breve)
</Update>

<Update label="22 jun 2024">
  ## v0.32.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.32.2)

* Atualizando `crewai create` CLI para usar a nova versão
  * Corrigindo a correspondência do agente de delegação
</Update>

<Update label="21 jun 2024">
  ## v0.32.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.32.0)

* Novos métodos `kickoff_for_each`, `kickoff_async` e `kickoff_for_each_async` para melhor controle sobre o processo de kickoff
  * Adicionando suporte para todas as integrações do LlamaIndex hub
  * Adicionando `usage_metrics` à saída completa ou a uma crew
  * Adicionando suporte a múltiplas crews no novo formato YAML
  * Atualizando dependências
  * Correção de bugs e TYPOs
  * Documentação atualizada
  * Adicionada busca na documentação
  * Tornando gpt-4o o modelo padrão
  * Adicionando novas documentações para LangTrace, Browserbase e Exa Search
  * Adicionando timestamp ao logging
</Update>

<Update label="23 mai 2024">
  ## v0.30.11

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.30.11)

* Atualizando o template de geração de projeto
</Update>

<Update label="14 mai 2024">
  ## v0.30.8

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.30.8)

* Atualizando dependências
  * Pequenas correções de bugs na estrutura do projeto crewAI
  * Removendo o parser YAML personalizado por enquanto
</Update>

<Update label="14 mai 2024">
  ## v0.30.5

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.30.5)

* Tornando a delegação de agentes mais versátil para modelos menores
</Update>

<Update label="13 mai 2024">
  ## v0.30.4

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.30.4)

**A atualização da documentação seguirá** desculpe por isso e obrigado por sua paciência, estamos lançando novas documentações em breve!

➿  Correção do callback da tarefa
  🧙  Capacidade de definir um agente específico como gerente em vez de deixar a equipe criar um para você
  📄  Capacidade de definir templates de sistema, prompt e resposta, para que funcione de forma mais confiável com modelos de código aberto (funciona melhor com modelos menores)
  👨‍💻  Melhorando a saída em json e pydantic (funciona melhor com modelos menores)
  🔎 Melhorando o reconhecimento de nomes de ferramentas (funciona melhor com modelos menores)
  🧰  Melhorias para uso de ferramentas (funciona melhor com modelos menores)
  📃  Suporte inicial para trazer seus próprios prompts
  2️⃣  Correção de métricas duplicadas do calculador de tokens
  🪚  Adicionando algumas novas ferramentas, Browserbase e Exa Search
  📁  Capacidade de criar diretório ao salvar como arquivo
  🔁  Atualizando dependências - verifique novamente as ferramentas
  📄  Melhorias gerais na documentação
  🐛  Correções de bugs menores (erros de digitação e afins)
  👬  Correção de problemas de co-worker / coworker
  👀  Atualizações menores no Readme
</Update>

<Update label="11 abr 2024">
  ## v0.28.8

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.28.8)

* atualizando a versão utilizada no crewai CLI
</Update>

<Update label="11 abr 2024">
  ## v0.28.7

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.28.7)

* Correções de bugs
  * Atualizando a versão da ferramenta crewAI com correções de bugs
</Update>

<Update label="08 abr 2024">
  ## v0.28.5

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.5)

* Problema de interpolação de memória de longo prazo
  * Atualizando a dependência do pacote de ferramentas com correções
  * Removendo certificado desnecessário
</Update>

<Update label="07 abr 2024">
  ## v0.28.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.2)

* Correção significativa de memória de longo prazo
</Update>

<Update label="06 abr 2024">
  ## v0.28.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.1)

* Atualizando crewai-tools para 0.1.15
</Update>

<Update label="05 abr 2024">
  ## v0.28.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.28.0)

* Não sobrescrevendo callbacks do LLM
  * Adicionando suporte a `max_execution_time`
  * Adicionando documentação específica sobre memória
  * Mudando a cor de registro de uso da ferramenta de amarelo para roxo
  * Atualizando a documentação
</Update>

<Update label="04 abr 2024">
  ## v0.27.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.27.0)

* 🧠 **Memória (memória compartilhada da equipe)** - Para habilitá-la, basta adicionar `memory=True` à sua equipe, funcionará de forma transparente e tornará os resultados melhores e mais confiáveis, está desabilitada por padrão por enquanto.
  * 🤚🏼 **Suporte Nativo a Entrada Humana:** [docs](https://docs.crewai.com/how-to/Human-Input-on-Execution/)
  * 🌐 **Suporte Universal a Ferramentas RAG:** Quaisquer modelos, além de apenas OpenAI. [Exemplo](https://docs.crewai.com/tools/DirectorySearchTool/#custom-model-and-embeddings)
  * 🔍 **Controle de Cache Aprimorado:** Conheça o engenhoso atributo cache\_function: [docs](https://docs.crewai.com/core-concepts/Tools/#custom-caching-mechanism)
  * 🔁 **Dependência crewai-tools Atualizada:** Sempre em sincronia com o mais recente e melhor.
  * ⛓️ **Delegação entre Agentes:** Cooperação mais suave entre os agentes.
  * 💠 **Melhorias no Prompt Interno:** Um fluxo de conversa mais refinado.
  * 📝 **Melhorando o uso de ferramentas com uma melhor análise**
  * 🔒 **Melhorias de segurança e atualização de dependências**
  * 📄 **Documentação aprimorada**
  * 🐛 **Correções de bugs**
</Update>

<Update label="12 mar 2024">
  ## v0.22.5

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.5)

* Outros problemas menores de importação nos novos templates
</Update>

<Update label="12 mar 2024">
  ## v0.22.4

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.4)

# Corrigindo problemas de template

Nesta documentação, abordaremos como corrigir problemas comuns relacionados a templates. Se você estiver enfrentando dificuldades, siga os passos abaixo para resolver as questões.

### 1. Erros de Sintaxe

Verifique se há erros de sintaxe no seu template. Um erro comum é esquecer de fechar uma tag ou usar a formatação incorreta.

### 2. Variáveis Não Definidas

Certifique-se de que todas as variáveis utilizadas no template estão devidamente definidas. Se uma variável não estiver definida, isso pode causar falhas na renderização.

### 3. Problemas de Estilo

Se o estilo do seu template não estiver sendo aplicado corretamente, verifique se os arquivos CSS estão sendo carregados. Além disso, confirme se as classes estão corretas.

### Passo 1: Validar o Template

Use um validador de templates para verificar se há erros de sintaxe. Isso pode ajudar a identificar problemas rapidamente.

### Passo 2: Definir Variáveis

Revise seu código e adicione definições para quaisquer variáveis que estejam faltando. Isso garantirá que o template funcione como esperado.

### Passo 3: Verificar Estilos

Verifique se os arquivos CSS estão corretamente vinculados no seu template. Você pode fazer isso inspecionando o código-fonte da página.

Seguindo os passos acima, você deve ser capaz de corrigir a maioria dos problemas relacionados a templates. Se os problemas persistirem, considere consultar a documentação do seu framework ou entrar em contato com o suporte.

## Recursos Adicionais

* [Documentação do CrewAI](https://crewai.com/docs)
  * [GitHub Issues](https://github.com/issues)
</Update>

<Update label="11 mar 2024">
  ## v0.22.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.2)

* Corrigindo bug no novo template cli
  * Garantindo a ordem das tarefas no novo template cli
</Update>

<Update label="11 mar 2024">
  ## v0.22.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.22.0)

* Adicionando o comando inicial da CLI `crewai create`
  * Adicionando a capacidade de definir agentes e tarefas usando dicionários
  * Adicionando logs de agente mais claros
  * Corrigindo o bug de Exceder a profundidade máxima de recursão
  * Corrigindo a documentação
  * Atualizando o README
</Update>

<Update label="04 mar 2024">
  ## v0.19.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.19.0)

* Eficiência no uso de ferramentas +1023,21%
  * Média de ferramentas utilizadas +276%
  * Erros nas ferramentas reduzidos em 67%, mais confiável do que nunca.
  * Capacidades de delegação aprimoradas
  * Capacidade de retornar à chamada de função definindo `function_calling_llm` para Agent ou Crew
  * Capacidade de obter métricas de execução da equipe após `kickoff` com `crew.usage_metrics`
  * Adicionando a capacidade de passar entradas no kickoff agora `crew.kickoff(inputs: {'key': 'value})`
  * Atualizando a documentação
</Update>

<Update label="28 fev 2024">
  ## v0.16.3

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.16.3)

* Correção de bugs gerais
  * Garantir que o código seja compatível com versões anteriores
</Update>

<Update label="28 fev 2024">
  ## v0.16.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.16.0)

* Removendo a dependência `crewai_tools` remanescente
  * Adicionando suporte inicial para interpolação de entradas (documentação ausente)
  * Adicionando a capacidade de rastrear uso de ferramentas, erros de ferramentas, erros de formatação, uso de tokens
  * Atualizando o README
</Update>

<Update label="26 fev 2024">
  ## v0.14.4

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.4)

* Atualizando timeouts
  * Atualizando documentos
  * Removendo crewai\_tools como obrigatório
  * Tornando os agentes sem memória por padrão para redução de contagem de tokens (mudança breaking para pessoas que contavam com isso anteriormente)
</Update>

<Update label="24 fev 2024">
  ## v0.14.3

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.3)

* Corrigindo link de documentação quebrado
  * Adicionando suporte para agentes sem ferramentas
  * Evitando saídas de tarefa vazias
</Update>

<Update label="22 fev 2024">
  ## v0.14.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.0)

# Todas as melhorias da v0.14.0rc

* Suporte para exportar json e pydantic de modelos de código aberto
</Update>

<Update label="20 fev 2024">
  ## v0.14.0rc

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.14.0rc0)

* Adicionando suporte ao crewai-tools
  * Adicionando suporte para formatar a saída de tarefas como Objetos Pydantic ou JSON
  * Adicionando suporte para salvar a saída de tarefas em um arquivo
  * Melhorada a confiabilidade para delegação entre agentes
  * Reformulação da lógica de uso de ferramentas para o uso adequado de chamadas de função
  * Atualizando prompts internos
  * Suporte a ferramentas sem argumentos
  * Correções de bugs
</Update>

<Update label="16 fev 2024">
  ## v0.11.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.11.2)

* Adicionando mais registros de erro para que os usuários entendam o que está acontecendo se uma ferramenta falhar
</Update>

<Update label="16 fev 2024">
  ## v0.11.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.11.1)

* Corrige um bug na lógica de uso da ferramenta que estava armazenando em cache o resultado mesmo se houvesse um erro no uso, impedindo que a ferramenta fosse utilizada novamente.
  * Também imprimirá qualquer mensagem de erro em vermelho, permitindo que o usuário entenda qual foi o problema com a ferramenta.
</Update>

<Update label="13 fev 2024">
  ## v0.11.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.11.0)

* Capacidade de definir `function_calling_llm` tanto para toda a equipe quanto para agentes individuais
  * Algumas tentativas iniciais de redução de custos
  * Melhorando a chamada de funções para ferramentas
  * Atualizações na documentação
</Update>

<Update label="10 fev 2024">
  ## v0.10.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.10.0)

* Capacidade de obter `full_output` do crew kickoff com todas as saídas das tarefas
  * Capacidade de definir a função `step_callback` para tanto Agentes quanto Equipes, permitindo que você obtenha todos os passos intermediários
  * Lembrando o Agente do formato esperado após um certo número de usos de ferramentas.
  * Novos detalhes de uso de ferramentas agora utilizando json, desbloqueando ferramentas com múltiplos argumentos
  * Refatoração da lógica de delegação geral, agora muito mais confiável
  * Correção do bug `max_inter`, agora forçando corretamente o llm a responder à medida que chega a isso
  * Estrutura de cache reconstruída, garantindo que múltiplos agentes possam usar o mesmo cache
  * Refatoração da lógica de prevenção de uso repetido de Tarefas
  * Remoção do agora desnecessário `CrewAgentOutputParser`
  * Opção para compartilhar dados completos relacionados à equipe com a equipe do crewAI
  * Atualização geral da documentação
</Update>

<Update label="08 fev 2024">
  ## v0.5.5

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.5)

* Melhorias gerais na documentação + readme
  * Correção do controlador RPM sendo configurado desnecessariamente
  * Adição de telemetria anônima em estágio inicial para melhoria da biblioteca
</Update>

<Update label="07 fev 2024">
  ## v0.5.3

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.3)

* correção rápida para gerente hierárquico
</Update>

<Update label="06 fev 2024">
  ## v0.5.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.2)

* Adicionando `manager_llm` para processo hierárquico
  * Melhorando a lógica de `max_inter` e `max_rpm`
  * Atualizando README e Docs
</Update>

<Update label="04 fev 2024">
  ## v0.5.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.5.0)

Esta nova versão traz muitas novas funcionalidades e melhorias para a biblioteca.

* Adição de Callbacks de Tarefa.
  * Adição de suporte para processos Hierárquicos.
  * Adição da capacidade de referenciar tarefas específicas em outra tarefa.
  * Adição da capacidade de execução paralela de tarefas.

* Reformulação de Máximas Iterações e Máximas Solicitações por Minuto.
  * Melhorias na experiência do desenvolvedor, docstrings e afins.
  * Pequenas melhorias e correções de TYPOs.
  * Correção de erros de tipagem estática.
  * README e Documentação atualizados.
</Update>

<Update label="14 jan 2024">
  ## v0.1.32

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.32)

* Mudando para LangChain 0.1.0
  * Melhorando Prompts
  * Adicionando a capacidade de limitar o número máximo de iterações para um agente
  * Adicionando a capacidade de limitar solicitações por minuto para Agentes e Equipes
  * Adicionando suporte inicial para traduções
  * Adicionando tradução em grego
  * Melhorar a legibilidade do código
  * Iniciando nova documentação com mkdocs
</Update>

<Update label="07 jan 2024">
  ## v0.1.23

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.23)

* Muitas melhorias de confiabilidade
  * Mudanças nos prompts
  * Mudanças iniciais para suporte a múltiplas línguas
  * Correção de bug na execução repetida de tarefas
  * Melhor tratamento de erros de execução
  * Atualizando o READMe
</Update>

<Update label="30 dez 2023">
  ## v0.1.14

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.14)

* Adicionando cache de ferramentas para prevenção de execução em loop. (@joaomdmoura)
  * Adicionando mais diretrizes para delegação de Agentes. (@joaomdmoura)
  * Atualizando para usar a nova versão da lib openai. (@joaomdmoura)
  * Adicionando níveis de verbosidade ao logger. (@joaomdmoura)
  * Removendo código WIP. (@joaomdmoura)
  * Muitas melhorias na qualidade de vida dos desenvolvedores (Agradecimentos especiais a @greysonlalonde).
  * Atualizando para pydantic v2 (Agradecimentos especiais a @greysonlalonde também).
</Update>

<Update label="24 nov 2023">
  ## v0.1.2

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.2)

* Adicionando a capacidade de usar outros LLMs, não apenas OpenAI
</Update>

<Update label="19 nov 2023">
  ## v0.1.1

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.1)

# CrewAI v0.1.1 Notas de Lançamento

* **Modo Verbose do Crew**: Agora permitindo que você inspecione as tarefas que estão sendo executadas.

* **Atualizações no README e Docs**: Uma série de atualizações menores na documentação.
</Update>

<Update label="14 nov 2023">
  ## v0.1.0

[Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/v0.1.0)

# CrewAI v0.1.0 Notas de Lançamento

Estamos empolgados em anunciar o lançamento inicial do CrewAI, versão 0.1.0! O CrewAI é uma estrutura projetada para facilitar a orquestração de agentes de IA autônomos capazes de interpretar papéis e colaborar para realizar tarefas complexas de forma mais eficiente.

* **Lançamento Inicial**: O CrewAI agora está oficialmente disponível! Este lançamento fundamental estabelece as bases para que os agentes de IA trabalhem em conjunto, cada um com seu próprio papel e objetivos especializados.

* **Design de Agentes Baseado em Papéis**: Defina e personalize agentes com papéis específicos, metas e as ferramentas necessárias para ter sucesso.

* **Delegação Entre Agentes**: Os agentes agora estão equipados para delegar tarefas de forma autônoma, permitindo a distribuição dinâmica da carga de trabalho entre a equipe.

* **Gerenciamento de Tarefas**: Crie e atribua tarefas dinamicamente com a flexibilidade de especificar as ferramentas necessárias para cada tarefa.

* **Processos Sequenciais**: Configure seus agentes para abordar tarefas uma após a outra, garantindo fluxos de trabalho organizados e previsíveis.

* **Documentação**: Comece a explorar o CrewAI com nossa documentação inicial que o orienta através da configuração e uso da estrutura.

* Documentação detalhada da API para as classes `Agent`, `Task`, `Crew` e `Process`.
  * Exemplos e tutoriais para ajudá-lo a construir sua primeira aplicação CrewAI.
  * Configuração básica para mecanismos de colaboração e delegação entre agentes.

## Problemas Conhecidos

* Como este é o primeiro lançamento, pode haver bugs não descobertos e áreas para otimização. Incentivamos a comunidade a relatar quaisquer problemas encontrados durante o uso.

* **Gerenciamento Avançado de Processos**: Em lançamentos futuros, introduziremos processos mais complexos para gerenciamento de tarefas, incluindo fluxos de trabalho consensuais e hierárquicos.
</Update>

**Examples:**

Example 1 (unknown):
```unknown
2. **Atualize o crewai:**

     Para atualizar o crewai, use o seguinte comando:
```

Example 2 (unknown):
```unknown
3. **Confirme a atualização:**

     Após a instalação, verifique novamente a versão para garantir que a atualização foi bem-sucedida:
```

Example 3 (unknown):
```unknown
## Novas Funcionalidades

  Após a atualização, você poderá aproveitar as seguintes novas funcionalidades do comando `create`:

  * **Melhorias na criação de projetos:** Agora, você pode especificar templates personalizados.
  * **Integração com GitHub:** Facilita a conexão e o gerenciamento de repositórios diretamente do seu projeto.

  ## Exemplos de Uso

  Para criar um novo projeto com o comando `create`, utilize a seguinte sintaxe:
```

Example 4 (unknown):
```unknown
## Conclusão

  Manter o crewai atualizado é essencial para aproveitar ao máximo suas funcionalidades. Siga os passos acima para garantir que você esteja sempre utilizando a versão mais recente do comando `create`. Para mais informações, consulte a [documentação oficial do crewai](https://crewai.com/docs).
</Update>

<Update label="23 out 2024">
  ## v0.76.0

  [Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.76.0)

  * correção/corrigido prompt da API ausente + atualização da documentação do CLI
  * tarefa(readme): corrigindo etapa para 'executar testes' na contribuição
  * suporte à execução de código não seguro. adicionar na instalação do docker e verificações de execução
  * Corrigir importações de memória para funções de incorporação
</Update>

<Update label="23 out 2024">
  ## v0.75.1

  [Ver release no GitHub](https://github.com/crewAIInc/crewAI/releases/tag/0.75.1)

  # nova opção `--provider` no crewai crewat

  A nova opção `--provider` foi adicionada ao comando `crewat` do CrewAI. Esta opção permite que os usuários especifiquem o provedor de serviços que desejam utilizar ao executar o comando.

  ## Como usar

  Para utilizar a nova opção, você pode executar o seguinte comando:
```

---

## 도구를 사용하는 에이전트 정의

**URL:** llms-txt#도구를-사용하는-에이전트-정의

**Contents:**
- 파라미터
- 커스텀 모델 및 임베딩
- 에이전트 통합 예시

channel_researcher = Agent(
    role="Channel Researcher",
    goal="특정 YouTube 채널에서 관련 정보 추출",
    backstory="YouTube 채널 콘텐츠 분석을 전문으로 하는 전문가 연구원입니다.",
    tools=[youtube_channel_tool],
    verbose=True,
)
python Code theme={null}
youtube_channel_tool = YoutubeChannelSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # 또는 google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # 또는 openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import YoutubeChannelSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## 파라미터

`YoutubeChannelSearchTool`은 다음 파라미터를 허용합니다:

* **youtube\_channel\_handle**: 선택 사항. 검색할 YouTube 채널의 핸들입니다. 초기화 시 제공되면, 에이전트가 도구를 사용할 때 별도로 입력할 필요가 없습니다. 핸들이 '@'로 시작하지 않으면 자동으로 추가됩니다.
* **config**: 선택 사항. LLM 및 임베더 설정을 포함한 기본 RAG 시스템의 구성입니다.
* **summarize**: 선택 사항. 검색된 콘텐츠를 요약할지 여부입니다. 기본값은 `False`입니다.

에이전트와 함께 도구를 사용할 때 에이전트가 제공해야 하는 값은 다음과 같습니다:

* **search\_query**: 필수. 채널 콘텐츠에서 관련 정보를 찾기 위한 검색어입니다.
* **youtube\_channel\_handle**: 초기화 시 제공하지 않은 경우에만 필수. 검색할 YouTube 채널의 핸들입니다.

## 커스텀 모델 및 임베딩

기본적으로, 해당 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 사용자 정의하려면 아래와 같이 config 딕셔너리를 사용할 수 있습니다:
```

Example 2 (unknown):
```unknown
## 에이전트 통합 예시

다음은 `YoutubeChannelSearchTool`을 CrewAI 에이전트와 통합하는 방법에 대한 좀 더 자세한 예시입니다:
```

---

## Integração com Google Calendar

**URL:** llms-txt#integração-com-google-calendar

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração com Google Calendar
  - 1. Conecte sua Conta Google
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica de Agente de Calendário

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/google_calendar

Gerenciamento de eventos e agendas com integração ao Google Calendar para o CrewAI.

Permita que seus agentes gerenciem eventos de calendário, agendas e disponibilidade através do Google Calendar. Crie e atualize eventos, gerencie participantes, verifique disponibilidade e otimize seu fluxo de agendamento com automação potencializada por IA.

Antes de usar a integração com o Google Calendar, certifique-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Google com acesso ao Google Calendar
* Sua conta Google conectada pela [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração com Google Calendar

### 1. Conecte sua Conta Google

1. Acesse [Integrações do CrewAI AMP](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Google Calendar** na seção de Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para acesso ao calendário e contatos
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="google_calendar/create_event">
    **Descrição:** Cria um evento no Google Calendar.

* `eventName` (string, obrigatório): Nome do evento.
    * `startTime` (string, obrigatório): Horário de início – Aceita timestamp Unix ou formatos de data ISO8601.
    * `endTime` (string, opcional): Horário de término – Padrão para uma hora após o início, se deixado em branco.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
    * `attendees` (string, opcional): Participantes – Aceita um array de e-mails ou e-mails separados por vírgula.
    * `eventLocation` (string, opcional): Local do evento.
    * `eventDescription` (string, opcional): Descrição do evento.
    * `eventId` (string, opcional): ID do evento – Um ID da sua aplicação para associar a este evento. Você pode usar esse ID para sincronizar atualizações posteriores neste evento.
    * `includeMeetLink` (boolean, opcional): Incluir link do Google Meet? – Cria automaticamente um link para conferência Google Meet para este evento.
  </Accordion>

<Accordion title="google_calendar/update_event">
    **Descrição:** Atualiza um evento existente no Google Calendar.

* `eventId` (string, obrigatório): ID do evento – O ID do evento a ser atualizado.
    * `eventName` (string, opcional): Nome do evento.
    * `startTime` (string, opcional): Horário de início – Aceita timestamp Unix ou formatos de data ISO8601.
    * `endTime` (string, opcional): Horário de término – Padrão para uma hora após o início, se deixado em branco.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
    * `attendees` (string, opcional): Participantes – Aceita um array de e-mails ou e-mails separados por vírgula.
    * `eventLocation` (string, opcional): Local do evento.
    * `eventDescription` (string, opcional): Descrição do evento.
  </Accordion>

<Accordion title="google_calendar/view_events">
    **Descrição:** Lista eventos do Google Calendar.

* `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
    * `after` (string, opcional): Após – Filtra eventos que começam após a data fornecida (Unix em milissegundos ou timestamp ISO). (exemplo: "2025-04-12T10:00:00Z ou 1712908800000").
    * `before` (string, opcional): Antes – Filtra eventos que terminam antes da data fornecida (Unix em milissegundos ou timestamp ISO). (exemplo: "2025-04-12T10:00:00Z ou 1712908800000").
  </Accordion>

<Accordion title="google_calendar/get_event_by_id">
    **Descrição:** Obtém um evento específico pelo ID no Google Calendar.

* `eventId` (string, obrigatório): ID do evento.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
  </Accordion>

<Accordion title="google_calendar/delete_event">
    **Descrição:** Exclui um evento do Google Calendar.

* `eventId` (string, obrigatório): ID do evento – O ID do evento do calendário a ser excluído.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
  </Accordion>

<Accordion title="google_calendar/get_contacts">
    **Descrição:** Obtém contatos do Google Calendar.

* `paginationParameters` (objeto, opcional): Parâmetros de Paginação.
      
  </Accordion>

<Accordion title="google_calendar/search_contacts">
    **Descrição:** Pesquisa contatos no Google Calendar.

* `query` (string, opcional): Termo de pesquisa para buscar contatos.
  </Accordion>

<Accordion title="google_calendar/list_directory_people">
    **Descrição:** Lista pessoas do diretório.

* `paginationParameters` (objeto, opcional): Parâmetros de Paginação.
      
  </Accordion>

<Accordion title="google_calendar/search_directory_people">
    **Descrição:** Pesquisa pessoas no diretório.

* `query` (string, obrigatório): Termo de pesquisa para buscar contatos.
    * `paginationParameters` (objeto, opcional): Parâmetros de Paginação.
      
  </Accordion>

<Accordion title="google_calendar/list_other_contacts">
    **Descrição:** Lista outros contatos.

* `paginationParameters` (objeto, opcional): Parâmetros de Paginação.
      
  </Accordion>

<Accordion title="google_calendar/search_other_contacts">
    **Descrição:** Pesquisa outros contatos.

* `query` (string, opcional): Termo de pesquisa para buscar contatos.
  </Accordion>

<Accordion title="google_calendar/get_availability">
    **Descrição:** Obtém informações de disponibilidade para calendários.

* `timeMin` (string, obrigatório): Início do intervalo. Em formato ISO.
    * `timeMax` (string, obrigatório): Fim do intervalo. Em formato ISO.
    * `timeZone` (string, opcional): Fuso horário usado na resposta. Opcional. O padrão é UTC.
    * `items` (array, opcional): Lista de calendários e/ou grupos para consulta. Padrão para o calendário padrão do usuário.
      
  </Accordion>
</AccordionGroup>

### Configuração Básica de Agente de Calendário

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="google_calendar/create_event">
    **Descrição:** Cria um evento no Google Calendar.

    **Parâmetros:**

    * `eventName` (string, obrigatório): Nome do evento.
    * `startTime` (string, obrigatório): Horário de início – Aceita timestamp Unix ou formatos de data ISO8601.
    * `endTime` (string, opcional): Horário de término – Padrão para uma hora após o início, se deixado em branco.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
    * `attendees` (string, opcional): Participantes – Aceita um array de e-mails ou e-mails separados por vírgula.
    * `eventLocation` (string, opcional): Local do evento.
    * `eventDescription` (string, opcional): Descrição do evento.
    * `eventId` (string, opcional): ID do evento – Um ID da sua aplicação para associar a este evento. Você pode usar esse ID para sincronizar atualizações posteriores neste evento.
    * `includeMeetLink` (boolean, opcional): Incluir link do Google Meet? – Cria automaticamente um link para conferência Google Meet para este evento.
  </Accordion>

  <Accordion title="google_calendar/update_event">
    **Descrição:** Atualiza um evento existente no Google Calendar.

    **Parâmetros:**

    * `eventId` (string, obrigatório): ID do evento – O ID do evento a ser atualizado.
    * `eventName` (string, opcional): Nome do evento.
    * `startTime` (string, opcional): Horário de início – Aceita timestamp Unix ou formatos de data ISO8601.
    * `endTime` (string, opcional): Horário de término – Padrão para uma hora após o início, se deixado em branco.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
    * `attendees` (string, opcional): Participantes – Aceita um array de e-mails ou e-mails separados por vírgula.
    * `eventLocation` (string, opcional): Local do evento.
    * `eventDescription` (string, opcional): Descrição do evento.
  </Accordion>

  <Accordion title="google_calendar/view_events">
    **Descrição:** Lista eventos do Google Calendar.

    **Parâmetros:**

    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
    * `after` (string, opcional): Após – Filtra eventos que começam após a data fornecida (Unix em milissegundos ou timestamp ISO). (exemplo: "2025-04-12T10:00:00Z ou 1712908800000").
    * `before` (string, opcional): Antes – Filtra eventos que terminam antes da data fornecida (Unix em milissegundos ou timestamp ISO). (exemplo: "2025-04-12T10:00:00Z ou 1712908800000").
  </Accordion>

  <Accordion title="google_calendar/get_event_by_id">
    **Descrição:** Obtém um evento específico pelo ID no Google Calendar.

    **Parâmetros:**

    * `eventId` (string, obrigatório): ID do evento.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
  </Accordion>

  <Accordion title="google_calendar/delete_event">
    **Descrição:** Exclui um evento do Google Calendar.

    **Parâmetros:**

    * `eventId` (string, obrigatório): ID do evento – O ID do evento do calendário a ser excluído.
    * `calendar` (string, opcional): Calendário – Use as Configurações de Workflow do Connect Portal para permitir que o usuário selecione em qual calendário o evento será adicionado. Padrão para o calendário principal do usuário se deixado em branco.
  </Accordion>

  <Accordion title="google_calendar/get_contacts">
    **Descrição:** Obtém contatos do Google Calendar.

    **Parâmetros:**

    * `paginationParameters` (objeto, opcional): Parâmetros de Paginação.
```

Example 4 (unknown):
```unknown
</Accordion>

  <Accordion title="google_calendar/search_contacts">
    **Descrição:** Pesquisa contatos no Google Calendar.

    **Parâmetros:**

    * `query` (string, opcional): Termo de pesquisa para buscar contatos.
  </Accordion>

  <Accordion title="google_calendar/list_directory_people">
    **Descrição:** Lista pessoas do diretório.

    **Parâmetros:**

    * `paginationParameters` (objeto, opcional): Parâmetros de Paginação.
```

---

## Visão Geral do MLflow

**URL:** llms-txt#visão-geral-do-mlflow

**Contents:**
  - Funcionalidades
- Instruções de Configuração

[MLflow](https://mlflow.org/) é uma plataforma open-source que auxilia profissionais e equipes de machine learning a lidar com as complexidades do processo de aprendizagem de máquina.

Ela oferece um recurso de tracing que aprimora a observabilidade de LLMs em suas aplicações de IA Generativa, capturando informações detalhadas sobre a execução dos serviços de sua aplicação.
O tracing fornece uma forma de registrar os inputs, outputs e metadados associados a cada etapa intermediária de uma requisição, permitindo que você identifique facilmente a origem de bugs e comportamentos inesperados.

<img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow-tracing.gif?s=be88ff36aec776c005102164d804322a" alt="Visão geral do uso de tracing MLflow com crewAI" data-og-width="1144" width="1144" data-og-height="720" height="720" data-path="images/mlflow-tracing.gif" data-optimize="true" data-opv="3" />

* **Painel de Tracing**: Monitore as atividades dos seus agentes crewAI com painéis detalhados que incluem entradas, saídas e metadados dos spans.
* **Tracing Automatizado**: Uma integração totalmente automatizada com crewAI, que pode ser habilitada executando `mlflow.crewai.autolog()`.
* **Instrumentação Manual de Tracing com pouco esforço**: Personalize a instrumentação dos traces usando as APIs de alto nível do MLflow, como decorators, wrappers de funções e context managers.
* **Compatibilidade com OpenTelemetry**: O MLflow Tracing suporta a exportação de traces para um OpenTelemetry Collector, que pode então ser usado para exportar traces para diversos backends como Jaeger, Zipkin e AWS X-Ray.
* **Empacote e Faça Deploy dos Agents**: Empacote e faça deploy de seus agents crewAI em um servidor de inferência com diversas opções de destino.
* **Hospede LLMs com Segurança**: Hospede múltiplos LLMs de vários provedores em um endpoint unificado através do gateway do MFflow.
* **Avaliação**: Avalie seus agents crewAI com uma ampla variedade de métricas utilizando a API conveniente `mlflow.evaluate()`.

## Instruções de Configuração

<Steps>
  <Step title="Instale o pacote MLflow">
    
  </Step>

<Step title="Inicie o servidor de tracking do MFflow">
    
  </Step>

<Step title="Inicialize o MLflow em sua aplicação">
    Adicione as duas linhas a seguir ao código da sua aplicação:

Exemplo de uso para tracing de Agents do CrewAI:

Consulte a [Documentação de Tracing do MLflow](https://mlflow.org/docs/latest/llms/tracing/index.html) para mais configurações e casos de uso.
  </Step>

<Step title="Visualize as atividades dos Agents">
    Agora os traces dos seus agentes crewAI estão sendo capturados pelo MLflow.
    Vamos acessar o servidor de tracking do MLflow para visualizar os traces e obter insights dos seus Agents.

Abra `127.0.0.1:5000` em seu navegador para acessar o servidor de tracking do MLflow.

<Frame caption="Painel de Tracing do MLflow">
      <img src="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=0685aeb79319ad21ff842053ce5303c9" alt="Exemplo de tracing do MLflow com crewai" data-og-width="3024" width="3024" data-og-height="1712" height="1712" data-path="images/mlflow1.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=280&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=f45f73922d8ea58f0e72c16c0e22d977 280w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=560&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=5025f431d9c88bb7a094ab032aeaa753 560w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=840&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=385879dd49ee957a4c25c5f94a9766e1 840w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=1100&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=c779a19494038367ecb7f1caefe1014c 1100w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=1650&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=ff45740a0aaab934952c2928edbdcbc6 1650w, https://mintcdn.com/crewai/qVjgZHKAyEOgSSUS/images/mlflow1.png?w=2500&fit=max&auto=format&n=qVjgZHKAyEOgSSUS&q=85&s=af14478b932df5a9f9261514f38d5e14 2500w" />
    </Frame>
  </Step>
</Steps>

**Examples:**

Example 1 (unknown):
```unknown
</Step>

  <Step title="Inicie o servidor de tracking do MFflow">
```

Example 2 (unknown):
```unknown
</Step>

  <Step title="Inicialize o MLflow em sua aplicação">
    Adicione as duas linhas a seguir ao código da sua aplicação:
```

Example 3 (unknown):
```unknown
Exemplo de uso para tracing de Agents do CrewAI:
```

---

## Configure the tool with custom parameters

**URL:** llms-txt#configure-the-tool-with-custom-parameters

**Contents:**
  - Tool Parameters

custom_extractor = TavilyExtractorTool(
    extract_depth='advanced',
    include_images=True,
    timeout=120
)

agent_with_custom_tool = Agent(
    role="Advanced Content Extractor",
    goal="Extract comprehensive content with images",
    tools=[custom_extractor]
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Tool Parameters

You can customize the tool's behavior by setting parameters during initialization:
```

---

## Process and inspect chunks

**URL:** llms-txt#process-and-inspect-chunks

**Contents:**
  - Problemas Comuns de Armazenamento de Knowledge

test_source.add()
print(f"Number of chunks created: {len(test_source.chunks)}")
for i, chunk in enumerate(test_source.chunks[:3]):  # Show first 3 chunks
    print(f"Chunk {i+1}: {chunk[:50]}...")
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Problemas Comuns de Armazenamento de Knowledge

**Erros "Arquivo não encontrado":**
```

---

## Define an agent with the AIMindTool

**URL:** llms-txt#define-an-agent-with-the-aimindtool

**Contents:**
- Conclusão

@agent
def data_analyst(self) -> Agent:
    return Agent(
        config=self.agents_config["data_analyst"],
        allow_delegation=False,
        tools=[aimind_tool]
    )
```

O `AIMindTool` oferece uma forma poderosa de consultar suas fontes de dados utilizando linguagem natural, facilitando a extração de insights sem a necessidade de escrever consultas SQL complexas. Ao conectar diversas fontes de dados e aproveitar a tecnologia AI-Minds, essa ferramenta permite que agentes acessem e analisem dados de maneira eficiente.

---

## Inicialize a ferramenta com um arquivo DOCX específico,

**URL:** llms-txt#inicialize-a-ferramenta-com-um-arquivo-docx-específico,

---

## Integração com Asana

**URL:** llms-txt#integração-com-asana

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Asana
  - 1. Conecte sua Conta Asana
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ações Disponíveis
- Exemplos de Uso
  - Configuração Básica do Agente Asana

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/asana

Coordenação de tarefas e projetos em equipe com a integração Asana para CrewAI.

Permita que seus agentes gerenciem tarefas, projetos e a coordenação da equipe através do Asana. Crie tarefas, atualize o status de projetos, gerencie atribuições e otimize o fluxo de trabalho da sua equipe com automação baseada em IA.

Antes de usar a integração com o Asana, assegure-se de ter:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Uma conta Asana com as permissões apropriadas
* Sua conta Asana conectada através da [página de Integrações](https://app.crewai.com/crewai_plus/connectors)

## Configurando a Integração Asana

### 1. Conecte sua Conta Asana

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Asana** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para gerenciamento de tarefas e projetos
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

<AccordionGroup>
  <Accordion title="asana/create_comment">
    **Descrição:** Cria um comentário no Asana.

* `task` (string, obrigatório): ID da Tarefa - O ID da tarefa à qual o comentário será adicionado. O comentário será escrito pelo usuário atualmente autenticado.
    * `text` (string, obrigatório): Texto (exemplo: "Este é um comentário.").
  </Accordion>

<Accordion title="asana/create_project">
    **Descrição:** Cria um projeto no Asana.

* `name` (string, obrigatório): Nome (exemplo: "Itens para comprar").
    * `workspace` (string, obrigatório): Área de trabalho - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham em qual área de trabalho criar projetos. Por padrão, será usada a primeira área de trabalho do usuário se deixado em branco.
    * `team` (string, opcional): Equipe - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham com qual equipe compartilhar o projeto. Por padrão, será usada a primeira equipe do usuário se deixado em branco.
    * `notes` (string, opcional): Notas (exemplo: "Esses são itens que precisamos comprar.").
  </Accordion>

<Accordion title="asana/get_projects">
    **Descrição:** Obtém uma lista de projetos do Asana.

* `archived` (string, opcional): Arquivado - Escolha "true" para mostrar projetos arquivados, "false" para exibir apenas projetos ativos ou "default" para mostrar ambos.
      * Opções: `default`, `true`, `false`
  </Accordion>

<Accordion title="asana/get_project_by_id">
    **Descrição:** Obtém um projeto pelo ID no Asana.

* `projectFilterId` (string, obrigatório): ID do Projeto.
  </Accordion>

<Accordion title="asana/create_task">
    **Descrição:** Cria uma tarefa no Asana.

* `name` (string, obrigatório): Nome (exemplo: "Nome da tarefa").
    * `workspace` (string, opcional): Área de trabalho - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham em qual área de trabalho criar tarefas. Por padrão, será usada a primeira área de trabalho do usuário se deixado em branco.
    * `project` (string, opcional): Projeto - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham em qual projeto criar a tarefa.
    * `notes` (string, opcional): Notas.
    * `dueOnDate` (string, opcional): Data de Vencimento - A data em que esta tarefa deve ser concluída. Não pode ser usada em conjunto com Due At. (exemplo: "YYYY-MM-DD").
    * `dueAtDate` (string, opcional): Vence Em - A data e hora (timestamp ISO) em que esta tarefa deve ser concluída. Não pode ser usada em conjunto com Due On. (exemplo: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, opcional): Responsável - O ID do usuário Asana a quem esta tarefa será atribuída. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem um responsável.
    * `gid` (string, opcional): ID Externo - Um ID da sua aplicação para associar esta tarefa. Você pode usar este ID para sincronizar atualizações com esta tarefa posteriormente.
  </Accordion>

<Accordion title="asana/update_task">
    **Descrição:** Atualiza uma tarefa no Asana.

* `taskId` (string, obrigatório): ID da Tarefa - O ID da tarefa a ser atualizada.
    * `completeStatus` (string, opcional): Status de Conclusão.
      * Opções: `true`, `false`
    * `name` (string, opcional): Nome (exemplo: "Nome da Tarefa").
    * `notes` (string, opcional): Notas.
    * `dueOnDate` (string, opcional): Data de Vencimento - A data em que esta tarefa deve ser concluída. Não pode ser usada junto com Due At. (exemplo: "YYYY-MM-DD").
    * `dueAtDate` (string, opcional): Vence Em - A data e hora (timestamp ISO) em que esta tarefa deve ser concluída. Não pode ser usada junto com Due On. (exemplo: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, opcional): Responsável - O ID do usuário Asana a quem esta tarefa será atribuída. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem o responsável.
    * `gid` (string, opcional): ID Externo - Um ID da sua aplicação para associar a tarefa. Você pode usar este ID para sincronizar atualizações posteriormente.
  </Accordion>

<Accordion title="asana/get_tasks">
    **Descrição:** Obtém uma lista de tarefas no Asana.

* `workspace` (string, opcional): Área de trabalho - O ID da área de trabalho para filtrar tarefas. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem uma área de trabalho.
    * `project` (string, opcional): Projeto - O ID do projeto para filtrar as tarefas. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem um projeto.
    * `assignee` (string, opcional): Responsável - O ID do responsável para filtrar tarefas. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem um responsável.
    * `completedSince` (string, opcional): Concluída desde - Retorna apenas tarefas que estejam incompletas ou que tenham sido concluídas desde este horário (timestamp ISO ou Unix). (exemplo: "2014-04-25T16:15:47-04:00").
  </Accordion>

<Accordion title="asana/get_tasks_by_id">
    **Descrição:** Obtém uma lista de tarefas pelo ID no Asana.

* `taskId` (string, obrigatório): ID da Tarefa.
  </Accordion>

<Accordion title="asana/get_task_by_external_id">
    **Descrição:** Obtém uma tarefa pelo ID externo no Asana.

* `gid` (string, obrigatório): ID Externo - O ID que esta tarefa está associada ou sincronizada, de sua aplicação.
  </Accordion>

<Accordion title="asana/add_task_to_section">
    **Descrição:** Adiciona uma tarefa a uma seção no Asana.

* `sectionId` (string, obrigatório): ID da Seção - O ID da seção à qual a tarefa será adicionada.
    * `taskId` (string, obrigatório): ID da Tarefa - O ID da tarefa. (exemplo: "1204619611402340").
    * `beforeTaskId` (string, opcional): Antes da Tarefa - O ID de uma tarefa nesta seção antes da qual esta tarefa será inserida. Não pode ser usada junto com After Task ID. (exemplo: "1204619611402340").
    * `afterTaskId` (string, opcional): Após a Tarefa - O ID de uma tarefa nesta seção após a qual esta tarefa será inserida. Não pode ser usada junto com Before Task ID. (exemplo: "1204619611402340").
  </Accordion>

<Accordion title="asana/get_teams">
    **Descrição:** Obtém uma lista de equipes no Asana.

* `workspace` (string, obrigatório): Área de trabalho - Retorna as equipes nesta área de trabalho visíveis para o usuário autorizado.
  </Accordion>

<Accordion title="asana/get_workspaces">
    **Descrição:** Obtém uma lista de áreas de trabalho do Asana.

**Parâmetros:** Nenhum obrigatório.
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Asana

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ações Disponíveis

<AccordionGroup>
  <Accordion title="asana/create_comment">
    **Descrição:** Cria um comentário no Asana.

    **Parâmetros:**

    * `task` (string, obrigatório): ID da Tarefa - O ID da tarefa à qual o comentário será adicionado. O comentário será escrito pelo usuário atualmente autenticado.
    * `text` (string, obrigatório): Texto (exemplo: "Este é um comentário.").
  </Accordion>

  <Accordion title="asana/create_project">
    **Descrição:** Cria um projeto no Asana.

    **Parâmetros:**

    * `name` (string, obrigatório): Nome (exemplo: "Itens para comprar").
    * `workspace` (string, obrigatório): Área de trabalho - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham em qual área de trabalho criar projetos. Por padrão, será usada a primeira área de trabalho do usuário se deixado em branco.
    * `team` (string, opcional): Equipe - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham com qual equipe compartilhar o projeto. Por padrão, será usada a primeira equipe do usuário se deixado em branco.
    * `notes` (string, opcional): Notas (exemplo: "Esses são itens que precisamos comprar.").
  </Accordion>

  <Accordion title="asana/get_projects">
    **Descrição:** Obtém uma lista de projetos do Asana.

    **Parâmetros:**

    * `archived` (string, opcional): Arquivado - Escolha "true" para mostrar projetos arquivados, "false" para exibir apenas projetos ativos ou "default" para mostrar ambos.
      * Opções: `default`, `true`, `false`
  </Accordion>

  <Accordion title="asana/get_project_by_id">
    **Descrição:** Obtém um projeto pelo ID no Asana.

    **Parâmetros:**

    * `projectFilterId` (string, obrigatório): ID do Projeto.
  </Accordion>

  <Accordion title="asana/create_task">
    **Descrição:** Cria uma tarefa no Asana.

    **Parâmetros:**

    * `name` (string, obrigatório): Nome (exemplo: "Nome da tarefa").
    * `workspace` (string, opcional): Área de trabalho - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham em qual área de trabalho criar tarefas. Por padrão, será usada a primeira área de trabalho do usuário se deixado em branco.
    * `project` (string, opcional): Projeto - Use as Configurações de Fluxo do Portal Connect para permitir que usuários escolham em qual projeto criar a tarefa.
    * `notes` (string, opcional): Notas.
    * `dueOnDate` (string, opcional): Data de Vencimento - A data em que esta tarefa deve ser concluída. Não pode ser usada em conjunto com Due At. (exemplo: "YYYY-MM-DD").
    * `dueAtDate` (string, opcional): Vence Em - A data e hora (timestamp ISO) em que esta tarefa deve ser concluída. Não pode ser usada em conjunto com Due On. (exemplo: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, opcional): Responsável - O ID do usuário Asana a quem esta tarefa será atribuída. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem um responsável.
    * `gid` (string, opcional): ID Externo - Um ID da sua aplicação para associar esta tarefa. Você pode usar este ID para sincronizar atualizações com esta tarefa posteriormente.
  </Accordion>

  <Accordion title="asana/update_task">
    **Descrição:** Atualiza uma tarefa no Asana.

    **Parâmetros:**

    * `taskId` (string, obrigatório): ID da Tarefa - O ID da tarefa a ser atualizada.
    * `completeStatus` (string, opcional): Status de Conclusão.
      * Opções: `true`, `false`
    * `name` (string, opcional): Nome (exemplo: "Nome da Tarefa").
    * `notes` (string, opcional): Notas.
    * `dueOnDate` (string, opcional): Data de Vencimento - A data em que esta tarefa deve ser concluída. Não pode ser usada junto com Due At. (exemplo: "YYYY-MM-DD").
    * `dueAtDate` (string, opcional): Vence Em - A data e hora (timestamp ISO) em que esta tarefa deve ser concluída. Não pode ser usada junto com Due On. (exemplo: "2019-09-15T02:06:58.147Z").
    * `assignee` (string, opcional): Responsável - O ID do usuário Asana a quem esta tarefa será atribuída. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem o responsável.
    * `gid` (string, opcional): ID Externo - Um ID da sua aplicação para associar a tarefa. Você pode usar este ID para sincronizar atualizações posteriormente.
  </Accordion>

  <Accordion title="asana/get_tasks">
    **Descrição:** Obtém uma lista de tarefas no Asana.

    **Parâmetros:**

    * `workspace` (string, opcional): Área de trabalho - O ID da área de trabalho para filtrar tarefas. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem uma área de trabalho.
    * `project` (string, opcional): Projeto - O ID do projeto para filtrar as tarefas. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem um projeto.
    * `assignee` (string, opcional): Responsável - O ID do responsável para filtrar tarefas. Use as Configurações de Fluxo do Portal Connect para permitir que usuários selecionem um responsável.
    * `completedSince` (string, opcional): Concluída desde - Retorna apenas tarefas que estejam incompletas ou que tenham sido concluídas desde este horário (timestamp ISO ou Unix). (exemplo: "2014-04-25T16:15:47-04:00").
  </Accordion>

  <Accordion title="asana/get_tasks_by_id">
    **Descrição:** Obtém uma lista de tarefas pelo ID no Asana.

    **Parâmetros:**

    * `taskId` (string, obrigatório): ID da Tarefa.
  </Accordion>

  <Accordion title="asana/get_task_by_external_id">
    **Descrição:** Obtém uma tarefa pelo ID externo no Asana.

    **Parâmetros:**

    * `gid` (string, obrigatório): ID Externo - O ID que esta tarefa está associada ou sincronizada, de sua aplicação.
  </Accordion>

  <Accordion title="asana/add_task_to_section">
    **Descrição:** Adiciona uma tarefa a uma seção no Asana.

    **Parâmetros:**

    * `sectionId` (string, obrigatório): ID da Seção - O ID da seção à qual a tarefa será adicionada.
    * `taskId` (string, obrigatório): ID da Tarefa - O ID da tarefa. (exemplo: "1204619611402340").
    * `beforeTaskId` (string, opcional): Antes da Tarefa - O ID de uma tarefa nesta seção antes da qual esta tarefa será inserida. Não pode ser usada junto com After Task ID. (exemplo: "1204619611402340").
    * `afterTaskId` (string, opcional): Após a Tarefa - O ID de uma tarefa nesta seção após a qual esta tarefa será inserida. Não pode ser usada junto com Before Task ID. (exemplo: "1204619611402340").
  </Accordion>

  <Accordion title="asana/get_teams">
    **Descrição:** Obtém uma lista de equipes no Asana.

    **Parâmetros:**

    * `workspace` (string, obrigatório): Área de trabalho - Retorna as equipes nesta área de trabalho visíveis para o usuário autorizado.
  </Accordion>

  <Accordion title="asana/get_workspaces">
    **Descrição:** Obtém uma lista de áreas de trabalho do Asana.

    **Parâmetros:** Nenhum obrigatório.
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Asana
```

---

## Google Docs 기능을 가진 에이전트 생성

**URL:** llms-txt#google-docs-기능을-가진-에이전트-생성

docs_agent = Agent(
    role="문서 작성자",
    goal="Google Docs 문서를 효율적으로 생성하고 관리",
    backstory="Google Docs 문서 생성 및 편집 전문 AI 어시스턴트.",
    apps=['google_docs']  # 모든 Google Docs 작업을 사용할 수 있습니다
)

---

## 프롬프트 생성기 생성

**URL:** llms-txt#프롬프트-생성기-생성

prompt_generator = Prompts(
    agent=agent,
    has_tools=len(agent.tools) > 0,
    use_system_prompt=agent.use_system_prompt
)

---

## Example task to generate and execute code

**URL:** llms-txt#example-task-to-generate-and-execute-code

coding_task = Task(
    description="Write a Python function to calculate the Fibonacci sequence up to the 10th number and print the result.",
    expected_output="The Fibonacci sequence up to the 10th number.",
    agent=programmer_agent,
)

---

## Ferramenta RAG

**URL:** llms-txt#ferramenta-rag

Source: https://docs.crewai.com/pt-BR/tools/ai-ml/ragtool

O `RagTool` é uma ferramenta dinâmica de base de conhecimento para responder perguntas usando Geração Aumentada por Recuperação.

---

## Agente com gerenciamento automático de contexto (padrão)

**URL:** llms-txt#agente-com-gerenciamento-automático-de-contexto-(padrão)

**Contents:**
  - Limites Estritos de Contexto (`respect_context_window=False`)

smart_agent = Agent(
    role="Analista de Pesquisa",
    goal="Analisar grandes documentos e conjuntos de dados",
    backstory="Especialista em processar informações extensas",
    respect_context_window=True,  # 🔑 Padrão: gerencia limites de contexto automaticamente
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**O que acontece quando os limites de contexto são excedidos:**

* ⚠️ **Mensagem de aviso**: `"Context length exceeded. Summarizing content to fit the model context window."`
* 🔄 **Resumir automaticamente**: O CrewAI resume o histórico da conversa de forma inteligente
* ✅ **Execução contínua**: A execução da tarefa prossegue normalmente com o contexto resumido
* 📝 **Informação preservada**: Informações-chave são mantidas enquanto reduz a contagem de tokens

### Limites Estritos de Contexto (`respect_context_window=False`)

Quando você precisa de controle total e prefere que a execução pare a perder qualquer informação:
```

---

## Reset only agent-specific knowledge

**URL:** llms-txt#reset-only-agent-specific-knowledge

crew.reset_memories(command_type='agent_knowledge')

---

## Create agent with specific Slack actions only

**URL:** llms-txt#create-agent-with-specific-slack-actions-only

communication_manager = Agent(
    role="Communication Coordinator",
    goal="Manage team communications and ensure important messages reach the right people",
    backstory="An experienced communication coordinator who handles team messaging and notifications.",
    apps=[
        'slack/send_message',
        'slack/send_direct_message',
        'slack/search_messages'
    ]  # Using canonical action names from canonical_integrations.yml
)

---

## Zendesk 통합

**URL:** llms-txt#zendesk-통합

**Contents:**
- 개요
- 사전 준비 사항
- Zendesk 통합 설정
  - 1. Zendesk 계정 연결
  - 2. 필수 패키지 설치
  - 3. 환경 변수 설정
- 사용 가능한 도구
  - **티켓 관리**
  - **사용자 관리**
  - **관리 도구**

Source: https://docs.crewai.com/ko/enterprise/integrations/zendesk

CrewAI를 위한 Zendesk 통합으로 고객 지원 및 헬프데스크 관리.

에이전트가 Zendesk를 통해 고객 지원 운영을 관리할 수 있도록 지원합니다. 티켓 생성 및 업데이트, 사용자 관리, 지원 지표 추적, 그리고 AI 기반 자동화를 통해 고객 서비스 워크플로우를 간소화할 수 있습니다.

Zendesk 통합을 사용하기 전에 다음을 확인하세요.

* 활성 구독이 있는 [CrewAI AMP](https://app.crewai.com) 계정
* 적절한 API 권한이 있는 Zendesk 계정
* [통합 페이지](https://app.crewai.com/integrations)를 통해 Zendesk 계정 연결

1. [CrewAI AMP 통합](https://app.crewai.com/crewai_plus/connectors)으로 이동합니다.
2. 인증 통합 섹션에서 **Zendesk**를 찾습니다.
3. **연결**을 클릭하고 OAuth 과정을 완료합니다.
4. 티켓 및 사용자 관리에 필요한 권한을 부여합니다.
5. [통합 설정](https://app.crewai.com/crewai_plus/settings/integrations)에서 Enterprise Token을 복사합니다.

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>

<AccordionGroup>
  <Accordion title="zendesk/create_ticket">
    **설명:** Zendesk에 새로운 지원 티켓을 생성합니다.

* `ticketSubject` (string, 필수): 티켓 제목 줄 (예: "도와주세요, 프린터에 불이 났어요!")
    * `ticketDescription` (string, 필수): 티켓에 표시될 첫 번째 댓글 (예: "연기가 정말 화려하네요.")
    * `requesterName` (string, 필수): 지원 요청자의 이름 (예: "Jane Customer")
    * `requesterEmail` (string, 필수): 지원 요청자의 이메일 (예: "[jane@example.com](mailto:jane@example.com)")
    * `assigneeId` (string, 선택): 이 티켓에 할당된 Zendesk 에이전트 ID - 사용자가 담당자를 선택할 수 있도록 Connect Portal Workflow Settings 를 사용하세요
    * `ticketType` (string, 선택): 티켓 유형 - 옵션: problem, incident, question, task
    * `ticketPriority` (string, 선택): 우선순위 수준 - 옵션: urgent, high, normal, low
    * `ticketStatus` (string, 선택): 티켓 상태 - 옵션: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, 선택): task 유형 티켓의 마감일 (ISO 8601 타임스탬프)
    * `ticketTags` (string, 선택): 적용할 태그 배열 (예: `["enterprise", "other_tag"]`)
    * `ticketExternalId` (string, 선택): 티켓을 로컬 레코드와 연결할 외부 ID
    * `ticketCustomFields` (object, 선택): JSON 형식의 사용자 정의 필드 값
  </Accordion>

<Accordion title="zendesk/update_ticket">
    **설명:** Zendesk의 기존 지원 티켓을 업데이트합니다.

* `ticketId` (string, 필수): 업데이트할 티켓의 ID (예: "35436")
    * `ticketSubject` (string, 선택): 업데이트된 티켓 제목
    * `requesterName` (string, 필수): 이 티켓을 요청한 사용자의 이름
    * `requesterEmail` (string, 필수): 이 티켓을 요청한 사용자의 이메일
    * `assigneeId` (string, 선택): 업데이트된 담당자 ID - Connect Portal Workflow Settings 를 사용하세요
    * `ticketType` (string, 선택): 업데이트된 티켓 유형 - 옵션: problem, incident, question, task
    * `ticketPriority` (string, 선택): 업데이트된 우선순위 - 옵션: urgent, high, normal, low
    * `ticketStatus` (string, 선택): 업데이트된 상태 - 옵션: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, 선택): 업데이트된 마감일 (ISO 8601 타임스탬프)
    * `ticketTags` (string, 선택): 업데이트된 태그 배열
    * `ticketExternalId` (string, 선택): 업데이트된 외부 ID
    * `ticketCustomFields` (object, 선택): 업데이트된 사용자 정의 필드 값
  </Accordion>

<Accordion title="zendesk/get_ticket_by_id">
    **설명:** ID로 특정 티켓을 조회합니다.

* `ticketId` (string, 필수): 조회할 티켓의 ID (예: "35436")
  </Accordion>

<Accordion title="zendesk/add_comment_to_ticket">
    **설명:** 기존 티켓에 댓글이나 내부 노트를 추가합니다.

* `ticketId` (string, 필수): 댓글을 추가할 티켓의 ID (예: "35436")
    * `commentBody` (string, 필수): 댓글 메시지 (일반 텍스트 또는 HTML 지원, 예: "도움을 주셔서 감사합니다!")
    * `isInternalNote` (boolean, 선택): 공개 답글 대신 내부 노트로 설정하려면 true (기본값: false)
    * `isPublic` (boolean, 선택): 공개 댓글이면 true, 내부 노트이면 false
  </Accordion>

<Accordion title="zendesk/search_tickets">
    **설명:** 다양한 필터 및 조건을 사용하여 티켓을 검색합니다.

* `ticketSubject` (string, 선택): 티켓 제목 내 텍스트로 필터링
    * `ticketDescription` (string, 선택): 티켓 설명 및 댓글 내 텍스트로 필터링
    * `ticketStatus` (string, 선택): 상태로 필터링 - 옵션: new, open, pending, hold, solved, closed
    * `ticketType` (string, 선택): 유형으로 필터링 - 옵션: problem, incident, question, task, no\_type
    * `ticketPriority` (string, 선택): 우선순위로 필터링 - 옵션: urgent, high, normal, low, no\_priority
    * `requesterId` (string, 선택): 요청자 사용자 ID로 필터링
    * `assigneeId` (string, 선택): 담당 에이전트 ID로 필터링
    * `recipientEmail` (string, 선택): 원래 수신자 이메일 주소로 필터링
    * `ticketTags` (string, 선택): 티켓 태그로 필터링
    * `ticketExternalId` (string, 선택): 외부 ID로 필터링
    * `createdDate` (object, 선택): 생성일로 필터링 (연산자: EQUALS, LESS\_THAN\_EQUALS, GREATER\_THAN\_EQUALS, 값)
    * `updatedDate` (object, 선택): 업데이트 날짜로 필터링 (연산자와 값)
    * `dueDate` (object, 선택): 마감일로 필터링 (연산자와 값)
    * `sort_by` (string, 선택): 정렬 필드 - 옵션: created\_at, updated\_at, priority, status, ticket\_type
    * `sort_order` (string, 선택): 정렬 방향 - 옵션: asc, desc
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="zendesk/create_user">
    **설명:** Zendesk에서 새로운 사용자를 생성합니다.

* `name` (string, 필수): 사용자의 전체 이름
    * `email` (string, 선택): 사용자의 이메일 주소 (예: "[jane@example.com](mailto:jane@example.com)")
    * `phone` (string, 선택): 사용자의 전화번호
    * `role` (string, 선택): 사용자 역할 - 옵션: admin, agent, end-user
    * `externalId` (string, 선택): 다른 시스템의 고유 식별자
    * `details` (string, 선택): 추가 사용자 정보
    * `notes` (string, 선택): 사용자에 대한 내부 메모
  </Accordion>

<Accordion title="zendesk/update_user">
    **설명:** 기존 사용자의 정보를 업데이트합니다.

* `userId` (string, 필수): 업데이트할 사용자의 ID
    * `name` (string, 선택): 업데이트할 사용자 이름
    * `email` (string, 선택): 업데이트할 이메일 (업데이트 시 보조 이메일로 추가됨)
    * `phone` (string, 선택): 업데이트할 전화번호
    * `role` (string, 선택): 업데이트할 역할 - 옵션: admin, agent, end-user
    * `externalId` (string, 선택): 업데이트된 외부 ID
    * `details` (string, 선택): 업데이트된 사용자 상세 정보
    * `notes` (string, 선택): 업데이트된 내부 메모
  </Accordion>

<Accordion title="zendesk/get_user_by_id">
    **설명:** ID로 특정 사용자를 조회합니다.

* `userId` (string, 필수): 조회할 사용자 ID
  </Accordion>

<Accordion title="zendesk/search_users">
    **설명:** 다양한 기준으로 사용자를 검색합니다.

* `name` (string, 선택): 사용자 이름으로 필터링
    * `email` (string, 선택): 사용자 이메일로 필터링 (예: "[jane@example.com](mailto:jane@example.com)")
    * `role` (string, 선택): 역할로 필터링 - 옵션: admin, agent, end-user
    * `externalId` (string, 선택): 외부 ID로 필터링
    * `sort_by` (string, 선택): 정렬 필드 - 옵션: created\_at, updated\_at
    * `sort_order` (string, 선택): 정렬 방향 - 옵션: asc, desc
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="zendesk/get_ticket_fields">
    **설명:** 티켓에 사용할 수 있는 모든 표준 및 맞춤 필드를 검색합니다.

* `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>

<Accordion title="zendesk/get_ticket_audits">
    **설명:** 티켓의 감사 기록(읽기 전용 이력)을 가져옵니다.

* `ticketId` (string, 선택 사항): 특정 티켓의 감사를 조회합니다(비워두면 모든 비보관된 티켓의 감사를 조회, 예: "1234")
    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>
</AccordionGroup>

커스텀 필드를 사용하면 조직에 특화된 추가 정보를 저장할 수 있습니다:

* **긴급** - 즉각적인 조치가 필요한 치명적 이슈
* **높음** - 신속하게 해결해야 하는 중요한 이슈
* **보통** - 대부분의 티켓에 해당하는 표준 우선순위
* **낮음** - 여유가 있을 때 처리해도 되는 사소한 이슈

* **new** - 최근에 생성됨, 아직 할당되지 않음
* **open** - 현재 작업 중
* **pending** - 고객 응답 또는 외부 조치 대기 중
* **hold** - 일시 중지됨
* **solved** - 문제가 해결되어 고객 확인 대기 중
* **closed** - 티켓이 완료되어 종료됨

### 기본 Zendesk 에이전트 설정

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. 환경 변수 설정

<Note>
  `Agent(apps=[])`와 함께 통합을 사용하려면 Enterprise Token으로 `CREWAI_PLATFORM_INTEGRATION_TOKEN` 환경 변수를 설정해야 합니다.
</Note>
```

Example 2 (unknown):
```unknown
또는 `.env` 파일에 추가하세요:
```

Example 3 (unknown):
```unknown
## 사용 가능한 도구

### **티켓 관리**

<AccordionGroup>
  <Accordion title="zendesk/create_ticket">
    **설명:** Zendesk에 새로운 지원 티켓을 생성합니다.

    **매개변수:**

    * `ticketSubject` (string, 필수): 티켓 제목 줄 (예: "도와주세요, 프린터에 불이 났어요!")
    * `ticketDescription` (string, 필수): 티켓에 표시될 첫 번째 댓글 (예: "연기가 정말 화려하네요.")
    * `requesterName` (string, 필수): 지원 요청자의 이름 (예: "Jane Customer")
    * `requesterEmail` (string, 필수): 지원 요청자의 이메일 (예: "[jane@example.com](mailto:jane@example.com)")
    * `assigneeId` (string, 선택): 이 티켓에 할당된 Zendesk 에이전트 ID - 사용자가 담당자를 선택할 수 있도록 Connect Portal Workflow Settings 를 사용하세요
    * `ticketType` (string, 선택): 티켓 유형 - 옵션: problem, incident, question, task
    * `ticketPriority` (string, 선택): 우선순위 수준 - 옵션: urgent, high, normal, low
    * `ticketStatus` (string, 선택): 티켓 상태 - 옵션: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, 선택): task 유형 티켓의 마감일 (ISO 8601 타임스탬프)
    * `ticketTags` (string, 선택): 적용할 태그 배열 (예: `["enterprise", "other_tag"]`)
    * `ticketExternalId` (string, 선택): 티켓을 로컬 레코드와 연결할 외부 ID
    * `ticketCustomFields` (object, 선택): JSON 형식의 사용자 정의 필드 값
  </Accordion>

  <Accordion title="zendesk/update_ticket">
    **설명:** Zendesk의 기존 지원 티켓을 업데이트합니다.

    **매개변수:**

    * `ticketId` (string, 필수): 업데이트할 티켓의 ID (예: "35436")
    * `ticketSubject` (string, 선택): 업데이트된 티켓 제목
    * `requesterName` (string, 필수): 이 티켓을 요청한 사용자의 이름
    * `requesterEmail` (string, 필수): 이 티켓을 요청한 사용자의 이메일
    * `assigneeId` (string, 선택): 업데이트된 담당자 ID - Connect Portal Workflow Settings 를 사용하세요
    * `ticketType` (string, 선택): 업데이트된 티켓 유형 - 옵션: problem, incident, question, task
    * `ticketPriority` (string, 선택): 업데이트된 우선순위 - 옵션: urgent, high, normal, low
    * `ticketStatus` (string, 선택): 업데이트된 상태 - 옵션: new, open, pending, hold, solved, closed
    * `ticketDueAt` (string, 선택): 업데이트된 마감일 (ISO 8601 타임스탬프)
    * `ticketTags` (string, 선택): 업데이트된 태그 배열
    * `ticketExternalId` (string, 선택): 업데이트된 외부 ID
    * `ticketCustomFields` (object, 선택): 업데이트된 사용자 정의 필드 값
  </Accordion>

  <Accordion title="zendesk/get_ticket_by_id">
    **설명:** ID로 특정 티켓을 조회합니다.

    **매개변수:**

    * `ticketId` (string, 필수): 조회할 티켓의 ID (예: "35436")
  </Accordion>

  <Accordion title="zendesk/add_comment_to_ticket">
    **설명:** 기존 티켓에 댓글이나 내부 노트를 추가합니다.

    **매개변수:**

    * `ticketId` (string, 필수): 댓글을 추가할 티켓의 ID (예: "35436")
    * `commentBody` (string, 필수): 댓글 메시지 (일반 텍스트 또는 HTML 지원, 예: "도움을 주셔서 감사합니다!")
    * `isInternalNote` (boolean, 선택): 공개 답글 대신 내부 노트로 설정하려면 true (기본값: false)
    * `isPublic` (boolean, 선택): 공개 댓글이면 true, 내부 노트이면 false
  </Accordion>

  <Accordion title="zendesk/search_tickets">
    **설명:** 다양한 필터 및 조건을 사용하여 티켓을 검색합니다.

    **매개변수:**

    * `ticketSubject` (string, 선택): 티켓 제목 내 텍스트로 필터링
    * `ticketDescription` (string, 선택): 티켓 설명 및 댓글 내 텍스트로 필터링
    * `ticketStatus` (string, 선택): 상태로 필터링 - 옵션: new, open, pending, hold, solved, closed
    * `ticketType` (string, 선택): 유형으로 필터링 - 옵션: problem, incident, question, task, no\_type
    * `ticketPriority` (string, 선택): 우선순위로 필터링 - 옵션: urgent, high, normal, low, no\_priority
    * `requesterId` (string, 선택): 요청자 사용자 ID로 필터링
    * `assigneeId` (string, 선택): 담당 에이전트 ID로 필터링
    * `recipientEmail` (string, 선택): 원래 수신자 이메일 주소로 필터링
    * `ticketTags` (string, 선택): 티켓 태그로 필터링
    * `ticketExternalId` (string, 선택): 외부 ID로 필터링
    * `createdDate` (object, 선택): 생성일로 필터링 (연산자: EQUALS, LESS\_THAN\_EQUALS, GREATER\_THAN\_EQUALS, 값)
    * `updatedDate` (object, 선택): 업데이트 날짜로 필터링 (연산자와 값)
    * `dueDate` (object, 선택): 마감일로 필터링 (연산자와 값)
    * `sort_by` (string, 선택): 정렬 필드 - 옵션: created\_at, updated\_at, priority, status, ticket\_type
    * `sort_order` (string, 선택): 정렬 방향 - 옵션: asc, desc
  </Accordion>
</AccordionGroup>

### **사용자 관리**

<AccordionGroup>
  <Accordion title="zendesk/create_user">
    **설명:** Zendesk에서 새로운 사용자를 생성합니다.

    **매개변수:**

    * `name` (string, 필수): 사용자의 전체 이름
    * `email` (string, 선택): 사용자의 이메일 주소 (예: "[jane@example.com](mailto:jane@example.com)")
    * `phone` (string, 선택): 사용자의 전화번호
    * `role` (string, 선택): 사용자 역할 - 옵션: admin, agent, end-user
    * `externalId` (string, 선택): 다른 시스템의 고유 식별자
    * `details` (string, 선택): 추가 사용자 정보
    * `notes` (string, 선택): 사용자에 대한 내부 메모
  </Accordion>

  <Accordion title="zendesk/update_user">
    **설명:** 기존 사용자의 정보를 업데이트합니다.

    **매개변수:**

    * `userId` (string, 필수): 업데이트할 사용자의 ID
    * `name` (string, 선택): 업데이트할 사용자 이름
    * `email` (string, 선택): 업데이트할 이메일 (업데이트 시 보조 이메일로 추가됨)
    * `phone` (string, 선택): 업데이트할 전화번호
    * `role` (string, 선택): 업데이트할 역할 - 옵션: admin, agent, end-user
    * `externalId` (string, 선택): 업데이트된 외부 ID
    * `details` (string, 선택): 업데이트된 사용자 상세 정보
    * `notes` (string, 선택): 업데이트된 내부 메모
  </Accordion>

  <Accordion title="zendesk/get_user_by_id">
    **설명:** ID로 특정 사용자를 조회합니다.

    **매개변수:**

    * `userId` (string, 필수): 조회할 사용자 ID
  </Accordion>

  <Accordion title="zendesk/search_users">
    **설명:** 다양한 기준으로 사용자를 검색합니다.

    **매개변수:**

    * `name` (string, 선택): 사용자 이름으로 필터링
    * `email` (string, 선택): 사용자 이메일로 필터링 (예: "[jane@example.com](mailto:jane@example.com)")
    * `role` (string, 선택): 역할로 필터링 - 옵션: admin, agent, end-user
    * `externalId` (string, 선택): 외부 ID로 필터링
    * `sort_by` (string, 선택): 정렬 필드 - 옵션: created\_at, updated\_at
    * `sort_order` (string, 선택): 정렬 방향 - 옵션: asc, desc
  </Accordion>
</AccordionGroup>

### **관리 도구**

<AccordionGroup>
  <Accordion title="zendesk/get_ticket_fields">
    **설명:** 티켓에 사용할 수 있는 모든 표준 및 맞춤 필드를 검색합니다.

    **파라미터:**

    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>

  <Accordion title="zendesk/get_ticket_audits">
    **설명:** 티켓의 감사 기록(읽기 전용 이력)을 가져옵니다.

    **파라미터:**

    * `ticketId` (string, 선택 사항): 특정 티켓의 감사를 조회합니다(비워두면 모든 비보관된 티켓의 감사를 조회, 예: "1234")
    * `paginationParameters` (object, 선택 사항): 페이지네이션 설정
      * `pageCursor` (string, 선택 사항): 페이지네이션을 위한 페이지 커서
  </Accordion>
</AccordionGroup>

## 커스텀 필드

커스텀 필드를 사용하면 조직에 특화된 추가 정보를 저장할 수 있습니다:
```

Example 4 (unknown):
```unknown
## 티켓 우선순위 레벨

우선순위 레벨 이해하기:

* **긴급** - 즉각적인 조치가 필요한 치명적 이슈
* **높음** - 신속하게 해결해야 하는 중요한 이슈
* **보통** - 대부분의 티켓에 해당하는 표준 우선순위
* **낮음** - 여유가 있을 때 처리해도 되는 사소한 이슈

## 티켓 상태 워크플로우

표준 티켓 상태 진행:

* **new** - 최근에 생성됨, 아직 할당되지 않음
* **open** - 현재 작업 중
* **pending** - 고객 응답 또는 외부 조치 대기 중
* **hold** - 일시 중지됨
* **solved** - 문제가 해결되어 고객 확인 대기 중
* **closed** - 티켓이 완료되어 종료됨

## 사용 예시

### 기본 Zendesk 에이전트 설정
```

---

## 프롬프트 커스터마이징

**URL:** llms-txt#프롬프트-커스터마이징

**Contents:**
- 프롬프트를 커스터마이즈해야 하는 이유
- CrewAI의 Prompt 시스템 이해하기
- 기본 시스템 지침 이해하기
  - CrewAI가 자동으로 삽입하는 내용
  - 전체 시스템 프롬프트 보기

Source: https://docs.crewai.com/ko/guides/advanced/customizing-prompts

CrewAI를 위한 저수준 프롬프트 커스터마이징에 대해 자세히 알아보고, 다양한 모델과 언어에 대해 매우 맞춤화되고 복잡한 사용 사례를 구현할 수 있습니다.

## 프롬프트를 커스터마이즈해야 하는 이유

CrewAI의 기본 프롬프트는 많은 시나리오에서 잘 작동하지만, 저수준 커스터마이징은 훨씬 더 유연하고 강력한 에이전트 행동으로 이어집니다. 더 깊은 제어를 통해 얻을 수 있는 이점은 다음과 같습니다:

1. **특정 LLM에 맞게 최적화** – GPT-4, Claude, Llama와 같은 다양한 모델은 각자의 고유한 아키텍처에 맞는 프롬프트 형식에서 최고의 성능을 발휘합니다.
2. **언어 변경** – 영어를 넘어서는 언어로만 작동하는 에이전트를 구축하여 미묘한 뉘앙스도 정확하게 처리할 수 있습니다.
3. **복잡한 도메인에 특화** – 헬스케어, 금융, 법률 등 매우 전문적인 산업군에 맞춰 프롬프트를 조정할 수 있습니다.
4. **톤과 스타일 조정** – 에이전트의 톤과 스타일을 좀 더 형식적, 캐주얼, 창의적, 혹은 분석적으로 만들 수 있습니다.
5. **초고도 커스텀 사례 지원** – 복잡하고 프로젝트에 특화된 요구사항을 충족하기 위해 고급 프롬프트 구조 및 포맷을 활용할 수 있습니다.

이 가이드에서는 CrewAI의 프롬프트를 더 낮은 레벨에서 활용하여, 에이전트의 사고 및 상호작용 방식을 세밀하게 제어하는 방법을 다룹니다.

## CrewAI의 Prompt 시스템 이해하기

내부적으로 CrewAI는 광범위하게 커스터마이즈할 수 있는 모듈식 prompt 시스템을 사용합니다:

* **Agent 템플릿** – 각 agent가 할당된 역할을 수행하는 방식을 결정합니다.
* **Prompt 슬라이스** – 작업, 도구 사용, 출력 구조와 같은 특수한 동작을 제어합니다.
* **오류 처리** – agent가 실패, 예외, 또는 타임아웃에 어떻게 반응할지 지정합니다.
* **도구별 prompt** – 도구가 호출되거나 사용되는 방법에 대한 상세 지침을 정의합니다.

이 요소들이 어떻게 구성되어 있는지 보려면 [CrewAI 저장소의 원본 prompt 템플릿](https://github.com/crewAIInc/crewAI/blob/main/src/crewai/translations/en.json)을 확인하세요. 여기서 필요에 따라 오버라이드하거나 수정하여 고급 동작을 구현할 수 있습니다.

<Warning>
  **프로덕션 투명성 문제**: CrewAI는 여러분이 인지하지 못하는 사이에 기본 지침을 프롬프트에 자동으로 삽입합니다. 이 섹션에서는 내부적으로 어떤 일이 일어나고 있는지와 완전한 제어권을 얻는 방법을 설명합니다.
</Warning>

여러분이 `role`, `goal`, `backstory`로 에이전트를 정의할 때, CrewAI는 형식 및 동작을 제어하는 추가 시스템 지침을 자동으로 추가합니다. 이러한 기본 삽입을 이해하는 것은 완전한 프롬프트 투명성이 필요한 프로덕션 시스템에서 매우 중요합니다.

### CrewAI가 자동으로 삽입하는 내용

에이전트 구성에 따라 CrewAI는 다양한 기본 지침을 추가합니다:

#### 도구가 없는 에이전트를 위한 안내

#### 도구가 있는 에이전트를 위한 안내

#### 구조화된 출력(JSON/Pydantic)의 경우

LLM에 전달되는 프롬프트가 정확히 무엇인지 확인하려면, 생성된 프롬프트를 확인할 수 있습니다:

```python  theme={null}
from crewai import Agent, Crew, Task
from crewai.utilities.prompts import Prompts

**Examples:**

Example 1 (unknown):
```unknown
#### 도구가 있는 에이전트를 위한 안내
```

Example 2 (unknown):
```unknown
#### 구조화된 출력(JSON/Pydantic)의 경우
```

Example 3 (unknown):
```unknown
### 전체 시스템 프롬프트 보기

LLM에 전달되는 프롬프트가 정확히 무엇인지 확인하려면, 생성된 프롬프트를 확인할 수 있습니다:
```

---

## Task to list workspace users

**URL:** llms-txt#task-to-list-workspace-users

user_management_task = Task(
    description="List all users in the workspace and provide a summary of team members",
    agent=notion_agent,
    expected_output="Complete list of workspace users with their details"
)

---

## Crie uma tarefa de exemplo

**URL:** llms-txt#crie-uma-tarefa-de-exemplo

task = Task(
    description="Analyze the sales data and identify trends",
    expected_output="A detailed analysis with key insights and trends",
    agent=agent
)

---

## 팀 및 채널 탐색 작업

**URL:** llms-txt#팀-및-채널-탐색-작업

explore_teams_task = Task(
    description="내가 멤버인 모든 팀을 나열한 다음 첫 번째 팀의 채널을 가져오세요.",
    agent=teams_agent,
    expected_output="팀 및 채널 목록이 표시됨."
)

---

## ignore_scrape_failures=True

**URL:** llms-txt#ignore_scrape_failures=true

---

## Create a task for the agent to write a specific file

**URL:** llms-txt#create-a-task-for-the-agent-to-write-a-specific-file

write_config_task = Task(
    description="""
    Create a configuration file with the following database settings:
    - host: db.example.com
    - port: 5432
    - username: app_user
    - password: secure_password
    
    Save this configuration as JSON to {my_bucket}.
    """,
    expected_output="Confirmation that the configuration file was successfully saved to S3.",
    agent=file_writer_agent,
)

---

## Configure logging

**URL:** llms-txt#configure-logging

logger = logging.getLogger('memory_errors')

class MemoryErrorTracker(BaseEventListener):
    def __init__(self, notify_email: Optional[str] = None):
        super().__init__()
        self.notify_email = notify_email
        self.error_count = 0

def setup_listeners(self, crewai_event_bus):
        @crewai_event_bus.on(MemorySaveFailedEvent)
        def on_memory_save_failed(source, event: MemorySaveFailedEvent):
            self.error_count += 1
            agent_info = f"Agent '{event.agent_role}'" if event.agent_role else "Unknown agent"
            error_message = f"Memory save failed: {event.error}. {agent_info}"
            logger.error(error_message)

if self.notify_email and self.error_count % 5 == 0:
                self._send_notification(error_message)

@crewai_event_bus.on(MemoryQueryFailedEvent)
        def on_memory_query_failed(source, event: MemoryQueryFailedEvent):
            self.error_count += 1
            error_message = f"Memory query failed: {event.error}. Query: '{event.query}'"
            logger.error(error_message)

if self.notify_email and self.error_count % 5 == 0:
                self._send_notification(error_message)

def _send_notification(self, message):
        # Implement your notification system (email, Slack, etc.)
        print(f"[NOTIFICATION] Would send to {self.notify_email}: {message}")

---

## Define your own system template without default instructions

**URL:** llms-txt#define-your-own-system-template-without-default-instructions

**Contents:**
  - 관측 도구를 활용한 디버깅
  - 프로덕션을 위한 모범 사례
- 프롬프트 파일 관리 모범 사례
- 프롬프트를 커스터마이즈하는 가장 간단한 방법
  - 예시: 기본 프롬프트 커스터마이징

custom_system_template = """You are {role}. {backstory}
Your goal is: {goal}

Respond naturally and conversationally. Focus on providing helpful, accurate information."""

custom_prompt_template = """Task: {input}

Please complete this task thoughtfully."""

agent = Agent(
    role="Research Assistant",
    goal="Help users find accurate information",
    backstory="You are a helpful research assistant.",
    system_template=custom_system_template,
    prompt_template=custom_prompt_template,
    use_system_prompt=True  # Use separate system/user messages
)
json  theme={null}
{
  "slices": {
    "no_tools": "\nProvide your best answer in a natural, conversational way.",
    "tools": "\nYou have access to these tools: {tools}\n\nUse them when helpful, but respond naturally.",
    "formatted_task_instructions": "Format your response as: {output_format}"
  }
}
python  theme={null}
crew = Crew(
    agents=[agent],
    tasks=[task],
    prompt_file="custom_prompts.json",
    verbose=True
)
python  theme={null}
agent = Agent(
    role="Analyst",
    goal="Analyze data",
    backstory="Expert analyst",
    use_system_prompt=False  # Disables system prompt separation
)
json  theme={null}
{
  "slices": {
    "format": "When responding, follow this structure:\n\nTHOUGHTS: Your step-by-step thinking\nACTION: Any tool you're using\nRESULT: Your final answer or conclusion"
  }
}
python  theme={null}
from crewai import Agent, Crew, Task, Process

**Examples:**

Example 1 (unknown):
```unknown
#### 옵션 2: 사용자 지정 프롬프트 파일

특정 프롬프트 슬라이스를 오버라이드하려면 `custom_prompts.json` 파일을 생성하세요:
```

Example 2 (unknown):
```unknown
그런 다음 crew에서 사용하세요:
```

Example 3 (unknown):
```unknown
#### 옵션 3: o1 모델에 대한 시스템 프롬프트 비활성화
```

Example 4 (unknown):
```unknown
### 관측 도구를 활용한 디버깅

프로덕션 투명성을 위해 관측 플랫폼과 통합하여 모든 prompt 및 LLM 상호작용을 모니터링하세요. 이를 통해 LLM에 어떤 prompt(기본 지침 포함)가 전송되고 있는지 정확히 확인할 수 있습니다.

다양한 플랫폼(Langfuse, MLflow, Weights & Biases, 커스텀 로깅 솔루션 등)과의 통합에 대한 자세한 가이드는 [관측 문서](/ko/observability/overview)를 참고하세요.

### 프로덕션을 위한 모범 사례

1. **프로덕션에 배포하기 전에 반드시 생성된 prompt를 점검하세요**
2. **prompt 내용을 완전히 제어해야 할 경우에는 커스텀 템플릿을 사용하세요**
3. **지속적인 prompt 모니터링을 위해 관측 도구를 통합하세요** ([Observability 문서](/ko/observability/overview) 참고)
4. **서로 다른 LLM으로 테스트하세요**. 기본 instruction은 모델마다 다르게 작동할 수 있습니다
5. **팀 투명성을 위해 prompt 커스터마이징을 문서화하세요**

<Tip>
  기본 instruction은 일관된 agent 동작을 보장하기 위해 존재하지만, 도메인 특화 요구사항과 충돌할 수 있습니다. 위의 커스터마이징 옵션을 사용하여 프로덕션 시스템에서 agent의 동작을 완전히 제어할 수 있습니다.
</Tip>

## 프롬프트 파일 관리 모범 사례

저수준 프롬프트 커스터마이징을 수행할 때는 다음 지침을 따라 조직적이고 유지 관리가 용이하도록 하세요:

1. **파일 분리** – 커스터마이징한 프롬프트는 메인 코드베이스 외부의 전용 JSON 파일에 저장하세요.
2. **버전 관리** – 리포지토리 내에서 변경 사항을 추적하여 프롬프트 조정 내역이 명확히 문서화되도록 하세요.
3. **모델 또는 언어별 정리** – `prompts_llama.json` 또는 `prompts_es.json`과 같이 네이밍 스킴을 사용해 특화된 구성을 빠르게 식별할 수 있도록 하세요.
4. **변경 사항 문서화** – 주석을 추가하거나 README를 유지 관리하여 커스터마이징의 목적과 범위를 상세히 기술하세요.
5. **수정 최소화** – 실제로 조정이 필요한 특정 부분만 오버라이드하고, 나머지 부분은 기본 기능을 유지하세요.

## 프롬프트를 커스터마이즈하는 가장 간단한 방법

가장 간단한 접근 방법 중 하나는 오버라이드하려는 프롬프트에 대한 JSON 파일을 생성한 다음, 해당 파일을 Crew에 지정하는 것입니다.

1. 업데이트된 프롬프트 슬라이스로 JSON 파일을 만드세요.
2. Crew의 `prompt_file` 파라미터를 통해 그 파일을 참조하세요.

그러면 CrewAI가 기본값과 사용자가 지정한 내용을 병합하므로, 모든 프롬프트를 다시 정의할 필요가 없습니다. 방법은 다음과 같습니다:

### 예시: 기본 프롬프트 커스터마이징

수정하고 싶은 프롬프트를 포함하는 `custom_prompts.json` 파일을 생성하세요. 변경 사항만이 아니라 포함해야 하는 모든 최상위 프롬프트를 반드시 나열해야 합니다:
```

---

## Linkup Search Tool

**URL:** llms-txt#linkup-search-tool

Source: https://docs.crewai.com/pt-BR/tools/search-research/linkupsearchtool

O `LinkupSearchTool` permite consultar a API do Linkup para obter informações contextuais.

---

## MCP 보안 고려사항

**URL:** llms-txt#mcp-보안-고려사항

**Contents:**
- 개요
  - 위험
  - 1. MCP 서버 신뢰하기
  - 2. Tool Metadata를 통한 보안 프롬프트 인젝션: "Model Control Protocol"의 위험성
  - Stdio 전송 보안
  - 혼동된 대리인(Confused Deputy) 공격
  - 원격 전송 보안 (SSE & Streamable HTTP)
  - SSE 보안 고려사항
  - a. DNS 리바인딩 공격 (특히 SSE의 경우)
  - b. HTTPS 사용

Source: https://docs.crewai.com/ko/mcp/security

MCP 서버를 CrewAI agent와 통합할 때 중요한 보안 모범 사례에 대해 알아보세요.

<Warning>
  MCP 보안에서 가장 중요한 측면은 **신뢰**입니다. 신뢰할 수 있다고 확신하는 MCP 서버에만 CrewAI 에이전트를 **연결해야 합니다**.
</Warning>

CrewAI 에이전트에 MCP(Model Context Protocol) 서버와 같은 외부 서비스를 통합할 때 보안이 가장 중요합니다.\
MCP 서버는 노출한 도구를 기반으로 코드를 실행하거나 데이터에 접근하거나 다른 시스템과 상호작용할 수 있습니다.\
응용 프로그램과 데이터를 보호하기 위해 그 영향력을 이해하고 모범 사례를 따르는 것이 매우 중요합니다.

* 에이전트가 실행 중인 머신에서 임의의 코드를 실행할 수 있습니다(특히 서버가 실행되는 명령어를 제어할 수 있는 `Stdio` 전송 방식을 사용할 경우).
* 에이전트나 그 환경에서 민감한 데이터가 노출될 수 있습니다.
* 예기치 않은 방식으로 에이전트의 동작이 조작되어, 본인 동의 없이 API 호출이 이루어질 수 있습니다.
* 정교한 프롬프트 인젝션 기법(아래 참조)을 통해 에이전트의 reasoning 프로세스가 탈취될 수 있습니다.

<Warning>
  **신뢰할 수 있는 MCP 서버에만 연결하십시오.**
</Warning>

`MCPServerAdapter`를 MCP 서버에 연결하도록 구성하기 전에 다음을 반드시 확인하십시오:

* **서버 운영자는 누구입니까?** 신뢰할 수 있는 잘 알려진 서비스이거나 여러분이 직접 제어하는 내부 서버입니까?
* **어떤 도구를 노출합니까?** 도구의 기능을 이해해야 합니다. 공격자가 제어권을 얻거나 서버 자체가 악의적이라면 이 도구들이 오용될 수 있습니까?
* **어떤 데이터를 접근하거나 처리합니까?** MCP 서버에 전송되거나 처리될 수 있는 민감한 정보가 있는지 반드시 파악하십시오.

특히 에이전트가 민감한 작업이나 데이터를 처리하는 경우, 알 수 없거나 검증되지 않은 MCP 서버에는 연결하지 마십시오.

### 2. Tool Metadata를 통한 보안 프롬프트 인젝션: "Model Control Protocol"의 위험성

중요하면서도 미묘한 위험 중 하나는 툴 메타데이터를 통한 프롬프트 인젝션 가능성입니다. 그 과정은 다음과 같습니다:

1. CrewAI 에이전트가 MCP 서버에 연결하면, 일반적으로 사용 가능한 툴 목록을 요청합니다.
2. MCP 서버는 각 툴에 대한 메타데이터를 이름, 설명, 파라미터 설명과 함께 응답합니다.
3. 에이전트의 언더라이잉 Language Model(LLM)은 해당 메타데이터를 활용해 언제, 어떻게 툴을 사용할지 이해합니다. 이 메타데이터는 LLM의 시스템 프롬프트나 컨텍스트에 포함되는 경우가 많습니다.
4. 악의적인 MCP 서버는 툴의 메타데이터(이름, 설명 등)에 숨겨진 또는 노골적인 명령어를 삽입할 수 있습니다. 이러한 명령은 프롬프트 인젝션으로 동작하여, LLM에게 특정 방식으로 동작하라고 지시하거나, 민감한 정보를 공개하게 하거나, 악의적인 행동을 수행하게 만들 수 있습니다.

**중요하게도, 이 공격은 에이전트가 해당 툴을 실제로 *사용*하지 않더라도 단순히 악성 서버에 연결해 툴 목록을 조회하는 것만으로도 발생할 수 있습니다.** 악의적인 메타데이터에 노출되는 것만으로도 에이전트의 행동이 손상될 수 있습니다.

* **신뢰되지 않은 서버에 대한 극도의 주의:** 반복합니다. *완전히 신뢰하지 않는 MCP 서버에는 절대 연결하지 마십시오.* 메타데이터 인젝션의 위험성 때문에 이 점이 매우 중요합니다.

Stdio(표준 입력/출력) 전송은 일반적으로 CrewAI 애플리케이션과 동일한 머신에서 실행되는 로컬 MCP 서버에 사용됩니다.

* **프로세스 격리**: 기본적으로 네트워크에 노출되지 않아 일반적으로 더 안전하지만, `StdioServerParameters`로 실행되는 스크립트나 명령어가 신뢰할 수 있는 소스에서 왔으며 적절한 파일 시스템 권한을 가지고 있는지 확인해야 합니다. 악의적인 Stdio 서버 스크립트는 여전히 로컬 시스템에 피해를 줄 수 있습니다.
* **입력값 정제**: Stdio 서버 스크립트가 에이전트 상호작용에서 파생된 복잡한 입력을 받는 경우, 스크립트 자체에서 이러한 입력값을 정제하여 명령어 삽입이나 스크립트 논리 내 다른 취약점이 발생하지 않도록 해야 합니다.
* **리소스 제한**: 로컬 Stdio 서버 프로세스는 로컬 자원(CPU, 메모리)을 소모하므로, 반드시 정상적으로 동작하는지, 시스템 자원을 소모하지 않는지 주의 깊게 관리해야 합니다.

### 혼동된 대리인(Confused Deputy) 공격

[혼동된 대리인 문제(Confused Deputy Problem)](https://en.wikipedia.org/wiki/Confused_deputy_problem)는 고전적인 보안 취약점으로, MCP 통합에서 특히 MCP 서버가 다른 서드파티 서비스(예: Google Calendar, GitHub)와 OAuth 2.0을 통한 인증을 할 때 프록시 역할을 할 경우 나타날 수 있습니다.

1. MCP 서버(여기서는 `MCP-Proxy`라고 부르겠습니다)가 에이전트가 `ThirdPartyAPI`와 상호작용할 수 있도록 허용합니다.
2. `MCP-Proxy`는 `ThirdPartyAPI`의 인증 서버와 통신할 때 자체의 단일 고정 `client_id`를 사용합니다.
3. 사용자(즉, 여러분)는 정당하게 `MCP-Proxy`가 여러분을 대신해 `ThirdPartyAPI`에 접근할 수 있도록 승인합니다. 이 과정에서 `ThirdPartyAPI`의 인증 서버는 여러분의 브라우저에 `MCP-Proxy`의 `client_id`에 대한 동의 쿠키를 설정할 수 있습니다.
4. 공격자는 악의적인 링크를 만듭니다. 이 링크는 `MCP-Proxy`와의 OAuth 플로우를 시작하지만, `ThirdPartyAPI`의 인증 서버를 속이도록 설계되어 있습니다.
5. 여러분이 이 링크를 클릭하고, `ThirdPartyAPI`의 인증 서버가 이미 존재하는 `MCP-Proxy`의 `client_id`에 대한 동의 쿠키를 확인하면, 다시 동의를 묻지 않고 *건너뛰기* 할 수 있습니다.
6. 그러면 `MCP-Proxy`가 (공격자에게) 인증 코드를 전달하도록 속거나, 공격자가 여러분을 가장해 `MCP-Proxy`에 사용할 수 있는 MCP 인증 코드를 받게 될 수 있습니다.

**대응 방안(주로 MCP 서버 개발자용):**

* 다운스트림 서비스를 위해 정적 client ID를 사용하는 MCP 프록시 서버는 **각 클라이언트 애플리케이션 또는 에이전트별**로 명시적인 사용자 동의를 반드시 받아야 합니다. 이 동의는 서드파티 서비스와의 OAuth 플로우 시작 *이전*에 이루어져야 하며, `MCP-Proxy` 자체가 동의 화면을 표시하도록 해야 합니다.

* MCP 서버가 여러 번 OAuth 인증을 위해 리디렉션하는 경우, 특히 예상치 않거나 요청된 권한이 과도하게 넓다면 주의해야 합니다.
* 자신과 프록시할 수 있는 서드파티 서비스의 구분을 명확하게 하는 MCP 서버를 선호하는 것이 좋습니다.

### 원격 전송 보안 (SSE & Streamable HTTP)

Server-Sent Events(SSE) 또는 Streamable HTTP를 통해 원격 MCP 서버에 연결할 때, 표준 웹 보안 관행이 필수적입니다.

### a. DNS 리바인딩 공격 (특히 SSE의 경우)

<Critical>
  **DNS 리바인딩 공격으로부터 보호하세요.**
</Critical>

DNS 리바인딩은 공격자가 제어하는 웹사이트가 동일 출처 정책(same-origin policy)을 우회하여 사용자의 로컬 네트워크(예: `localhost`) 또는 인트라넷에 있는 서버에 요청을 보낼 수 있도록 합니다. 이는 MCP 서버를 로컬(예: 개발용)로 실행하고 브라우저와 유사한 환경에서 agent를 사용하는 경우(일반적인 CrewAI 백엔드 구성에서는 드물지만) 또는 MCP 서버가 내부 네트워크상에 있을 경우 특히 위험할 수 있습니다.

**MCP 서버 구현자를 위한 대응 전략:**

* **`Origin` 및 `Host` 헤더 검증**: MCP 서버(특히 SSE 서버)는 `Origin` 및/또는 `Host` HTTP 헤더를 검증하여 요청이 예상되는 도메인/클라이언트로부터 오는지 확인해야 합니다.
* **`localhost`(127.0.0.1)로 바인딩**: 개발을 위해 MCP 서버를 로컬에서 실행할 때는 `0.0.0.0` 대신 `127.0.0.1`로 바인딩하세요. 이를 통해 네트워크의 다른 기기에서 접근하지 못하도록 막을 수 있습니다.
* **인증(Authentication)**: MCP 서버가 공개된 익명 접근을 목적으로 하지 않는 한 모든 연결에 대해 인증을 요구하세요.

* **전송 중 데이터 암호화**: 원격 MCP 서버의 URL에는 항상 HTTPS(HTTP Secure)를 사용하세요. 이는 CrewAI 애플리케이션과 MCP 서버 간의 통신을 암호화하여 도청 및 중간자 공격으로부터 보호합니다. `MCPServerAdapter`는 URL에 제공된 스킴(`http` 또는 `https`)을 그대로 따릅니다.

### c. 토큰 패스스루(Token Passthrough) (안티 패턴)

이 문제는 주로 MCP 서버 개발자들에게 해당되지만, 이를 이해하는 것은 안전한 서버를 선택하는 데 도움이 됩니다.

"토큰 패스스루"란, MCP 서버가 CrewAI agent로부터 받은 액세스 토큰(예를 들어 `ServiceA`를 위한 토큰일 수도 있음)을 별도의 적절한 검증 없이 다른 하위 API(`ServiceB`)로 그대로 전달하는 것을 의미합니다. 특히, `ServiceB`(또는 MCP 서버 자체)는 명시적으로 *자신들을 위해* 발급된 토큰만 받아야 합니다(즉, 토큰 내의 'audience' 클레임이 해당 서버/서비스와 일치해야 함).

* MCP 서버나 하위 API의 보안 제어(예 : 속도 제한, 세밀한 권한 부여 등)를 우회할 수 있습니다.
* 감사 추적 및 책임성을 저해할 수 있습니다.
* 탈취된 토큰의 악용을 허용할 수 있습니다.

**대응 방안 (MCP 서버 개발자용):**

* MCP 서버는 **명시적으로 자신을 위해 발급된 토큰만** 받아야 합니다. 토큰의 audience 클레임을 반드시 검증해야 합니다.

**CrewAI 사용자에게 미치는 영향:**

* 사용자가 직접적으로 제어할 수는 없지만, 보안 모범 사례를 준수하는 잘 설계된 MCP 서버에 연결하는 것이 중요함을 강조합니다.

* **신원 확인**: MCP 서버가 민감한 도구 또는 비공개 데이터에 대한 액세스를 제공하는 경우, 클라이언트(귀하의 CrewAI 애플리케이션)의 신원을 확인하기 위해 강력한 인증 메커니즘을 반드시 구현해야 합니다. 이는 API 키, OAuth 토큰 또는 기타 표준 방법을 포함할 수 있습니다.
* **최소 권한 원칙**: `MCPServerAdapter`에서 사용하는 자격 증명(있는 경우)은 필요한 도구에 접근하는 데 꼭 필요한 권한만 가지고 있도록 해야 합니다.

* **입력 검증은 매우 중요합니다**: MCP 서버는 에이전트로부터 받은 모든 입력을 처리하거나 도구에 전달하기 *전에* 철저하게 검증해야 합니다. 이는 많은 일반적인 취약점에 대한 1차 방어선입니다:
  * **명령어 삽입:** 도구가 입력을 기반으로 셸 명령, SQL 쿼리 또는 기타 해석형 언어 문장을 구성하는 경우, 서버는 악의적 명령어 주입 및 실행을 방지하기 위해 이 입력을 꼼꼼하게 정제해야 합니다.
  * **경로 탐색:** 도구가 입력 매개변수에 따라 파일에 접근하는 경우, 서버는 미허가 파일 또는 디렉터리에 접근하지 못하도록 이 경로를 검증 및 정제해야 합니다(예: `../` 시퀀스 차단).
  * **데이터 타입 및 범위 검사:** 서버는 입력 데이터가 기대하는 데이터 타입(예: 문자열, 숫자, 불리언)에 부합하는지, 허용 범위 내에 있거나 정의된 형식(예: URL에 대한 정규식)에 맞는지 확인해야 합니다.
  * **JSON 스키마 검증:** 모든 도구 매개변수는 정의된 JSON 스키마에 엄격하게 맞춰 검증되어야 합니다. 이를 통해 잘못된 요청을 조기에 차단할 수 있습니다.
* **클라이언트 측 인지**: 서버 측 검증이 가장 중요하지만, CrewAI 사용자는 특히 신뢰도가 낮은 또는 새로운 MCP 서버와 상호작용할 때 자신의 에이전트가 MCP 도구에 전달하도록 설계된 데이터에 각별히 유의해야 합니다.

### e. 속도 제한 및 리소스 관리

* **오용 방지**: MCP 서버는 악의적(서비스 거부 공격 등)이든 비의도적(예: 잘못 구성된 agent가 과도한 요청을 보내는 경우)이든 오용을 방지하기 위해 속도 제한을 구현해야 합니다.
* **클라이언트 측 재시도**: 일시적인 네트워크 문제나 서버의 속도 제한이 예상될 경우, CrewAI 작업에서 합리적인 재시도 로직을 구현하되, 서버 부하를 가중시킬 수 있는 과도한 재시도는 피해야 합니다.

## 4. 보안 MCP 서버 구현 권장 사항 (개발자용)

CrewAI 에이전트가 연결할 수 있는 MCP 서버를 개발하고 있다면, 위의 내용에 추가하여 다음과 같은 모범 사례를 고려하세요:

* **안전한 코딩 관행 준수**: 선택한 언어 및 프레임워크에 대한 표준 안전 코딩 원칙(예: OWASP Top 10)을 준수하세요.
* **최소 권한 원칙**: MCP 서버를 실행하는 프로세스(특히 `Stdio`의 경우)는 작업에 필요한 최소 권한만 보유하도록 하세요. 툴 자체도 자신의 기능 수행에 필요한 최소한의 권한만으로 동작해야 합니다.
* **종속성 관리**: 운영 체제 패키지, 언어 런타임, 써드파티 라이브러리 등 모든 서버 측 종속성을 최신 상태로 유지하여 알려진 취약점을 패치하세요. 취약한 종속성을 스캔하는 도구를 사용하세요.
* **안전한 기본값**: 서버와 그 도구를 기본적으로 안전하게 설계하세요. 예를 들어, 위험할 수 있는 기능은 기본적으로 꺼져 있거나 명확한 경고와 함께 명시적으로 opt-in 하도록 해야 합니다.
* **툴에 대한 접근 제어**: 인증 및 권한이 부여된 에이전트 또는 사용자만 특정 툴(특히 강력하거나 민감하거나 비용이 발생하는 툴)에 접근할 수 있도록 강력한 메커니즘을 구현하세요.
* **안전한 오류 처리**: 서버는 클라이언트에게 상세한 내부 오류 메시지, 스택 트레이스 또는 디버깅 정보를 노출해서는 안 됩니다. 이러한 정보는 내부 동작이나 잠재적 취약점을 드러낼 수 있습니다. 오류는 서버 측에서 진단을 목적으로 포괄적으로 기록하세요.
* **포괄적인 로깅 및 모니터링**: 보안 관련 이벤트(예: 인증 시도, 툴 호출, 오류, 권한 변경)에 대해 상세하게 로깅하세요. 이런 로그를 모니터링하여 의심스러운 활동이나 악용 패턴을 파악하세요.
* **MCP 인증 사양 준수**: 인증 및 권한 부여를 구현할 경우, [MCP Authorization specification](https://modelcontextprotocol.io/specification/draft/basic/authorization) 및 관련 [OAuth 2.0 security best practices](https://datatracker.ietf.org/doc/html/rfc9700)를 엄격히 준수하세요.
* **정기적인 보안 감사**: MCP 서버가 민감한 데이터를 처리하거나, 중요한 작업을 수행하거나, 대외적으로 노출된 경우 자격을 갖춘 전문가의 정기적인 보안 감사를 고려하세요.

MCP 보안에 대한 자세한 내용은 공식 문서를 참고하세요:

* **[MCP 전송 보안](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations)**

이러한 보안 고려사항을 이해하고 모범 사례를 구현하면 CrewAI 프로젝트에서 MCP 서버의 강력한 기능을 안전하게 활용할 수 있습니다.\
여기서 다루는 내용이 모든 것을 포괄하는 것은 아니지만, 가장 일반적이고 중요한 보안 문제들을 포함하고 있습니다.\
위협은 계속 진화하기 때문에 지속적으로 정보를 확인하고 그에 맞춰 보안 조치를 조정하는 것이 중요합니다.

---

## Get the base storage path

**URL:** llms-txt#get-the-base-storage-path

storage_path = db_storage_path()
print(f"CrewAI storage location: {storage_path}")

---

## Ferramenta S3 Writer

**URL:** llms-txt#ferramenta-s3-writer

Source: https://docs.crewai.com/pt-BR/tools/cloud-storage/s3writertool

A `S3WriterTool` permite que agentes CrewAI escrevam conteúdo em arquivos em buckets Amazon S3.

---

## The same seed always produces the same fingerprint

**URL:** llms-txt#the-same-seed-always-produces-the-same-fingerprint

same_fingerprint = Fingerprint.generate(seed="my-agent-id")
assert deterministic_fingerprint.uuid_str == same_fingerprint.uuid_str

---

## Use with knowledge sources

**URL:** llms-txt#use-with-knowledge-sources

knowledge_source = StringKnowledgeSource(
    content="Your knowledge content here"
)
knowledge_source.storage = custom_storage
python  theme={null}
import os
from pathlib import Path

**Examples:**

Example 1 (unknown):
```unknown
#### Opção 3: Armazenamento de Knowledge Específico do Projeto
```

---

## Task to send an email

**URL:** llms-txt#task-to-send-an-email

send_email_task = Task(
    description="Send an email to 'colleague@example.com' with subject 'Project Update' and body 'Hi, here is the latest project update. Best regards.'",
    agent=outlook_agent,
    expected_output="Email sent successfully to colleague@example.com"
)

---

## Create a task with more specific instructions

**URL:** llms-txt#create-a-task-with-more-specific-instructions

**Contents:**
- Tratamento de Erros

advanced_scrape_task = Task(
    description="""
    Extract content from example.com with the following requirements:
    - Convert the content to plain text format
    - Enable JavaScript rendering
    - Use a US-based proxy
    - Handle any scraping failures gracefully
    """,
    expected_output="The extracted content from example.com",
    agent=web_scraper_agent,
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## Tratamento de Erros

Por padrão, a `ScrapflyScrapeWebsiteTool` irá lançar uma exceção se a raspagem falhar. Os agentes podem ser instruídos a tratar falhas de forma mais flexível especificando o parâmetro `ignore_scrape_failures`:
```

---

## Obtenha as chaves do seu projeto na página de configurações do projeto: https://cloud.langfuse.com

**URL:** llms-txt#obtenha-as-chaves-do-seu-projeto-na-página-de-configurações-do-projeto:-https://cloud.langfuse.com

os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..."
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # 🇪🇺 Região UE

---

## 도구 출력 결과로 강제 지정하기

**URL:** llms-txt#도구-출력-결과로-강제-지정하기

**Contents:**
- 소개
- 도구 출력을 결과로 강제 지정하기

Source: https://docs.crewai.com/ko/learn/force-tool-output-as-result

CrewAI에서 에이전트의 작업에서 도구 출력을 결과로 강제 지정하는 방법을 알아봅니다.

CrewAI에서는 도구의 출력을 에이전트 작업의 결과로 강제로 사용할 수 있습니다.\
이 기능은 작업 실행 중에 에이전트가 출력을 수정하지 못하도록 하고, 도구의 출력이 반드시 캡처되어 작업 결과로 반환되도록 보장하고 싶을 때 유용합니다.

## 도구 출력을 결과로 강제 지정하기

도구의 출력을 에이전트 작업의 결과로 강제 지정하려면, 에이전트에 도구를 추가할 때 `result_as_answer` 매개변수를 `True`로 설정해야 합니다.\
이 매개변수는 도구의 출력이 에이전트에 의해 수정되지 않고 작업 결과로 캡처되어 반환되도록 보장합니다.

다음은 에이전트 작업의 결과로 도구 출력을 강제 지정하는 방법의 예시입니다:

```python Code theme={null}
from crewai.agent import Agent
from my_tool import MyCustomTool

---

## 두 필터가 모두 결합됩니다 (AND 논리)

**URL:** llms-txt#두-필터가-모두-결합됩니다-(and-논리)

**Contents:**
- 검색 매개변수
- 반환 형식
- 기본 임베딩
- 커스텀 임베딩

json  theme={null}
[
  {
    "metadata": {
      // Any metadata stored with the document
    },
    "context": "The actual text content of the document",
    "distance": 0.95  // Similarity score
  }
]
python  theme={null}
from transformers import AutoTokenizer, AutoModel
import torch

**Examples:**

Example 1 (unknown):
```unknown
## 검색 매개변수

이 도구는 스키마에서 다음과 같은 매개변수를 허용합니다:

* `query` (str): 유사한 문서를 찾기 위한 검색 쿼리
* `filter_by` (str, 선택 사항): 필터링할 메타데이터 필드
* `filter_value` (Any, 선택 사항): 필터 기준 값

## 반환 형식

이 도구는 결과를 JSON 형식으로 반환합니다:
```

Example 2 (unknown):
```unknown
## 기본 임베딩

기본적으로, 이 도구는 벡터화를 위해 OpenAI의 `text-embedding-3-large` 모델을 사용합니다. 이를 위해서는 다음이 필요합니다:

* 환경변수에 설정된 OpenAI API 키: `OPENAI_API_KEY`

## 커스텀 임베딩

기본 임베딩 모델 대신 다음과 같은 경우에 사용자 정의 임베딩 함수를 사용하고 싶을 수 있습니다:

1. 다른 임베딩 모델을 사용하고 싶은 경우 (예: Cohere, HuggingFace, Ollama 모델)
2. 오픈소스 임베딩 모델을 사용하여 비용을 절감해야 하는 경우
3. 벡터 차원 또는 임베딩 품질에 대한 특정 요구 사항이 있는 경우
4. 도메인 특화 임베딩을 사용하고 싶은 경우 (예: 의료 또는 법률 텍스트)

다음은 HuggingFace 모델을 사용하는 예시입니다:
```

---

## Exemplo de limitação da busca ao conteúdo de um site específico,

**URL:** llms-txt#exemplo-de-limitação-da-busca-ao-conteúdo-de-um-site-específico,

---

## 발견된 모든 웹사이트에서 검색할 수 있음

**URL:** llms-txt#발견된-모든-웹사이트에서-검색할-수-있음

tool = WebsiteSearchTool()

---

## Obtenha apenas ferramentas Zendesk específicas

**URL:** llms-txt#obtenha-apenas-ferramentas-zendesk-específicas

actions_list=["zendesk/create_ticket", "zendesk/update_ticket", "zendesk/add_comment_to_ticket"]
)

support_agent = Agent(
    role="Agente de Suporte ao Cliente",
    goal="Atender consultas de clientes e resolver issues de suporte de forma eficiente",
    backstory="Um agente de suporte experiente que se especializa em resolução de tickets e comunicação com clientes.",
    apps=['zendesk']
)

---

## Example task to write a report

**URL:** llms-txt#example-task-to-write-a-report

write_task = Task(
    description="Generate a summary report of the quarterly sales data and save it to {my_bucket}.",
    expected_output="Confirmation that the report was successfully saved to S3.",
    agent=file_writer_agent,
)

---

## os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # 🇺🇸 US 지역

**URL:** llms-txt#os.environ["langfuse_host"]-=-"https://us.cloud.langfuse.com"-#-🇺🇸-us-지역

---

## If false, the task will be skipped, if true, then execute the task.

**URL:** llms-txt#if-false,-the-task-will-be-skipped,-if-true,-then-execute-the-task.

def is_data_missing(output: TaskOutput) -> bool:
    return len(output.pydantic.events) < 10  # this will skip this task

---

## Obtenha apenas ferramentas específicas do Google Sheets

**URL:** llms-txt#obtenha-apenas-ferramentas-específicas-do-google-sheets

actions_list=["google_sheets/get_values", "google_sheets/update_values"]
)

data_collector = Agent(
    role="Data Collector",
    goal="Coletar e organizar dados em planilhas",
    backstory="Um assistente de IA dedicado à coleta e organização de dados.",
    apps=['google_sheets']
)

---

## Gerar embeddings da OpenAI

**URL:** llms-txt#gerar-embeddings-da-openai

def get_openai_embedding(text):
    response = client.embeddings.create(
        input=text,
        model="text-embedding-3-large"
    )
    return response.data[0].embedding

---

## Integração Stripe

**URL:** llms-txt#integração-stripe

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Stripe
  - 1. Conecte sua Conta Stripe
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ferramentas Disponíveis
  - **Gerenciamento de Clientes**
  - **Gerenciamento de Assinaturas**
  - **Gerenciamento de Produtos**

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/stripe

Processamento de pagamentos e gerenciamento de assinaturas com integração Stripe para CrewAI.

Permita que seus agentes gerenciem pagamentos, assinaturas e faturamento de clientes através do Stripe. Gerencie dados de clientes, processe assinaturas, gerencie produtos e acompanhe transações financeiras para otimizar seus fluxos de pagamento com automação impulsionada por IA.

Antes de usar a integração com o Stripe, certifique-se de que você tem:

* Uma conta [CrewAI AMP](https://app.crewai.com) com uma assinatura ativa
* Uma conta Stripe com permissões apropriadas de API
* Sua conta Stripe conectada através da [página de Integrações](https://app.crewai.com/integrations)

## Configurando a Integração Stripe

### 1. Conecte sua Conta Stripe

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Stripe** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para processamento de pagamentos
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

## Ferramentas Disponíveis

### **Gerenciamento de Clientes**

<AccordionGroup>
  <Accordion title="stripe/create_customer">
    **Descrição:** Crie um novo cliente em sua conta Stripe.

* `emailCreateCustomer` (string, obrigatório): Endereço de e-mail do cliente
    * `name` (string, opcional): Nome completo do cliente
    * `description` (string, opcional): Descrição do cliente para referência interna
    * `metadataCreateCustomer` (objeto, opcional): Metadados adicionais como pares chave-valor (exemplo: `{"field1": 1, "field2": 2}`)
  </Accordion>

<Accordion title="stripe/get_customer_by_id">
    **Descrição:** Recupera um cliente específico pelo ID do cliente Stripe.

* `idGetCustomer` (string, obrigatório): O ID do cliente Stripe a ser recuperado
  </Accordion>

<Accordion title="stripe/get_customers">
    **Descrição:** Recupera uma lista de clientes com filtragem opcional.

* `emailGetCustomers` (string, opcional): Filtra clientes pelo endereço de e-mail
    * `createdAfter` (string, opcional): Filtra clientes criados após esta data (timestamp Unix)
    * `createdBefore` (string, opcional): Filtra clientes criados antes desta data (timestamp Unix)
    * `limitGetCustomers` (string, opcional): Número máximo de clientes a retornar (padrão: 10)
  </Accordion>

<Accordion title="stripe/update_customer">
    **Descrição:** Atualiza as informações de um cliente existente.

* `customerId` (string, obrigatório): O ID do cliente a ser atualizado
    * `emailUpdateCustomer` (string, opcional): Novo endereço de e-mail
    * `name` (string, opcional): Novo nome do cliente
    * `description` (string, opcional): Nova descrição do cliente
    * `metadataUpdateCustomer` (objeto, opcional): Novos metadados como pares chave-valor
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Assinaturas**

<AccordionGroup>
  <Accordion title="stripe/create_subscription">
    **Descrição:** Cria uma nova assinatura para um cliente.

* `customerIdCreateSubscription` (string, obrigatório): O ID do cliente para o qual a assinatura será criada
    * `plan` (string, obrigatório): O ID do plano para assinatura - Use as Configurações do Workflow do Portal Connect para permitir que usuários selecionem um plano
    * `metadataCreateSubscription` (objeto, opcional): Metadados adicionais para a assinatura
  </Accordion>

<Accordion title="stripe/get_subscriptions">
    **Descrição:** Recupera assinaturas com filtragem opcional.

* `customerIdGetSubscriptions` (string, opcional): Filtra assinaturas por ID do cliente
    * `subscriptionStatus` (string, opcional): Filtra por status da assinatura - Opções: incomplete, incomplete\_expired, trialing, active, past\_due, canceled, unpaid
    * `limitGetSubscriptions` (string, opcional): Número máximo de assinaturas a retornar (padrão: 10)
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Produtos**

<AccordionGroup>
  <Accordion title="stripe/create_product">
    **Descrição:** Cria um novo produto no seu catálogo Stripe.

* `productName` (string, obrigatório): Nome do produto
    * `description` (string, opcional): Descrição do produto
    * `metadataProduct` (objeto, opcional): Metadados adicionais do produto como pares chave-valor
  </Accordion>

<Accordion title="stripe/get_product_by_id">
    **Descrição:** Recupera um produto específico pelo ID do produto Stripe.

* `productId` (string, obrigatório): O ID do produto Stripe a ser recuperado
  </Accordion>

<Accordion title="stripe/get_products">
    **Descrição:** Recupera uma lista de produtos com filtragem opcional.

* `createdAfter` (string, opcional): Filtra produtos criados após esta data (timestamp Unix)
    * `createdBefore` (string, opcional): Filtra produtos criados antes desta data (timestamp Unix)
    * `limitGetProducts` (string, opcional): Número máximo de produtos a retornar (padrão: 10)
  </Accordion>
</AccordionGroup>

### **Operações Financeiras**

<AccordionGroup>
  <Accordion title="stripe/get_balance_transactions">
    **Descrição:** Recupera transações de saldo da sua conta Stripe.

* `balanceTransactionType` (string, opcional): Filtra por tipo de transação - Opções: charge, refund, payment, payment\_refund
    * `paginationParameters` (objeto, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor da página para paginação
  </Accordion>

<Accordion title="stripe/get_plans">
    **Descrição:** Recupera planos de assinatura da sua conta Stripe.

* `isPlanActive` (boolean, opcional): Filtra por status do plano - true para planos ativos, false para inativos
    * `paginationParameters` (objeto, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor da página para paginação
  </Accordion>
</AccordionGroup>

### Configuração Básica do Agente Stripe

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ferramentas Disponíveis

### **Gerenciamento de Clientes**

<AccordionGroup>
  <Accordion title="stripe/create_customer">
    **Descrição:** Crie um novo cliente em sua conta Stripe.

    **Parâmetros:**

    * `emailCreateCustomer` (string, obrigatório): Endereço de e-mail do cliente
    * `name` (string, opcional): Nome completo do cliente
    * `description` (string, opcional): Descrição do cliente para referência interna
    * `metadataCreateCustomer` (objeto, opcional): Metadados adicionais como pares chave-valor (exemplo: `{"field1": 1, "field2": 2}`)
  </Accordion>

  <Accordion title="stripe/get_customer_by_id">
    **Descrição:** Recupera um cliente específico pelo ID do cliente Stripe.

    **Parâmetros:**

    * `idGetCustomer` (string, obrigatório): O ID do cliente Stripe a ser recuperado
  </Accordion>

  <Accordion title="stripe/get_customers">
    **Descrição:** Recupera uma lista de clientes com filtragem opcional.

    **Parâmetros:**

    * `emailGetCustomers` (string, opcional): Filtra clientes pelo endereço de e-mail
    * `createdAfter` (string, opcional): Filtra clientes criados após esta data (timestamp Unix)
    * `createdBefore` (string, opcional): Filtra clientes criados antes desta data (timestamp Unix)
    * `limitGetCustomers` (string, opcional): Número máximo de clientes a retornar (padrão: 10)
  </Accordion>

  <Accordion title="stripe/update_customer">
    **Descrição:** Atualiza as informações de um cliente existente.

    **Parâmetros:**

    * `customerId` (string, obrigatório): O ID do cliente a ser atualizado
    * `emailUpdateCustomer` (string, opcional): Novo endereço de e-mail
    * `name` (string, opcional): Novo nome do cliente
    * `description` (string, opcional): Nova descrição do cliente
    * `metadataUpdateCustomer` (objeto, opcional): Novos metadados como pares chave-valor
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Assinaturas**

<AccordionGroup>
  <Accordion title="stripe/create_subscription">
    **Descrição:** Cria uma nova assinatura para um cliente.

    **Parâmetros:**

    * `customerIdCreateSubscription` (string, obrigatório): O ID do cliente para o qual a assinatura será criada
    * `plan` (string, obrigatório): O ID do plano para assinatura - Use as Configurações do Workflow do Portal Connect para permitir que usuários selecionem um plano
    * `metadataCreateSubscription` (objeto, opcional): Metadados adicionais para a assinatura
  </Accordion>

  <Accordion title="stripe/get_subscriptions">
    **Descrição:** Recupera assinaturas com filtragem opcional.

    **Parâmetros:**

    * `customerIdGetSubscriptions` (string, opcional): Filtra assinaturas por ID do cliente
    * `subscriptionStatus` (string, opcional): Filtra por status da assinatura - Opções: incomplete, incomplete\_expired, trialing, active, past\_due, canceled, unpaid
    * `limitGetSubscriptions` (string, opcional): Número máximo de assinaturas a retornar (padrão: 10)
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Produtos**

<AccordionGroup>
  <Accordion title="stripe/create_product">
    **Descrição:** Cria um novo produto no seu catálogo Stripe.

    **Parâmetros:**

    * `productName` (string, obrigatório): Nome do produto
    * `description` (string, opcional): Descrição do produto
    * `metadataProduct` (objeto, opcional): Metadados adicionais do produto como pares chave-valor
  </Accordion>

  <Accordion title="stripe/get_product_by_id">
    **Descrição:** Recupera um produto específico pelo ID do produto Stripe.

    **Parâmetros:**

    * `productId` (string, obrigatório): O ID do produto Stripe a ser recuperado
  </Accordion>

  <Accordion title="stripe/get_products">
    **Descrição:** Recupera uma lista de produtos com filtragem opcional.

    **Parâmetros:**

    * `createdAfter` (string, opcional): Filtra produtos criados após esta data (timestamp Unix)
    * `createdBefore` (string, opcional): Filtra produtos criados antes desta data (timestamp Unix)
    * `limitGetProducts` (string, opcional): Número máximo de produtos a retornar (padrão: 10)
  </Accordion>
</AccordionGroup>

### **Operações Financeiras**

<AccordionGroup>
  <Accordion title="stripe/get_balance_transactions">
    **Descrição:** Recupera transações de saldo da sua conta Stripe.

    **Parâmetros:**

    * `balanceTransactionType` (string, opcional): Filtra por tipo de transação - Opções: charge, refund, payment, payment\_refund
    * `paginationParameters` (objeto, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor da página para paginação
  </Accordion>

  <Accordion title="stripe/get_plans">
    **Descrição:** Recupera planos de assinatura da sua conta Stripe.

    **Parâmetros:**

    * `isPlanActive` (boolean, opcional): Filtra por status do plano - true para planos ativos, false para inativos
    * `paginationParameters` (objeto, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor da página para paginação
  </Accordion>
</AccordionGroup>

## Exemplos de Uso

### Configuração Básica do Agente Stripe
```

---

## 스트리머블 HTTP 전송

**URL:** llms-txt#스트리머블-http-전송

**Contents:**
- 개요
- 주요 개념
- 스트리머블 HTTP를 통한 연결
  - 1. 완전히 관리되는 연결(추천)
  - 2. 수동 연결 라이프사이클
- 보안 고려사항

Source: https://docs.crewai.com/ko/mcp/streamable-http

유연한 스트리머블 HTTP 전송을 사용하여 CrewAI를 원격 MCP 서버에 연결하는 방법을 알아보세요.

Streamable HTTP 전송은 원격 MCP 서버에 연결할 수 있는 유연한 방법을 제공합니다. 이는 종종 HTTP를 기반으로 구축되며, 요청-응답 및 스트리밍을 포함한 다양한 통신 패턴을 지원할 수 있습니다. 때때로 더 넓은 HTTP 상호작용 내에서 서버-클라이언트 스트림을 위해 Server-Sent Events(SSE)를 활용하기도 합니다.

* **원격 서버**: 원격에 호스팅된 MCP 서버용으로 설계되었습니다.
* **유연성**: 단순 SSE보다 더 복잡한 상호작용 패턴을 지원할 수 있으며, 서버가 구현한 경우 양방향 통신도 가능할 수 있습니다.
* **`MCPServerAdapter` 구성**: MCP 통신을 위한 서버의 기본 URL을 제공하고, 전송 유형으로 `"streamable-http"`를 지정해야 합니다.

Streamable HTTP MCP 서버와의 연결 라이프사이클을 관리하는 주요 방법에는 두 가지가 있습니다:

### 1. 완전히 관리되는 연결(추천)

추천되는 방법은 Python 컨텍스트 매니저(`with` 문)을 사용하는 것으로, 연결의 설정과 해제를 자동으로 처리합니다.

**참고:** `"http://localhost:8001/mcp"`은 실제 사용 중인 Streamable HTTP MCP 서버의 URL로 교체해야 합니다.

보다 명시적인 제어가 필요한 시나리오에서는 `MCPServerAdapter` 연결을 직접 관리할 수 있습니다.

<Info>
  연결을 종료하고 리소스를 해제하려면 작업이 끝난 후 반드시 `mcp_server_adapter.stop()`을 호출하는 것이 **매우 중요**합니다. 이를 보장하는 가장 안전한 방법은 `try...finally` 블록을 사용하는 것입니다.
</Info>

Streamable HTTP 전송을 사용할 때는 일반적인 웹 보안 모범 사례가 매우 중요합니다:

* **HTTPS 사용**: 데이터 전송을 암호화하기 위해 항상 MCP 서버 URL에 HTTPS(HTTP Secure)를 사용하는 것이 좋습니다.
* **인증**: MCP 서버가 민감한 도구나 데이터를 노출하는 경우 강력한 인증 메커니즘을 구현하세요.
* **입력 검증**: MCP 서버가 모든 수신 요청과 매개변수를 반드시 검증하도록 하십시오.

MCP 통합 보안에 대한 종합적인 안내는 [보안 고려사항](./security.mdx) 페이지와 공식 [MCP 전송 보안 문서](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations)를 참고하시기 바랍니다.

**Examples:**

Example 1 (unknown):
```unknown
**참고:** `"http://localhost:8001/mcp"`은 실제 사용 중인 Streamable HTTP MCP 서버의 URL로 교체해야 합니다.

### 2. 수동 연결 라이프사이클

보다 명시적인 제어가 필요한 시나리오에서는 `MCPServerAdapter` 연결을 직접 관리할 수 있습니다.

<Info>
  연결을 종료하고 리소스를 해제하려면 작업이 끝난 후 반드시 `mcp_server_adapter.stop()`을 호출하는 것이 **매우 중요**합니다. 이를 보장하는 가장 안전한 방법은 `try...finally` 블록을 사용하는 것입니다.
</Info>
```

---

## Initialize the tool with a specific DOCX file,

**URL:** llms-txt#initialize-the-tool-with-a-specific-docx-file,

---

## Verify model availability

**URL:** llms-txt#verify-model-availability

from crewai.rag.embeddings.configurator import EmbeddingConfigurator

configurator = EmbeddingConfigurator()
try:
    embedder = configurator.configure_embedder({
        "provider": "ollama",
        "config": {"model": "mxbai-embed-large"}
    })
    print("Embedder configured successfully")
except Exception as e:
    print(f"Configuration error: {e}")
python  theme={null}
import os

**Examples:**

Example 1 (unknown):
```unknown
**API 키 문제:**
```

---

## 일반적인 JSON 내용 검색

**URL:** llms-txt#일반적인-json-내용-검색

---

## └── Another Agent Role/      # Another agent's collection

**URL:** llms-txt#└──-another-agent-role/------#-another-agent's-collection

**Contents:**
  - Exemplos Completos Funcionais

python  theme={null}
from crewai import Agent, Task, Crew
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

**Examples:**

Example 1 (unknown):
```unknown
### Exemplos Completos Funcionais

#### Exemplo 1: Knowledge Apenas do Agente
```

---

## MongoDB 벡터 검색 도구

**URL:** llms-txt#mongodb-벡터-검색-도구

Source: https://docs.crewai.com/ko/tools/database-data/mongodbvectorsearchtool

MongoDBVectorSearchTool은(는) 선택적인 인덱싱 도우미와 함께 MongoDB Atlas에서 벡터 검색을 수행합니다.

---

## so the agent can only scrap the content of the specified website

**URL:** llms-txt#so-the-agent-can-only-scrap-the-content-of-the-specified-website

tool = ScrapeWebsiteTool(website_url='https://www.example.com')

---

## 이 방법은 JSON 경로를 사전에 알고 있거나 동적으로 식별할 수 있을 때 적합합니다.

**URL:** llms-txt#이-방법은-json-경로를-사전에-알고-있거나-동적으로-식별할-수-있을-때-적합합니다.

tool = JSONSearchTool()

---

## This prevents naming conflicts between different MCP servers

**URL:** llms-txt#this-prevents-naming-conflicts-between-different-mcp-servers

**Contents:**
- Error Handling and Resilience
  - Graceful Server Failures

python  theme={null}
agent = Agent(
    role="Resilient Researcher",
    goal="Research despite server issues",
    backstory="Experienced researcher who adapts to available tools",
    mcps=[
        "https://primary-server.com/mcp",         # Primary data source
        "https://backup-server.com/mcp",          # Backup if primary fails
        "https://unreachable-server.com/mcp",     # Will be skipped with warning
        "crewai-amp:reliable-service"             # Reliable AMP service
    ]
)

**Examples:**

Example 1 (unknown):
```unknown
## Error Handling and Resilience

The MCP DSL is designed to be robust and user-friendly:

### Graceful Server Failures
```

---

## Get your Braintrust credentials

**URL:** llms-txt#get-your-braintrust-credentials

BRAINTRUST_API_KEY = getpass("🔑 Enter your Braintrust API Key: ")

---

## Hyperbrowser Load Tool

**URL:** llms-txt#hyperbrowser-load-tool

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/hyperbrowserloadtool

O `HyperbrowserLoadTool` permite realizar web scraping e crawling utilizando o Hyperbrowser.

---

## Inicie a ferramenta

**URL:** llms-txt#inicie-a-ferramenta

scrape_tool = ScrapeElementFromWebsiteTool()

---

## 리스너 인스턴스 생성

**URL:** llms-txt#리스너-인스턴스-생성

my_custom_listener = MyCustomListener()
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
3. `__init__.py`에서 리스너 인스턴스를 임포트하여 로드되도록 합니다:
```

---

## Tarefa para obter todos os sites

**URL:** llms-txt#tarefa-para-obter-todos-os-sites

get_sites_task = Task(
    description="Listar todos os sites do SharePoint aos quais tenho acesso.",
    agent=sharepoint_agent,
    expected_output="Uma lista de sites do SharePoint com seus nomes de exibição e URLs."
)

---

## `DOCXSearchTool`

**URL:** llms-txt#`docxsearchtool`

**Contents:**
- Descrição
- Instalação
- Exemplo

<Note>
  Ainda estamos trabalhando na melhoria das ferramentas, portanto pode haver comportamentos inesperados ou alterações no futuro.
</Note>

A `DOCXSearchTool` é uma ferramenta RAG desenvolvida para buscas semânticas dentro de documentos DOCX.
Ela permite que os usuários pesquisem e extraiam informações relevantes de arquivos DOCX de forma eficiente, utilizando buscas baseadas em consultas.
Esta ferramenta é inestimável para análise de dados, gestão da informação e tarefas de pesquisa,
otimizando o processo de encontrar informações específicas em grandes coleções de documentos.

Instale o pacote crewai\_tools executando o seguinte comando no seu terminal:

O exemplo a seguir demonstra a inicialização da DOCXSearchTool para buscar dentro do conteúdo de qualquer arquivo DOCX ou com o caminho de um arquivo DOCX específico.

```python Code theme={null}
from crewai_tools import DOCXSearchTool

**Examples:**

Example 1 (unknown):
```unknown
## Exemplo

O exemplo a seguir demonstra a inicialização da DOCXSearchTool para buscar dentro do conteúdo de qualquer arquivo DOCX ou com o caminho de um arquivo DOCX específico.
```

---

## Reset specific memory types

**URL:** llms-txt#reset-specific-memory-types

**Contents:**
  - 프로덕션 모범 사례
  - 일반적인 스토리지 문제

crew.reset_memories(command_type='short')     # 단기 메모리
crew.reset_memories(command_type='long')      # 장기 메모리
crew.reset_memories(command_type='entity')    # 엔티티 메모리
crew.reset_memories(command_type='knowledge') # 지식 스토리지
bash  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 프로덕션 모범 사례

1. \*\*`CREWAI_STORAGE_DIR`\*\*를 프로덕션 환경에서 제어가 쉬운 경로로 설정하세요.
2. **명시적인 임베딩 공급자**를 선택하여 LLM 설정과 일치시키세요.
3. **스토리지 디렉토리 크기를 모니터링**하여 대규모 배포에 대비하세요.
4. **스토리지 디렉토리**를 백업 전략에 포함하세요.
5. **적절한 파일 권한**을 설정하세요 (디렉토리는 0o755, 파일은 0o644).
6. **컨테이너화된 배포**를 위해 프로젝트 상대 경로를 사용하세요.

### 일반적인 스토리지 문제

**"ChromaDB permission denied" 오류:**
```

---

## Initialize the tool to search within any DOCX file's content

**URL:** llms-txt#initialize-the-tool-to-search-within-any-docx-file's-content

tool = DOCXSearchTool()

---

## Datadog Integration

**URL:** llms-txt#datadog-integration

Source: https://docs.crewai.com/en/observability/datadog

Learn how to integrate Datadog with CrewAI to submit LLM Observability traces to Datadog.

---

## `OxylabsGoogleSearchScraperTool`

**URL:** llms-txt#`oxylabsgooglesearchscrapertool`

**Contents:**
  - Exemplo

```python  theme={null}
from crewai_tools import OxylabsGoogleSearchScraperTool

---

## Armazenar no diretório do projeto

**URL:** llms-txt#armazenar-no-diretório-do-projeto

project_root = Path(__file__).parent
storage_dir = project_root / "crewai_storage"

os.environ["CREWAI_STORAGE_DIR"] = str(storage_dir)

---

## List knowledge collections and files

**URL:** llms-txt#list-knowledge-collections-and-files

**Contents:**
  - Controlando Localizações de Armazenamento de Knowledge

if os.path.exists(knowledge_path):
    print("\nKnowledge storage contents:")
    for item in os.listdir(knowledge_path):
        item_path = os.path.join(knowledge_path, item)
        if os.path.isdir(item_path):
            print(f"📁 Collection: {item}/")
            # Show collection contents
            try:
                for subitem in os.listdir(item_path):
                    print(f"   └── {subitem}")
            except PermissionError:
                print(f"   └── (permission denied)")
        else:
            print(f"📄 {item}")
else:
    print("No knowledge storage found yet.")
python  theme={null}
import os
from crewai import Crew

**Examples:**

Example 1 (unknown):
```unknown
### Controlando Localizações de Armazenamento de Knowledge

#### Opção 1: Variável de Ambiente (Recomendado)
```

---

## 특정 GitHub 저장소 내에서 시맨틱 검색을 위한 도구를 초기화하여, agent가 실행 중에 알게 된 어떤 저장소라도 검색할 수 있도록 함

**URL:** llms-txt#특정-github-저장소-내에서-시맨틱-검색을-위한-도구를-초기화하여,-agent가-실행-중에-알게-된-어떤-저장소라도-검색할-수-있도록-함

**Contents:**
- 인자
- 커스텀 모델 및 임베딩

tool = GithubSearchTool(
	gh_token='your_github_personal_access_token',
	content_types=['code', 'issue'] # 옵션: code, repo, pr, issue
)
python Code theme={null}
tool = GithubSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # 또는 google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # 또는 openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인자

* `github_repo` : 검색이 수행될 GitHub 저장소의 URL입니다. 이 필드는 필수이며, 검색 대상 저장소를 지정합니다.
* `gh_token` : 인증에 필요한 GitHub 개인 액세스 토큰(PAT)입니다. GitHub 계정의 설정 > 개발자 설정 > 개인 액세스 토큰에서 생성할 수 있습니다.
* `content_types` : 검색에 포함할 콘텐츠 유형을 지정합니다. 다음 옵션 중에서 콘텐츠 유형의 목록을 제공해야 합니다: 코드 내에서 검색하려면 `code`, 저장소의 일반 정보 내에서 검색하려면 `repo`, 풀 리퀘스트에서 검색하려면 `pr`, 이슈에서 검색하려면 `issue`.
  이 필드는 필수이며, GitHub 저장소 내에서 특정 콘텐츠 유형에 맞춰 검색을 조정할 수 있습니다.

## 커스텀 모델 및 임베딩

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 커스터마이징하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다.
```

---

## 에이전트에 도구 추가

**URL:** llms-txt#에이전트에-도구-추가

**Contents:**
- 에이전트 메모리와 컨텍스트
- 컨텍스트 윈도우 관리
  - 컨텍스트 윈도우 관리 방식
  - 자동 컨텍스트 처리 (`respect_context_window=True`)

researcher = Agent(
    role="AI Technology Researcher",
    goal="Research the latest AI developments",
    tools=[search_tool, wiki_tool],
    verbose=True
)
python Code theme={null}
from crewai import Agent

analyst = Agent(
    role="Data Analyst",
    goal="Analyze and remember complex data patterns",
    memory=True,  # Enable memory
    verbose=True
)
python Code theme={null}

**Examples:**

Example 1 (unknown):
```unknown
## 에이전트 메모리와 컨텍스트

에이전트는 상호작용의 메모리를 유지하고 이전 작업의 컨텍스트를 사용할 수 있습니다. 이는 여러 작업에 걸쳐 정보를 유지해야 하는 복잡한 워크플로우에서 특히 유용합니다.
```

Example 2 (unknown):
```unknown
<Note>
  `memory`가 활성화되면 에이전트는 여러 상호작용에 걸쳐 컨텍스트를 유지하게 되어, 복잡하고 여러 단계로 이루어진 작업을 처리하는 능력이 향상됩니다.
</Note>

## 컨텍스트 윈도우 관리

CrewAI는 대화가 언어 모델의 토큰 한도를 초과하는 상황을 처리하기 위해 정교한 자동 컨텍스트 윈도우 관리 기능을 포함하고 있습니다. 이 강력한 기능은 `respect_context_window` 매개변수로 제어됩니다.

### 컨텍스트 윈도우 관리 방식

에이전트의 대화 기록이 LLM의 컨텍스트 윈도우 크기를 초과할 경우, CrewAI는 이 상황을 자동으로 감지하고 다음 중 하나를 수행할 수 있습니다:

1. **자동으로 내용을 요약** ( `respect_context_window=True` 인 경우)
2. **오류와 함께 실행 중지** ( `respect_context_window=False` 인 경우)

### 자동 컨텍스트 처리 (`respect_context_window=True`)

이 설정은 대부분의 사용 사례에서 **기본값이자 권장 옵션**입니다. 활성화되면 CrewAI는 다음과 같이 동작합니다:
```

---

## CSV RAG Search

**URL:** llms-txt#csv-rag-search

Source: https://docs.crewai.com/en/tools/file-document/csvsearchtool

The `CSVSearchTool` is a powerful RAG (Retrieval-Augmented Generation) tool designed for semantic searches within a CSV file's content.

---

## Imprima o resultado bruto primeiro

**URL:** llms-txt#imprima-o-resultado-bruto-primeiro

print("Raw result:", result)

---

## Create a multimodal agent

**URL:** llms-txt#create-a-multimodal-agent

image_analyst = Agent(
    role="Product Analyst",
    goal="Analyze product images and provide detailed descriptions",
    backstory="Expert in visual product analysis with deep knowledge of design and features",
    multimodal=True
)

---

## Stagehand Tool

**URL:** llms-txt#stagehand-tool

Source: https://docs.crewai.com/en/tools/web-scraping/stagehandtool

Web automation tool that integrates Stagehand with CrewAI for browser interaction and automation

---

## 해당 사이트의 URL을 제공하세요:

**URL:** llms-txt#해당-사이트의-url을-제공하세요:

**Contents:**
- 인수
- 커스텀 모델 및 임베딩

tool = CodeDocsSearchTool(docs_url='https://docs.example.com/reference')
python Code theme={null}
tool = CodeDocsSearchTool(
    config=dict(
        llm=dict(
            provider="ollama", # or google, openai, anthropic, llama2, ...
            config=dict(
                model="llama2",
                # temperature=0.5,
                # top_p=1,
                # stream=true,
            ),
        ),
        embedder=dict(
            provider="google", # or openai, ollama, ...
            config=dict(
                model="models/embedding-001",
                task_type="retrieval_document",
                # title="Embeddings",
            ),
        ),
    )
)
```

**Examples:**

Example 1 (unknown):
```unknown
<Note>
  '[https://docs.example.com/reference'를](https://docs.example.com/reference'를) 원하는 문서 URL로,
  'How to use search tool'을 필요에 맞는 검색 쿼리로 대체하세요.
</Note>

## 인수

다음 매개변수들은 `CodeDocsSearchTool`의 동작을 사용자 지정하는 데 사용할 수 있습니다:

| 인수            | 타입       | 설명                                  |
| :------------ | :------- | :---------------------------------- |
| **docs\_url** | `string` | *선택 사항*. 검색할 코드 도큐멘테이션의 URL을 지정합니다. |

## 커스텀 모델 및 임베딩

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 커스터마이즈하려면 아래와 같이 config 딕셔너리를 사용할 수 있습니다.
```

---

## Integração com Slack

**URL:** llms-txt#integração-com-slack

**Contents:**
- Visão Geral
- Pré-requisitos
- Configurando a Integração Slack
  - 1. Conecte seu Workspace do Slack
  - 2. Instale o Pacote Necessário
  - 3. Configuração de variável de ambiente
- Ferramentas Disponíveis
  - **Gerenciamento de Usuários**
  - **Gerenciamento de Canais**
  - **Mensagens**

Source: https://docs.crewai.com/pt-BR/enterprise/integrations/slack

Comunicação e colaboração em equipe com a integração Slack para CrewAI.

Permita que seus agentes gerenciem a comunicação da equipe pelo Slack. Envie mensagens, pesquise conversas, gerencie canais e coordene as atividades do time para otimizar os fluxos de colaboração com automação impulsionada por IA.

Antes de usar a integração com o Slack, certifique-se de que você tenha:

* Uma conta [CrewAI AMP](https://app.crewai.com) com assinatura ativa
* Um workspace do Slack com permissões apropriadas
* Seu workspace do Slack conectado por meio da [página de Integrações](https://app.crewai.com/integrations)

## Configurando a Integração Slack

### 1. Conecte seu Workspace do Slack

1. Acesse [CrewAI AMP Integrações](https://app.crewai.com/crewai_plus/connectors)
2. Encontre **Slack** na seção Integrações de Autenticação
3. Clique em **Conectar** e complete o fluxo OAuth
4. Conceda as permissões necessárias para comunicação em equipe
5. Copie seu Token Enterprise em [Configurações de Integração](https://app.crewai.com/crewai_plus/settings/integrations)

### 2. Instale o Pacote Necessário

### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>

Ou adicione ao seu arquivo `.env`:

## Ferramentas Disponíveis

### **Gerenciamento de Usuários**

<AccordionGroup>
  <Accordion title="slack/list_members">
    **Descrição:** Lista todos os membros de um canal do Slack.

* Nenhum parâmetro necessário – recupera todos os membros do canal
  </Accordion>

<Accordion title="slack/get_user_by_email">
    **Descrição:** Encontre um usuário no seu workspace do Slack pelo endereço de e-mail.

* `email` (string, obrigatório): O endereço de e-mail de um usuário do workspace
  </Accordion>

<Accordion title="slack/get_users_by_name">
    **Descrição:** Pesquise usuários pelo nome ou nome de exibição.

* `name` (string, obrigatório): Nome real do usuário para a pesquisa
    * `displayName` (string, obrigatório): Nome de exibição do usuário para a pesquisa
    * `paginationParameters` (object, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor de página para paginação
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Canais**

<AccordionGroup>
  <Accordion title="slack/list_channels">
    **Descrição:** Lista todos os canais do seu workspace no Slack.

* Nenhum parâmetro necessário – recupera todos os canais acessíveis
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="slack/send_message">
    **Descrição:** Envie uma mensagem para um canal do Slack.

* `channel` (string, obrigatório): Nome ou ID do canal – Use as Configurações de Workflow do Connect Portal para que usuários selecionem o canal, ou insira o nome do canal para criar um novo
    * `message` (string, obrigatório): Texto da mensagem a ser enviada
    * `botName` (string, obrigatório): Nome do bot que enviará a mensagem
    * `botIcon` (string, obrigatório): Ícone do bot – Pode ser uma URL de imagem ou um emoji (ex.: ":dog:")
    * `blocks` (object, opcional): JSON do Slack Block Kit para mensagens ricas com anexos e elementos interativos
    * `authenticatedUser` (boolean, opcional): Se verdadeiro, a mensagem aparecerá como enviada pelo seu usuário autenticado do Slack ao invés do aplicativo (por padrão é falso)
  </Accordion>

<Accordion title="slack/send_direct_message">
    **Descrição:** Envie uma mensagem direta para um usuário específico no Slack.

* `memberId` (string, obrigatório): ID do usuário destinatário – Use as Configurações de Workflow do Connect Portal para que usuários selecionem um membro
    * `message` (string, obrigatório): Texto da mensagem a ser enviada
    * `botName` (string, obrigatório): Nome do bot que enviará a mensagem
    * `botIcon` (string, obrigatório): Ícone do bot – Pode ser uma URL de imagem ou um emoji (ex.: ":dog:")
    * `blocks` (object, opcional): JSON do Slack Block Kit para formatação rica com anexos e elementos interativos
    * `authenticatedUser` (boolean, opcional): Se verdadeiro, a mensagem aparecerá como enviada pelo seu usuário autenticado do Slack (padrão é falso)
  </Accordion>
</AccordionGroup>

### **Pesquisa & Descoberta**

<AccordionGroup>
  <Accordion title="slack/search_messages">
    **Descrição:** Procure por mensagens em todo o seu workspace do Slack.

* `query` (string, obrigatório): Consulta de pesquisa usando a sintaxe do Slack para encontrar mensagens que correspondam aos critérios especificados

**Exemplos de Consultas de Pesquisa:**

* `"project update"` – Busca mensagens contendo "project update"
    * `from:@john in:#general` – Busca mensagens do John no canal #general
    * `has:link after:2023-01-01` – Busca mensagens com links após 1º de janeiro de 2023
    * `in:@channel before:yesterday` – Busca mensagens em um canal específico antes de ontem
  </Accordion>
</AccordionGroup>

## Integração com Block Kit

O Block Kit do Slack permite criar mensagens ricas e interativas. Veja alguns exemplos de como usar o parâmetro `blocks`:

### Texto Simples com Anexo

### Formatação Rica com Seções

### Configuração Básica de Agente Slack

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
### 3. Configuração de variável de ambiente

<Note>
  Para usar integrações com `Agent(apps=[])`, você deve definir a variável de ambiente `CREWAI_PLATFORM_INTEGRATION_TOKEN` com seu Enterprise Token.
</Note>
```

Example 2 (unknown):
```unknown
Ou adicione ao seu arquivo `.env`:
```

Example 3 (unknown):
```unknown
## Ferramentas Disponíveis

### **Gerenciamento de Usuários**

<AccordionGroup>
  <Accordion title="slack/list_members">
    **Descrição:** Lista todos os membros de um canal do Slack.

    **Parâmetros:**

    * Nenhum parâmetro necessário – recupera todos os membros do canal
  </Accordion>

  <Accordion title="slack/get_user_by_email">
    **Descrição:** Encontre um usuário no seu workspace do Slack pelo endereço de e-mail.

    **Parâmetros:**

    * `email` (string, obrigatório): O endereço de e-mail de um usuário do workspace
  </Accordion>

  <Accordion title="slack/get_users_by_name">
    **Descrição:** Pesquise usuários pelo nome ou nome de exibição.

    **Parâmetros:**

    * `name` (string, obrigatório): Nome real do usuário para a pesquisa
    * `displayName` (string, obrigatório): Nome de exibição do usuário para a pesquisa
    * `paginationParameters` (object, opcional): Configurações de paginação
      * `pageCursor` (string, opcional): Cursor de página para paginação
  </Accordion>
</AccordionGroup>

### **Gerenciamento de Canais**

<AccordionGroup>
  <Accordion title="slack/list_channels">
    **Descrição:** Lista todos os canais do seu workspace no Slack.

    **Parâmetros:**

    * Nenhum parâmetro necessário – recupera todos os canais acessíveis
  </Accordion>
</AccordionGroup>

### **Mensagens**

<AccordionGroup>
  <Accordion title="slack/send_message">
    **Descrição:** Envie uma mensagem para um canal do Slack.

    **Parâmetros:**

    * `channel` (string, obrigatório): Nome ou ID do canal – Use as Configurações de Workflow do Connect Portal para que usuários selecionem o canal, ou insira o nome do canal para criar um novo
    * `message` (string, obrigatório): Texto da mensagem a ser enviada
    * `botName` (string, obrigatório): Nome do bot que enviará a mensagem
    * `botIcon` (string, obrigatório): Ícone do bot – Pode ser uma URL de imagem ou um emoji (ex.: ":dog:")
    * `blocks` (object, opcional): JSON do Slack Block Kit para mensagens ricas com anexos e elementos interativos
    * `authenticatedUser` (boolean, opcional): Se verdadeiro, a mensagem aparecerá como enviada pelo seu usuário autenticado do Slack ao invés do aplicativo (por padrão é falso)
  </Accordion>

  <Accordion title="slack/send_direct_message">
    **Descrição:** Envie uma mensagem direta para um usuário específico no Slack.

    **Parâmetros:**

    * `memberId` (string, obrigatório): ID do usuário destinatário – Use as Configurações de Workflow do Connect Portal para que usuários selecionem um membro
    * `message` (string, obrigatório): Texto da mensagem a ser enviada
    * `botName` (string, obrigatório): Nome do bot que enviará a mensagem
    * `botIcon` (string, obrigatório): Ícone do bot – Pode ser uma URL de imagem ou um emoji (ex.: ":dog:")
    * `blocks` (object, opcional): JSON do Slack Block Kit para formatação rica com anexos e elementos interativos
    * `authenticatedUser` (boolean, opcional): Se verdadeiro, a mensagem aparecerá como enviada pelo seu usuário autenticado do Slack (padrão é falso)
  </Accordion>
</AccordionGroup>

### **Pesquisa & Descoberta**

<AccordionGroup>
  <Accordion title="slack/search_messages">
    **Descrição:** Procure por mensagens em todo o seu workspace do Slack.

    **Parâmetros:**

    * `query` (string, obrigatório): Consulta de pesquisa usando a sintaxe do Slack para encontrar mensagens que correspondam aos critérios especificados

    **Exemplos de Consultas de Pesquisa:**

    * `"project update"` – Busca mensagens contendo "project update"
    * `from:@john in:#general` – Busca mensagens do John no canal #general
    * `has:link after:2023-01-01` – Busca mensagens com links após 1º de janeiro de 2023
    * `in:@channel before:yesterday` – Busca mensagens em um canal específico antes de ontem
  </Accordion>
</AccordionGroup>

## Integração com Block Kit

O Block Kit do Slack permite criar mensagens ricas e interativas. Veja alguns exemplos de como usar o parâmetro `blocks`:

### Texto Simples com Anexo
```

Example 4 (unknown):
```unknown
### Formatação Rica com Seções
```

---

## Scrape a website with markdown formatting

**URL:** llms-txt#scrape-a-website-with-markdown-formatting

**Contents:**
- Arguments
- Example with Parameters

result = tool.run(url="https://example.com", include_markdown=True)
python Code theme={null}
from crewai_tools import SerperScrapeWebsiteTool

tool = SerperScrapeWebsiteTool()

**Examples:**

Example 1 (unknown):
```unknown
## Arguments

The `SerperScrapeWebsiteTool` accepts the following arguments:

* **url**: Required. The URL of the website to scrape.
* **include\_markdown**: Optional. Whether to include markdown formatting in the scraped content. Defaults to `True`.

## Example with Parameters

Here is an example demonstrating how to use the tool with different parameters:
```

---

## Ferramenta de Raspagem de Sites Scrapfly

**URL:** llms-txt#ferramenta-de-raspagem-de-sites-scrapfly

Source: https://docs.crewai.com/pt-BR/tools/web-scraping/scrapflyscrapetool

A `ScrapflyScrapeWebsiteTool` aproveita a API de web scraping da Scrapfly para extrair conteúdo de sites em diversos formatos.

---

## Stdio 전송

**URL:** llms-txt#stdio-전송

**Contents:**
- 개요
- 주요 개념
- Stdio를 통한 연결
  - 1. 완전 관리형 연결(권장)

Source: https://docs.crewai.com/ko/mcp/stdio

Stdio(표준 입력/출력) 전송 메커니즘을 사용하여 CrewAI를 로컬 MCP 서버에 연결하는 방법을 알아보세요.

Stdio(표준 입력/출력) 트랜스포트는 `MCPServerAdapter`를 로컬 MCP 서버에 연결하기 위해 설계되었습니다. 이 MCP 서버는 표준 입력 및 출력 스트림을 통해 통신합니다. 이는 일반적으로 MCP 서버가 CrewAI 애플리케이션과 동일한 머신에서 실행되는 스크립트나 실행 파일일 때 사용됩니다.

* **로컬 실행**: Stdio 전송은 MCP 서버를 위한 로컬에서 실행 중인 프로세스를 관리합니다.
* **`StdioServerParameters`**: `mcp` 라이브러리의 이 클래스는 Stdio 서버를 실행하기 위한 명령어, 인수, 환경 변수를 구성하는 데 사용됩니다.

연결 수명 주기를 관리하기 위한 두 가지 주요 접근 방식으로 Stdio 기반 MCP 서버에 연결할 수 있습니다.

Python 컨텍스트 관리자(`with` 문)를 사용하는 것이 권장되는 방법입니다. 이 방식은 MCP 서버 프로세스의 시작과 컨텍스트 종료 시 자동 종료를 처리합니다.

```python  theme={null}
from crewai import Agent, Task, Crew, Process
from crewai_tools import MCPServerAdapter
from mcp import StdioServerParameters
import os

---

## `LlamaIndexTool`

**URL:** llms-txt#`llamaindextool`

**Contents:**
- Descrição
- Instalação
- Passos para Começar
- Exemplo
  - A partir de uma ferramenta do LlamaIndex

A `LlamaIndexTool` foi projetada para ser um wrapper geral em torno das ferramentas e mecanismos de consulta do LlamaIndex, permitindo que você aproveite os recursos do LlamaIndex em pipelines de RAG/agent como ferramentas que podem ser acopladas aos agentes do CrewAI. Essa ferramenta permite integrar de forma transparente as poderosas capacidades de processamento e recuperação de dados do LlamaIndex em seus fluxos de trabalho com o CrewAI.

Para utilizar esta ferramenta, é necessário instalar o LlamaIndex:

## Passos para Começar

Para utilizar a `LlamaIndexTool` de forma eficaz, siga os passos abaixo:

1. **Instale o LlamaIndex**: Instale o pacote LlamaIndex usando o comando acima.
2. **Configure o LlamaIndex**: Siga a [documentação do LlamaIndex](https://docs.llamaindex.ai/) para configurar um pipeline de RAG/agent.
3. **Crie uma Ferramenta ou Mecanismo de Consulta**: Crie uma ferramenta ou mecanismo de consulta do LlamaIndex que você deseja usar com o CrewAI.

Os exemplos a seguir demonstram como inicializar a ferramenta a partir de diferentes componentes do LlamaIndex:

### A partir de uma ferramenta do LlamaIndex

```python Code theme={null}
from crewai_tools import LlamaIndexTool
from crewai import Agent
from llama_index.core.tools import FunctionTool

**Examples:**

Example 1 (unknown):
```unknown
## Passos para Começar

Para utilizar a `LlamaIndexTool` de forma eficaz, siga os passos abaixo:

1. **Instale o LlamaIndex**: Instale o pacote LlamaIndex usando o comando acima.
2. **Configure o LlamaIndex**: Siga a [documentação do LlamaIndex](https://docs.llamaindex.ai/) para configurar um pipeline de RAG/agent.
3. **Crie uma Ferramenta ou Mecanismo de Consulta**: Crie uma ferramenta ou mecanismo de consulta do LlamaIndex que você deseja usar com o CrewAI.

## Exemplo

Os exemplos a seguir demonstram como inicializar a ferramenta a partir de diferentes componentes do LlamaIndex:

### A partir de uma ferramenta do LlamaIndex
```

---

## Armazene dados sensíveis em variáveis de ambiente

**URL:** llms-txt#armazene-dados-sensíveis-em-variáveis-de-ambiente

**Contents:**
  - Segurança no Armazenamento

crew = Crew(
    memory=True,
    embedder={
        "provider": "openai",
        "config": {
            "api_key": os.getenv("OPENAI_API_KEY"),
            "model": "text-embedding-3-small"
        }
    }
)
python  theme={null}
import os
from crewai import Crew
from crewai.memory import LongTermMemory
from crewai.memory.storage.ltm_sqlite_storage import LTMSQLiteStorage

**Examples:**

Example 1 (unknown):
```unknown
### Segurança no Armazenamento
```

---

## Defina as variáveis de ambiente

**URL:** llms-txt#defina-as-variáveis-de-ambiente

**Contents:**
  - Passo 3: Inicialize o OpenTelemetry com o Phoenix
  - Passo 4: Crie uma Aplicação CrewAI

os.environ["PHOENIX_CLIENT_HEADERS"] = f"api_key={PHOENIX_API_KEY}"
os.environ["PHOENIX_COLLECTOR_ENDPOINT"] = "https://app.phoenix.arize.com" # Phoenix Cloud, altere para seu endpoint se estiver utilizando uma instância self-hosted
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
os.environ["SERPER_API_KEY"] = SERPER_API_KEY
python  theme={null}
from phoenix.otel import register

tracer_provider = register(
    project_name="crewai-tracing-demo",
    auto_instrument=True,
)
python  theme={null}
from crewai import Agent, Crew, Process, Task
from crewai_tools import SerperDevTool
from openinference.instrumentation.crewai import CrewAIInstrumentor
from phoenix.otel import register

**Examples:**

Example 1 (unknown):
```unknown
### Passo 3: Inicialize o OpenTelemetry com o Phoenix

Inicialize o SDK de instrumentação OpenTelemetry do OpenInference para começar a capturar rastros e enviá-los ao Phoenix.
```

Example 2 (unknown):
```unknown
### Passo 4: Crie uma Aplicação CrewAI

Vamos criar uma aplicação CrewAI em que dois agentes colaboram para pesquisar e escrever um post de blog sobre avanços em IA.
```

---

## 4. Not crash or hang on server failures

**URL:** llms-txt#4.-not-crash-or-hang-on-server-failures

**Contents:**
  - Timeout Protection

**Examples:**

Example 1 (unknown):
```unknown
### Timeout Protection

All MCP operations have built-in timeouts:

* **Connection timeout**: 10 seconds
* **Tool execution timeout**: 30 seconds
* **Discovery timeout**: 15 seconds
```

---

## Create a deterministic fingerprint using a seed string

**URL:** llms-txt#create-a-deterministic-fingerprint-using-a-seed-string

deterministic_fingerprint = Fingerprint.generate(seed="my-agent-id")

---

## 실제 payload로 OneDrive 트리거 시뮬레이션

**URL:** llms-txt#실제-payload로-onedrive-트리거-시뮬레이션

**Contents:**
- Troubleshooting

crewai triggers run microsoft_onedrive/file_changed
```

`crewai triggers run` 명령은 완전한 OneDrive payload로 크루를 실행하여 배포 전에 파싱 로직을 테스트할 수 있게 해줍니다.

<Warning>
  개발 중에는 `crewai triggers run microsoft_onedrive/file_changed`를 사용하세요 (`crewai run`이 아님). 배포 후에는 크루가 자동으로 트리거 payload를 받습니다.
</Warning>

* Ensure the connected account has permission to read the file metadata included in the webhook
* `crewai triggers run microsoft_onedrive/file_changed`로 로컬 테스트하여 정확한 payload 구조를 확인하세요
* If the trigger fires but the payload is missing `permissions`, confirm the site-level sharing settings allow Graph to return this field
* For large tenants, filter notifications upstream so the crew only runs on relevant directories
* 주의: 트리거 실행을 시뮬레이션하려면 `crewai triggers run`을 사용하세요 (`crewai run`이 아님)

---

## Inicialize a ferramenta com um arquivo CSV específico.

**URL:** llms-txt#inicialize-a-ferramenta-com-um-arquivo-csv-específico.

---

## 도구 개요

**URL:** llms-txt#도구-개요

**Contents:**
- **도구 카테고리**
- **빠른 접근**
- **시작하기**

Source: https://docs.crewai.com/ko/tools/overview

CrewAI의 AI 에이전트를 강화하는 40개 이상의 방대한 도구 라이브러리를 확인해보세요

CrewAI는 에이전트의 기능을 향상시키기 위한 다양한 사전 구축 도구 라이브러리를 제공합니다. 파일 처리부터 웹 스크래핑, 데이터베이스 쿼리, AI 서비스에 이르기까지 모두 지원합니다.

<CardGroup cols={2}>
  <Card title="파일 & 문서" icon="folder-open" href="/ko/tools/file-document/overview" color="#3B82F6">
    PDF, DOCX, JSON, CSV 등 다양한 파일 형식을 읽고, 작성하고, 검색할 수 있습니다. 문서 처리 워크플로우에 적합합니다.
  </Card>

<Card title="웹 스크래핑 & 브라우징" icon="globe" href="/ko/tools/web-scraping/overview" color="#10B981">
    웹사이트에서 데이터를 추출하고, 브라우저 상호작용을 자동화하며, Firecrawl, Selenium 등과 같은 도구로 대규모로 콘텐츠를 스크래핑할 수 있습니다.
  </Card>

<Card title="검색 & 리서치" icon="magnifying-glass" href="/ko/tools/search-research/overview" color="#F59E0B">
    웹 검색을 수행하고, 코드 저장소를 찾으며, YouTube 콘텐츠를 리서치하고, 인터넷 전반에 걸쳐 정보를 탐색할 수 있습니다.
  </Card>

<Card title="데이터베이스 & 데이터" icon="database" href="/ko/tools/database-data/overview" color="#8B5CF6">
    SQL 데이터베이스, 벡터 스토어, 데이터 웨어하우스에 연결합니다. MySQL, PostgreSQL, Snowflake, Qdrant, Weaviate를 쿼리할 수 있습니다.
  </Card>

<Card title="AI & 머신러닝" icon="brain" href="/ko/tools/ai-ml/overview" color="#EF4444">
    DALL-E로 이미지 생성, 비전 태스크 처리, LangChain과의 통합, RAG 시스템 구축, 코드 인터프리터 활용 등이 가능합니다.
  </Card>

<Card title="클라우드 & 스토리지" icon="cloud" href="/ko/tools/cloud-storage/overview" color="#06B6D4">
    AWS S3, Amazon Bedrock 및 기타 클라우드 스토리지 및 AI 서비스 등 클라우드 서비스와 상호작용할 수 있습니다.
  </Card>

<Card title="자동화" icon="bolt" href="/ko/tools/automation/overview" color="#84CC16">
    Apify, Composio 등과 함께 워크플로우를 자동화하고 에이전트를 외부 서비스와 연결하세요.
  </Card>

<Card title="통합" icon="plug" href="/ko/tools/tool-integrations/overview" color="#0891B2">
    Amazon Bedrock 및 CrewAI Automation 툴킷 등 외부 시스템과 CrewAI를 통합합니다.
  </Card>
</CardGroup>

특정 도구가 필요하신가요? 인기 있는 옵션들을 소개합니다:

<CardGroup cols={3}>
  <Card title="RAG Tool" icon="image" href="/ko/tools/ai-ml/ragtool">
    검색 기반 생성(Retrieval-Augmented Generation) 구현
  </Card>

<Card title="Serper Dev" icon="book-atlas" href="/ko/tools/search-research/serperdevtool">
    구글 검색 API
  </Card>

<Card title="File Read" icon="file" href="/ko/tools/file-document/filereadtool">
    모든 파일 유형 읽기
  </Card>

<Card title="Scrape Website" icon="globe" href="/ko/tools/web-scraping/scrapewebsitetool">
    웹 콘텐츠 추출
  </Card>

<Card title="Code Interpreter" icon="code" href="/ko/tools/ai-ml/codeinterpretertool">
    Python 코드 실행
  </Card>

<Card title="S3 Reader" icon="cloud" href="/ko/tools/cloud-storage/s3readertool">
    AWS S3 파일 액세스
  </Card>
</CardGroup>

CrewAI 프로젝트에서 어떤 도구를 사용하려면:

1. **도구를 임포트**하여 crew 설정에 추가합니다.
2. **에이전트의 tool 목록**에 추가합니다.
3. 필요한 **API 키 또는 설정을 구성**합니다.

```python  theme={null}
from crewai_tools import FileReadTool, SerperDevTool

---

## Instead of modifying lists in place:

**URL:** llms-txt#instead-of-modifying-lists-in-place:

self.state.items.append(new_item)  # Mutable operation

---

## Exemplo de estrutura de resultado da proteção

**URL:** llms-txt#exemplo-de-estrutura-de-resultado-da-proteção

**Contents:**
  - Propriedades do Resultado
- Integração com o Sistema de Tarefas
  - Validação Automática

{
    "valid": False,
    "feedback": "Content appears to be hallucinated (score: 4.2/10, verdict: HALLUCINATED). The output contains information not supported by the provided context."
}
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### Propriedades do Resultado

* **valid**: Booleano indicando se a saída passou na validação
* **feedback**: Explicação detalhada quando a validação falha, incluindo:
  * Pontuação de fidelidade
  * Classificação do veredito
  * Motivos específicos para a falha

## Integração com o Sistema de Tarefas

### Validação Automática

Quando uma proteção é adicionada à tarefa, ela valida automaticamente a saída antes da tarefa ser marcada como concluída:
```

---

## Você pode customizar facilmente para combinar com seu provedor preferido

**URL:** llms-txt#você-pode-customizar-facilmente-para-combinar-com-seu-provedor-preferido

python  theme={null}
from crewai import Crew

**Examples:**

Example 1 (unknown):
```unknown
#### Personalizando Provedores de Embedding
```

---

## Weave Integration

**URL:** llms-txt#weave-integration

Source: https://docs.crewai.com/en/observability/weave

Learn how to use Weights & Biases (W&B) Weave to track, experiment with, evaluate, and improve your CrewAI applications.

---

## String UUID - identificador único (gerado automaticamente)

**URL:** llms-txt#string-uuid---identificador-único-(gerado-automaticamente)

uuid_str = fingerprint.uuid_str  # e.g., "123e4567-e89b-12d3-a456-426614174000"

---

## 모든 상품 정보 추출

**URL:** llms-txt#모든-상품-정보-추출

result = stagehand_tool.run(
    instruction="Extract all product names, prices, and descriptions", 
    url="https://example.com/products",
    command_type="extract"
)

---

## Create the prompt generator

**URL:** llms-txt#create-the-prompt-generator

prompt_generator = Prompts(
    agent=agent,
    has_tools=len(agent.tools) > 0,
    use_system_prompt=agent.use_system_prompt
)

---

## Create comprehensive research task

**URL:** llms-txt#create-comprehensive-research-task

research_task = Task(
    description="""Research the impact of AI agents on business productivity.
    Include current weather impacts on remote work, financial market trends,
    and recent academic publications on AI agent frameworks.""",
    expected_output="""Comprehensive report covering:
    1. AI agent business impact analysis
    2. Weather considerations for remote work
    3. Financial market trends related to AI
    4. Academic research citations and insights
    5. Competitive landscape analysis""",
    agent=multi_source_agent
)

---

## Create an agent focused on text editing

**URL:** llms-txt#create-an-agent-focused-on-text-editing

text_editor = Agent(
    role="Document Editor",
    goal="Edit and update content in Google Docs documents",
    backstory="An AI assistant skilled in precise text editing and content management.",
    apps=['google_docs/insert_text', 'google_docs/replace_text', 'google_docs/delete_content_range']
)

---

## Define the manager agent

**URL:** llms-txt#define-the-manager-agent

manager = Agent(
    role="Project Manager",
    goal="Efficiently manage the crew and ensure high-quality task completion",
    backstory="You're an experienced project manager, skilled in overseeing complex projects and guiding teams to success. Your role is to coordinate the efforts of the crew members, ensuring that each task is completed on time and to the highest standard.",
    allow_delegation=True,
)

---

## Create the Atlas Vector Search index (e.g., 3072 dims for text-embedding-3-large)

**URL:** llms-txt#create-the-atlas-vector-search-index-(e.g.,-3072-dims-for-text-embedding-3-large)

**Contents:**
- Example

tool.create_vector_search_index(dimensions=3072)
python Code theme={null}
from crewai import Agent, Task, Crew
from crewai_tools import MongoDBVectorSearchTool

tool = MongoDBVectorSearchTool(
    connection_string="mongodb+srv://...",
    database_name="mydb",
    collection_name="docs",
)

agent = Agent(
    role="RAG Agent",
    goal="Answer using MongoDB vector search",
    backstory="Knowledge retrieval specialist",
    tools=[tool],
    verbose=True,
)

task = Task(
    description="Find relevant content for 'indexing guidance'",
    expected_output="A concise answer citing the most relevant matches",
    agent=agent,
)

crew = Crew(
    agents=[agent],
    tasks=[task],
    verbose=True,
)

result = crew.kickoff()
```

**Examples:**

Example 1 (unknown):
```unknown
## Example
```

---

## Define your agent

**URL:** llms-txt#define-your-agent

researcher = Agent(
    role="Research Specialist",
    goal="Research topics thoroughly",
    backstory="Expert researcher with skills in finding information",
    llm=create_llm("openai/gpt-4o"), # Replace with the model you want to use
    verbose=True
)

---

## Configurar modelo personalizado para vetorizador e modelo generativo

**URL:** llms-txt#configurar-modelo-personalizado-para-vetorizador-e-modelo-generativo

**Contents:**
- Pré-carregando Documentos

tool = WeaviateVectorSearchTool(
    collection_name='example_collections',
    limit=3,
    vectorizer=Configure.Vectorizer.text2vec_openai(model="nomic-embed-text"),
    generative_model=Configure.Generative.openai(model="gpt-4o-mini"),
    weaviate_cluster_url="https://your-weaviate-cluster-url.com",
    weaviate_api_key="your-weaviate-api-key",
)
python Code theme={null}
import os
from crewai_tools import WeaviateVectorSearchTool
import weaviate
from weaviate.classes.init import Auth

**Examples:**

Example 1 (unknown):
```unknown
## Pré-carregando Documentos

Você pode pré-carregar seu banco de dados Weaviate com documentos antes de utilizar a ferramenta:
```

---

## Tarefa para listar arquivos e criar pasta

**URL:** llms-txt#tarefa-para-listar-arquivos-e-criar-pasta

organize_files_task = Task(
    description="Listar todos os arquivos no diretório raiz do meu OneDrive e criar uma nova pasta chamada 'Documentos do Projeto'.",
    agent=onedrive_agent,
    expected_output="Lista de arquivos exibida e nova pasta 'Documentos do Projeto' criada."
)

---

## Crie um agente com capacidades do Google Docs

**URL:** llms-txt#crie-um-agente-com-capacidades-do-google-docs

docs_agent = Agent(
    role="Criador de Documentos",
    goal="Criar e gerenciar documentos do Google Docs de forma eficiente",
    backstory="Um assistente IA especializado em criação e edição de documentos do Google Docs.",
    apps=['google_docs']  # Todas as ações do Google Docs estarão disponíveis
)

---

## Defina um agente que usa a ferramenta

**URL:** llms-txt#defina-um-agente-que-usa-a-ferramenta

video_researcher = Agent(
    role="Video Researcher",
    goal="Extract and analyze information from YouTube videos",
    backstory="""You are an expert video researcher who specializes in extracting 
    and analyzing information from YouTube videos. You have a keen eye for detail 
    and can quickly identify key points and insights from video content.""",
    tools=[youtube_search_tool],
    verbose=True,
)

---

## Opção 1: Acessando propriedades via indexação de dicionário

**URL:** llms-txt#opção-1:-acessando-propriedades-via-indexação-de-dicionário

print("Acessando propriedades - Opção 1")
title = result["title"]
content = result["content"]
print("Título:", title)
print("Conteúdo:", content)

---

## Snowflake Search Tool

**URL:** llms-txt#snowflake-search-tool

Source: https://docs.crewai.com/pt-BR/tools/database-data/snowflakesearchtool

O `SnowflakeSearchTool` permite que agentes CrewAI executem consultas SQL e realizem buscas semânticas em data warehouses Snowflake.

---

## ✅ Use o parâmetro context para dependências entre tarefas

**URL:** llms-txt#✅-use-o-parâmetro-context-para-dependências-entre-tarefas

**Contents:**
  - 4. **Descrições Claras de Tarefas**

writing_task = Task(
    description="Write article based on research",
    agent=writer,
    context=[research_task],  # Shares research results
    ...
)
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
### 4. **Descrições Claras de Tarefas**
```

---

## 에이전트가 지정한 디렉터리의 내용만 읽을 수 있도록 합니다.

**URL:** llms-txt#에이전트가-지정한-디렉터리의-내용만-읽을-수-있도록-합니다.

**Contents:**
- 인수

tool = DirectoryReadTool(directory='/path/to/your/directory')
```

다음 매개변수들은 `DirectoryReadTool`의 동작을 사용자 정의하는 데 사용할 수 있습니다:

| 인수            | 타입       | 설명                                                                                            |
| :------------ | :------- | :-------------------------------------------------------------------------------------------- |
| **directory** | `string` | *선택 사항*. 나열하려는 디렉터리의 경로를 지정하는 인수입니다. 절대 경로와 상대 경로 모두 허용하며, 원하는 디렉터리로 도구를 안내하여 내용을 나열할 수 있습니다. |

---

## para pesquisar em quaisquer sites descobertos

**URL:** llms-txt#para-pesquisar-em-quaisquer-sites-descobertos

tool = WebsiteSearchTool()

---

## 특정 PDF 경로로 도구를 초기화하여 해당 문서 내에서만 검색합니다.

**URL:** llms-txt#특정-pdf-경로로-도구를-초기화하여-해당-문서-내에서만-검색합니다.

**Contents:**
- 인수
- 커스텀 모델 및 임베딩

tool = PDFSearchTool(pdf='path/to/your/document.pdf')
python Code theme={null}
from crewai_tools import PDFSearchTool
from chromadb.config import Settings  # Chroma 영속성 설정

tool = PDFSearchTool(
    config={
        # 필수: 임베딩 제공자와 설정
        "embedding_model": {
            # 사용 가능 공급자: "openai", "azure", "google-generativeai", "google-vertex",
            # "voyageai", "cohere", "huggingface", "jina", "sentence-transformer",
            # "text2vec", "ollama", "openclip", "instructor", "onnx", "roboflow", "watsonx", "custom"
            "provider": "openai",
            "config": {
                # "model" 키는 내부적으로 "model_name"으로 매핑됩니다.
                "model": "text-embedding-3-small",
                # 선택: API 키 (미설정 시 환경변수 사용)
                # "api_key": "sk-...",

# 공급자별 예시
                # --- Google ---
                # (provider를 "google-generativeai"로 설정)
                # "model": "models/embedding-001",
                # "task_type": "retrieval_document",

# --- Cohere ---
                # (provider를 "cohere"로 설정)
                # "model": "embed-english-v3.0",

# --- Ollama(로컬) ---
                # (provider를 "ollama"로 설정)
                # "model": "nomic-embed-text",
            },
        },

# 필수: 벡터DB 설정
        "vectordb": {
            "provider": "chromadb",  # 또는 "qdrant"
            "config": {
                # Chroma 설정 예시
                # "settings": Settings(
                #     persist_directory="/content/chroma",
                #     allow_reset=True,
                #     is_persistent=True,
                # ),

# Qdrant 설정 예시
                # from qdrant_client.models import VectorParams, Distance
                # "vectors_config": VectorParams(size=384, distance=Distance.COSINE),

# 참고: 컬렉션 이름은 도구에서 관리합니다(기본값: "rag_tool_collection").
            }
        },
    }
)
```

**Examples:**

Example 1 (unknown):
```unknown
## 인수

* `pdf`: **선택 사항** 검색할 PDF 경로입니다. 초기화 시 또는 `run` 메서드의 인수로 제공할 수 있습니다. 초기화 시 제공되면, 도구는 지정된 문서로 검색 범위를 제한합니다.

## 커스텀 모델 및 임베딩

기본적으로 이 도구는 임베딩과 요약 모두에 OpenAI를 사용합니다. 모델을 커스터마이즈하려면 다음과 같이 config 딕셔너리를 사용할 수 있습니다. 참고: 임베딩은 벡터DB에 저장되어야 하므로 vectordb 설정이 필요합니다.
```

---

## Custom LLM Implementation

**URL:** llms-txt#custom-llm-implementation

**Contents:**
- Overview
- Quick Start
- Using Your Custom LLM

Source: https://docs.crewai.com/en/learn/custom-llm

Learn how to create custom LLM implementations in CrewAI.

CrewAI supports custom LLM implementations through the `BaseLLM` abstract base class. This allows you to integrate any LLM provider that doesn't have built-in support in LiteLLM, or implement custom authentication mechanisms.

Here's a minimal custom LLM implementation:

## Using Your Custom LLM

```python  theme={null}
from crewai import Agent, Task, Crew

**Examples:**

Example 1 (unknown):
```unknown
## Using Your Custom LLM
```

---

## Create a task that includes error handling instructions

**URL:** llms-txt#create-a-task-that-includes-error-handling-instructions

**Contents:**
- Limitações de Taxa
- Detalhes de Implementação
- Conclusão

robust_extract_task = Task(
    description="""
    Extract the main heading from example.com.
    Be aware that you might encounter errors such as:
    - Invalid URL format
    - Missing API key
    - Rate limit exceeded
    - Network or API errors
    
    If you encounter any errors, provide a clear explanation of what went wrong
    and suggest possible solutions.
    """,
    expected_output="Either the extracted heading or a clear error explanation",
    agent=web_scraper_agent,
)
python Code theme={null}
class ScrapegraphScrapeTool(BaseTool):
    """
    A tool that uses Scrapegraph AI to intelligently scrape website content.
    """
    
    # Implementation details...
    
    def _run(self, **kwargs: Any) -> Any:
        website_url = kwargs.get("website_url", self.website_url)
        user_prompt = (
            kwargs.get("user_prompt", self.user_prompt)
            or "Extract the main content of the webpage"
        )

if not website_url:
            raise ValueError("website_url is required")

# Validate URL format
        self._validate_url(website_url)

try:
            # Make the SmartScraper request
            response = self._client.smartscraper(
                website_url=website_url,
                user_prompt=user_prompt,
            )

return response
        # Error handling...
```

A `ScrapegraphScrapeTool` oferece uma maneira poderosa de extrair conteúdo de sites utilizando o entendimento do formato das páginas pela IA. Ao permitir que os agentes direcionem informações específicas por meio de prompts em linguagem natural, ela torna tarefas de web scraping mais eficientes e focadas. Esta ferramenta é especialmente útil para extração de dados, monitoramento de conteúdo e pesquisas em que informações específicas precisam ser extraídas de páginas web.

**Examples:**

Example 1 (unknown):
```unknown
## Limitações de Taxa

A API do Scrapegraph possui limites de requisição que variam conforme o seu plano de assinatura. Considere as seguintes boas práticas:

* Implemente atrasos apropriados entre requisições ao processar múltiplas URLs.
* Trate erros de limite de requisição de forma apropriada em sua aplicação.
* Verifique os limites do seu plano de API no painel do Scrapegraph.

## Detalhes de Implementação

A `ScrapegraphScrapeTool` utiliza o cliente Python do Scrapegraph para se comunicar com a API SmartScraper:
```

---

## Define templates for system, user (prompt), and assistant (response) messages

**URL:** llms-txt#define-templates-for-system,-user-(prompt),-and-assistant-(response)-messages

system_template = """<|begin_of_text|><|start_header_id|>system<|end_header_id|>{{ .System }}<|eot_id|>"""
prompt_template = """<|start_header_id|>user<|end_header_id|>{{ .Prompt }}<|eot_id|>"""
response_template = """<|start_header_id|>assistant<|end_header_id|>{{ .Response }}<|eot_id|>"""

---

## Fix storage permissions

**URL:** llms-txt#fix-storage-permissions

chmod -R 755 ~/.local/share/CrewAI/
python  theme={null}

**Examples:**

Example 1 (unknown):
```unknown
**Knowledge não persistindo entre execuções:**
```

---

## File Write

**URL:** llms-txt#file-write

Source: https://docs.crewai.com/en/tools/file-document/filewritetool

The `FileWriterTool` is designed to write content to files.

---

## conforme aprendem seus caminhos durante a execução

**URL:** llms-txt#conforme-aprendem-seus-caminhos-durante-a-execução

tool = XMLSearchTool()

---

## YouTube Channel RAG Search

**URL:** llms-txt#youtube-channel-rag-search

Source: https://docs.crewai.com/en/tools/search-research/youtubechannelsearchtool

The `YoutubeChannelSearchTool` is designed to perform a RAG (Retrieval-Augmented Generation) search within the content of a Youtube channel.

---

## 자동화

**URL:** llms-txt#자동화

**Contents:**
- 개요
- 배포 방법
  - GitHub로 배포
  - ZIP으로 배포
- 자동화 대시보드
- 모범 사례
- 관련 문서

Source: https://docs.crewai.com/ko/enterprise/features/automations

배포된 크루(자동화)를 한 곳에서 관리, 배포 및 모니터링하세요.

자동화는 배포된 크루를 운영하는 허브입니다. GitHub 또는 ZIP으로 배포하고, 환경 변수를 관리하고, 필요 시 재배포하며 각 자동화의 상태를 모니터링하세요.

<Frame>
    <img src="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=a7d0655da82c70b0ca152715cb8253f4" alt="자동화 개요" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/automations-overview.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=280&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=18456289664a18d4b83b2acdae616a44 280w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=560&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=4737cb32db15d7f121a1366ae5c80c0e 560w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=840&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=69473aff76b3ea16974be8226590d114 840w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=1100&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=a742c3a1f81537f0a2d9668e5671c1aa 1100w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=1650&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=6a9aed77a2491e2dc3da8f511f391487 1650w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-overview.png?w=2500&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=c64e992c5464916085b9114abab0d7c0 2500w" />
</Frame>

버전 관리 및 지속적 배포에 적합합니다.

<Steps>
  <Step title="GitHub 연결">
    <b>Configure GitHub</b>를 클릭하고 접근을 승인합니다.
  </Step>

<Step title="리포지토리 & 브랜치 선택">
    배포할 <b>리포지토리</b>와 <b>브랜치</b>를 선택합니다.
  </Step>

<Step title="자동 배포 활성화(선택)">
    <b>Automatically deploy new commits</b>를 켜면 푸시 시마다 자동 배포됩니다.
  </Step>

<Step title="환경 변수 추가">
    개별로 추가하거나 <b>Bulk View</b>를 사용해 여러 변수를 한 번에 추가합니다.
  </Step>

<Step title="배포">
    <b>Deploy</b>를 클릭해 라이브 자동화를 생성합니다.
  </Step>
</Steps>

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=4fb72dc68799d5a0c35e2e74f1a7cc6c" alt="GitHub 배포" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/deploy-from-github.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b15575b0b30c64e8b7a20de9e97468e5 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=c041da5b5b79d38cb2a3f8d6f00e14a7 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=0783c12a6f83d09ce83e66aa34edcacd 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=d703da835283f7e73079ef66f664587c 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=f73b6afc4c3c3075ded4da6559676fa3 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-github.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=c3d82425923c1f57264b7cb5af9004b3 2500w" />
</Frame>

Git 없이 빠르게 배포 — 프로젝트 ZIP 패키지를 업로드하세요.

<Steps>
  <Step title="파일 선택">
    컴퓨터에서 ZIP 파일을 선택합니다.
  </Step>

<Step title="환경 변수 추가">
    필요한 변수를 제공합니다.
  </Step>

<Step title="배포">
    <b>Deploy</b>를 클릭해 라이브 자동화를 생성합니다.
  </Step>
</Steps>

<Frame>
    <img src="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=8cea74868a553d34b0aa182ad5489099" alt="ZIP 배포" data-og-width="3648" width="3648" data-og-height="2266" height="2266" data-path="images/enterprise/deploy-from-zip.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=280&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=961637aa95a2795071b4a54e921f3f03 280w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=560&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=62994bfdf5667fc17880ed33c32a7aa6 560w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=840&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=b0c4ef28de74989c1fdbf1076d12ba3c 840w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=1100&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=19fe8b770051a0426f120d6b661a6f40 1100w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=1650&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=a80e4bf6e8befdf57a5ea79840b45136 1650w, https://mintcdn.com/crewai/oMMe1eXJrzmWf3MN/images/enterprise/deploy-from-zip.png?w=2500&fit=max&auto=format&n=oMMe1eXJrzmWf3MN&q=85&s=61e870a88f47df3e282a134e754fc09d 2500w" />
</Frame>

테이블에는 모든 라이브 자동화가 다음 정보와 함께 표시됩니다:

* **CREW**: 자동화 이름
* **STATUS**: Online / Failed / In Progress
* **URL**: kickoff/status 엔드포인트
* **TOKEN**: 자동화 토큰
* **ACTIONS**: 재배포, 삭제 등

* 이름으로 검색
* <b>Status</b>로 필터
* <b>Source</b>로 필터 (GitHub / Studio / ZIP)

배포 후 **Options** 드롭다운에서 `chat with this crew`, `Export React Component`, `Export as MCP`를 사용할 수 있습니다.

<Frame>
    <img src="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=f7fb571e8473f5cb7940c3e3bb34f95c" alt="자동화 표" data-og-width="2874" width="2874" data-og-height="932" height="932" data-path="images/enterprise/automations-table.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=280&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=5833733acf6f2e07d0a39abffe87de40 280w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=560&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=858a8b93744d4f23e07e9ec58227aac0 560w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=840&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=e0fe6df6d821e1edc729681e8d314d22 840w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=1100&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=cb68b81e23a169714985d93bb0913170 1100w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=1650&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=401736c16a6074de6b60de8234cbe206 1650w, https://mintcdn.com/crewai/Grq_Qb7_m8o-TQ5O/images/enterprise/automations-table.png?w=2500&fit=max&auto=format&n=Grq_Qb7_m8o-TQ5O&q=85&s=1b9a5f852f474d6a68a5cf4dda5a0021 2500w" />
</Frame>

* 버전 관리 및 CI/CD를 위해 GitHub 배포를 권장
* 코드/구성 변경 후 재배포 사용 또는 푸시마다 자동 배포 설정

<CardGroup cols={3}>
  <Card title="크루 배포" href="/ko/enterprise/guides/deploy-crew" icon="rocket">
    GitHub 또는 ZIP 파일로 크루 배포
  </Card>

<Card title="자동화 트리거" href="/ko/enterprise/guides/automation-triggers" icon="trigger">
    웹훅 또는 API로 자동화 트리거
  </Card>

<Card title="Webhook 자동화" href="/ko/enterprise/guides/webhook-automation" icon="webhook">
    실시간 이벤트/업데이트 스트리밍
  </Card>
</CardGroup>

---

## Create a StdioServerParameters object

**URL:** llms-txt#create-a-stdioserverparameters-object

stdio_params=StdioServerParameters(
    command="python3", 
    args=["servers/your_stdio_server.py"],
    env={"UV_PYTHON": "3.12", **os.environ},
)

mcp_server_adapter = MCPServerAdapter(server_params=stdio_params)
try:
    mcp_server_adapter.start()  # Manually start the connection and server process
    tools = mcp_server_adapter.tools
    print(f"Available tools (manual Stdio): {[tool.name for tool in tools]}")

# Example: Using the tools with your Agent, Task, Crew setup
    manual_agent = Agent(
        role="Local Task Executor",
        goal="Execute a specific local task using a manually managed Stdio tool.",
        backstory="An AI proficient in controlling local processes via MCP.",
        tools=tools,
        verbose=True
    )
    
    manual_task = Task(
        description="Execute the 'perform_analysis' command via the Stdio tool.",
        expected_output="Results of the analysis.",
        agent=manual_agent
    )
    
    manual_crew = Crew(
        agents=[manual_agent],
        tasks=[manual_task],
        verbose=True,
        process=Process.sequential
    )
        
       
    result = manual_crew.kickoff() # Actual inputs depend on your tool
    print("\nCrew Task Result (Stdio - Manual):\n", result)
            
except Exception as e:
    print(f"An error occurred during manual Stdio MCP integration: {e}")
finally:
    if mcp_server_adapter and mcp_server_adapter.is_connected: # Check if connected before stopping
        print("Stopping Stdio MCP server connection (manual)...")
        mcp_server_adapter.stop()  # **Crucial: Ensure stop is called**
    elif mcp_server_adapter: # If adapter exists but not connected (e.g. start failed)
        print("Stdio MCP server adapter was not connected. No stop needed or start failed.")

플레이스홀더 경로 및 명령어를 실제 Stdio 서버 정보로 교체해야 합니다. `StdioServerParameters`의 `env` 파라미터는
서버 프로세스용 환경 변수를 설정할 때 사용할 수 있습니다. 이는 서버의 동작을 구성하거나 필요한 경로(예: `PYTHONPATH`)를 제공하는 데 유용할 수 있습니다.

---

## Transporte HTTP Streamable

**URL:** llms-txt#transporte-http-streamable

**Contents:**
- Visão Geral
- Conceitos-Chave
- Conectando via HTTP Streamable
  - 1. Conexão Totalmente Gerenciada (Recomendado)
  - 2. Ciclo de Vida da Conexão Manual
- Considerações de Segurança

Source: https://docs.crewai.com/pt-BR/mcp/streamable-http

Saiba como conectar o CrewAI a servidores MCP remotos usando o transporte HTTP Streamable flexível.

O transporte HTTP Streamable oferece uma maneira flexível de se conectar a servidores MCP remotos. Ele é frequentemente baseado em HTTP e pode suportar vários padrões de comunicação, incluindo requisição-resposta e streaming, às vezes utilizando Server-Sent Events (SSE) para fluxos do servidor para o cliente dentro de uma interação HTTP mais ampla.

* **Servidores Remotos**: Projetado para servidores MCP hospedados remotamente.
* **Flexibilidade**: Pode suportar padrões de interação mais complexos do que SSE puro, potencialmente incluindo comunicação bidirecional se o servidor implementá-la.
* **Configuração do `MCPServerAdapter`**: Você precisará fornecer a URL base do servidor para comunicação MCP e especificar `"streamable-http"` como o tipo de transporte.

## Conectando via HTTP Streamable

Você tem dois métodos principais para gerenciar o ciclo de vida da conexão com um servidor MCP HTTP Streamable:

### 1. Conexão Totalmente Gerenciada (Recomendado)

A abordagem recomendada é usar um gerenciador de contexto Python (`with` statement), que lida automaticamente com a configuração e encerramento da conexão.

**Nota:** Substitua `"http://localhost:8001/mcp"` pela URL real do seu servidor MCP HTTP Streamable.

### 2. Ciclo de Vida da Conexão Manual

Para cenários que exigem controle mais explícito, você pode gerenciar a conexão do `MCPServerAdapter` manualmente.

<Info>
  É **crítico** chamar `mcp_server_adapter.stop()` quando terminar para fechar a conexão e liberar recursos. Usar um bloco `try...finally` é a forma mais segura de garantir isso.
</Info>

## Considerações de Segurança

Ao utilizar o transporte HTTP Streamable, as melhores práticas gerais de segurança web são fundamentais:

* **Use HTTPS**: Sempre prefira HTTPS (HTTP Seguro) para as URLs do seu servidor MCP para criptografar os dados em trânsito.
* **Autenticação**: Implemente mecanismos robustos de autenticação se seu servidor MCP expuser ferramentas ou dados sensíveis.
* **Validação de Entrada**: Garanta que seu servidor MCP valide todas as requisições e parâmetros recebidos.

Para um guia abrangente sobre como proteger suas integrações MCP, consulte nossa página de [Considerações de Segurança](./security.mdx) e a documentação oficial de [Segurança em Transportes MCP](https://modelcontextprotocol.io/docs/concepts/transports#security-considerations).

**Examples:**

Example 1 (unknown):
```unknown
**Nota:** Substitua `"http://localhost:8001/mcp"` pela URL real do seu servidor MCP HTTP Streamable.

### 2. Ciclo de Vida da Conexão Manual

Para cenários que exigem controle mais explícito, você pode gerenciar a conexão do `MCPServerAdapter` manualmente.

<Info>
  É **crítico** chamar `mcp_server_adapter.stop()` quando terminar para fechar a conexão e liberar recursos. Usar um bloco `try...finally` é a forma mais segura de garantir isso.
</Info>
```

---

## Load an agent from repository

**URL:** llms-txt#load-an-agent-from-repository

analyst = Agent(
    from_repository="market-analyst-agent",
    verbose=True
)

---
